/**
 * CanvasXpress 14.0 - JavaScript Canvas Library
 * 
 * Copyright (c) 2009-2017 Isaac Neuhaus
 * 
 * imnphd@gmail.com
 * 
 * 
 * Redistributions of this source code must retain this copyright notice and the following disclaimer.
 * 
 * CanvasXpress is licensed under the terms of the Open Source GPL version 3.0 license.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 * 
 * Please see a copy of the GNU General Public License at http://www.gnu.org/licenses.
 * 
 * Commercial use may be granted to the extent that this source code does NOT become part of any other Open Source or Commercially licensed development library or toolkit without explicit permission.
 * Please contact me for additional information.
 * 
 * Network graphs were implemented based on the HeyGraph by Tom Martin http://www.heychinaski.com.
 * 
 * Thanks to Mingyi Liu for his contributions with the Ext-JS panel and network graphs and Charles Tilford for his input to the Genome Browser.
 * 
 */
/**
 * 
 * canvas.text.js
 * @projectDescription An cross-browser implementation of the HTML5 <canvas> text methods 
 * @author Fabien Mï¿½nager 
 * @version $Revision: 1.4 $ 
 * @license MIT License <http://www.opensource.org/licenses/mit-license.php> 
 * 
 * Known issues: 
 * - The 'light' font weight is not supported, neither is the 'oblique' font style. 
 * - Optimize the different hacks (for Opera9) 
 * 
 **** 
 * 
 * sprintf() for JavaScript v.0.4
 *
 * Copyright (c) 2007 Alexandru Marasteanu <http://alexei.417.ro/>
 * Thanks to David Baird (unit test and patch).
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA 02111-1307 USA
 *
 ***
 * 
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 *
 ****
 *
 * canvas_wrapper.js
 * Canvas doesn't support getCoords() which I really need....
 * So I made a wrapper, code mostly taken from excanvas.js by Google - http://code.google.com/p/explorercanvas/
 * alias some functions to make (compiled) code shorter
 *
 ****
 *
 * conrec.js
 * Copyright (c) 2010, Jason Davies.
 *
 * All rights reserved.  This code is based on Bradley White's Java version,
 * which is in turn based on Nicholas Yue's C++ version, which in turn is based
 * on Paul D. Bourke's original Fortran version.  See below for the respective
 * copyright notices.
 *
 * See http://paulbourke.net/papers/conrec for the original
 * paper by Paul D. Bourke.
 *
 * The vector conversion code is based on http://apptree.net/conrec.htm by
 * Graham Cox.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 ****
 *
 * conrec.js
 * Copyright (c) 1996-1997 Nicholas Yue
 *
 * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
 * Bourke's CONREC.F routine.
 *
 * The authors hereby grant permission to use, copy, and distribute this
 * software and its documentation for any purpose, provided that existing
 * copyright notices are retained in all copies and that this notice is
 * included verbatim in any distributions. Additionally, the authors grant
 * permission to modify this software and its documentation for any purpose,
 * provided that such modifications are not distributed without the explicit
 * consent of the authors and that existing copyright notices are retained in
 * all copies. Some of the algorithms implemented by this software are
 * patented, observe all applicable patent law.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
 * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
 * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 * 
 **** 
 *
 * jLouvain.js
 * Author: Corneliu S. (github.com/upphiminn)
 * This is a javascript implementation of the Louvain
 * community detection algorithm (http://arxiv.org/abs/0803.0476)
 * Based on https://bitbucket.org/taynaud/python-louvain/overview
 * 
 ****
 * 
 * science.js
 * Copyright (c) 2011, Jason Davies
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * The name Jason Davies may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 ****
 *
 * Apache-Style Software License for ColorBrewer software and ColorBrewer Color
 * Schemes
 * 
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The Pennsylvania State
 * University.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions as source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 
 * 2. The end-user documentation included with the redistribution, if any, must
 * include the following acknowledgment: "This product includes color
 * specifications and designs developed by Cynthia Brewer
 * (http://colorbrewer.org/)." Alternately, this acknowledgment may appear in the
 * software itself, if and wherever such third-party acknowledgments normally
 * appear.
 * 
 * 4. The name "ColorBrewer" must not be used to endorse or promote products
 * derived from this software without prior written permission. For written
 * permission, please contact Cynthia Brewer at cbrewer@psu.edu.
 * 
 * 5. Products derived from this software may not be called "ColorBrewer", nor
 * may "ColorBrewer" appear in their name, without prior written permission of
 * Cynthia Brewer.
 *
 ****
 * 
 * FileSaver.js
 * Copyright Â© 2015 [Eli Grey][1].
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 **** 
 * 
 * canvas-toBlob.js
 * Copyright Â© 2011 Eli Grey and Devin Samarin.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 ****
 *
 * Blob.js
 * Copyright Â© 2014 Eli Grey.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished
 * to do so, subject to the following conditions:
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 ****
 *
 * jstat.js
 * Copyright (c) 2013 jStat
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 ****
 *
 * numeric.js
 * Numeric Javascript
 * Copyright (C) 2011 by SÃ©bastien Loisel
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 ****
 *
 * spark-md5.js
 * Copyright (c) 2015 AndrÃ© Cruz <amdfcruz@gmail.com>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the 'Software'), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
function str_repeat(b, a) {
	for (var c = []; a > 0; c[--a] = b) {}
	return (c.join(""))
}

function sprintf() {
	var g = 0,
		e, h = arguments[g++],
		k = [],
		d, j, l, b;
	while (h) {
		if (d = /^[^\x25]+/.exec(h)) {
			k.push(d[0])
		} else {
			if (d = /^\x25{2}/.exec(h)) {
				k.push("%")
			} else {
				if (d = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(h)) {
					if (((e = arguments[d[1] || g++]) == null) || (e == undefined)) {
						throw ("Too few arguments.")
					}
					if (/[^s]/.test(d[7]) && (typeof(e) != "number")) {
						throw ("Expecting number but found " + typeof(e))
					}
					switch (d[7]) {
						case "b":
							e = e.toString(2);
							break;
						case "c":
							e = String.fromCharCode(e);
							break;
						case "d":
							e = parseInt(e);
							break;
						case "e":
							e = d[6] ? e.toExponential(d[6]) : e.toExponential();
							break;
						case "f":
							e = d[6] ? parseFloat(e).toFixed(d[6]) : parseFloat(e);
							break;
						case "o":
							e = e.toString(8);
							break;
						case "s":
							e = ((e = String(e)) && d[6] ? e.substring(0, d[6]) : e);
							break;
						case "u":
							e = Math.abs(e);
							break;
						case "x":
							e = e.toString(16);
							break;
						case "X":
							e = e.toString(16).toUpperCase();
							break
					}
					e = (/[def]/.test(d[7]) && d[2] && e > 0 ? "+" + e : e);
					l = d[3] ? d[3] == "0" ? "0" : d[3].charAt(1) : " ";
					b = d[5] - String(e).length;
					j = d[5] ? str_repeat(l, b) : "";
					k.push(d[4] ? e + j : j + e)
				} else {
					throw ("Huh ?!")
				}
			}
		}
		h = h.substring(d[0].length)
	}
	return k.join("")
};
var dateFormat = function() {
	var a = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
		b = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
		d = /[^-+\dA-Z]/g,
		c = function(f, e) {
			f = String(f);
			e = e || 2;
			while (f.length < e) {
				f = "0" + f
			}
			return f
		};
	return function(i, v, q) {
		var g = dateFormat;
		if (arguments.length == 1 && Object.prototype.toString.call(i) == "[object String]" && !/\d/.test(i)) {
			v = i;
			i = undefined
		}
		i = i ? new Date(i) : new Date;
		if (isNaN(i)) {
			throw SyntaxError("invalid date")
		}
		v = String(g.masks[v] || v || g.masks["default"]);
		if (v.slice(0, 4) == "UTC:") {
			v = v.slice(4);
			q = true
		}
		var t = q ? "getUTC" : "get",
			l = i[t + "Date"](),
			e = i[t + "Day"](),
			j = i[t + "Month"](),
			p = i[t + "FullYear"](),
			r = i[t + "Hours"](),
			k = i[t + "Minutes"](),
			u = i[t + "Seconds"](),
			n = i[t + "Milliseconds"](),
			f = q ? 0 : i.getTimezoneOffset(),
			h = {
				d: l,
				dd: c(l),
				ddd: g.i18n.dayNames[e],
				dddd: g.i18n.dayNames[e + 7],
				m: j + 1,
				mm: c(j + 1),
				mmm: g.i18n.monthNames[j],
				mmmm: g.i18n.monthNames[j + 12],
				yy: String(p).slice(2),
				yyyy: p,
				h: r % 12 || 12,
				hh: c(r % 12 || 12),
				H: r,
				HH: c(r),
				M: k,
				MM: c(k),
				s: u,
				ss: c(u),
				l: c(n, 3),
				L: c(n > 99 ? Math.round(n / 10) : n),
				t: r < 12 ? "a" : "p",
				tt: r < 12 ? "am" : "pm",
				T: r < 12 ? "A" : "P",
				TT: r < 12 ? "AM" : "PM",
				Z: q ? "UTC" : (String(i).match(b) || [""]).pop().replace(d, ""),
				o: (f > 0 ? "-" : "+") + c(Math.floor(Math.abs(f) / 60) * 100 + Math.abs(f) % 60, 4),
				S: ["th", "st", "nd", "rd"][l % 10 > 3 ? 0 : (l % 100 - l % 10 != 10) * l % 10]
			};
		return v.replace(a, function(m) {
			return m in h ? h[m] : m.slice(1, m.length - 1)
		})
	}
}();
dateFormat.masks = {
	"default": "ddd mmm dd yyyy HH:MM:ss",
	shortDate: "m/d/yy",
	mediumDate: "mmm d, yyyy",
	longDate: "mmmm d, yyyy",
	fullDate: "dddd, mmmm d, yyyy",
	shortTime: "h:MM TT",
	mediumTime: "h:MM:ss TT",
	longTime: "h:MM:ss TT Z",
	isoDate: "yyyy-mm-dd",
	isoTime: "HH:MM:ss",
	isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
	isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};
dateFormat.i18n = {
	dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
Date.prototype.format = function(a, b) {
	return dateFormat(this, a, b)
};
var Conrec = (function() {
	var d = 1e-20;
	var c = function(h, g) {
		var f = h.x - g.x,
			i = h.y - g.y;
		return f * f + i * i < d
	};
	var e = function(h) {
		var f = h.head;
		while (f) {
			var g = f.next;
			f.next = f.prev;
			f.prev = g;
			f = g
		}
		var g = h.head;
		h.head = h.tail;
		h.tail = g
	};
	var b = function(f) {
		this.level = f;
		this.s = null;
		this.count = 0
	};
	b.prototype.remove_seq = function(f) {
		if (f.prev) {
			f.prev.next = f.next
		} else {
			this.s = f.next
		}
		if (f.next) {
			f.next.prev = f.prev
		}--this.count
	};
	b.prototype.addSegment = function(k, j) {
		var p = this.s;
		var m = null;
		var l = null;
		var o = false;
		var n = false;
		while (p) {
			if (m == null) {
				if (c(k, p.head.p)) {
					m = p;
					o = true
				} else {
					if (c(k, p.tail.p)) {
						m = p
					}
				}
			}
			if (l == null) {
				if (c(j, p.head.p)) {
					l = p;
					n = true
				} else {
					if (c(j, p.tail.p)) {
						l = p
					}
				}
			}
			if (l != null && m != null) {
				break
			} else {
				p = p.next
			}
		}
		var i = ((m != null) ? 1 : 0) | ((l != null) ? 2 : 0);
		switch (i) {
			case 0:
				var f = {
					p: k,
					prev: null
				};
				var h = {
					p: j,
					next: null
				};
				f.next = h;
				h.prev = f;
				m = {
					head: f,
					tail: h,
					next: this.s,
					prev: null,
					closed: false
				};
				if (this.s) {
					this.s.prev = m
				}
				this.s = m;
				++this.count;
				break;
			case 1:
				var g = {
					p: j
				};
				if (o) {
					g.next = m.head;
					g.prev = null;
					m.head.prev = g;
					m.head = g
				} else {
					g.next = null;
					g.prev = m.tail;
					m.tail.next = g;
					m.tail = g
				}
				break;
			case 2:
				var g = {
					p: k
				};
				if (n) {
					g.next = l.head;
					g.prev = null;
					l.head.prev = g;
					l.head = g
				} else {
					g.next = null;
					g.prev = l.tail;
					l.tail.next = g;
					l.tail = g
				}
				break;
			case 3:
				if (m === l) {
					var g = {
						p: m.tail.p,
						next: m.head,
						prev: null
					};
					m.head.prev = g;
					m.head = g;
					m.closed = true;
					break
				}
				switch ((o ? 1 : 0) | (n ? 2 : 0)) {
					case 0:
						e(m);
					case 1:
						l.tail.next = m.head;
						m.head.prev = l.tail;
						l.tail = m.tail;
						this.remove_seq(m);
						break;
					case 3:
						e(m);
					case 2:
						m.tail.next = l.head;
						l.head.prev = m.tail;
						m.tail = l.tail;
						this.remove_seq(l);
						break
				}
		}
	};
	var a = function(f) {
		if (!f) {
			var g = this;
			g.contours = {};
			this.drawContour = function(j, i, o, n, m, l) {
				var h = g.contours[l];
				if (!h) {
					h = g.contours[l] = new b(m)
				}
				h.addSegment({
					x: j,
					y: i
				}, {
					x: o,
					y: n
				})
			};
			this.contourList = function() {
				var m = [];
				var j = g.contours;
				for (var n in j) {
					var p = j[n].s;
					var q = j[n].level;
					while (p) {
						var o = p.head;
						var i = [];
						i.level = q;
						i.k = n;
						while (o && o.p) {
							i.push(o.p);
							o = o.next
						}
						m.push(i);
						p = p.next
					}
				}
				m.sort(function(k, h) {
					return h.k - k.k
				});
				return m
			}
		} else {
			this.drawContour = f
		}
		this.h = new Array(5);
		this.sh = new Array(5);
		this.xh = new Array(5);
		this.yh = new Array(5)
	};
	a.prototype.contour = function(Q, L, P, r, u, B, A, t, v) {
		var N = this.h,
			S = this.sh,
			D = this.xh,
			U = this.yh;
		var H = this.drawContour;
		this.contours = {};
		var q = function(i, h) {
			return (N[h] * D[i] - N[i] * D[h]) / (N[h] - N[i])
		};
		var R = function(i, h) {
			return (N[h] * U[i] - N[i] * U[h]) / (N[h] - N[i])
		};
		var l;
		var g;
		var f;
		var s;
		var C;
		var E;
		var O = 0;
		var M = 0;
		var o = 0;
		var n = 0;
		var w = [0, 1, 1, 0];
		var K = [0, 0, 1, 1];
		var p = [
			[
				[0, 0, 8],
				[0, 2, 5],
				[7, 6, 9]
			],
			[
				[0, 3, 4],
				[1, 3, 1],
				[4, 3, 0]
			],
			[
				[9, 6, 7],
				[5, 2, 0],
				[8, 0, 0]
			]
		];
		for (var I = (u - 1); I >= r; I--) {
			for (var J = L; J <= P - 1; J++) {
				var V, T;
				V = Math.min(Q[J][I], Q[J][I + 1]);
				T = Math.min(Q[J + 1][I], Q[J + 1][I + 1]);
				C = Math.min(V, T);
				V = Math.max(Q[J][I], Q[J][I + 1]);
				T = Math.max(Q[J + 1][I], Q[J + 1][I + 1]);
				E = Math.max(V, T);
				if (E >= v[0] && C <= v[t - 1]) {
					for (var G = 0; G < t; G++) {
						if (v[G] >= C && v[G] <= E) {
							for (var F = 4; F >= 0; F--) {
								if (F > 0) {
									N[F] = Q[J + w[F - 1]][I + K[F - 1]] - v[G];
									D[F] = B[J + w[F - 1]];
									U[F] = A[I + K[F - 1]]
								} else {
									N[0] = 0.25 * (N[1] + N[2] + N[3] + N[4]);
									D[0] = 0.5 * (B[J] + B[J + 1]);
									U[0] = 0.5 * (A[I] + A[I + 1])
								}
								if (N[F] > 0) {
									S[F] = 1
								} else {
									if (N[F] < 0) {
										S[F] = -1
									} else {
										S[F] = 0
									}
								}
							}
							for (F = 1; F <= 4; F++) {
								l = F;
								g = 0;
								if (F != 4) {
									f = F + 1
								} else {
									f = 1
								}
								s = p[S[l] + 1][S[g] + 1][S[f] + 1];
								if (s != 0) {
									switch (s) {
										case 1:
											O = D[l];
											o = U[l];
											M = D[g];
											n = U[g];
											break;
										case 2:
											O = D[g];
											o = U[g];
											M = D[f];
											n = U[f];
											break;
										case 3:
											O = D[f];
											o = U[f];
											M = D[l];
											n = U[l];
											break;
										case 4:
											O = D[l];
											o = U[l];
											M = q(g, f);
											n = R(g, f);
											break;
										case 5:
											O = D[g];
											o = U[g];
											M = q(f, l);
											n = R(f, l);
											break;
										case 6:
											O = D[f];
											o = U[f];
											M = q(l, g);
											n = R(l, g);
											break;
										case 7:
											O = q(l, g);
											o = R(l, g);
											M = q(g, f);
											n = R(g, f);
											break;
										case 8:
											O = q(g, f);
											o = R(g, f);
											M = q(f, l);
											n = R(f, l);
											break;
										case 9:
											O = q(f, l);
											o = R(f, l);
											M = q(l, g);
											n = R(l, g);
											break;
										default:
											break
									}
									H(O, o, M, n, v[G], G)
								}
							}
						}
					}
				}
			}
		}
	};
	return a
})();
if (typeof exports !== "undefined") {
	exports.Conrec = Conrec
};
(function() {
	jLouvain = function() {
		var l = -1;
		var k = 1e-7;
		var i;
		var y;
		var s = {};
		var a;

		function d(C) {
			var B = {};
			C.forEach(function(E, D) {
				B[E] = true
			});
			return Object.keys(B)
		}

		function x(D) {
			var C = [];
			for (var B in D) {
				if (D.hasOwnProperty(B)) {
					C.push(D[B])
				}
			}
			return C
		}

		function v(E, C) {
			var B = E._assoc_mat[C] ? Object.keys(E._assoc_mat[C]) : [];
			var D = 0;
			B.forEach(function(F, G) {
				var H = E._assoc_mat[C][F] || 1;
				if (C == F) {
					H *= 2
				}
				D += H
			});
			return D
		}

		function f(D, C) {
			if (typeof D._assoc_mat[C] == "undefined") {
				return []
			}
			var B = Object.keys(D._assoc_mat[C]);
			return B
		}

		function g(D, C, B) {
			return D._assoc_mat[C] ? D._assoc_mat[C][B] : undefined
		}

		function A(C) {
			var B = 0;
			C.edges.forEach(function(D) {
				B += D.weight
			});
			return B
		}

		function c(D, C) {
			e(D, C);
			var B = D.edges.map(function(E) {
				return E.id1 + "_" + E.id2
			}).indexOf(C.id1 + "_" + C.id2);
			if (B != -1) {
				D.edges[B].weight = C.weight
			} else {
				D.edges.push(C)
			}
		}

		function z(B) {
			var C = {};
			B.forEach(function(E, D) {
				E.weight = E.weight || 1;
				C[E.id1] = C[E.id1] || {};
				C[E.id1][E.id2] = E.weight;
				C[E.id2] = C[E.id2] || {};
				C[E.id2][E.id1] = E.weight
			});
			return C
		}

		function e(C, B) {
			C._assoc_mat[B.id1] = C._assoc_mat[B.id1] || {};
			C._assoc_mat[B.id1][B.id2] = B.weight;
			C._assoc_mat[B.id2] = C._assoc_mat[B.id2] || {};
			C._assoc_mat[B.id2][B.id1] = B.weight
		}

		function t(D) {
			if (D == null || typeof(D) != "object") {
				return D
			}
			var B = D.constructor();
			for (var C in D) {
				B[C] = t(D[C])
			}
			return B
		}

		function p(D, B, C) {
			B.nodes_to_com = {};
			B.total_weight = 0;
			B.internals = {};
			B.degrees = {};
			B.gdegrees = {};
			B.loops = {};
			B.total_weight = A(D);
			if (typeof C == "undefined") {
				D.nodes.forEach(function(G, E) {
					B.nodes_to_com[G] = E;
					var F = v(D, G);
					if (F < 0) {
						throw "Bad graph type, use positive weights!"
					}
					B.degrees[E] = F;
					B.gdegrees[G] = F;
					B.loops[G] = g(D, G, G) || 0;
					B.internals[E] = B.loops[G]
				})
			} else {
				D.nodes.forEach(function(I, G) {
					var E = C[I];
					B.nodes_to_com[I] = E;
					var H = v(D, I);
					B.degrees[E] = (B.degrees[E] || 0) + H;
					B.gdegrees[I] = H;
					var J = 0;
					var F = f(D, I);
					F.forEach(function(K, L) {
						var M = D._assoc_mat[I][K];
						if (M <= 0) {
							throw "Bad graph type, use positive weights"
						}
						if (C[K] == E) {
							if (K == I) {
								J += M
							} else {
								J += M / 2
							}
						}
					});
					B.internals[E] = (B.internals[E] || 0) + J
				})
			}
		}

		function o(C) {
			var E = C.total_weight;
			var B = 0;
			var D = d(x(C.nodes_to_com));
			D.forEach(function(F, G) {
				var I = C.internals[F] || 0;
				var H = C.degrees[F] || 0;
				if (E > 0) {
					B = B + I / E - Math.pow((H / (2 * E)), 2)
				}
			});
			return B
		}

		function m(D, E, B) {
			var C = {};
			var F = f(E, D);
			F.forEach(function(G, H) {
				if (G != D) {
					var I = E._assoc_mat[D][G] || 1;
					var J = B.nodes_to_com[G];
					C[J] = (C[J] || 0) + I
				}
			});
			return C
		}

		function u(D, C, E, B) {
			B.nodes_to_com[D] = +C;
			B.degrees[C] = (B.degrees[C] || 0) + (B.gdegrees[D] || 0);
			B.internals[C] = (B.internals[C] || 0) + E + (B.loops[D] || 0)
		}

		function r(D, C, E, B) {
			B.degrees[C] = ((B.degrees[C] || 0) - (B.gdegrees[D] || 0));
			B.internals[C] = ((B.internals[C] || 0) - E - (B.loops[D] || 0));
			B.nodes_to_com[D] = -1
		}

		function j(F) {
			var D = 0;
			var B = t(F);
			var C = {};
			var E = Object.keys(F);
			E.forEach(function(H) {
				var I = F[H];
				var G = typeof C[I] == "undefined" ? -1 : C[I];
				if (G == -1) {
					C[I] = D;
					G = D;
					D = D + 1
				}
				B[H] = G
			});
			return B
		}

		function b(F, B) {
			var D = true,
				G = 0,
				E = o(B),
				C = E;
			while (D && G != l) {
				E = C;
				D = false;
				G += 1;
				F.nodes.forEach(function(J, I) {
					var M = B.nodes_to_com[J];
					var O = (B.gdegrees[J] || 0) / (B.total_weight * 2);
					var L = m(J, F, B);
					r(J, M, (L[M] || 0), B);
					var N = M;
					var H = 0;
					var K = Object.keys(L);
					K.forEach(function(P, Q) {
						var R = L[P] - (B.degrees[P] || 0) * O;
						if (R > H) {
							H = R;
							N = P
						}
					});
					u(J, N, L[N] || 0, B);
					if (N != M) {
						D = true
					}
				});
				C = o(B);
				if (C - E < k) {
					break
				}
			}
		}

		function h(C, G) {
			var B = {
				nodes: [],
				edges: [],
				_assoc_mat: {}
			};
			var D, F;
			var E = x(C);
			B.nodes = B.nodes.concat(d(E));
			G.edges.forEach(function(I, H) {
				F = I.weight || 1;
				var L = C[I.id1];
				var J = C[I.id2];
				D = (g(B, L, J) || 0);
				var K = (D + F);
				c(B, {
					source: L,
					target: J,
					weight: K
				})
			});
			return B
		}

		function w(C, E) {
			var B = t(C[0]);
			for (var D = 1; D < E + 1; D++) {
				Object.keys(B).forEach(function(H, G) {
					var I = H;
					var F = B[H];
					B[I] = C[D][F]
				})
			}
			return B
		}

		function n(J, D) {
			if (J.edges.length == 0) {
				var C = {};
				J.nodes.forEach(function(L, K) {
					C[L] = L
				});
				return C
			}
			var F = {};
			p(s, F, D);
			var H = o(F);
			var I = [];
			b(s, F);
			var B = o(F);
			var G = j(F.nodes_to_com);
			I.push(G);
			H = B;
			var E = h(G, s);
			p(E, F);
			while (true) {
				b(E, F);
				B = o(F);
				if (B - H < k) {
					break
				}
				G = j(F.nodes_to_com);
				I.push(G);
				H = B;
				E = h(G, E);
				p(E, F)
			}
			return I
		}
		var q = function() {
			var B = {};
			var C = n(s, a);
			return w(C, C.length - 1)
		};
		q.nodes = function(B) {
			if (arguments.length > 0) {
				i = B
			}
			return q
		};
		q.edges = function(C) {
			if (typeof i == "undefined") {
				throw "Please provide the graph nodes first!"
			}
			if (arguments.length > 0) {
				y = C;
				var B = z(C);
				s = {
					nodes: i,
					edges: y,
					_assoc_mat: B
				}
			}
			return q
		};
		q.partition_init = function(B) {
			if (arguments.length > 0) {
				a = B
			}
			return q
		};
		return q
	}
})(); /*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */
(function(a) {
	a.URL = a.URL || a.webkitURL;
	if (a.Blob && a.URL) {
		try {
			new Blob;
			return
		} catch (d) {}
	}
	var c = a.BlobBuilder || a.WebKitBlobBuilder || a.MozBlobBuilder || (function(p) {
		var g = function(z) {
				return Object.prototype.toString.call(z).match(/^\[object\s(.*)\]$/)[1]
			},
			y = function m() {
				this.data = []
			},
			w = function i(B, z, A) {
				this.data = B;
				this.size = B.length;
				this.type = z;
				this.encoding = A
			},
			q = y.prototype,
			v = w.prototype,
			s = p.FileReaderSync,
			e = function(z) {
				this.code = this[this.name = z]
			},
			r = ("NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR").split(" "),
			u = r.length,
			l = p.URL || p.webkitURL || p,
			t = l.createObjectURL,
			f = l.revokeObjectURL,
			k = l,
			o = p.btoa,
			j = p.atob,
			h = p.ArrayBuffer,
			n = p.Uint8Array,
			x = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;
		w.fake = v.fake = true;
		while (u--) {
			e.prototype[r[u]] = u + 1
		}
		if (!l.createObjectURL) {
			k = p.URL = function(A) {
				var z = document.createElementNS("http://www.w3.org/1999/xhtml", "a"),
					B;
				z.href = A;
				if (!("origin" in z)) {
					if (z.protocol.toLowerCase() === "data:") {
						z.origin = null
					} else {
						B = A.match(x);
						z.origin = B && B[1]
					}
				}
				return z
			}
		}
		k.createObjectURL = function(A) {
			var B = A.type,
				z;
			if (B === null) {
				B = "application/octet-stream"
			}
			if (A instanceof w) {
				z = "data:" + B;
				if (A.encoding === "base64") {
					return z + ";base64," + A.data
				} else {
					if (A.encoding === "URI") {
						return z + "," + decodeURIComponent(A.data)
					}
				}
				if (o) {
					return z + ";base64," + o(A.data)
				} else {
					return z + "," + encodeURIComponent(A.data)
				}
			} else {
				if (t) {
					return t.call(l, A)
				}
			}
		};
		k.revokeObjectURL = function(z) {
			if (z.substring(0, 5) !== "data:" && f) {
				f.call(l, z)
			}
		};
		q.append = function(D) {
			var F = this.data;
			if (n && (D instanceof h || D instanceof n)) {
				var E = "",
					A = new n(D),
					B = 0,
					C = A.length;
				for (; B < C; B++) {
					E += String.fromCharCode(A[B])
				}
				F.push(E)
			} else {
				if (g(D) === "Blob" || g(D) === "File") {
					if (s) {
						var z = new s;
						F.push(z.readAsBinaryString(D))
					} else {
						throw new e("NOT_READABLE_ERR")
					}
				} else {
					if (D instanceof w) {
						if (D.encoding === "base64" && j) {
							F.push(j(D.data))
						} else {
							if (D.encoding === "URI") {
								F.push(decodeURIComponent(D.data))
							} else {
								if (D.encoding === "raw") {
									F.push(D.data)
								}
							}
						}
					} else {
						if (typeof D !== "string") {
							D += ""
						}
						F.push(unescape(encodeURIComponent(D)))
					}
				}
			}
		};
		q.getBlob = function(z) {
			if (!arguments.length) {
				z = null
			}
			return new w(this.data.join(""), z, "raw")
		};
		q.toString = function() {
			return "[object BlobBuilder]"
		};
		v.slice = function(C, z, B) {
			var A = arguments.length;
			if (A < 3) {
				B = null
			}
			return new w(this.data.slice(C, A > 1 ? z : this.data.length), B, this.encoding)
		};
		v.toString = function() {
			return "[object Blob]"
		};
		v.close = function() {
			this.size = 0;
			delete this.data
		};
		return y
	}(a));
	a.Blob = function(j, h) {
		var l = h ? (h.type || "") : "";
		var g = new c();
		if (j) {
			for (var k = 0, e = j.length; k < e; k++) {
				if (Uint8Array && j[k] instanceof Uint8Array) {
					g.append(j[k].buffer)
				} else {
					g.append(j[k])
				}
			}
		}
		var f = g.getBlob(l);
		if (!f.slice && f.webkitSlice) {
			f.slice = f.webkitSlice
		}
		return f
	};
	var b = Object.getPrototypeOf || function(e) {
		return e.__proto__
	};
	a.Blob.prototype = b(new a.Blob())
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
/*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */
(function(a) {
	var b = a.Uint8Array,
		d = a.HTMLCanvasElement,
		c = d && d.prototype,
		e = /\s*;\s*base64\s*(?:;|$)/i,
		f = "toDataURL",
		h, g = function(p) {
			var q = p.length,
				m = new b(q / 4 * 3 | 0),
				o = 0,
				s = 0,
				t = [0, 0],
				j = 0,
				r = 0,
				n, k, l;
			while (q--) {
				k = p.charCodeAt(o++);
				n = h[k - 43];
				if (n !== 255 && n !== l) {
					t[1] = t[0];
					t[0] = k;
					r = (r << 6) | n;
					j++;
					if (j === 4) {
						m[s++] = r >>> 16;
						if (t[1] !== 61) {
							m[s++] = r >>> 8
						}
						if (t[0] !== 61) {
							m[s++] = r
						}
						j = 0
					}
				}
			}
			return m
		};
	if (b) {
		h = new b([62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51])
	}
	if (d && !c.toBlob) {
		c.toBlob = function(p, n) {
			if (!n) {
				n = "image/png"
			}
			if (this.mozGetAsFile) {
				p(this.mozGetAsFile("canvas", n));
				return
			}
			if (this.msToBlob && /^\s*image\/png\s*(?:$|;)/i.test(n)) {
				p(this.msToBlob());
				return
			}
			var m = Array.prototype.slice.call(arguments, 1),
				k = this[f].apply(this, m),
				j = k.indexOf(","),
				o = k.substring(j + 1),
				i = e.test(k.substring(0, j)),
				l;
			if (Blob.fake) {
				l = new Blob;
				if (i) {
					l.encoding = "base64"
				} else {
					l.encoding = "URI"
				}
				l.data = o;
				l.size = o.length
			} else {
				if (b) {
					if (i) {
						l = new Blob([g(o)], {
							type: n
						})
					} else {
						l = new Blob([decodeURIComponent(o)], {
							type: n
						})
					}
				}
			}
			p(l)
		};
		if (c.toDataURLHD) {
			c.toBlobHD = function() {
				f = "toDataURLHD";
				var i = this.toBlob();
				f = "toDataURL";
				return i
			}
		} else {
			c.toBlobHD = c.toBlob
		}
	}
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
;
var saveAs = saveAs || (function(g) {
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return
	}
	var r = g.document,
		l = function() {
			return g.URL || g.webkitURL || g
		},
		n = r.createElementNS("http://www.w3.org/1999/xhtml", "a"),
		e = "download" in n,
		j = function(t) {
			var s = r.createEvent("MouseEvents");
			s.initMouseEvent("click", true, false, g, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
			t.dispatchEvent(s)
		},
		o = g.webkitRequestFileSystem,
		p = g.requestFileSystem || o || g.mozRequestFileSystem,
		m = function(s) {
			(g.setImmediate || g.setTimeout)(function() {
				throw s
			}, 0)
		},
		b = "application/octet-stream",
		k = 0,
		h = 500,
		i = function(t) {
			var s = function() {
				if (typeof t === "string") {
					l().revokeObjectURL(t)
				} else {
					t.remove()
				}
			};
			if (g.chrome) {
				s()
			} else {
				setTimeout(s, h)
			}
		},
		q = function(t, s, w) {
			s = [].concat(s);
			var v = s.length;
			while (v--) {
				var x = t["on" + s[v]];
				if (typeof x === "function") {
					try {
						x.call(t, w || t)
					} catch (u) {
						m(u)
					}
				}
			}
		},
		f = function(s) {
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(s.type)) {
				return new Blob(["\ufeff", s], {
					type: s.type
				})
			}
			return s
		},
		d = function(s, t) {
			s = f(s);
			var u = this,
				A = s.type,
				D = false,
				w, v, z = function() {
					q(u, "writestart progress write writeend".split(" "))
				},
				C = function() {
					if (D || !w) {
						w = l().createObjectURL(s)
					}
					if (v) {
						v.location.href = w
					} else {
						var E = g.open(w, "_blank");
						if (E == undefined && typeof safari !== "undefined") {
							g.location.href = w
						}
					}
					u.readyState = u.DONE;
					z();
					i(w)
				},
				y = function(E) {
					return function() {
						if (u.readyState !== u.DONE) {
							return E.apply(this, arguments)
						}
					}
				},
				x = {
					create: true,
					exclusive: false
				},
				B;
			u.readyState = u.INIT;
			if (!t) {
				t = "download"
			}
			if (e) {
				w = l().createObjectURL(s);
				n.href = w;
				n.download = t;
				j(n);
				u.readyState = u.DONE;
				z();
				i(w);
				return
			}
			if (g.chrome && A && A !== b) {
				B = s.slice || s.webkitSlice;
				s = B.call(s, 0, s.size, b);
				D = true
			}
			if (o && t !== "download") {
				t += ".download"
			}
			if (A === b || o) {
				v = g
			}
			if (!p) {
				C();
				return
			}
			k += s.size;
			p(g.TEMPORARY, k, y(function(E) {
				E.root.getDirectory("saved", x, y(function(F) {
					var G = function() {
						F.getFile(t, x, y(function(H) {
							H.createWriter(y(function(I) {
								I.onwriteend = function(J) {
									v.location.href = H.toURL();
									u.readyState = u.DONE;
									q(u, "writeend", J);
									i(H)
								};
								I.onerror = function() {
									var J = I.error;
									if (J.code !== J.ABORT_ERR) {
										C()
									}
								};
								"writestart progress write abort".split(" ").forEach(function(J) {
									I["on" + J] = u["on" + J]
								});
								I.write(s);
								u.abort = function() {
									I.abort();
									u.readyState = u.DONE
								};
								u.readyState = u.WRITING
							}), C)
						}), C)
					};
					F.getFile(t, {
						create: false
					}, y(function(H) {
						H.remove();
						G()
					}), y(function(H) {
						if (H.code === H.NOT_FOUND_ERR) {
							G()
						} else {
							C()
						}
					}))
				}), C)
			}), C)
		},
		c = d.prototype,
		a = function(s, t) {
			return new d(s, t)
		};
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(s, t) {
			return navigator.msSaveOrOpenBlob(f(s), t)
		}
	}
	c.abort = function() {
		var s = this;
		s.readyState = s.DONE;
		q(s, "abort")
	};
	c.readyState = c.INIT = 0;
	c.WRITING = 1;
	c.DONE = 2;
	c.error = c.onwritestart = c.onprogress = c.onwrite = c.onabort = c.onerror = c.onwriteend = null;
	return a
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content));
if (typeof module !== "undefined" && module.exports) {
	module.exports.saveAs = saveAs
} else {
	if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
		define([], function() {
			return saveAs
		})
	}
};
"use strict";
var numeric = (typeof exports === "undefined") ? (function numeric() {}) : (exports);
if (typeof global !== "undefined") {
	global.numeric = numeric
}
numeric.version = "1.2.6";
numeric._myIndexOf = (function _myIndexOf(a) {
	var c = this.length,
		b;
	for (b = 0; b < c; ++b) {
		if (this[b] === a) {
			return b
		}
	}
	return -1
});
numeric.myIndexOf = (Array.prototype.indexOf) ? Array.prototype.indexOf : numeric._myIndexOf;
numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;
numeric._dim = function _dim(a) {
	var b = [];
	while (typeof a === "object") {
		b.push(a.length);
		a = a[0]
	}
	return b
};
numeric.dim = function dim(a) {
	var c, b;
	if (typeof a === "object") {
		c = a[0];
		if (typeof c === "object") {
			b = c[0];
			if (typeof b === "object") {
				return numeric._dim(a)
			}
			return [a.length, c.length]
		}
		return [a.length]
	}
	return []
};
numeric.mapreduce = function mapreduce(a, b) {
	return Function("x", "accum", "_s", "_k", 'if(typeof accum === "undefined") accum = ' + b + ';\nif(typeof x === "number") { var xi = x; ' + a + '; return accum; }\nif(typeof _s === "undefined") _s = numeric.dim(x);\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i,xi;\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) {\n        accum = arguments.callee(x[i],accum,_s,_k+1);\n    }    return accum;\n}\nfor(i=_n-1;i>=1;i-=2) { \n    xi = x[i];\n    ' + a + ";\n    xi = x[i-1];\n    " + a + ";\n}\nif(i === 0) {\n    xi = x[i];\n    " + a + "\n}\nreturn accum;")
};
numeric.mapreduce2 = function mapreduce2(b, a) {
	return Function("x", "var n = x.length;\nvar i,xi;\n" + a + ";\nfor(i=n-1;i!==-1;--i) { \n    xi = x[i];\n    " + b + ";\n}\nreturn accum;")
};
numeric.same = function same(a, d) {
	var b, c;
	if (!(a instanceof Array) || !(d instanceof Array)) {
		return false
	}
	c = a.length;
	if (c !== d.length) {
		return false
	}
	for (b = 0; b < c; b++) {
		if (a[b] === d[b]) {
			continue
		}
		if (typeof a[b] === "object") {
			if (!same(a[b], d[b])) {
				return false
			}
		} else {
			return false
		}
	}
	return true
};
numeric.rep = function rep(e, b, a) {
	if (typeof a === "undefined") {
		a = 0
	}
	var f = e[a],
		c = Array(f),
		d;
	if (a === e.length - 1) {
		for (d = f - 2; d >= 0; d -= 2) {
			c[d + 1] = b;
			c[d] = b
		}
		if (d === -1) {
			c[0] = b
		}
		return c
	}
	for (d = f - 1; d >= 0; d--) {
		c[d] = numeric.rep(e, b, a + 1)
	}
	return c
};
numeric.dotMMsmall = function dotMMsmall(v, u) {
	var l, g, e, c, b, a, n, s, m, h, f, o, w, d;
	c = v.length;
	b = u.length;
	a = u[0].length;
	n = Array(c);
	for (l = c - 1; l >= 0; l--) {
		s = Array(a);
		m = v[l];
		for (e = a - 1; e >= 0; e--) {
			h = m[b - 1] * u[b - 1][e];
			for (g = b - 2; g >= 1; g -= 2) {
				f = g - 1;
				h += m[g] * u[g][e] + m[f] * u[f][e]
			}
			if (g === 0) {
				h += m[0] * u[0][e]
			}
			s[e] = h
		}
		n[l] = s
	}
	return n
};
numeric._getCol = function _getCol(b, c, a) {
	var e = b.length,
		d;
	for (d = e - 1; d > 0; --d) {
		a[d] = b[d][c];
		--d;
		a[d] = b[d][c]
	}
	if (d === 0) {
		a[0] = b[0][c]
	}
};
numeric.dotMMbig = function dotMMbig(r, q) {
	var s = numeric._getCol,
		a = q.length,
		u = Array(a);
	var d = r.length,
		c = q[0].length,
		b = new Array(d),
		l;
	var f = numeric.dotVV;
	var h, g, e, o;
	--a;
	--d;
	for (h = d; h !== -1; --h) {
		b[h] = Array(c)
	}--c;
	for (h = c; h !== -1; --h) {
		s(q, h, u);
		for (g = d; g !== -1; --g) {
			o = 0;
			l = r[g];
			b[g][h] = f(l, u)
		}
	}
	return b
};
numeric.dotMV = function dotMV(a, g) {
	var e = a.length,
		d = g.length,
		c;
	var b = Array(e),
		f = numeric.dotVV;
	for (c = e - 1; c >= 0; c--) {
		b[c] = f(a[c], g)
	}
	return b
};
numeric.dotVM = function dotVM(h, g) {
	var w, v, u, n, m, l, D, B, A, e, s, f, c, z, d, b, a, o, C;
	n = h.length;
	m = g[0].length;
	D = Array(m);
	for (u = m - 1; u >= 0; u--) {
		e = h[n - 1] * g[n - 1][u];
		for (v = n - 2; v >= 1; v -= 2) {
			s = v - 1;
			e += h[v] * g[v][u] + h[s] * g[s][u]
		}
		if (v === 0) {
			e += h[0] * g[0][u]
		}
		D[u] = e
	}
	return D
};
numeric.dotVV = function dotVV(a, f) {
	var c, e = a.length,
		d, b = a[e - 1] * f[e - 1];
	for (c = e - 2; c >= 1; c -= 2) {
		d = c - 1;
		b += a[c] * f[c] + a[d] * f[d]
	}
	if (c === 0) {
		b += a[0] * f[0]
	}
	return b
};
numeric.dot = function dot(a, c) {
	var b = numeric.dim;
	switch (b(a).length * 1000 + b(c).length) {
		case 2002:
			if (c.length < 10) {
				return numeric.dotMMsmall(a, c)
			} else {
				return numeric.dotMMbig(a, c)
			}
		case 2001:
			return numeric.dotMV(a, c);
		case 1002:
			return numeric.dotVM(a, c);
		case 1001:
			return numeric.dotVV(a, c);
		case 1000:
			return numeric.mulVS(a, c);
		case 1:
			return numeric.mulSV(a, c);
		case 0:
			return a * c;
		default:
			throw new Error("numeric.dot only works on vectors and matrices")
	}
};
numeric.diag = function diag(g) {
	var e, f, c, h = g.length,
		a = Array(h),
		b;
	for (e = h - 1; e >= 0; e--) {
		b = Array(h);
		f = e + 2;
		for (c = h - 1; c >= f; c -= 2) {
			b[c] = 0;
			b[c - 1] = 0
		}
		if (c > e) {
			b[c] = 0
		}
		b[e] = g[e];
		for (c = e - 1; c >= 1; c -= 2) {
			b[c] = 0;
			b[c - 1] = 0
		}
		if (c === 0) {
			b[0] = 0
		}
		a[e] = b
	}
	return a
};
numeric.getDiag = function(a) {
	var d = Math.min(a.length, a[0].length),
		c, b = Array(d);
	for (c = d - 1; c >= 1; --c) {
		b[c] = a[c][c];
		--c;
		b[c] = a[c][c]
	}
	if (c === 0) {
		b[0] = a[0][0]
	}
	return b
};
numeric.identity = function identity(a) {
	return numeric.diag(numeric.rep([a], 1))
};
numeric.pointwise2 = function pointwise2(d, g, c) {
	if (typeof c === "undefined") {
		c = ""
	}
	var h = [];
	var e;
	var i = /\[i\]$/,
		a, f = "";
	var b = false;
	for (e = 0; e < d.length; e++) {
		if (i.test(d[e])) {
			a = d[e].substring(0, d[e].length - 3);
			f = a
		} else {
			a = d[e]
		}
		if (a === "ret") {
			b = true
		}
		h.push(a)
	}
	h[d.length] = ("var _n = " + f + ".length;\nvar i" + (b ? "" : ", ret = Array(_n)") + ";\n" + c + "\nfor(i=_n-1;i!==-1;--i) {\n" + g + "\n}\nreturn ret;");
	return Function.apply(null, h)
};
numeric._biforeach = (function _biforeach(a, h, d, b, e) {
	if (b === d.length - 1) {
		e(a, h);
		return
	}
	var c, g = d[b];
	for (c = g - 1; c >= 0; c--) {
		_biforeach(typeof a === "object" ? a[c] : a, typeof h === "object" ? h[c] : h, d, b + 1, e)
	}
});
numeric._biforeach2 = (function _biforeach2(a, j, e, b, g) {
	if (b === e.length - 1) {
		return g(a, j)
	}
	var d, h = e[b],
		c = Array(h);
	for (d = h - 1; d >= 0; --d) {
		c[d] = _biforeach2(typeof a === "object" ? a[d] : a, typeof j === "object" ? j[d] : j, e, b + 1, g)
	}
	return c
});
numeric._foreach = (function _foreach(a, d, b, e) {
	if (b === d.length - 1) {
		e(a);
		return
	}
	var c, g = d[b];
	for (c = g - 1; c >= 0; c--) {
		_foreach(a[c], d, b + 1, e)
	}
});
numeric._foreach2 = (function _foreach2(a, e, b, g) {
	if (b === e.length - 1) {
		return g(a)
	}
	var d, h = e[b],
		c = Array(h);
	for (d = h - 1; d >= 0; d--) {
		c[d] = _foreach2(a[d], e, b + 1, g)
	}
	return c
});
numeric.ops2 = {
	add: "+",
	sub: "-",
	mul: "*",
	div: "/",
	mod: "%",
	and: "&&",
	or: "||",
	eq: "===",
	neq: "!==",
	lt: "<",
	gt: ">",
	leq: "<=",
	geq: ">=",
	band: "&",
	bor: "|",
	bxor: "^",
	lshift: "<<",
	rshift: ">>",
	rrshift: ">>>"
};
numeric.opseq = {
	addeq: "+=",
	subeq: "-=",
	muleq: "*=",
	diveq: "/=",
	modeq: "%=",
	lshifteq: "<<=",
	rshifteq: ">>=",
	rrshifteq: ">>>=",
	bandeq: "&=",
	boreq: "|=",
	bxoreq: "^="
};
numeric.mathfuns = ["abs", "acos", "asin", "atan", "ceil", "cos", "exp", "floor", "log", "round", "sin", "sqrt", "tan", "isNaN", "isFinite"];
numeric.mathfuns2 = ["atan2", "pow", "max", "min"];
numeric.ops1 = {
	neg: "-",
	not: "!",
	bnot: "~",
	clone: ""
};
numeric.mapreducers = {
	any: ["if(xi) return true;", "var accum = false;"],
	all: ["if(!xi) return false;", "var accum = true;"],
	sum: ["accum += xi;", "var accum = 0;"],
	prod: ["accum *= xi;", "var accum = 1;"],
	norm2Squared: ["accum += xi*xi;", "var accum = 0;"],
	norminf: ["accum = max(accum,abs(xi));", "var accum = 0, max = Math.max, abs = Math.abs;"],
	norm1: ["accum += abs(xi)", "var accum = 0, abs = Math.abs;"],
	sup: ["accum = max(accum,xi);", "var accum = -Infinity, max = Math.max;"],
	inf: ["accum = min(accum,xi);", "var accum = Infinity, min = Math.min;"]
};
(function() {
	var b, e;
	for (b = 0; b < numeric.mathfuns2.length; ++b) {
		e = numeric.mathfuns2[b];
		numeric.ops2[e] = e
	}
	for (b in numeric.ops2) {
		if (numeric.ops2.hasOwnProperty(b)) {
			e = numeric.ops2[b];
			var c, d, a = "";
			if (numeric.myIndexOf.call(numeric.mathfuns2, b) !== -1) {
				a = "var " + e + " = Math." + e + ";\n";
				c = function(g, f, h) {
					return g + " = " + e + "(" + f + "," + h + ")"
				};
				d = function(f, g) {
					return f + " = " + e + "(" + f + "," + g + ")"
				}
			} else {
				c = function(g, f, h) {
					return g + " = " + f + " " + e + " " + h
				};
				if (numeric.opseq.hasOwnProperty(b + "eq")) {
					d = function(f, g) {
						return f + " " + e + "= " + g
					}
				} else {
					d = function(f, g) {
						return f + " = " + f + " " + e + " " + g
					}
				}
			}
			numeric[b + "VV"] = numeric.pointwise2(["x[i]", "y[i]"], c("ret[i]", "x[i]", "y[i]"), a);
			numeric[b + "SV"] = numeric.pointwise2(["x", "y[i]"], c("ret[i]", "x", "y[i]"), a);
			numeric[b + "VS"] = numeric.pointwise2(["x[i]", "y"], c("ret[i]", "x[i]", "y"), a);
			numeric[b] = Function("var n = arguments.length, i, x = arguments[0], y;\nvar VV = numeric." + b + "VV, VS = numeric." + b + "VS, SV = numeric." + b + 'SV;\nvar dim = numeric.dim;\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof x === "object") {\n      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n  else ' + d("x", "y") + "\n}\nreturn x;\n");
			numeric[e] = numeric[b];
			numeric[b + "eqV"] = numeric.pointwise2(["ret[i]", "x[i]"], d("ret[i]", "x[i]"), a);
			numeric[b + "eqS"] = numeric.pointwise2(["ret[i]", "x"], d("ret[i]", "x"), a);
			numeric[b + "eq"] = Function("var n = arguments.length, i, x = arguments[0], y;\nvar V = numeric." + b + "eqV, S = numeric." + b + 'eqS\nvar s = numeric.dim(x);\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n  else numeric._biforeach(x,y,s,0,S);\n}\nreturn x;\n')
		}
	}
	for (b = 0; b < numeric.mathfuns2.length; ++b) {
		e = numeric.mathfuns2[b];
		delete numeric.ops2[e]
	}
	for (b = 0; b < numeric.mathfuns.length; ++b) {
		e = numeric.mathfuns[b];
		numeric.ops1[e] = e
	}
	for (b in numeric.ops1) {
		if (numeric.ops1.hasOwnProperty(b)) {
			a = "";
			e = numeric.ops1[b];
			if (numeric.myIndexOf.call(numeric.mathfuns, b) !== -1) {
				if (Math.hasOwnProperty(e)) {
					a = "var " + e + " = Math." + e + ";\n"
				}
			}
			numeric[b + "eqV"] = numeric.pointwise2(["ret[i]"], "ret[i] = " + e + "(ret[i]);", a);
			numeric[b + "eq"] = Function("x", 'if(typeof x !== "object") return ' + e + "x\nvar i;\nvar V = numeric." + b + "eqV;\nvar s = numeric.dim(x);\nnumeric._foreach(x,s,0,V);\nreturn x;\n");
			numeric[b + "V"] = numeric.pointwise2(["x[i]"], "ret[i] = " + e + "(x[i]);", a);
			numeric[b] = Function("x", 'if(typeof x !== "object") return ' + e + "(x)\nvar i;\nvar V = numeric." + b + "V;\nvar s = numeric.dim(x);\nreturn numeric._foreach2(x,s,0,V);\n")
		}
	}
	for (b = 0; b < numeric.mathfuns.length; ++b) {
		e = numeric.mathfuns[b];
		delete numeric.ops1[e]
	}
	for (b in numeric.mapreducers) {
		if (numeric.mapreducers.hasOwnProperty(b)) {
			e = numeric.mapreducers[b];
			numeric[b + "V"] = numeric.mapreduce2(e[0], e[1]);
			numeric[b] = Function("x", "s", "k", e[1] + 'if(typeof x !== "object") {    xi = x;\n' + e[0] + ';\n    return accum;\n}if(typeof s === "undefined") s = numeric.dim(x);\nif(typeof k === "undefined") k = 0;\nif(k === s.length-1) return numeric.' + b + "V(x);\nvar xi;\nvar n = x.length, i;\nfor(i=n-1;i!==-1;--i) {\n   xi = arguments.callee(x[i]);\n" + e[0] + ";\n}\nreturn accum;\n")
		}
	}
}());
numeric.det = function det(p) {
	var u = numeric.dim(p);
	if (u.length !== 2 || u[0] !== u[1]) {
		throw new Error("numeric: det() only works on square matrices")
	}
	var b = u[0],
		l = 1,
		f, e, d, a = numeric.clone(p),
		o, q, c, r, m, h, g;
	for (e = 0; e < b - 1; e++) {
		d = e;
		for (f = e + 1; f < b; f++) {
			if (Math.abs(a[f][e]) > Math.abs(a[d][e])) {
				d = f
			}
		}
		if (d !== e) {
			r = a[d];
			a[d] = a[e];
			a[e] = r;
			l *= -1
		}
		o = a[e];
		for (f = e + 1; f < b; f++) {
			q = a[f];
			c = q[e] / o[e];
			for (d = e + 1; d < b - 1; d += 2) {
				m = d + 1;
				q[d] -= o[d] * c;
				q[m] -= o[m] * c
			}
			if (d !== b) {
				q[d] -= o[d] * c
			}
		}
		if (o[e] === 0) {
			return 0
		}
		l *= o[e]
	}
	return l * a[e][e]
};
numeric.transpose = function transpose(k) {
	var g, e, c = k.length,
		a = k[0].length,
		h = Array(a),
		d, b, f;
	for (e = 0; e < a; e++) {
		h[e] = Array(c)
	}
	for (g = c - 1; g >= 1; g -= 2) {
		b = k[g];
		d = k[g - 1];
		for (e = a - 1; e >= 1; --e) {
			f = h[e];
			f[g] = b[e];
			f[g - 1] = d[e];
			--e;
			f = h[e];
			f[g] = b[e];
			f[g - 1] = d[e]
		}
		if (e === 0) {
			f = h[0];
			f[g] = b[0];
			f[g - 1] = d[0]
		}
	}
	if (g === 0) {
		d = k[0];
		for (e = a - 1; e >= 1; --e) {
			h[e][0] = d[e];
			--e;
			h[e][0] = d[e]
		}
		if (e === 0) {
			h[0][0] = d[0]
		}
	}
	return h
};
numeric.negtranspose = function negtranspose(k) {
	var g, e, c = k.length,
		a = k[0].length,
		h = Array(a),
		d, b, f;
	for (e = 0; e < a; e++) {
		h[e] = Array(c)
	}
	for (g = c - 1; g >= 1; g -= 2) {
		b = k[g];
		d = k[g - 1];
		for (e = a - 1; e >= 1; --e) {
			f = h[e];
			f[g] = -b[e];
			f[g - 1] = -d[e];
			--e;
			f = h[e];
			f[g] = -b[e];
			f[g - 1] = -d[e]
		}
		if (e === 0) {
			f = h[0];
			f[g] = -b[0];
			f[g - 1] = -d[0]
		}
	}
	if (g === 0) {
		d = k[0];
		for (e = a - 1; e >= 1; --e) {
			h[e][0] = -d[e];
			--e;
			h[e][0] = -d[e]
		}
		if (e === 0) {
			h[0][0] = -d[0]
		}
	}
	return h
};
numeric.norm2 = function norm2(a) {
	return Math.sqrt(numeric.norm2Squared(a))
};
numeric.getBlock = function getBlock(a, e, d) {
	var b = numeric.dim(a);

	function c(f, h) {
		var l, g = e[h],
			m = d[h] - g,
			j = Array(m);
		if (h === b.length - 1) {
			for (l = m; l >= 0; l--) {
				j[l] = f[l + g]
			}
			return j
		}
		for (l = m; l >= 0; l--) {
			j[l] = c(f[l + g], h + 1)
		}
		return j
	}
	return c(a, 0)
};
numeric.setBlock = function setBlock(a, f, e, d) {
	var b = numeric.dim(a);

	function c(g, o, j) {
		var l, h = f[j],
			m = e[j] - h;
		if (j === b.length - 1) {
			for (l = m; l >= 0; l--) {
				g[l + h] = o[l]
			}
		}
		for (l = m; l >= 0; l--) {
			c(g[l + h], o[l], j + 1)
		}
	}
	c(a, d, 0);
	return a
};
numeric.getRange = function getRange(b, l, k) {
	var e = l.length,
		d = k.length;
	var g, f;
	var a = Array(e),
		h, c;
	for (g = e - 1; g !== -1; --g) {
		a[g] = Array(d);
		h = a[g];
		c = b[l[g]];
		for (f = d - 1; f !== -1; --f) {
			h[f] = c[k[f]]
		}
	}
	return a
};
numeric.tensor = function tensor(h, g) {
	if (typeof h === "number" || typeof g === "number") {
		return numeric.mul(h, g)
	}
	var o = numeric.dim(h),
		k = numeric.dim(g);
	if (o.length !== 1 || k.length !== 1) {
		throw new Error("numeric: tensor product is only defined for vectors")
	}
	var c = o[0],
		b = k[0],
		a = Array(c),
		l, e, d, f;
	for (e = c - 1; e >= 0; e--) {
		l = Array(b);
		f = h[e];
		for (d = b - 1; d >= 3; --d) {
			l[d] = f * g[d];
			--d;
			l[d] = f * g[d];
			--d;
			l[d] = f * g[d];
			--d;
			l[d] = f * g[d]
		}
		while (d >= 0) {
			l[d] = f * g[d];
			--d
		}
		a[e] = l
	}
	return a
};
numeric.T = function T(a, b) {
	this.x = a;
	this.y = b
};
numeric.t = function t(a, b) {
	return new numeric.T(a, b)
};
numeric.Tbinop = function Tbinop(c, e, d, g, a) {
	var f = numeric.indexOf;
	if (typeof a !== "string") {
		var b;
		a = "";
		for (b in numeric) {
			if (numeric.hasOwnProperty(b) && (c.indexOf(b) >= 0 || e.indexOf(b) >= 0 || d.indexOf(b) >= 0 || g.indexOf(b) >= 0) && b.length > 1) {
				a += "var " + b + " = numeric." + b + ";\n"
			}
		}
	}
	return Function(["y"], "var x = this;\nif(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n" + a + "\nif(x.y) {  if(y.y) {    return new numeric.T(" + g + ");\n  }\n  return new numeric.T(" + d + ");\n}\nif(y.y) {\n  return new numeric.T(" + e + ");\n}\nreturn new numeric.T(" + c + ");\n")
};
numeric.T.prototype.add = numeric.Tbinop("add(x.x,y.x)", "add(x.x,y.x),y.y", "add(x.x,y.x),x.y", "add(x.x,y.x),add(x.y,y.y)");
numeric.T.prototype.sub = numeric.Tbinop("sub(x.x,y.x)", "sub(x.x,y.x),neg(y.y)", "sub(x.x,y.x),x.y", "sub(x.x,y.x),sub(x.y,y.y)");
numeric.T.prototype.mul = numeric.Tbinop("mul(x.x,y.x)", "mul(x.x,y.x),mul(x.x,y.y)", "mul(x.x,y.x),mul(x.y,y.x)", "sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))");
numeric.T.prototype.reciprocal = function reciprocal() {
	var a = numeric.mul,
		c = numeric.div;
	if (this.y) {
		var b = numeric.add(a(this.x, this.x), a(this.y, this.y));
		return new numeric.T(c(this.x, b), c(numeric.neg(this.y), b))
	}
	return new T(c(1, this.x))
};
numeric.T.prototype.div = function div(b) {
	if (!(b instanceof numeric.T)) {
		b = new numeric.T(b)
	}
	if (b.y) {
		return this.mul(b.reciprocal())
	}
	var a = numeric.div;
	if (this.y) {
		return new numeric.T(a(this.x, b.x), a(this.y, b.x))
	}
	return new numeric.T(a(this.x, b.x))
};
numeric.T.prototype.dot = numeric.Tbinop("dot(x.x,y.x)", "dot(x.x,y.x),dot(x.x,y.y)", "dot(x.x,y.x),dot(x.y,y.x)", "sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))");
numeric.T.prototype.transpose = function transpose() {
	var b = numeric.transpose,
		a = this.x,
		c = this.y;
	if (c) {
		return new numeric.T(b(a), b(c))
	}
	return new numeric.T(b(a))
};
numeric.T.prototype.transjugate = function transjugate() {
	var b = numeric.transpose,
		a = this.x,
		c = this.y;
	if (c) {
		return new numeric.T(b(a), numeric.negtranspose(c))
	}
	return new numeric.T(b(a))
};
numeric.Tunop = function Tunop(b, d, a) {
	if (typeof a !== "string") {
		a = ""
	}
	return Function("var x = this;\n" + a + "\nif(x.y) {  " + d + ";\n}\n" + b + ";\n")
};
numeric.T.prototype.exp = numeric.Tunop("return new numeric.T(ex)", "return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))", "var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;");
numeric.T.prototype.conj = numeric.Tunop("return new numeric.T(x.x);", "return new numeric.T(x.x,numeric.neg(x.y));");
numeric.T.prototype.neg = numeric.Tunop("return new numeric.T(neg(x.x));", "return new numeric.T(neg(x.x),neg(x.y));", "var neg = numeric.neg;");
numeric.T.prototype.sin = numeric.Tunop("return new numeric.T(numeric.sin(x.x))", "return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));");
numeric.T.prototype.cos = numeric.Tunop("return new numeric.T(numeric.cos(x.x))", "return x.exp().add(x.neg().exp()).div(2);");
numeric.T.prototype.abs = numeric.Tunop("return new numeric.T(numeric.abs(x.x));", "return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));", "var mul = numeric.mul;");
numeric.T.prototype.log = numeric.Tunop("return new numeric.T(numeric.log(x.x));", "var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\nreturn new numeric.T(numeric.log(r.x),theta.x);");
numeric.T.prototype.norm2 = numeric.Tunop("return numeric.norm2(x.x);", "var f = numeric.norm2Squared;\nreturn Math.sqrt(f(x.x)+f(x.y));");
numeric.T.prototype.get = function get(d) {
	var a = this.x,
		f = this.y,
		b = 0,
		c, e = d.length;
	if (f) {
		while (b < e) {
			c = d[b];
			a = a[c];
			f = f[c];
			b++
		}
		return new numeric.T(a, f)
	}
	while (b < e) {
		c = d[b];
		a = a[c];
		b++
	}
	return new numeric.T(a)
};
numeric.T.prototype.set = function set(c, j) {
	var g = this.x,
		e = this.y,
		b = 0,
		h, a = c.length,
		f = j.x,
		d = j.y;
	if (a === 0) {
		if (d) {
			this.y = d
		} else {
			if (e) {
				this.y = undefined
			}
		}
		this.x = g;
		return this
	}
	if (d) {
		if (e) {} else {
			e = numeric.rep(numeric.dim(g), 0);
			this.y = e
		}
		while (b < a - 1) {
			h = c[b];
			g = g[h];
			e = e[h];
			b++
		}
		h = c[b];
		g[h] = f;
		e[h] = d;
		return this
	}
	if (e) {
		while (b < a - 1) {
			h = c[b];
			g = g[h];
			e = e[h];
			b++
		}
		h = c[b];
		g[h] = f;
		if (f instanceof Array) {
			e[h] = numeric.rep(numeric.dim(f), 0)
		} else {
			e[h] = 0
		}
		return this
	}
	while (b < a - 1) {
		h = c[b];
		g = g[h];
		b++
	}
	h = c[b];
	g[h] = f;
	return this
};
numeric.T.prototype.getRows = function getRows(e, c) {
	var h = c - e + 1,
		b;
	var f = Array(h),
		d, a = this.x,
		g = this.y;
	for (b = e; b <= c; b++) {
		f[b - e] = a[b]
	}
	if (g) {
		d = Array(h);
		for (b = e; b <= c; b++) {
			d[b - e] = g[b]
		}
		return new numeric.T(f, d)
	}
	return new numeric.T(f)
};
numeric.T.prototype.setRows = function setRows(f, d, b) {
	var c;
	var g = this.x,
		e = this.y,
		a = b.x,
		h = b.y;
	for (c = f; c <= d; c++) {
		g[c] = a[c - f]
	}
	if (h) {
		if (!e) {
			e = numeric.rep(numeric.dim(g), 0);
			this.y = e
		}
		for (c = f; c <= d; c++) {
			e[c] = h[c - f]
		}
	} else {
		if (e) {
			for (c = f; c <= d; c++) {
				e[c] = numeric.rep([a[c - f].length], 0)
			}
		}
	}
	return this
};
numeric.T.prototype.getRow = function getRow(b) {
	var a = this.x,
		c = this.y;
	if (c) {
		return new numeric.T(a[b], c[b])
	}
	return new numeric.T(a[b])
};
numeric.T.prototype.setRow = function setRow(c, b) {
	var e = this.x,
		d = this.y,
		a = b.x,
		f = b.y;
	e[c] = a;
	if (f) {
		if (!d) {
			d = numeric.rep(numeric.dim(e), 0);
			this.y = d
		}
		d[c] = f
	} else {
		if (d) {
			d = numeric.rep([a.length], 0)
		}
	}
	return this
};
numeric.T.prototype.getBlock = function getBlock(f, e) {
	var c = this.x,
		d = this.y,
		a = numeric.getBlock;
	if (d) {
		return new numeric.T(a(c, f, e), a(d, f, e))
	}
	return new numeric.T(a(c, f, e))
};
numeric.T.prototype.setBlock = function setBlock(i, h, d) {
	if (!(d instanceof numeric.T)) {
		d = new numeric.T(d)
	}
	var c = this.x,
		g = this.y,
		a = numeric.setBlock,
		f = d.x,
		e = d.y;
	if (e) {
		if (!g) {
			this.y = numeric.rep(numeric.dim(this), 0);
			g = this.y
		}
		a(c, i, h, f);
		a(g, i, h, e);
		return this
	}
	a(c, i, h, f);
	if (g) {
		a(g, i, h, numeric.rep(numeric.dim(f), 0))
	}
};
numeric.T.rep = function rep(d, b) {
	var c = numeric.T;
	if (!(b instanceof c)) {
		b = new c(b)
	}
	var a = b.x,
		f = b.y,
		e = numeric.rep;
	if (f) {
		return new c(e(d, a), e(d, f))
	}
	return new c(e(d, a))
};
numeric.T.diag = function diag(c) {
	if (!(c instanceof numeric.T)) {
		c = new numeric.T(c)
	}
	var a = c.x,
		e = c.y,
		b = numeric.diag;
	if (e) {
		return new numeric.T(b(a), b(e))
	}
	return new numeric.T(b(a))
};
numeric.T.eig = function eig() {
	if (this.y) {
		throw new Error("eig: not implemented for complex matrices.")
	}
	return numeric.eig(this.x)
};
numeric.T.identity = function identity(a) {
	return new numeric.T(numeric.identity(a))
};
numeric.T.prototype.getDiag = function getDiag() {
	var c = numeric;
	var a = this.x,
		b = this.y;
	if (b) {
		return new c.T(c.getDiag(a), c.getDiag(b))
	}
	return new c.T(c.getDiag(a))
};
numeric.house = function house(a) {
	var b = numeric.clone(a);
	var c = a[0] >= 0 ? 1 : -1;
	var d = c * numeric.norm2(a);
	b[0] += d;
	var e = numeric.norm2(b);
	if (e === 0) {
		throw new Error("eig: internal error")
	}
	return numeric.div(b, e)
};
numeric.toUpperHessenberg = function toUpperHessenberg(o) {
	var u = numeric.dim(o);
	if (u.length !== 2 || u[0] !== u[1]) {
		throw new Error("numeric: toUpperHessenberg() only works on square matrices")
	}
	var f = u[0],
		l, h, g, p, r, d = numeric.clone(o),
		c, a, q, b, n = numeric.identity(f),
		e;
	for (h = 0; h < f - 2; h++) {
		p = Array(f - h - 1);
		for (l = h + 1; l < f; l++) {
			p[l - h - 1] = d[l][h]
		}
		if (numeric.norm2(p) > 0) {
			r = numeric.house(p);
			c = numeric.getBlock(d, [h + 1, h], [f - 1, f - 1]);
			a = numeric.tensor(r, numeric.dot(r, c));
			for (l = h + 1; l < f; l++) {
				q = d[l];
				b = a[l - h - 1];
				for (g = h; g < f; g++) {
					q[g] -= 2 * b[g - h]
				}
			}
			c = numeric.getBlock(d, [0, h + 1], [f - 1, f - 1]);
			a = numeric.tensor(numeric.dot(c, r), r);
			for (l = 0; l < f; l++) {
				q = d[l];
				b = a[l];
				for (g = h + 1; g < f; g++) {
					q[g] -= 2 * b[g - h - 1]
				}
			}
			c = Array(f - h - 1);
			for (l = h + 1; l < f; l++) {
				c[l - h - 1] = n[l]
			}
			a = numeric.tensor(r, numeric.dot(r, c));
			for (l = h + 1; l < f; l++) {
				e = n[l];
				b = a[l - h - 1];
				for (g = 0; g < f; g++) {
					e[g] -= 2 * b[g]
				}
			}
		}
	}
	return {
		H: d,
		Q: n
	}
};
numeric.epsilon = 2.220446049250313e-16;
numeric.QRFrancis = function(z, h) {
	if (typeof h === "undefined") {
		h = 10000
	}
	z = numeric.clone(z);
	var D = numeric.clone(z);
	var E = numeric.dim(z),
		K = E[0],
		y, A, U, S, R, P, n, e, l, q = numeric.identity(K),
		u, r, I, G, F, O, M, L, N;
	if (K < 3) {
		return {
			Q: q,
			B: [
				[0, K - 1]
			]
		}
	}
	var V = numeric.epsilon;
	for (N = 0; N < h; N++) {
		for (M = 0; M < K - 1; M++) {
			if (Math.abs(z[M + 1][M]) < V * (Math.abs(z[M][M]) + Math.abs(z[M + 1][M + 1]))) {
				var p = numeric.QRFrancis(numeric.getBlock(z, [0, 0], [M, M]), h);
				var o = numeric.QRFrancis(numeric.getBlock(z, [M + 1, M + 1], [K - 1, K - 1]), h);
				I = Array(M + 1);
				for (O = 0; O <= M; O++) {
					I[O] = q[O]
				}
				G = numeric.dot(p.Q, I);
				for (O = 0; O <= M; O++) {
					q[O] = G[O]
				}
				I = Array(K - M - 1);
				for (O = M + 1; O < K; O++) {
					I[O - M - 1] = q[O]
				}
				G = numeric.dot(o.Q, I);
				for (O = M + 1; O < K; O++) {
					q[O] = G[O - M - 1]
				}
				return {
					Q: q,
					B: p.B.concat(numeric.add(o.B, M + 1))
				}
			}
		}
		U = z[K - 2][K - 2];
		S = z[K - 2][K - 1];
		R = z[K - 1][K - 2];
		P = z[K - 1][K - 1];
		e = U + P;
		n = (U * P - S * R);
		l = numeric.getBlock(z, [0, 0], [2, 2]);
		if (e * e >= 4 * n) {
			var g, f;
			g = 0.5 * (e + Math.sqrt(e * e - 4 * n));
			f = 0.5 * (e - Math.sqrt(e * e - 4 * n));
			l = numeric.add(numeric.sub(numeric.dot(l, l), numeric.mul(l, g + f)), numeric.diag(numeric.rep([3], g * f)))
		} else {
			l = numeric.add(numeric.sub(numeric.dot(l, l), numeric.mul(l, e)), numeric.diag(numeric.rep([3], n)))
		}
		y = [l[0][0], l[1][0], l[2][0]];
		A = numeric.house(y);
		I = [z[0], z[1], z[2]];
		G = numeric.tensor(A, numeric.dot(A, I));
		for (O = 0; O < 3; O++) {
			r = z[O];
			F = G[O];
			for (L = 0; L < K; L++) {
				r[L] -= 2 * F[L]
			}
		}
		I = numeric.getBlock(z, [0, 0], [K - 1, 2]);
		G = numeric.tensor(numeric.dot(I, A), A);
		for (O = 0; O < K; O++) {
			r = z[O];
			F = G[O];
			for (L = 0; L < 3; L++) {
				r[L] -= 2 * F[L]
			}
		}
		I = [q[0], q[1], q[2]];
		G = numeric.tensor(A, numeric.dot(A, I));
		for (O = 0; O < 3; O++) {
			u = q[O];
			F = G[O];
			for (L = 0; L < K; L++) {
				u[L] -= 2 * F[L]
			}
		}
		var w;
		for (M = 0; M < K - 2; M++) {
			for (L = M; L <= M + 1; L++) {
				if (Math.abs(z[L + 1][L]) < V * (Math.abs(z[L][L]) + Math.abs(z[L + 1][L + 1]))) {
					var p = numeric.QRFrancis(numeric.getBlock(z, [0, 0], [L, L]), h);
					var o = numeric.QRFrancis(numeric.getBlock(z, [L + 1, L + 1], [K - 1, K - 1]), h);
					I = Array(L + 1);
					for (O = 0; O <= L; O++) {
						I[O] = q[O]
					}
					G = numeric.dot(p.Q, I);
					for (O = 0; O <= L; O++) {
						q[O] = G[O]
					}
					I = Array(K - L - 1);
					for (O = L + 1; O < K; O++) {
						I[O - L - 1] = q[O]
					}
					G = numeric.dot(o.Q, I);
					for (O = L + 1; O < K; O++) {
						q[O] = G[O - L - 1]
					}
					return {
						Q: q,
						B: p.B.concat(numeric.add(o.B, L + 1))
					}
				}
			}
			w = Math.min(K - 1, M + 3);
			y = Array(w - M);
			for (O = M + 1; O <= w; O++) {
				y[O - M - 1] = z[O][M]
			}
			A = numeric.house(y);
			I = numeric.getBlock(z, [M + 1, M], [w, K - 1]);
			G = numeric.tensor(A, numeric.dot(A, I));
			for (O = M + 1; O <= w; O++) {
				r = z[O];
				F = G[O - M - 1];
				for (L = M; L < K; L++) {
					r[L] -= 2 * F[L - M]
				}
			}
			I = numeric.getBlock(z, [0, M + 1], [K - 1, w]);
			G = numeric.tensor(numeric.dot(I, A), A);
			for (O = 0; O < K; O++) {
				r = z[O];
				F = G[O];
				for (L = M + 1; L <= w; L++) {
					r[L] -= 2 * F[L - M - 1]
				}
			}
			I = Array(w - M);
			for (O = M + 1; O <= w; O++) {
				I[O - M - 1] = q[O]
			}
			G = numeric.tensor(A, numeric.dot(A, I));
			for (O = M + 1; O <= w; O++) {
				u = q[O];
				F = G[O - M - 1];
				for (L = 0; L < K; L++) {
					u[L] -= 2 * F[L]
				}
			}
		}
	}
	throw new Error("numeric: eigenvalue iteration does not converge -- increase maxiter?")
};
numeric.eig = function eig(L, l) {
	var f = numeric.toUpperHessenberg(L);
	var o = numeric.QRFrancis(f.H, l);
	var r = numeric.T;
	var O = L.length,
		W, S, V = false,
		J = o.B,
		D = numeric.dot(o.Q, numeric.dot(f.H, numeric.transpose(o.Q)));
	var u = new r(numeric.dot(o.Q, f.Q)),
		G;
	var P = J.length,
		U;
	var aa, Z, Y, X, h, g, e, C, z, K, I, w, v;
	var ab = Math.sqrt;
	for (S = 0; S < P; S++) {
		W = J[S][0];
		if (W === J[S][1]) {} else {
			U = W + 1;
			aa = D[W][W];
			Z = D[W][U];
			Y = D[U][W];
			X = D[U][U];
			if (Z === 0 && Y === 0) {
				continue
			}
			h = -aa - X;
			g = aa * X - Z * Y;
			e = h * h - 4 * g;
			if (e >= 0) {
				if (h < 0) {
					C = -0.5 * (h - ab(e))
				} else {
					C = -0.5 * (h + ab(e))
				}
				w = (aa - C) * (aa - C) + Z * Z;
				v = Y * Y + (X - C) * (X - C);
				if (w > v) {
					w = ab(w);
					K = (aa - C) / w;
					I = Z / w
				} else {
					v = ab(v);
					K = Y / v;
					I = (X - C) / v
				}
				G = new r([
					[I, -K],
					[K, I]
				]);
				u.setRows(W, U, G.dot(u.getRows(W, U)))
			} else {
				C = -0.5 * h;
				z = 0.5 * ab(-e);
				w = (aa - C) * (aa - C) + Z * Z;
				v = Y * Y + (X - C) * (X - C);
				if (w > v) {
					w = ab(w + z * z);
					K = (aa - C) / w;
					I = Z / w;
					C = 0;
					z /= w
				} else {
					v = ab(v + z * z);
					K = Y / v;
					I = (X - C) / v;
					C = z / v;
					z = 0
				}
				G = new r([
					[I, -K],
					[K, I]
				], [
					[C, z],
					[z, -C]
				]);
				u.setRows(W, U, G.dot(u.getRows(W, U)))
			}
		}
	}
	var s = u.dot(L).dot(u.transjugate()),
		O = L.length,
		F = numeric.T.identity(O);
	for (U = 0; U < O; U++) {
		if (U > 0) {
			for (S = U - 1; S >= 0; S--) {
				var M = s.get([S, S]),
					N = s.get([U, U]);
				if (numeric.neq(M.x, N.x) || numeric.neq(M.y, N.y)) {
					C = s.getRow(S).getBlock([S], [U - 1]);
					z = F.getRow(U).getBlock([S], [U - 1]);
					F.set([U, S], (s.get([S, U]).neg().sub(C.dot(z))).div(M.sub(N)))
				} else {
					F.setRow(U, F.getRow(S));
					continue
				}
			}
		}
	}
	for (U = 0; U < O; U++) {
		C = F.getRow(U);
		F.setRow(U, C.div(C.norm2()))
	}
	F = F.transpose();
	F = u.transjugate().dot(F);
	return {
		lambda: s.getDiag(),
		E: F
	}
};
(function(a) {
	if (typeof exports === "object") {
		module.exports = a()
	} else {
		if (typeof define === "function" && define.amd) {
			define(a)
		} else {
			var c;
			try {
				c = window
			} catch (b) {
				c = self
			}
			c.SparkMD5 = a()
		}
	}
}(function(c) {
	var e = function(s, r) {
			return (s + r) & 4294967295
		},
		j = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

	function l(z, v, u, r, y, w) {
		v = e(e(v, z), e(r, w));
		return e((v << y) | (v >>> (32 - y)), u)
	}

	function d(s, u) {
		var t = s[0],
			r = s[1],
			w = s[2],
			v = s[3];
		t += (r & w | ~r & v) + u[0] - 680876936 | 0;
		t = (t << 7 | t >>> 25) + r | 0;
		v += (t & r | ~t & w) + u[1] - 389564586 | 0;
		v = (v << 12 | v >>> 20) + t | 0;
		w += (v & t | ~v & r) + u[2] + 606105819 | 0;
		w = (w << 17 | w >>> 15) + v | 0;
		r += (w & v | ~w & t) + u[3] - 1044525330 | 0;
		r = (r << 22 | r >>> 10) + w | 0;
		t += (r & w | ~r & v) + u[4] - 176418897 | 0;
		t = (t << 7 | t >>> 25) + r | 0;
		v += (t & r | ~t & w) + u[5] + 1200080426 | 0;
		v = (v << 12 | v >>> 20) + t | 0;
		w += (v & t | ~v & r) + u[6] - 1473231341 | 0;
		w = (w << 17 | w >>> 15) + v | 0;
		r += (w & v | ~w & t) + u[7] - 45705983 | 0;
		r = (r << 22 | r >>> 10) + w | 0;
		t += (r & w | ~r & v) + u[8] + 1770035416 | 0;
		t = (t << 7 | t >>> 25) + r | 0;
		v += (t & r | ~t & w) + u[9] - 1958414417 | 0;
		v = (v << 12 | v >>> 20) + t | 0;
		w += (v & t | ~v & r) + u[10] - 42063 | 0;
		w = (w << 17 | w >>> 15) + v | 0;
		r += (w & v | ~w & t) + u[11] - 1990404162 | 0;
		r = (r << 22 | r >>> 10) + w | 0;
		t += (r & w | ~r & v) + u[12] + 1804603682 | 0;
		t = (t << 7 | t >>> 25) + r | 0;
		v += (t & r | ~t & w) + u[13] - 40341101 | 0;
		v = (v << 12 | v >>> 20) + t | 0;
		w += (v & t | ~v & r) + u[14] - 1502002290 | 0;
		w = (w << 17 | w >>> 15) + v | 0;
		r += (w & v | ~w & t) + u[15] + 1236535329 | 0;
		r = (r << 22 | r >>> 10) + w | 0;
		t += (r & v | w & ~v) + u[1] - 165796510 | 0;
		t = (t << 5 | t >>> 27) + r | 0;
		v += (t & w | r & ~w) + u[6] - 1069501632 | 0;
		v = (v << 9 | v >>> 23) + t | 0;
		w += (v & r | t & ~r) + u[11] + 643717713 | 0;
		w = (w << 14 | w >>> 18) + v | 0;
		r += (w & t | v & ~t) + u[0] - 373897302 | 0;
		r = (r << 20 | r >>> 12) + w | 0;
		t += (r & v | w & ~v) + u[5] - 701558691 | 0;
		t = (t << 5 | t >>> 27) + r | 0;
		v += (t & w | r & ~w) + u[10] + 38016083 | 0;
		v = (v << 9 | v >>> 23) + t | 0;
		w += (v & r | t & ~r) + u[15] - 660478335 | 0;
		w = (w << 14 | w >>> 18) + v | 0;
		r += (w & t | v & ~t) + u[4] - 405537848 | 0;
		r = (r << 20 | r >>> 12) + w | 0;
		t += (r & v | w & ~v) + u[9] + 568446438 | 0;
		t = (t << 5 | t >>> 27) + r | 0;
		v += (t & w | r & ~w) + u[14] - 1019803690 | 0;
		v = (v << 9 | v >>> 23) + t | 0;
		w += (v & r | t & ~r) + u[3] - 187363961 | 0;
		w = (w << 14 | w >>> 18) + v | 0;
		r += (w & t | v & ~t) + u[8] + 1163531501 | 0;
		r = (r << 20 | r >>> 12) + w | 0;
		t += (r & v | w & ~v) + u[13] - 1444681467 | 0;
		t = (t << 5 | t >>> 27) + r | 0;
		v += (t & w | r & ~w) + u[2] - 51403784 | 0;
		v = (v << 9 | v >>> 23) + t | 0;
		w += (v & r | t & ~r) + u[7] + 1735328473 | 0;
		w = (w << 14 | w >>> 18) + v | 0;
		r += (w & t | v & ~t) + u[12] - 1926607734 | 0;
		r = (r << 20 | r >>> 12) + w | 0;
		t += (r ^ w ^ v) + u[5] - 378558 | 0;
		t = (t << 4 | t >>> 28) + r | 0;
		v += (t ^ r ^ w) + u[8] - 2022574463 | 0;
		v = (v << 11 | v >>> 21) + t | 0;
		w += (v ^ t ^ r) + u[11] + 1839030562 | 0;
		w = (w << 16 | w >>> 16) + v | 0;
		r += (w ^ v ^ t) + u[14] - 35309556 | 0;
		r = (r << 23 | r >>> 9) + w | 0;
		t += (r ^ w ^ v) + u[1] - 1530992060 | 0;
		t = (t << 4 | t >>> 28) + r | 0;
		v += (t ^ r ^ w) + u[4] + 1272893353 | 0;
		v = (v << 11 | v >>> 21) + t | 0;
		w += (v ^ t ^ r) + u[7] - 155497632 | 0;
		w = (w << 16 | w >>> 16) + v | 0;
		r += (w ^ v ^ t) + u[10] - 1094730640 | 0;
		r = (r << 23 | r >>> 9) + w | 0;
		t += (r ^ w ^ v) + u[13] + 681279174 | 0;
		t = (t << 4 | t >>> 28) + r | 0;
		v += (t ^ r ^ w) + u[0] - 358537222 | 0;
		v = (v << 11 | v >>> 21) + t | 0;
		w += (v ^ t ^ r) + u[3] - 722521979 | 0;
		w = (w << 16 | w >>> 16) + v | 0;
		r += (w ^ v ^ t) + u[6] + 76029189 | 0;
		r = (r << 23 | r >>> 9) + w | 0;
		t += (r ^ w ^ v) + u[9] - 640364487 | 0;
		t = (t << 4 | t >>> 28) + r | 0;
		v += (t ^ r ^ w) + u[12] - 421815835 | 0;
		v = (v << 11 | v >>> 21) + t | 0;
		w += (v ^ t ^ r) + u[15] + 530742520 | 0;
		w = (w << 16 | w >>> 16) + v | 0;
		r += (w ^ v ^ t) + u[2] - 995338651 | 0;
		r = (r << 23 | r >>> 9) + w | 0;
		t += (w ^ (r | ~v)) + u[0] - 198630844 | 0;
		t = (t << 6 | t >>> 26) + r | 0;
		v += (r ^ (t | ~w)) + u[7] + 1126891415 | 0;
		v = (v << 10 | v >>> 22) + t | 0;
		w += (t ^ (v | ~r)) + u[14] - 1416354905 | 0;
		w = (w << 15 | w >>> 17) + v | 0;
		r += (v ^ (w | ~t)) + u[5] - 57434055 | 0;
		r = (r << 21 | r >>> 11) + w | 0;
		t += (w ^ (r | ~v)) + u[12] + 1700485571 | 0;
		t = (t << 6 | t >>> 26) + r | 0;
		v += (r ^ (t | ~w)) + u[3] - 1894986606 | 0;
		v = (v << 10 | v >>> 22) + t | 0;
		w += (t ^ (v | ~r)) + u[10] - 1051523 | 0;
		w = (w << 15 | w >>> 17) + v | 0;
		r += (v ^ (w | ~t)) + u[1] - 2054922799 | 0;
		r = (r << 21 | r >>> 11) + w | 0;
		t += (w ^ (r | ~v)) + u[8] + 1873313359 | 0;
		t = (t << 6 | t >>> 26) + r | 0;
		v += (r ^ (t | ~w)) + u[15] - 30611744 | 0;
		v = (v << 10 | v >>> 22) + t | 0;
		w += (t ^ (v | ~r)) + u[6] - 1560198380 | 0;
		w = (w << 15 | w >>> 17) + v | 0;
		r += (v ^ (w | ~t)) + u[13] + 1309151649 | 0;
		r = (r << 21 | r >>> 11) + w | 0;
		t += (w ^ (r | ~v)) + u[4] - 145523070 | 0;
		t = (t << 6 | t >>> 26) + r | 0;
		v += (r ^ (t | ~w)) + u[11] - 1120210379 | 0;
		v = (v << 10 | v >>> 22) + t | 0;
		w += (t ^ (v | ~r)) + u[2] + 718787259 | 0;
		w = (w << 15 | w >>> 17) + v | 0;
		r += (v ^ (w | ~t)) + u[9] - 343485551 | 0;
		r = (r << 21 | r >>> 11) + w | 0;
		s[0] = t + s[0] | 0;
		s[1] = r + s[1] | 0;
		s[2] = w + s[2] | 0;
		s[3] = v + s[3] | 0
	}

	function q(t) {
		var u = [],
			r;
		for (r = 0; r < 64; r += 4) {
			u[r >> 2] = t.charCodeAt(r) + (t.charCodeAt(r + 1) << 8) + (t.charCodeAt(r + 2) << 16) + (t.charCodeAt(r + 3) << 24)
		}
		return u
	}

	function m(r) {
		var t = [],
			s;
		for (s = 0; s < 64; s += 4) {
			t[s >> 2] = r[s] + (r[s + 1] << 8) + (r[s + 2] << 16) + (r[s + 3] << 24)
		}
		return t
	}

	function k(A) {
		var u = A.length,
			r = [1732584193, -271733879, -1732584194, 271733878],
			w, t, z, x, y, v;
		for (w = 64; w <= u; w += 64) {
			d(r, q(A.substring(w - 64, w)))
		}
		A = A.substring(w - 64);
		t = A.length;
		z = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		for (w = 0; w < t; w += 1) {
			z[w >> 2] |= A.charCodeAt(w) << ((w % 4) << 3)
		}
		z[w >> 2] |= 128 << ((w % 4) << 3);
		if (w > 55) {
			d(r, z);
			for (w = 0; w < 16; w += 1) {
				z[w] = 0
			}
		}
		x = u * 8;
		x = x.toString(16).match(/(.*?)(.{0,8})$/);
		y = parseInt(x[2], 16);
		v = parseInt(x[1], 16) || 0;
		z[14] = y;
		z[15] = v;
		d(r, z);
		return r
	}

	function n(z) {
		var t = z.length,
			r = [1732584193, -271733879, -1732584194, 271733878],
			v, s, y, w, x, u;
		for (v = 64; v <= t; v += 64) {
			d(r, m(z.subarray(v - 64, v)))
		}
		z = (v - 64) < t ? z.subarray(v - 64) : new Uint8Array(0);
		s = z.length;
		y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		for (v = 0; v < s; v += 1) {
			y[v >> 2] |= z[v] << ((v % 4) << 3)
		}
		y[v >> 2] |= 128 << ((v % 4) << 3);
		if (v > 55) {
			d(r, y);
			for (v = 0; v < 16; v += 1) {
				y[v] = 0
			}
		}
		w = t * 8;
		w = w.toString(16).match(/(.*?)(.{0,8})$/);
		x = parseInt(w[2], 16);
		u = parseInt(w[1], 16) || 0;
		y[14] = x;
		y[15] = u;
		d(r, y);
		return r
	}

	function i(u) {
		var t = "",
			r;
		for (r = 0; r < 4; r += 1) {
			t += j[(u >> (r * 8 + 4)) & 15] + j[(u >> (r * 8)) & 15]
		}
		return t
	}

	function b(r) {
		var s;
		for (s = 0; s < r.length; s += 1) {
			r[s] = i(r[s])
		}
		return r.join("")
	}
	if (b(k("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
		e = function(r, u) {
			var t = (r & 65535) + (u & 65535),
				s = (r >> 16) + (u >> 16) + (t >> 16);
			return (s << 16) | (t & 65535)
		}
	}
	if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
		(function() {
			function r(t, s) {
				t = (t | 0) || 0;
				if (t < 0) {
					return Math.max(t + s, 0)
				}
				return Math.min(t, s)
			}
			ArrayBuffer.prototype.slice = function(z, A) {
				var s = this.byteLength,
					u = r(z, s),
					v = s,
					w, y, t, x;
				if (A !== c) {
					v = r(A, s)
				}
				if (u > v) {
					return new ArrayBuffer(0)
				}
				w = v - u;
				y = new ArrayBuffer(w);
				t = new Uint8Array(y);
				x = new Uint8Array(this, u, w);
				t.set(x);
				return y
			}
		})()
	}

	function a(r) {
		if (/[\u0080-\uFFFF]/.test(r)) {
			r = unescape(encodeURIComponent(r))
		}
		return r
	}

	function h(v, u) {
		var t = v.length,
			w = new ArrayBuffer(t),
			r = new Uint8Array(w),
			s;
		for (s = 0; s < t; s += 1) {
			r[s] = v.charCodeAt(s)
		}
		return u ? r : w
	}

	function g(r) {
		return String.fromCharCode.apply(null, new Uint8Array(r))
	}

	function p(u, s, t) {
		var r = new Uint8Array(u.byteLength + s.byteLength);
		r.set(new Uint8Array(u));
		r.set(new Uint8Array(s), u.byteLength);
		return t ? r : r.buffer
	}

	function o(u) {
		var s = [],
			t = u.length,
			r;
		for (r = 0; r < t - 1; r += 2) {
			s.push(parseInt(u.substr(r, 2), 16))
		}
		return String.fromCharCode.apply(String, s)
	}

	function f() {
		this.reset()
	}
	f.prototype.append = function(r) {
		this.appendBinary(a(r));
		return this
	};
	f.prototype.appendBinary = function(t) {
		this._buff += t;
		this._length += t.length;
		var s = this._buff.length,
			r;
		for (r = 64; r <= s; r += 64) {
			d(this._hash, q(this._buff.substring(r - 64, r)))
		}
		this._buff = this._buff.substring(r - 64);
		return this
	};
	f.prototype.end = function(t) {
		var w = this._buff,
			v = w.length,
			u, s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			r;
		for (u = 0; u < v; u += 1) {
			s[u >> 2] |= w.charCodeAt(u) << ((u % 4) << 3)
		}
		this._finish(s, v);
		r = b(this._hash);
		if (t) {
			r = o(r)
		}
		this.reset();
		return r
	};
	f.prototype.reset = function() {
		this._buff = "";
		this._length = 0;
		this._hash = [1732584193, -271733879, -1732584194, 271733878];
		return this
	};
	f.prototype.getState = function() {
		return {
			buff: this._buff,
			length: this._length,
			hash: this._hash
		}
	};
	f.prototype.setState = function(r) {
		this._buff = r.buff;
		this._length = r.length;
		this._hash = r.hash;
		return this
	};
	f.prototype.destroy = function() {
		delete this._hash;
		delete this._buff;
		delete this._length
	};
	f.prototype._finish = function(s, w) {
		var u = w,
			t, v, r;
		s[u >> 2] |= 128 << ((u % 4) << 3);
		if (u > 55) {
			d(this._hash, s);
			for (u = 0; u < 16; u += 1) {
				s[u] = 0
			}
		}
		t = this._length * 8;
		t = t.toString(16).match(/(.*?)(.{0,8})$/);
		v = parseInt(t[2], 16);
		r = parseInt(t[1], 16) || 0;
		s[14] = v;
		s[15] = r;
		d(this._hash, s)
	};
	f.hash = function(s, r) {
		return f.hashBinary(a(s), r)
	};
	f.hashBinary = function(t, s) {
		var u = k(t),
			r = b(u);
		return s ? o(r) : r
	};
	f.ArrayBuffer = function() {
		this.reset()
	};
	f.ArrayBuffer.prototype.append = function(r) {
		var u = p(this._buff.buffer, r, true),
			t = u.length,
			s;
		this._length += r.byteLength;
		for (s = 64; s <= t; s += 64) {
			d(this._hash, m(u.subarray(s - 64, s)))
		}
		this._buff = (s - 64) < t ? new Uint8Array(u.buffer.slice(s - 64)) : new Uint8Array(0);
		return this
	};
	f.ArrayBuffer.prototype.end = function(t) {
		var w = this._buff,
			v = w.length,
			s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			u, r;
		for (u = 0; u < v; u += 1) {
			s[u >> 2] |= w[u] << ((u % 4) << 3)
		}
		this._finish(s, v);
		r = b(this._hash);
		if (t) {
			r = o(r)
		}
		this.reset();
		return r
	};
	f.ArrayBuffer.prototype.reset = function() {
		this._buff = new Uint8Array(0);
		this._length = 0;
		this._hash = [1732584193, -271733879, -1732584194, 271733878];
		return this
	};
	f.ArrayBuffer.prototype.getState = function() {
		var r = f.prototype.getState.call(this);
		r.buff = g(r.buff);
		return r
	};
	f.ArrayBuffer.prototype.setState = function(r) {
		r.buff = h(r.buff, true);
		return f.prototype.setState.call(this, r)
	};
	f.ArrayBuffer.prototype.destroy = f.prototype.destroy;
	f.ArrayBuffer.prototype._finish = f.prototype._finish;
	f.ArrayBuffer.hash = function(r, t) {
		var u = n(new Uint8Array(r)),
			s = b(u);
		return t ? o(s) : s
	};
	return f
}));
if (typeof(CanvasXpress) == "undefined") {
	CanvasXpress = {}
}
var CanvasXpress = function(f, d, a, b, e, g, c) {
	this.setInit = function() {
		this.target = f;
		this.events = b;
		this.info = e;
		this.userId = 294882621166851;
		this.href = location.href;
		this.protocol = this.href.split(":")[0];
		this.meta = {
			version: 14,
			buildDate: "02-05-2017",
			ids: {},
			start: new Date().getTime(),
			data: false,
			canvas: {},
			config: {
				user: a,
				orig: {},
				vals: {},
				keys: []
			},
			vals: {},
			events: {},
			system: {},
			client: "",
			info: false,
			def: {}
		}
	};
	this.validateParameters = function() {
		this.validateData();
		this.validateConfig();
		this.validateEvents();
		this.validateInfo();
		this.validateAfterRender()
	};
	this.validateData = function() {
		this.dataURL = false;
		if (typeof(d) == "string") {
			if (!this.isValidURL(d)) {
				alert("Not a valid url\n")
			} else {
				this.dataURL = d;
				d = false
			}
		} else {
			try {
				JSON.stringify(d)
			} catch (h) {
				alert("Data object malformed:\n" + h)
			}
		}
	};
	this.validateConfig = function() {
		if (!a) {
			a = {}
		} else {
			try {
				JSON.stringify(a)
			} catch (h) {
				alert("Config object malformed:\n" + h)
			}
		}
	};
	this.validateEvents = function() {};
	this.validateInfo = function() {
		if (!e) {
			e = ""
		}
	};
	this.validateAfterRender = function() {
		if (g) {
			try {
				JSON.stringify(g)
			} catch (h) {
				alert("AfterRender object malformed:\n" + h)
			}
		}
	};
	this.afterRender = function() {
		if (g) {
			for (var j = 0; j < g.length; j++) {
				var h = g[j];
				var k = h.shift();
				var n = h.length > 0 ? h.shift() : [];
				var m = h.length > 0 ? h.shift() : {};
				this.flashInfoSpan(20, 20, k);
				for (var l in m) {
					this[l] = m[l]
				}
				this[k].apply(this, n)
			}
		}
	};
	if (!f) {
		f = this.createNewTarget()
	} else {
		if (typeof(f) == "object") {
			d = f.data || false;
			a = f.config || false;
			b = f.events || false;
			e = f.info || false;
			g = f.afterRender || false;
			c = f.hidden || false;
			f = f.renderTo || this.createNewTarget()
		}
	}
	this.initialize = function() {
		CanvasXpress.instances.push(this);
		this.setInit();
		this.initDOM();
		this.initInterface();
		this.validateParameters();
		this.initConfig(a);
		this.initViewport(c);
		this.initPrimitives();
		this.initUtils();
		this.initMathUtils();
		this.initLegendUtils();
		this.initFilterUtils();
		this.initClusterUtils();
		this.initSortUtils();
		this.initExample();
		this.initVocabulary();
		this.initDataUtils();
		this.initData(d);
		this.initValidity();
		this.initLayout();
		this.initEvents();
		this.initTooltip();
		this.initToolbar();
		this.initMenus();
		this.initLinks();
		this.initConfigurator();
		this.initDataFilter();
		this.initDataTable();
		this.initAcknowlegments();
		this.initCodeInfo();
		this.initBin();
		this.initDataExplorer();
		this.initAnimation();
		this.initRemote();
		this.initStack(d, a, b, e);
		this.initGraph();
// this.afterRender(); // Baohong
		this.getDataFromURL();
		this.showToolbar(2000);
		this.teaseMobileControls(2000)
	};
	this.initialize()
};
CanvasXpress.instances = [];
CanvasXpress.cacheImages = {};
CanvasXpress.cacheImagesReady = false;
CanvasXpress.cachePatterns = {};
CanvasXpress.cacheText = {};
CanvasXpress.vocabulary = {};
CanvasXpress.stack = {};
CanvasXpress.current = false;
CanvasXpress.resizing = false;
CanvasXpress.loadGoogleFonts = (function() {
	if (navigator.onLine) {
		var b = document.createElement("link");
		b.type = "text/css";
		b.rel = "stylesheet";
		b.href = "https://fonts.googleapis.com/css?family=Indie+Flower|Ubuntu:400,700,700italic";
		var a = document.getElementsByTagName("head")[0];
		a.appendChild(b);
		var c = new Image;
		c.onerror = function() {
			var f = document.createElement("canvas");
			var e = f.getContext("2d", {
				willReadFrequently: true
			});
			var d = "10px Ubuntu";
			e.font = d;
			e.fillText("css loaded", 100, 100);
			d = "10px Indie Flower";
			e.font = d;
			e.fillText("css loaded", 100, 100)
		};
		c.src = "https://fonts.googleapis.com/css?family=Indie+Flower|Ubuntu:400,700,700italic"
	}
}());
CanvasXpress.getObject = function(c, b) {
	for (var a = 0; a < CanvasXpress.instances.length; a++) {
		if (CanvasXpress.instances[a].target == c) {
			return CanvasXpress.instances[a]
		}
	}
	if (b) {
		return CanvasXpress.injectObject(c)
	}
};
CanvasXpress.$ = function(b, a) {
	return CanvasXpress.getObject(b, a)
};
CanvasXpress.destroy = function(a) {
	if (CanvasXpress.instances.length > 0) {
		CanvasXpress.instances[0].destroy(a)
	}
};
CanvasXpress.injectObject = function(d) {
	var a = document.getElementById(d);
	if (!a) {
		var b = document.createElement("canvas");
		b.id = d;
		b.width = 100;
		b.height = 100;
		document.body.appendChild(b);
		a = new CanvasXpress({
			renderTo: d,
			hidden: true
		})
	}
	return a
};
CanvasXpress.setExampleContainer = function(a) {
	if (!a) {
		a = "Show-All"
	}
	var j = CanvasXpress.getObject("CanvasXpress-Silent", true);
	var d = j.getWindowSize();
	var e = j.getWindowScroll();
	var c = Math.max(0, ((d[0] - 500) / 2) + e[0]);
	var h = Math.max(0, ((d[1] - 500) / 2) + e[1]);
	var g = j.$cX("div", {
		id: a + "-cX-API-Example",
		className: "CanvasXpressConfiguratorExample draggable"
	}, {
		width: "535px",
		maxHeight: "500px",
		cursor: "move",
		display: "block",
		padding: "10px",
		position: "absolute",
		overflow: "hidden",
		paddingBottom: "35px",
		left: c + "px",
		top: h + "px"
	});
	var b = j.$cX("span", {
		id: a + "-cX-API-ExampleSpan",
		className: "CanvasXpressConfiguratorExample",
		innerHTML: ""
	});
	var f = j.$cX("img", {
		id: a + "-cX-API-ExampleClose",
		className: "CanvasXpressConfigurator",
		property: a,
		src: CanvasXpress.images.cancel1,
		alt: "Close",
		title: "Close"
	});
	var i = j.$cX("div", {
		id: a + "-cX-API-ExampleContent",
		className: "CanvasXpressConfiguratorExampleContent"
	}, {
		maxWidth: "535px",
		maxHeight: "500px",
		overflow: "auto"
	});
	g.appendChild(b);
	g.appendChild(f);
	g.appendChild(j.$cX("br"));
	g.appendChild(i);
	document.body.appendChild(g);
	return j
};
CanvasXpress.showExample = function(h, g) {
	if (g) {
		var c = CanvasXpress.setExampleContainer(g);
		var b = c.$(g + "-cX-API-Example");
		var f = c.$(g + "-cX-API-ExampleSpan");
		var d = c.$(g + "-cX-API-ExampleClose");
		var a = c.$(g + "-cX-API-ExampleContent");
		d.onclick = function() {
			var j = c.$(this.property + "-cX-API-Example");
			if (j) {
				c.removeEvtListener(j, "mousedown", c.registerMousemove, false);
				var l = j.getElementsByTagName("canvas");
				var k = [];
				for (var e = 0; e < l.length; e++) {
					k.push(l[e].id)
				}
				for (var e = 0; e < k.length; e++) {
					c.destroy(k[e])
				}
				j.parentNode.removeChild(j)
			}
		};
		c.addEvtListener(b, "mousedown", c.registerMousemove, false);
		c.stopEvent(h);
		c.cancelEvent(h);
		c.clickExamplePropertyDescription(h, g, true);
		return false
	}
};
CanvasXpress.showAllExamples = function(v, x) {
	var o = CanvasXpress.setExampleContainer();
	var u = o.$("Show-All-cX-API-Example");
	var g = o.$("Show-All-cX-API-ExampleSpan");
	var m = o.$("Show-All-cX-API-ExampleClose");
	var p = o.$("Show-All-cX-API-ExampleContent");
	m.onclick = function() {
		var c = o.$(this.property + "-cX-API-Example");
		if (c) {
			clearInterval(w);
			o.removeEvtListener(c, "mousedown", o.registerMousemove, false);
			var e = c.getElementsByTagName("canvas");
			while (e.length > 0) {
				o.destroy(e[0].id)
			}
			c.parentNode.removeChild(c)
		}
	};
	p.appendChild(o.$cX("canvas", {
		id: "Show-All-cX-API-Example-Canvas",
		width: 500,
		height: 500
	}));
	o.addEvtListener(u, "mousedown", o.registerMousemove, false);
	o.stopEvent(v);
	o.cancelEvent(v);
	new CanvasXpress("Show-All-cX-API-Example-Canvas");
	var a = [];
	var l = x ? [x] : o.getKeys(CanvasXpress.doc.M).sort();
	for (var s = 0; s < l.length; s++) {
		var k = l[s];
		for (var q = 0; q < CanvasXpress.doc.M[k]["P"].length; q++) {
			var b = CanvasXpress.doc.M[k]["P"][q];
			var n = CanvasXpress.doc.P[b];
			if (n.H) {
				var h = o.getExamplesDocObject(b);
				a = a.concat(h)
			}
		}
	}
	var r = 0;
	var d = "Show-All-cX-API-Example-Canvas";
	var f = function() {
		o.destroy(d);
		d = a[r][0];
		o.insertTarget(d, p, 500, 500);
		var y = a[r][1];
		var z = a[r][2];
		z.disableToolbar = true;
		var e = new CanvasXpress(d, y, z);
		g.innerHTML = d.replace("CanvasXpress-Silent-cX-ConfiguratorExample-", "").split("-")[0];
		var t = a[r][3];
		if (t) {
			for (var j = 0; j < t.length; j++) {
				if (t[j].match(/:/)) {
					var c = t[j].split(":");
					e[c.shift()].apply(e, c)
				} else {
					e[t[j]]()
				}
			}
		}
		r++;
		if (r == a.length) {
			r = 0
		}
	};
	var w = setInterval(function() {
		f()
	}, 1000);
	return false
};
CanvasXpress.prototype.initDOM = function() {
	this.$ = function(a) {
		return document.getElementById(a)
	};
	this.$cX = function(b, f, c) {
		var d = document.createElement(b);
		if (f) {
			for (var a in f) {
				d[a] = f[a]
			}
		}
		if (c) {
			for (var a in c) {
				d.style[a] = c[a]
			}
		}
		return d
	};
	this.createNewTarget = function() {
		var a = this.$cX("canvas", {
			id: this.newId("canvasXpress")
		});
		document.body.appendChild(a);
		return a.id
	};
	this.newId = function(b) {
		var c = 0;
		var a = this.target + b + c;
		while (this.meta.ids[a]) {
			c++;
			a = this.target + b + c
		}
		this.meta.ids[a] = true;
		return a
	};
	this.insertTarget = function(e, g, d, f, b) {
		if (e && g) {
			var i = this.$(e);
			if (i) {
				return
			} else {
				i = this.$cX("canvas", {
					id: e,
					width: d,
					height: f
				})
			}
			if (b) {
				g.parentNode.insertBefore(i, g.nextSibling)
			} else {
				g.parentNode.insertBefore(i, g)
			}
		}
	};
	this.removeTarget = function(a) {
		var b = this.$(a);
		if (b) {
			b.parentNode.removeChild(b)
		}
	};
	this.getWindowSize = function() {
		var a = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
		var b = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
		return [a, b]
	};
	this.getWindowScroll = function() {
		var c = document.documentElement;
		var a = (window.pageXOffset || c.scrollLeft) - (c.clientLeft || 0);
		var b = (window.pageYOffset || c.scrollTop) - (c.clientTop || 0);
		return [a, b]
	};
	this.hasClass = function(a, b) {
		return new RegExp("(\\s|^)" + b + "(\\s|$)").test(a.className)
	};
	this.addClass = function(a, b) {
		if (!this.hasClass(a, b)) {
			a.className += (a.className ? " " : "") + b
		}
	};
	this.removeClass = function(a, b) {
		if (this.hasClass(a, b)) {
			a.className = a.className.replace(new RegExp("(\\s|^)" + b + "(\\s|$)"), " ").replace(/^\s+|\s+$/g, "")
		}
	};
	this.cancelEvent = function(a) {
		if (!a) {
			a = window.event
		}
		if (!a) {
			return
		}
		if (this.meta.system.browser.match(/safari/i)) {
			return false
		} else {
			if (a.preventDefault) {
				a.preventDefault()
			} else {
				a.returnValue = false
			}
		}
	};
	this.stopEvent = function(a) {
		if (!a) {
			a = window.event
		}
		if (!a) {
			return
		}
		if (a.stopPropagation) {
			a.stopPropagation()
		} else {
			a.cancelBubble = true
		}
	};
	this.normalizeEvtName = function(a) {
		return this.meta.system.isIE ? "on" + a : a
	};
	this.copyEvent = function(c) {
		var b = {};
		for (var a in c) {
			b[a] = c[a]
		}
		return b
	};
	this.addEvtListener = function(g, d, h, b) {
		if (g && d && h) {
			var a = this.meta.events;
			if (g.id) {
				if (!a[g.id]) {
					a[g.id] = {}
				}
				a[g.id][d] = [h, b]
			} else {
				if (!a[g]) {
					a[g] = {}
				}
				a[g][d] = [h, b]
			}
			if (this.meta.system.isIE) {
				g.attachEvent(this.normalizeEvtName(d), h)
			} else {
				g.addEventListener(d, h, b);
				if (d == "mousewheel") {
					g.addEventListener("DOMMouseScroll", h, b)
				}
			}
		}
	};
	this.removeEvtListener = function(i, h, j, g) {
		if (i && h && j) {
			var a = this.meta.events;
			var d = a[i.id || i];
			if (d && d.hasOwnProperty(h)) {
				delete(d[h]);
				if (this.meta.system.isIE) {
					i.detachEvent(this.normalizeEvtName(h), j)
				} else {
					i.removeEventListener(h, j, g);
					if (h == "mousewheel") {
						i.removeEventListener("DOMMouseScroll", j, g)
					}
				}
				var b = this.getKeys(a[i.id || i]);
				if (b && b.length < 1) {
					delete(a[i.id || i])
				}
			}
		}
	};
	this.addRemoveEvtListener = function(a, g, d, h, b) {
		if (a && g && d && h) {
			this[a](g, d, h, b)
		}
	};
	this.purgeEventListeners = function() {
		var a = this.meta.events;
		for (var b in a) {
			var d = this.$(b) || b;
			for (var c in a[b]) {
				this.removeEvtListener(d, c, a[b][0], a[b][1])
			}
		}
	};
	this.preventSelection = function() {
		if (document.selection) {
			document.selection.empty()
		} else {
			if (window.getSelection) {
				window.getSelection().removeAllRanges()
			}
		}
	};
	this.getTargetEvent = function(a) {
		return a.target || a.srcElement
	};
	this.setInterval = function(i, f) {
		var e = Date.now;
		var a = window.requestAnimationFrame;
		var h = e();
		var b;
		var g = function() {
			e() - h < f || (h += f, i());
			b || a(g)
		};
		a(g);
		return {
			clear: function() {
				b = 1
			}
		}
	};
	this.setTimeout = function(i, g) {
		var f = Date.now;
		var a = window.requestAnimationFrame;
		var h = f();
		var e;
		var b = function() {
			f() - h < g ? e || a(b) : i()
		};
		a(b);
		return {
			clear: function() {
				e = 1
			}
		}
	};
	this.initializeBrowser = function() {
		var b = function() {
			var e = navigator.userAgent;
			var d;
			var c = e.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
			if (/trident/i.test(c[1])) {
				d = /\brv[ :]+(\d+)/g.exec(e) || [];
				return "IE " + (d[1] || "")
			}
			if (c[1] === "Chrome") {
				d = e.match(/\b(OPR|Edge)\/(\d+)/);
				if (d != null) {
					return d.slice(1).join(" ").replace("OPR", "Opera")
				}
			}
			c = c[2] ? [c[1], c[2]] : [navigator.appName, navigator.appVersion, "-?"];
			if ((d = e.match(/version\/(\d+)/i)) != null) {
				c.splice(1, 1, d[1])
			}
			return c.join(" ")
		};
		var a = b().split(" ");
		this.meta.system = {
			browser: a[0],
			browserVersion: a[1],
			isjQuery: typeof $ === "function" ? true : false,
			isIE: this.browser == "IE" ? true : false,
			isTouchScreen: "ontouchstart" in window || "onmsgesturechange" in window || navigator.maxTouchPoints
		}
	};
	this.initializeBrowser()
};
CanvasXpress.prototype.initInterface = function() {
	this.isValidURL = function(b) {
		var a = new RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$", "i");
		return a.test(b)
	};
	this.loadParamsFile = function(a) {
		return function(h) {
			a.removeMenus();
			a.resetConfigurator();
			var d = h.target.files[0];
			var g = d.type;
			var c = d.name.split(".");
			var b = new FileReader();
			var f = c.pop();
			if (f == "json") {
				b.onload = function() {
					try {
						var m = JSON.parse(b.result);
						a.setConfigDefaults();
						a.layoutValid = false;
						for (var o in m.config) {
							a[o] = m.config[o]
						}
						for (var k = 0; k < m.afterRender.length; k++) {
							var j = m.afterRender[k];
							var l = j[0];
							var q = j[1] || [];
							a[l].apply(a, q)
						}
					} catch (n) {
						alert("Oooops! Not a CanvasXpress json parameter file")
					}
				};
				b.readAsText(d)
			} else {
				alert("Oooops! Not a CanvasXpress json  parameter file")
			}
		}
	}(this);
	this.loadFile = function(a) {
		return function(j, c, l) {
			a.removeMenus();
			a.resetConfigurator();
			var g = j.target ? j.target.files[0] : j.files[0];
			var k = g.type;
			var d = g.name.split(".");
			var i = new FileReader();
			if (k == "image/png") {
				var h = function(n, e) {
					var o = "";
					for (var m = 0; m < 4; m++) {
						o += String.fromCharCode(n.getUint8(e + m))
					}
					return o == "tEXt"
				};
				var f = function(o, m, e) {
					var p = "";
					for (var n = 0; n < e; n++) {
						p += String.fromCharCode(o.getUint8(m + n))
					}
					return p.match(/CanvasXpress/)
				};
				i.onload = function() {
					var q = new DataView(this.result);
					var m = q.getUint32(8);
					var e = q.getUint32(8 + 4 + 4 + m + 4);
					if (h(q, 8 + 4 + 4 + m + 4 + 4) && f(q, 8 + 4 + 4 + m + 4 + 4 + 4, e)) {
						var p = q.getUint32(8 + 4 + 4 + m + 4 + 4 + 4 + e + 4);
						var r = 8 + 4 + 4 + m + 4 + 4 + 4 + e + 4 + 4 + 4;
						var o = "";
						for (var n = 0; n < p; n++) {
							o += String.fromCharCode(q.getUint8(r + n))
						}
						o = o.replace("ReproducibleResearch\0", "");
						var s = JSON.parse(o);
						if (c) {
							return s
						}
						s.uploadFile = true;
						a.remoteServiceType = "file";
						a.updateRemoteData(s, l)
					} else {
						alert("Oooops! Not a CanvasXpress Image")
					}
				};
				i.readAsArrayBuffer(g)
			} else {
				var b = d.pop();
				if (b == "json") {
					i.onload = function() {
						try {
							var m = JSON.parse(i.result);
							m.uploadFile = true;
							a.remoteServiceType = "file";
							a.updateRemoteData(m, l)
						} catch (n) {
							alert("Oooops! Not a CanvasXpress json file")
						}
					}
				} else {
					if (b == "txt" || b == "csv" || b == "tsv" || b == "tab") {
						i.onload = function() {
							try {
								var r = i.result;
								var m = r.match(/,/g).length;
								var o = r.match(/\t/g).length;
								var n = b == "csv" && m > o ? "," : "\t";
								var p = a.delimitedToArray(r, n, true);
								p.renderTo = d[0];
								p.uploadFile = true;
								a.remoteServiceType = "file";
								a.updateRemoteData(p, l)
							} catch (q) {
								alert("Oooops! Not a CanvasXpress delimited file")
							}
						}
					}
				}
				i.readAsText(g)
			}
		}
	}(this);
	this.save = function(a) {
		return function(g, b, d) {
			a.removeMenus();
			a.resetConfigurator();
			CanvasXpress.stack[a.target].client = a.meta.client;
			CanvasXpress.stack[a.target].clientIP = a.meta.info;
			var h = d ? d + ".json" : "cX-" + a.target + ".json";
			h = h.replace(/.json.json$/, ".json");
			var c = new Blob([a.prettyJSON(CanvasXpress.stack[a.target])], {
				type: "text/plain;charset=" + document.characterSet
			});
			saveAs(c, h)
		}
	}(this);
	this.print = function(a) {
		return function(k, j) {
			var g = function() {
				var o;
				var e = [];
				for (var m = 0; m < 256; m++) {
					o = m;
					for (var f = 0; f < 8; f++) {
						o = ((o & 1) ? (3988292384 ^ (o >>> 1)) : (o >>> 1))
					}
					e[m] = o
				}
				return e
			};
			var c = function(n) {
				var e = window.crcTable || (window.crcTable = g());
				var m = 0 ^ (-1);
				for (var f = 0; f < n.length; f++) {
					m = (m >>> 8) ^ e[(m ^ n.charCodeAt(f)) & 255]
				}
				return (m ^ (-1)) >>> 0
			};
			var d = function(f, e) {
				var m = new Uint8Array(f.byteLength + e.byteLength);
				m.set(new Uint8Array(f), 0);
				m.set(new Uint8Array(e), f.byteLength);
				return m.buffer
			};
			var h = function(m) {
				var q = "tEXt";
				var f = m.length;
				var p = c(q + m);
				var e = new ArrayBuffer(12 + f);
				var o = new DataView(e);
				o.setUint32(0, f);
				for (var n = 0; n < q.length; n++) {
					o.setUint8(4 + n, q.charCodeAt(n))
				}
				for (var n = 0; n < m.length; n++) {
					o.setUint8(8 + n, m.charCodeAt(n))
				}
				o.setUint32(4 + 4 + f, p);
				return e
			};
			var b = function() {
				if (a.isReproducibleResearch) {
					return JSON.stringify(CanvasXpress.stack[a.target])
				} else {
					var e = JSON.parse(JSON.stringify(CanvasXpress.stack[a.target]));
					e.afterRender = [e.afterRender[0]];
					return JSON.stringify(e)
				}
			};
			var l = function(o, n, e, f) {
				var m = d(o, n);
				m = d(m, e);
				m = d(m, f);
				return m
			};
			var i = function(e) {
				var m = new FileReader();
				var f = "";
				if (a.isReproducibleResearch) {
					f += "<h2>Please be aware that the actual data is stored inside the image! Right click to save!</h2>"
				} else {
					f += "<h2>Right click to save image</h2>"
				}
				m.onload = function(n) {
					f += "<img src= '" + n.target.result + "'/>";
					a.showTooltipDiv(k, f, a.getTargetEvent(k), {
						maxWidth: a.width + "px",
						whiteSpace: "normal"
					})
				};
				m.readAsDataURL(e)
			};
			a.removeMenus();
			a.resetConfigurator();
			CanvasXpress.stack[a.target].client = a.meta.client;
			CanvasXpress.stack[a.target].clientIP = a.meta.info;
			a.meta.canvas.ctx.canvas.toBlob(function(f) {
				var e = new FileReader();
				var m = j ? j + ".png" : "cX-" + a.target + ".png";
				m = m.replace(/.png.png$/, ".png");
				e.onloadend = function() {
					var n = new DataView(this.result);
					var p = n.getUint32(8);
					var q = 8 + 4 + 4 + p + 4;
					var r = this.result.slice(0, q);
					var s = this.result.slice(q);
					var v = h("Software\0CanvasXpress Version: " + a.meta.version);
					var t = h("ReproducibleResearch\0" + b());
					var u = l(r, v, t, s);
					var o = new Blob([u], {
						type: "image/png"
					});
					if (a.printType == "download") {
						if (a.isReproducibleResearch) {
							a.flashInfoSpan(100, 100, "<h2>Please be aware <br>the actual data is stored<br>inside the downloaded image</h2>", 5000)
						}
						saveAs(o, m)
					} else {
						i(o)
					}
				};
				e.readAsArrayBuffer(f)
			}, "image/png");
			if (a.maximized) {
				a.clickGraphMaxMin(k)
			}
		}
	}(this);
	this.exportToExcel = function(i) {
		return this.exportToTabDelimited(i);
		var g = this.exportToHTML(i, true);
		var f = "data:application/vnd.ms-excel;base64,";
		var c = '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40"><head><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>{worksheet}</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--></head><body><table>{table}</table></body></html>';
		var b = function(d) {
			return window.btoa(unescape(encodeURIComponent(d)))
		};
		var h = function(d, j) {
			return d.replace(/{(\w+)}/g, function(k, l) {
				return j[l]
			})
		};
		var a = {
			worksheet: "Worksheet",
			table: g
		};
		var e = this.$(this.target + "-cX-linkExcel");
		if (!e) {
			e = this.$cX("a", {
				id: this.target + "-cX-linkExcel"
			}, {
				display: "none"
			});
			document.body.appendChild(e)
		}
		e.href = f + b(h(c, a));
		e.download = this.target + ".xls";
		e.click()
	};
	this.exportToHTML = function(e, b) {
		var c = "<table>";
		for (var a = 0; a < e.length; a++) {
			c += "<tr><td>";
			c += e[a].join("</td><td>");
			c += "</td></tr>"
		}
		c += "</table>";
		return b ? c : window.open().document.write(c)
	};
	this.exportToTabDelimited = function(c) {
		var b = "";
		for (var a = 0; a < c.length; a++) {
			b += c[a].join("\t") + "\n"
		}
		window.location.href = "data:text/tab-separated-values;charset=UTF-8," + encodeURIComponent(b)
	};
	this.arrayToHTML = function(e) {
		var c = '<div style="padding:2px;overflow:scroll;max-height:400px;max-width:600px;"><table style="border-collapse: collapse;">';
		for (var b = 0; b < e[0].length; b++) {
			c += "<tr>";
			for (var a = 0; a < e[0][b].length; a++) {
				if (e[1][b][a] && e[1][b][a] == "cxy") {
					c += '<td class="' + (e[1][b][a] || "cxb") + '">' + this.bestFormatNumber(e[0][b][a]) + "</td>"
				} else {
					c += '<td class="' + (e[1][b][a] || "cxb") + '">' + e[0][b][a] + "</td>"
				}
			}
			c += "</tr>"
		}
		c += "</table></div>";
		return c
	};
	this.prettyJSON = function(a) {
		return JSON.stringify(a, null, 2)
	};
	this.delimitedToArray = function(h, g, b) {
		g = g || ",";
		var e = new RegExp(("(\\" + g + '|\\r?\\n|\\r|^)(?:"([^"]*(?:""[^"]*)*)"|([^"\\' + g + "\\r\\n]*))"), "gi");
		var a = [
			[]
		];
		var f = null;
		while (f = e.exec(h)) {
			var c = f[1];
			if (c.length && c !== g) {
				a.push([])
			}
			var d;
			if (f[2]) {
				d = f[2].replace(new RegExp('""', "g"), '"')
			} else {
				d = f[3]
			}
			a[a.length - 1].push(isNaN(parseInt(d)) ? d : Number(d))
		}
		return b ? this.delimitedToCanvasXpress(a) : a
	};
	this.delimitedToCanvasXpress = function(f) {
		var b = function(i) {
			return i.filter(function(j, m) {
				return i.indexOf(j) === m
			})
		};
		var c = {
			y: {
				vars: [],
				smps: [],
				data: []
			}
		};
		var k = f[0].filter(Number);
		if (k.length == 0) {
			k = f.shift()
		} else {
			k = [];
			for (var d = 0; d < f[0].length; d++) {
				k.push("C" + (d + 1))
			}
		}
		var l = [];
		for (var d = 0; d < f.length; d++) {
			l.push(f[d][0])
		}
		var h = l.filter(Number);
		var e = b(l);
		if (h.length == 0 && e.length == l.length) {
			for (var d = 0; d < f.length; d++) {
				f[d].shift(f[d][0])
			}
		} else {
			l = [];
			for (var d = 0; d < f.length; d++) {
				l.push("R" + (d + 1))
			}
		}
		if (k.length > f[0].length) {
			k.shift();
			if (!k.length == f[0].length) {
				return false
			}
		}
		if (f[0].length != f[f.length - 1].length) {
			f.pop();
			l.pop();
			if (f[0].length != f[f.length - 1].length) {
				return false
			}
		}
		var g = [];
		for (var d = 0; d < k.length; d++) {
			g[d] = false;
			for (var a = 0; a < l.length; a++) {
				if (isNaN(f[a][d])) {
					g[d] = true;
					break
				}
			}
			if (!g[d]) {
				for (var a = 0; a < l.length; a++) {
					f[a][d] = Number(f[a][d])
				}
			} else {
				c.z = {}
			}
		}
		for (var d = 0; d < l.length; d++) {
			c.y.data[d] = [];
			c.y.vars.push(l[d])
		}
		for (var d = 0; d < k.length; d++) {
			if (g[d]) {
				c.z[k[d]] = [];
				for (var a = 0; a < l.length; a++) {
					c.z[k[d]].push(f[a][d])
				}
			} else {
				c.y.smps.push(k[d]);
				for (var a = 0; a < l.length; a++) {
					c.y.data[a].push(f[a][d])
				}
			}
		}
		return {
			data: c,
			config: {
				graphType: "Scatter2D"
			}
		}
	};
	this.getRDatasets = function() {
		var b = function(c) {
			return function(d) {
				c.Rdatasets = JSON.parse(d)
			}
		}(this);
		var a = this.RdatasetsURL + "datasets.json";
		this.ajaxRequest(a, false, b)
	};
	this.getRLibraryDataSets = function(a) {
		this.getDataSetListFromURL(this.RdatasetsURL + "json/" + a + "/datasets.json")
	};
	this.getDataFromURL = function() {
		if (this.dataURL) {
			var a = function(b) {
				return function(c) {
					var d = JSON.parse(c);
					b.remoteService = b.dataURL;
					b.remoteServiceType = "file";
					if (Array.isArray(d)) {
						b.setDataSetsFromURL(c)
					} else {
						d.renderTo = d.renderTo || b.newId("cX-data-url-");
						d.records = 0;
						b.updateRemoteData(d)
					}
				}
			}(this);
			this.ajaxRequest(this.dataURL, false, a)
		}
	};
	this.getDataSetListFromURL = function(a) {
		this.remoteService = a;
		this.ajaxRequest(a, false, this.setDataSetsFromURL)
	};
	this.setDataSetsFromURL = function(a) {
		return function(b) {
			var g = function(i) {
				return function(n) {
					var p = JSON.parse(n);
					f.updateRemoteData({
						data: p,
						ids: f.remoteIds,
						records: f.remoteIds.length
					})
				}
			}(f);
			var o = function() {
				var i = a.$("container-" + a.target).parentNode;
				while (i.id.match("canvasXpressRemoteWindow")) {
					i = i.parentNode
				}
				if (!i.id) {
					i.id = a.newId("-cX-data-sets-url-container-")
				}
				return i.id
			};
			var h = JSON.parse(b);
			var d = h[0][1];
			var c = [];
			for (var j = 0; j < h.length; j++) {
				c.push(h[j][0])
			}
			var k = o();
			var m = a.$("container-" + a.target).parentNode;
			var l = a.newId("cX-data-sets-");
			var e = a.$cX("canvas", {
				id: l,
				width: a.originalWidth + 18,
				height: a.originalHeight + 18
			});
			m.appendChild(e);
			var f = new CanvasXpress(l, false, {
				remoteService: a.remoteService
			});
			a.remoteIds = c;
			a.destroy(a.target);
			f.remoteData = h;
			f.remoteParentId = k;
			f.remoteIds = c;
			f.remoteServiceType = "file";
			f.ajaxRequest(d, false, g)
		}
	}(this);
	this.dumpToConsole = function(a) {
		console.log(this.target);
		console.log(this.prettyJSON(a))
	};
	this.initVocabulary = function() {
		if (!CanvasXpress.vocabulary) {
			CanvasXpress.vocabulary = {}
		}
		if (!CanvasXpress.vocabulary.n) {
			CanvasXpress.vocabulary.n = 0;
			CanvasXpress.vocabulary.byId = [];
			CanvasXpress.vocabulary.byStr = {}
		}
	};
	this.initStack = function(d, b, c, e) {
		if (!CanvasXpress.stack) {
			CanvasXpress.stack = {}
		}
		if (navigator.onLine && !this.meta.info) {
			this.setClientIPInfo()
		}
		var a = this.$(this.target);
		if (a) {
			CanvasXpress.stack[this.target] = {
				version: this.meta.version,
				renderTo: this.target,
				data: d ? JSON.parse(JSON.stringify(d)) : false,
				config: b ? JSON.parse(JSON.stringify(b)) : false,
				events: c || false,
				info: e || false,
				afterRender: [
// Baohong : redundant operation for subsequent plots
//                  ["setDimensions", [a.originalWidth, a.originalHeight, true]]
				]
			}
		}
	};
	this.getStack = function() {
		return CanvasXpress.stack[this.target].afterRender
	};
	this.stack = function() {
		if (!this.skipStack) {
			var g = this;
			var e = function(d) {
				for (var f = 0; f < d.length; f++) {
					if (d[f] instanceof Event) {
						d[f] = g.cloneEvent(d[f])
					}
				}
				return d
			};
			var i = arguments.callee.caller.caller;
			var h = i.toString().match(/.functionCaller *= *['"]?(.+?)['"]/);
			if (i && h && Array.from) {
				var b = e(Array.from(i.arguments));
				var j = CanvasXpress.stack[this.target].afterRender.length;
				h = h[1];
				switch (h) {
					case "sortSamples":
					case "sortSamplesByCategory":
					case "sortSamplesByVariable":
					case "sortVariables":
					case "sortVariablesByCategory":
					case "sortVariablesBySample":
						CanvasXpress.stack[this.target].afterRender.push([h, b, {
							sortDir: this.sortDir
						}]);
						break;
					case "broadcastDraw":
					case "segregateSamplesVariables":
						i = i.caller;
						h = i.toString().match(/.functionCaller *= *['"]?(.+?)['"]/)[1];
						b = e(Array.from(i.arguments));
						CanvasXpress.stack[this.target].afterRender.push([h, b]);
						break;
					case "updateDataFilter":
						CanvasXpress.stack[this.target].afterRender.push([h, [true], {
							toDoFilter: this.toDoFilter
						}]);
						break;
					case "setIndicesAfterPannEvent":
						CanvasXpress.stack[this.target].afterRender.push([h, b, {
							varIndices: this.varIndices,
							smpIndices: this.smpIndices,
							grpIndices: this.grpIndices
						}]);
						break;
					case "endCanvasResizer":
						CanvasXpress.stack[this.target].afterRender.push(["setDimensions", Array.from(arguments.callee.caller.arguments)]);
						break;
					case "setRangesAfterWheelEvent":
						var c = CanvasXpress.stack[this.target].afterRender;
						if (j > 1 && c[j - 1][0] == "setRangesAfterWheelEvent" && c[j - 2][0] == "setRangesAfterWheelEvent") {
							c.pop()
						}
						CanvasXpress.stack[this.target].afterRender.push([h, b]);
						break;
					case "updateDragScatter":
						var c = CanvasXpress.stack[this.target].afterRender;
						if (j > 1 && c[j - 1][0] == "updateDragScatter" && c[j - 2][0] == "updateDragScatter" && !b[0].shiftKey) {
							c.pop()
						}
						CanvasXpress.stack[this.target].afterRender.push([h, b, {
							moveLegend: this.moveLegend,
							moveLegendX: this.moveLegendX,
							moveLegendY: this.moveLegendY,
							moveLegendCurX: this.moveLegendCurX,
							moveLegendCurY: this.moveLegendCurY
						}]);
						break;
					case "handleDragEventOneDimension":
						CanvasXpress.stack[this.target].afterRender.push([h, b, {
							moveDendrogram: this.moveDendrogram,
							moveVarOverlay: this.moveVarOverlay,
							moveVar: this.moveVar,
							moveSmpOverlay: this.moveSmpOverlay,
							moveSmp: this.moveSmp
						}]);
						break;
// Baohong: can easily flood the stack when zoom in-and-out
                        case "setIndicesAfterWheelEvent":
                        break;

					default:
						CanvasXpress.stack[this.target].afterRender.push([h, b])
				}
			}
		}
	};
	this.getDragDivDimensions = function(E, y, A) {
		var w, k, m, i, x, n, r, j, B, s, z, q;
		var F = y[0];
		var G = null;
		var D = this.graphType;
		switch (E) {
			case "handleDragEventGenome":
			case "handleDragEventHeatmap":
			case "handleDragEventOneDimension":
			case "handleDragEventScatter":
			case "handlePanning":
			case "showHideSelectedDataPoint":
				G = y[1];
				break;
			case "updateDragNetwork":
				G = y[5];
				break
		}
		var H = G != null ? this.getBoundsXY(G) : false;
		if (H != false) {
			var C = F.xMouseDown;
			var v = F.yMouseDown;
			var u = F.ac.x;
			var a = F.ac.y;
			if (C >= H[0] && C <= H[1] && v >= H[2] && v <= H[3]) {
				if ((!D.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && !F.shiftKey) || (!D.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && F.shiftKey)) {
					w = x = H[0];
					m = r = H[1] - H[0]
				} else {
					w = x = Math.min(C, u);
					m = 0;
					r = u > C ? u - C : C - u
				}
				B = x;
				z = x + r;
				if ((!D.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && !F.shiftKey) || (!D.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && F.shiftKey) || D == "Genome") {
					k = n = H[2];
					i = j = H[3] - H[2]
				} else {
					k = n = Math.min(v, a);
					i = 0;
					j = a > v ? a - v : v - a
				}
				s = n;
				q = n + j
			} else {
				if (A && C >= H[4] && C <= H[5] && v >= H[6] && v <= H[7]) {
					var h = function() {
						w = x = H[4];
						k = v;
						n = a;
						m = r = H[5] - H[4];
						i = j = 3;
						B = C;
						s = v;
						z = C;
						q = n
					};
					var d = function() {
						w = C;
						x = u;
						k = n = H[6];
						m = r = 3;
						i = j = H[7] - H[6];
						B = C;
						s = v;
						z = x;
						q = v
					};
					if (A.moveDendrogram) {
						if (A.moveDendrogram == "varDendrogram" || (A.moveDendrogram == "smpDendrogram" && this.graphOrientation == "vertical")) {
							h()
						} else {
							d()
						}
					} else {
						if (A.moveSmpOverlay) {
							if (D.match(/Heatmap/) || this.graphOrientation == "horizontal") {
								d()
							} else {
								h()
							}
						} else {
							if (A.moveSmp) {
								if (D.match(/Heatmap/) || this.graphOrientation == "horizontal") {
									h()
								} else {
									d()
								}
							} else {
								if (A.moveVarOverlay) {
									h()
								} else {
									if (A.moveVar) {
										d()
									} else {
										alert("Ooop! Something went wrong")
									}
								}
							}
						}
					}
				} else {
					alert("Ooop! Something went really wrong")
				}
			}
		}
		return [w, k, m, i, x, n, r, j, B, s, z, q]
	};
	this.reproduce = function(a) {
		return function(l) {
			if (!l) {
				l = window.event
			}
			a.skipStack = true;
			a.resetMenus();
			a.resetLinks();
			var k = document.body;
			var s = a.$(a.target);
			var g = s.parentNode.getClientRects();
			var j = a.$(a.target + "-cX-Drag");
			var p = a.$(a.target + "-cX-Icon-Reproduce");
			if (!p) {
				p = a.$cX("img", {
					id: this.target + "-cX-Icon-Reproduce"
				}, {
					display: "none",
					position: "absolute",
					zIndex: 239010
				});
				document.body.appendChild(p)
			}
			var h = JSON.parse(JSON.stringify(CanvasXpress.stack[a.target].data));
			var d = JSON.parse(JSON.stringify(CanvasXpress.stack[a.target].config));
			var r = CanvasXpress.stack[a.target].afterRender;
			var b = r.length;
			a.setConfigDefaults();
			for (var o in d) {
				a[o] = d[o]
			}
			a.layoutValid = false;
			a.initializeData(h);
			a.resetLegendPosition();
			a.resetDendrograms();
			a.initializeGraph(true);
			a.flashInfoSpan(a.width, 0, "<b>Initial Graph</b>", a.reproduceTime);
			a[r[0][0]].apply(a, r[0][1]);
			var f = 1;
			var q = r.length;
			(function m() {
				setTimeout(function() {
					if (f < b) {
						var A = function(c) {
							if (z == "updateClickConfigurator") {
								return '<img src="' + CanvasXpress.images.mouseLeft2 + '"/>'
							} else {
								if (c.type.match(/wheel/)) {
									return '<img src="' + CanvasXpress.images.mouseScroll + '"/>'
								} else {
									if (c.type.match(/key/)) {
										return '<img src="' + CanvasXpress.images.keyEscape + '"/>'
									} else {
										if (c.type.match(/mouse/)) {
											return '<img src="' + CanvasXpress.images.mouseLeft + '"/>' + x(c)
										} else {
											return '<img src="' + CanvasXpress.images.mouseRight + '"/>'
										}
									}
								}
							}
						};
						var x = function(E) {
							var c = "";
							if (E.shiftKey) {
								c += '<img src="' + CanvasXpress.images.keyShiftIcon + '"/>'
							}
							if (E.ctrlKey) {
								c += '<img src="' + CanvasXpress.images.keyCtrlIcon + '"/>'
							}
							if (E.altKey) {
								c += '<img src="' + CanvasXpress.images.keyAltIcon + '"/>'
							}
							return c
						};
						var n = r[f];
						var z = n[0];
						var e = n[1] || [];
						var C = n[2] || {};
						var u = "<b>Next modification...</b><br><br><b>Function:</b> " + z + "<br><br>";
						var i = "";
						var D = false;
						if (e[0] && e[0].type) {
							i = A(e[0]);
							D = e[0].type.match(/wheel/) ? true : false
						} else {
							if (z == "updateDragScatter" || z == "setDimensions") {
								i = '<img src="' + CanvasXpress.images.mouseLeft + '"/>'
							}
						}
						var B = a.prettyJSON(e);
						if (B.length > 200) {
							B = B.substring(0, 250) + "..."
						}
						u += "<b>Parameters:</b> " + i + '<pre class="CanvasXpressCode">' + B + "</pre><br>";
						var t = a.prettyJSON(C);
						if (t.length > 200) {
							t = B.substring(0, 250) + "..."
						}
						u += '<b>Config:</b> <pre class="CanvasXpressCode">' + t + "</pre><br>";
						for (var w in C) {
							a[w] = C[w]
						}
						a.flashInfoSpan(a.width, 0, u, a.reproduceTime * 2);
						if (D && p) {
							var y = e[0];
							p.src = CanvasXpress.images.mouseScroll;
							p.style.left = k.scrollLeft + g[0].left + e[0].ac.x - 8 + "px";
							p.style.top = k.scrollTop + g[0].top + e[0].ac.y - 8 + "px";
							p.style.width = "16px";
							p.style.height = "16px";
							p.style.display = "block"
						} else {
							if (i != "" && z != "updateDragScatter" && j && p) {
								var y = e[0];
								var v = a.getDragDivDimensions(z, e, C);
								p.src = CanvasXpress.images.mouseLeft;
								p.style.left = k.scrollLeft + g[0].left + v[8] - 8 + "px";
								p.style.top = k.scrollTop + g[0].top + v[9] - 8 + "px";
								p.style.width = "16px";
								p.style.height = "16px";
								p.style.display = "block";
								j.style.left = v[0] + "px";
								j.style.top = v[1] + "px";
								j.style.width = v[2] + "px";
								j.style.height = v[3] + "px";
								j.style.display = "block";
								a.resizeMove(j, v[4], v[5], v[6], v[7], a.reproduceTime);
								a.resizeMove(p, k.scrollLeft + g[0].left + v[10] - 8, k.scrollTop + g[0].top + v[11] - 8, 16, 16, a.reproduceTime)
							}
						}
						setTimeout(function() {
							if (j && p) {
								a.resetDrag();
								if (D == "") {
									p.style.display = "none"
								}
							}
							a[z].apply(a, e);
							f++;
							m()
						}, z == "updateDragScatter" ? a.reproduceTime / 5000 : a.reproduceTime + 100)
					} else {
						if (p) {
							p.style.display = "none"
						}
						a.flashInfoSpan(a.width, 0, "<b>That's All Folks</b>", a.reproduceTime);
						a.skipStack = false;
						return
					}
				}, a.reproduceTime)
			})()
		}
	}(this)
};
CanvasXpress.prototype.initConfig = function(a) {
	this.setConfigDefaults = function() {
		var b = this.meta.config.keys;
		this.graphType = "Bar";
		b.push("graphType");
		this.graphOrientation = "horizontal";
		b.push("graphOrientation");
		this.transparency = null;
		b.push("transparency");
		this.canvasBox = false;
		b.push("canvasBox");
		this.canvasBoxColor = "rgb(204,204,204)";
		b.push("canvasBoxColor");
		this.plotBox = false;
		b.push("plotBox");
		this.plotBoxColor = "rgb(204,204,204)";
		b.push("plotBoxColor");
		this.invertGraph = false;
		b.push("invertGraph");
		this.loadImagesTimeOut = 100;
		b.push("loadImagesTimeOut");
		this.isR = false;
		b.push("isR");
		this.isReproducibleResearch = true;
		b.push("isReproducibleResearch");
		this.printType = "download";
		b.push("printType");
		this.thumbnail = false;
		b.push("thumbnail");
		this.reproduceTime = 2000;
		b.push("reproduceTime");
		this.functions = [];
		this.gradient = false;
		b.push("gradient");
		this.gradientType = "radial";
		b.push("gradientType");
		this.gradientOrientation = "vertical";
		b.push("gradientOrientation");
		this.gradientRatio = 1.3;
		b.push("gradientRatio");
		this.adjustAspectRatio = true;
		b.push("adjustAspectRatio");
		this.adjustAspectRatioMax = 3;
		b.push("adjustAspectRatioMax");
		this.percentAspectRatioPlotArea = 0.3;
		b.push("percentAspectRatioPlotArea");
		this.adjustAspectRatioYTries = 0;
		this.adjustAspectRatioXTries = 0;
		this.variableSeparationFactor = 2;
		b.push("variableSeparationFactor");
		this.sampleSeparationFactor = 1;
		b.push("sampleSeparationFactor");
		this.widthFactor = 1;
		b.push("widthFactor");
		this.acknowledgment = false;
		b.push("acknowledgment");
		this.foreground = "rgb(0,0,0)";
		b.push("foreground");
		this.foregroundWindow = "rgb(0,0,0)";
		b.push("foregroundWindow");
		this.windowBox = "rgb(0,0,0)";
		b.push("windowBox");
		this.background = "rgb(255,255,255)";
		b.push("background");
		this.backgroundWindow = "rgb(244,244,244)";
		b.push("backgroundWindow");
		this.backgroundType = "solid";
		b.push("backgroundType");
		this.backgroundImage = false;
		b.push("backgroundImage");
		this.backgroundVideo = false;
		b.push("backgroundVideo");
		this.backgroundWindowGradientOrientation = "vertical";
		b.push("backgroundWindowGradientOrientation");
		this.backgroundGradient1Color = "rgb(0,0,200)";
		b.push("backgroundGradient1Color");
		this.backgroundGradient2Color = "rgb(0,0,36)";
		b.push("backgroundGradient2Color");
		this.backgroundWindowGradient1Color = "rgb(0,0,200)";
		b.push("backgroundWindowGradient1Color");
		this.backgroundWindowGradient2Color = "rgb(0,0,36)";
		b.push("backgroundWindowGradient2Color");
		this.margin = 5;
		b.push("margin");
		this.marginLeft = 5;
		b.push("marginLeft");
		this.marginTop = 5;
		b.push("marginTop");
		this.marginBottom = 5;
		b.push("marginBottom");
		this.marginRight = 5;
		b.push("marginRight");
		this.showShadow = false;
		b.push("showShadow");
		this.showTextShadow = false;
		b.push("showTextShadow");
		this.shadowOffsetX = 1;
		b.push("shadowOffsetX");
		this.shadowOffsetY = 1;
		b.push("shadowOffsetY");
		this.shadowBlur = 2;
		b.push("shadowBlur");
		this.shadowColor = "rgba(0,0,0,0.5)";
		b.push("shadowColor");
		this.videoControls = true;
		b.push("videoControls");
		this.videoAutoplay = true;
		b.push("videoAutoplay");
		this.videoLoop = false;
		b.push("videoLoop");
		this.videoPreload = "none";
		b.push("videoPreload");
		this.videoData = "{}";
		b.push("videoData");
		this.videoPoster = "";
		b.push("videoPoster");
		this.videoClassName = "video-js vjs-default-skin";
		b.push("videoClassName");
		this.videoPlaybackRate = 1;
		b.push("videoPlaybackRate");
		this.videoCurrentTime = false;
		b.push("videoCurrentTime");
		this.videoGrid = false;
		b.push("videoGrid");
		this.videoGridStep = 10;
		b.push("videoGridStep");
		this.videoColor = "rgb(255,0,0)";
		b.push("videoColor");
		this.fontName = "Arial";
		b.push("fontName");
		this.fontStyle = "";
		b.push("fontStyle");
		this.fontSize = 12;
		b.push("fontSize");
		this.fontScaleFontFactor = 1;
		b.push("fontScaleFontFactor");
		this.align = "center";
		b.push("align");
		this.baseline = "middle";
		b.push("baseline");
		this.maxTextSize = 40;
		b.push("maxTextSize");
		this.minTextSize = 4;
		b.push("minTextSize");
		this.autoScaleFont = true;
		b.push("autoScaleFont");
		this.scaleTextConstantMult = 30;
		this.scaleTextConstantAdd = 2;
		this.title = false;
		b.push("title");
		this.titleFontSize = 16;
		b.push("titleFontSize");
		this.titleColor = "rgb(0,0,0)";
		b.push("titleColor");
		this.titleScaleFontFactor = 1;
		b.push("titleScaleFontFactor");
		this.titleFontStyle = "";
		b.push("titleFontStyle");
		this.subtitle = false;
		b.push("subtitle");
		this.subtitleFontSize = 14;
		b.push("subtitleFontSize");
		this.subtitleColor = "rgb(0,0,0)";
		b.push("subtitleColor");
		this.subtitleScaleFontFactor = 1;
		b.push("subtitleScaleFontFactor");
		this.subtitleFontStyle = "";
		b.push("subtitleFontStyle");
		this.citation = false;
		b.push("citation");
		this.citationColor = "rgb(0,0,0)";
		b.push("citationColor");
		this.citationFontStyle = "";
		b.push("citationFontStyle");
		this.citationFontSize = 7;
		b.push("citationFontSize");
		this.citationScaleFontFactor = 1;
		b.push("citationScaleFontFactor");
		this.dashLength = 8;
		b.push("dashLength");
		this.dotLength = 1;
		b.push("dotLength");
		this.arrowPointSize = 10;
		b.push("arrowPointSize");
		this.capType = "butt";
		b.push("capType");
		this.joinType = "mitter";
		b.push("joinType");
		this.lineWidthEvent = 2;
		b.push("lineWidthEvent");
		this.outlineWidth = 1;
		b.push("outlineWidth");
		this.lines = [];
		this.colorScheme = "User";
		b.push("colorScheme");
		this.colors = ["#fe296c", "#487eb6", "#a7ce31", "#f8cc03", "#ff8c02", "#699696", "#b77844", "#83acd0", "#c2e076", "#fadc5a", "#ff549f", "#ffaf54", "#9ab8b7", "#d2a683", "#3d699b", "#87ac22", "#cda908", "#d02158", "#d07300", "#567676"];
		b.push("colors");
		this.colorHSV = [0, 0, 1];
		this.colorRGB = [1, 1, 1];
		this.colorSpectrum = ["#4575b4", "#91bfdb", "#e0f3f8", "#ffffbf", "#fee090", "#fc8d59", "#d73027"];
		b.push("colorSpectrum");
		this.colorSpectrumBreaks = [];
		b.push("colorSpectrumBreaks");
		this.colorSpectrumZeroValue = null;
		b.push("colorSpectrumZeroValue");
		this.colorSpectrumNumber = 100;
		b.push("colorSpectrumNumber");
		this.oddColor = this.background;
		b.push("oddColor");
		this.evenColor = "rgb(245,245,245)";
		b.push("evenColor");
		this.patterns = ["solid", "hatchForward", "hatchReverse", "stripeHorizontal", "stripeVertical", "polkaDot", "crossHatch", "crossStripe", "squares", "circles", "plus", "squigles", "brick", "art", "pcx"];
		b.push("patterns");
		this.shapes = ["sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "pacman", "pacman2", "mdavid", "rect2", "rect3", "arc", "rectangle", "image"];
		b.push("shapes");
		this.sizes = [12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42];
		b.push("sizes");
		this.images = [];
		b.push("images");
		this.timeFormat = "isoDate";
		b.push("timeFormat");
		this.maxSmpStringLen = 30;
		b.push("maxSmpStringLen");
		this.smpLabelDescription = false;
		b.push("smpLabelDescription");
		this.smpTitle = false;
		b.push("smpTitle");
		this.smpTitleFontStyle = "";
		b.push("smpTitleFontStyle");
		this.smpTitleFontSize = 12;
		b.push("smpTitleFontSize");
		this.smpTitleFontColor = this.foreground;
		b.push("smpTitleFontColor");
		this.smpTitleScaleFontFactor = 1;
		b.push("smpTitleScaleFontFactor");
		this.smpLabelFontStyle = "";
		b.push("smpLabelFontStyle");
		this.smpLabelFontSize = 12;
		b.push("smpLabelFontSize");
		this.smpLabelFontColor = this.foreground;
		b.push("smpLabelFontColor");
		this.smpLabelScaleFontFactor = 1;
		b.push("smpLabelScaleFontFactor");
		this.smpLabelRotate = 0;
		b.push("smpLabelRotate");
		this.smpLabelInterval = 1;
		b.push("smpLabelInterval");
		this.showSampleNames = true;
		b.push("showSampleNames");
		this.highlightSmp = [];
		b.push("highlightSmp");
		this.smpHighlightColor = "rgb(255,0,0)";
		b.push("smpHighlightColor");
		this.filterSmpBy = [];
		b.push("filterSmpBy");
		this.filterSmpByOp = [];
		b.push("filterSmpByOp");
		this.filterSmpByValue = [];
		b.push("filterSmpByValue");
		this.filterSmpByCase = [];
		b.push("filterSmpByCase");
		this.filteredSmpIndices = [];
		b.push("filteredSmpIndices");
		this.maxVarStringLen = 30;
		b.push("maxVarStringLen");
		this.varLabelDescription = false;
		b.push("varLabelDescription");
		this.varTitle = false;
		b.push("varTitle");
		this.varTitleFontStyle = "";
		b.push("varTitleFontStyle");
		this.varTitleFontSize = 12;
		b.push("varTitleFontSize");
		this.varTitleFontColor = this.foreground;
		b.push("varTitleFontColor");
		this.varTitleScaleFontFactor = 1;
		b.push("varTitleScaleFontFactor");
		this.varLabelFontStyle = "";
		b.push("varLabelFontStyle");
		this.varLabelFontSize = 12;
		b.push("varLabelFontSize");
		this.varLabelFontColor = this.foreground;
		b.push("varLabelFontColor");
		this.varLabelScaleFontFactor = 1;
		b.push("varLabelScaleFontFactor");
		this.varLabelRotate = 0;
		b.push("varLabelRotate");
		this.varLabelInterval = 1;
		b.push("varLabelInterval");
		this.showVariableNames = true;
		b.push("showVariableNames");
		this.highlightVar = [];
		b.push("highlightVar");
		this.varHighlightColor = "rgb(255,0,0)";
		b.push("varHighlightColor");
		this.filterVarBy = [];
		b.push("filterVarBy");
		this.filterVarByOp = [];
		b.push("filterVarByOp");
		this.filterVarByValue = [];
		b.push("filterVarByValue");
		this.filterVarByCase = [];
		b.push("filterVarByCase");
		this.filteredVarIndices = [];
		b.push("filteredVarIndices");
		this.binConfigurations = {};
		b.push("binConfigurations");
		this.overlaysThickness = 18;
		b.push("overlaysThickness");
		this.smpOverlays = [];
		b.push("smpOverlays");
		this.smpOverlayProperties = {};
		b.push("smpOverlayProperties");
		this.showSmpOverlaysLegend = false;
		b.push("showSmpOverlaysLegend");
		this.varOverlays = [];
		b.push("varOverlays");
		this.varOverlayProperties = {};
		b.push("varOverlayProperties");
		this.showVarOverlaysLegend = false;
		b.push("showVarOverlaysLegend");
		this.showOverlays = true;
		b.push("showOverlays");
		this.showLevelOverlays = true;
		b.push("showLevelOverlays");
		this.overlayFontStyle = "";
		b.push("overlayFontStyle");
		this.overlayFontSize = 10;
		b.push("overlayFontSize");
		this.overlayFontColor = this.foreground;
		b.push("overlayFontColor");
		this.overlayScaleFontFactor = 1;
		b.push("overlayScaleFontFactor");
		this.showLegend = true;
		b.push("showLegend");
		this.legendColumns = 1;
		b.push("legendColumns");
		this.legendPosition = "right";
		b.push("legendPosition");
		this.legendInside = false;
		b.push("legendInside");
		this.legendColor = this.foreground;
		b.push("legendColor");
		this.legendBox = true;
		b.push("legendBox");
		this.legendBoxColor = "rgb(204,204,204)";
		b.push("legendBoxColor");
		this.legendBackgroundColor = this.background;
		b.push("legendBackgroundColor");
		this.legendFontStyle = "";
		b.push("legendFontStyle");
		this.legendFontSize = 12;
		b.push("legendFontSize");
		this.legendScaleFontFactor = 1;
		b.push("legendScaleFontFactor");
		this.showDecorations = false;
		b.push("showDecorations");
		this.showDecorationsLegend = true;
		b.push("showDecorationsLegend");
		this.decorationsPosition = "bottom";
		b.push("decorationsPosition");
		this.decorationsColor = this.foreground;
		b.push("decorationsColor");
		this.decorationsBox = true;
		b.push("decorationsBox");
		this.decorationsBoxColor = "rgb(204,204,204)";
		b.push("decorationsBoxColor");
		this.decorationsBackgroundColor = this.background;
		b.push("decorationsBackgroundColor");
		this.decorationFontStyle = "";
		b.push("decorationFontStyle");
		this.decorationFontSize = 12;
		b.push("decorationFontSize");
		this.decorationScaleFontFactor = 1;
		b.push("decorationScaleFontFactor");
		this.decorationsWidth = 10;
		b.push("decorationsWidth");
		this.decorationsHeight = 20;
		b.push("decorationsHeight");
		this.decorationsType = "bar";
		b.push("decorationsType");
		this.decorations = [];
		b.push("decorations");
		this.showDecorationsRegressionConfidence = true;
		b.push("showDecorationsRegressionConfidence");
		this.showDecorationsKaplanMeierConfidence = false;
		b.push("showDecorationsKaplanMeierConfidence");
		this.decorationsColors = [];
		b.push("decorationsColors");
		this.decorationsProperties = {};
		b.push("decorationsProperties");
		this.isGroupedData = false;
		this.isTransformedData = false;
		this.isBoxPlotCalc = false;
		this.isMarketDataFormated = false;
		this.isMarketSwitched = false;
		this.isGraphTime = false;
		b.push("isGraphTime");
		this.groupingFactors = [];
		b.push("groupingFactors");
		this.segregateSamplesBy = [];
		b.push("segregateSamplesBy");
		this.segregateVariablesBy = [];
		b.push("segregateVariablesBy");
		this.isLogData = false;
		b.push("isLogData");
		this.transformedData = false;
		b.push("transformedData");
		this.smpSort = -1;
		this.varSort = -1;
		this.tmpAsciiArray = [];
		this.sortDir = "ascending";
		b.push("sortDir");
		this.transformBase = 2;
		b.push("transformBase");
		this.transformType = false;
		b.push("transformType");
		this.transformCeilValue = false;
		b.push("transformCeilValue");
		this.transformFloorValue = false;
		b.push("transformFloorValue");
		this.ratioReference = 0;
		b.push("ratioReference");
		this.ratioSampleReference = false;
		b.push("ratioSampleReference");
		this.ratioGroupReference = false;
		b.push("ratioGroupReference");
		this.ratioLevelReference = "";
		b.push("ratioLevelReference");
		this.transformAxis = "samples";
		b.push("transformAxis");
		this.showErrorBars = true;
		b.push("showErrorBars");
		this.errorBarsType = "confidenceInterval95";
		b.push("errorBarsType");
		this.errorBarsWidth = 2;
		b.push("errorBarsWidth");
		this.standardDeviationType = "unbiased";
		b.push("standardDeviationType");
		this.errorEllipseConfidence = 0.99;
		b.push("errorEllipseConfidence");
		this.missingDataColor = "rgb(255,255,0)";
		b.push("missingDataColor");
		this.randomSeed = 8;
		b.push("randomSeed");
		this.pseudoRandom = true;
		b.push("pseudoRandom");
		this.randomData = false;
		this.randomDataUniform = false;
		b.push("randomDataUniform");
		this.randomDataSymmetrical = false;
		b.push("randomDataSymmetrical");
		this.randomDataMissing = false;
		b.push("randomDataMissing");
		this.randomDataMean = 0;
		b.push("randomDataMean");
		this.randomDataSigma = 1;
		b.push("randomDataSigma");
		this.randomDataVariables = 3;
		b.push("randomDataVariables");
		this.randomDataSamples = 36;
		b.push("randomDataSamples");
		this.randomDataVariableAnnotations = 2;
		b.push("randomDataVariableAnnotations");
		this.randomDataSampleAnnotations = 3;
		b.push("randomDataSampleAnnotations");
		this.randomDataVariableAnnotationRatio = 1;
		b.push("randomDataVariableAnnotationRatio");
		this.randomDataSampleAnnotationRatio = 6;
		b.push("randomDataSampleAnnotationRatio");
		this.randomMissingDataPercentage = 0;
		b.push("randomMissingDataPercentage");
		this.randomNetworkReduce = true;
		b.push("randomNetworkReduce");
		this.randomNetworkNodes = 50;
		b.push("randomNetworkNodes");
		this.randomNetworkNodeEdgesMax = 5;
		b.push("randomNetworkNodeEdgesMax");
		this.zoom = 1;
		b.push("zoom");
		this.zoomGlobal = 1;
		this.zoomStep = 0.2;
		b.push("zoomStep");
		this.zoomVariablesDisable = false;
		b.push("zoomVariablesDisable");
		this.zoomSamplesDisable = false;
		b.push("zoomSamplesDisable");
		this.panningX = 0;
		b.push("panningX");
		this.panningY = 0;
		b.push("panningY");
		this.panningGlobalX = 0;
		this.panningGlobalY = 0;
		this.panningStep = 0.2;
		b.push("panningStep");
		this.xAxisAbsMax = null;
		this.xAxisAbsMin = null;
		this.xAxisMaxStrLength = false;
		this.setMaxX = null;
		b.push("setMaxX");
		this.setMinX = null;
		b.push("setMinX");
		this.xAxisCurrent = 0;
		b.push("xAxisCurrent");
		this.xAxisTitle = false;
		b.push("xAxisTitle");
		this.xAxis = [];
		b.push("xAxis");
		this.xAxisTickStyle = "solid";
		b.push("xAxisTickStyle");
		this.xAxisTickFormat = false;
		b.push("xAxisTickFormat");
		this.xAxisTickColor = "rgb(204,204,204)";
		b.push("xAxisTickColor");
		this.xAxisExact = false;
		b.push("xAxisExact");
		this.xAxisValues = [];
		b.push("xAxisValues");
		this.xAxisMinorValues = [];
		b.push("xAxisMinorValues");
		this.xAxisTransform = false;
		b.push("xAxisTransform");
		this.xAxisTransformCeilValue = false;
		b.push("xAxisTransformCeilValue");
		this.xAxisTransformFloorValue = false;
		b.push("xAxisTransformFloorValue");
		this.xAxisTransformTicks = true;
		b.push("xAxisTransformTicks");
		this.xAxisShow = true;
		b.push("xAxisShow");
		this.xAxisS2Show = false;
		b.push("xAxisS2Show");
		this.xAxisTicks = 5;
		b.push("xAxisTicks");
		this.xAxisMinorTicks = true;
		b.push("xAxisMinorTicks");
		this.xAxisMajorTicks = true;
		b.push("xAxisMajorTicks");
		this.xAxisHistogramShow = false;
		b.push("xAxisHistogramShow");
		this.xAxisHistogramHeight = 50;
		b.push("xAxisHistogramHeight");
		this.timeValues = [];
		b.push("timeValues");
		this.timeValueIndices = [];
		b.push("timeValueIndices");
		this.timeTicksFirst = false;
		b.push("timeTicksFirst");
		this.xAxis2AbsMax = null;
		this.xAxis2AbsMin = null;
		this.xAxis2MaxStrLength = false;
		this.setMaxX2 = null;
		b.push("setMaxX2");
		this.setMinX2 = null;
		b.push("setMinX2");
		this.xAxis2Title = false;
		b.push("xAxis2Title");
		this.xAxis2TickFormat = false;
		b.push("xAxis2TickFormat");
		this.xAxis2Exact = false;
		b.push("xAxis2Exact");
		this.xAxis2Values = [];
		b.push("xAxis2Values");
		this.xAxis2MinorValues = [];
		b.push("xAxis2MinorValues");
		this.xAxis2Show = true;
		b.push("xAxis2Show");
		this.xAxis2Ticks = null;
		this.yAxisAbsMax = null;
		this.yAxisAbsMin = null;
		this.yAxisMaxStrLength = false;
		this.setMaxY = null;
		b.push("setMaxY");
		this.setMinY = null;
		b.push("setMinY");
		this.yAxisCurrent = 0;
		b.push("yAxisCurrent");
		this.yAxisTitle = false;
		b.push("yAxisTitle");
		this.yAxis = [];
		b.push("yAxis");
		this.yAxisTickStyle = "solid";
		b.push("yAxisTickStyle");
		this.yAxisTickFormat = false;
		b.push("yAxisTickFormat");
		this.yAxisTickColor = "rgb(204,204,204)";
		b.push("yAxisTickColor");
		this.yAxisExact = false;
		b.push("yAxisExact");
		this.yAxisValues = [];
		b.push("yAxisValues");
		this.yAxisMinorValues = [];
		b.push("yAxisMinorValues");
		this.yAxisTransform = false;
		b.push("yAxisTransform");
		this.yAxisTransformCeilValue = false;
		b.push("yAxisTransformCeilValue");
		this.yAxisTransformFloorValue = false;
		b.push("yAxisTransformFloorValue");
		this.yAxisTransformTicks = true;
		b.push("yAxisTransformTicks");
		this.yAxisShow = true;
		b.push("yAxisShow");
		this.yAxisS2Show = false;
		b.push("yAxisS2Show");
		this.yAxisTicks = 5;
		b.push("yAxisTicks");
		this.yAxisMinorTicks = true;
		b.push("yAxisMinorTicks");
		this.yAxisMajorTicks = true;
		b.push("yAxisMajorTicks");
		this.yAxisHistogramShow = false;
		b.push("yAxisHistogramShow");
		this.yAxisHistogramHeight = 50;
		b.push("yAxisHistogramHeight");
		this.zAxisAbsMax = null;
		this.zAxisAbsMin = null;
		this.zAxisMaxStrLength = false;
		this.setMaxZ = null;
		b.push("setMaxZ");
		this.setMinZ = null;
		b.push("setMinZ");
		this.zAxisCurrent = 0;
		b.push("zAxisCurrent");
		this.zAxisTitle = false;
		b.push("zAxisTitle");
		this.zAxis = [];
		b.push("zAxis");
		this.zAxisTickStyle = "solid";
		b.push("zAxisTickStyle");
		this.zAxisTickFormat = false;
		b.push("zAxisTickFormat");
		this.zAxisTickColor = "rgb(204,204,204)";
		b.push("zAxisTickColor");
		this.zAxisExact = false;
		b.push("zAxisExact");
		this.zAxisValues = [];
		b.push("zAxisValues");
		this.zAxisMinorValues = [];
		b.push("zAxisMinorValues");
		this.zAxisShow = true;
		b.push("zAxisShow");
		this.zAxisTicks = 10;
		this.rAxisAbsMax = null;
		this.rAxisAbsMin = null;
		this.rAxisMaxStrLength = false;
		this.rAxisTickColor = this.foreground;
		b.push("rAxisTickColor");
		this.rAxisValues = [];
		b.push("rAxisValues");
		this.rAxisMinorValues = [];
		b.push("rAxisMinorValues");
		this.rAxisShow = true;
		b.push("rAxisShow");
		this.rAxisLabelOrientation = "perpendicular";
		b.push("rAxisLabelOrientation");
		this.rAxisTicks = 5;
		b.push("rAxisTicks");
		this.axisTickColor = this.foreground;
		b.push("axisTickColor");
		this.axisTickFontStyle = "";
		b.push("axisTickFontStyle");
		this.axisTickFontSize = 12;
		b.push("axisTickFontSize");
		this.axisTickScaleFontFactor = 1;
		b.push("axisTickScaleFontFactor");
		this.axisTitleColor = this.foreground;
		b.push("axisTitleColor");
		this.axisTitleFontStyle = "";
		b.push("axisTitleFontStyle");
		this.axisTitleFontSize = 12;
		b.push("axisTitleFontSize");
		this.axisTitleScaleFontFactor = 1;
		b.push("axisTitleScaleFontFactor");
		this.axisExtension = 0.1;
		b.push("axisExtension");
		this.axisAlgorithm = "heckbert";
		b.push("axisAlgorithm");
		this.axisWilkinsonLoose = false;
		b.push("axisWilkinsonLoose");
		this.axisTicksAutoAdjust = false;
		b.push("axisTicksAutoAdjust");
		this.setMax = null;
		this.setMin = null;
		this.smpHairline = false;
		b.push("smpHairline");
		this.smpHairlineWidth = 0.3;
		b.push("smpHairlineWidth");
		this.smpHairlineColor = "rgb(204,204,204)";
		b.push("smpHairlineColor");
		this.blockContrast = false;
		b.push("blockContrast");
		this.plotByVariable = false;
		b.push("plotByVariable");
		this.is3DPlot = false;
		b.push("is3DPlot");
		this.showDataValues = false;
		b.push("showDataValues");
		this.jitter = true;
		b.push("jitter");
		this.objectBorderColor = "rgb(0,0,0)";
		b.push("objectBorderColor");
		this.lineDecoration = "symbol";
		b.push("lineDecoration");
		this.lineErrorType = "bar";
		b.push("lineErrorType");
		this.coordinateLineColor = false;
		b.push("coordinateLineColor");
		this.lineThickness = 1;
		b.push("lineThickness");
		this.lineType = "rect";
		b.push("lineType");
		this.tension = 0.3;
		b.push("tension");
		this.hullScale = 1.25;
		b.push("hullScale");
		this.boxPlotOutliersRatio = 8;
		b.push("boxPlotOutliersRatio");
		this.showBoxplotOriginalData = false;
		b.push("showBoxplotOriginalData");
		this.showViolinBoxplot = false;
		b.push("showViolinBoxplot");
		this.boxplotDataPointRatio = 2;
		b.push("boxplotDataPointRatio");
		this.boxplotDataPointTransparency = 0.5;
		b.push("boxplotDataPointTransparency");
		this.boxplotMedianColor = "rgb(0,0,0)";
		b.push("boxplotMedianColor");
		this.boxplotMedianWidth = 1;
		b.push("boxplotMedianWidth");
		this.boxplotMean = false;
		b.push("boxplotMean");
		this.boxplotMeanColor = "rgb(255,215,0)";
		b.push("boxplotMeanColor");
		this.boxplotMeanColorBorder = "rgb(255,0,0)";
		b.push("boxplotMeanColorBorder");
		this.boxplotConnect = false;
		b.push("boxplotConnect");
		this.boxplotConnectWidth = 2;
		b.push("boxplotConnectWidth");
		this.areaType = "normal";
		b.push("areaType");
		this.colorBy = false;
		b.push("colorBy");
		this.colorByShowLegend = true;
		b.push("colorByShowLegend");
		this.shapeBy = false;
		b.push("shapeBy");
		this.shapeByShowLegend = true;
		b.push("shapeByShowLegend");
		this.shapeByData = false;
		b.push("shapeByData");
		this.shapeByShape = false;
		b.push("shapeByShape");
		this.sizeBy = false;
		b.push("sizeBy");
		this.sizeByContinuous = false;
		b.push("sizeByContinuous");
		this.sizeByShowLegend = true;
		b.push("sizeByShowLegend");
		this.sizeByData = false;
		b.push("sizeByData");
		this.outlineBy = false;
		b.push("outlineBy");
		this.outlineByShowLegend = true;
		b.push("outlineByShowLegend");
		this.outlineByData = false;
		b.push("outlineByData");
		this.patternBy = false;
		b.push("patternBy");
		this.patternByShowLegend = true;
		b.push("patternByShowLegend");
		this.patternByData = false;
		b.push("patternByData");
		this.connectBy = false;
		b.push("connectBy");
		this.connectByColor = "rgb(0,0,0)";
		b.push("connectByColor");
		this.connectByData = {};
		this.treemapBy = false;
		b.push("treemapBy");
		this.metadataColorProperties = {};
		b.push("metadataColorProperties");
		this.motionBy = false;
		b.push("motionBy");
		this.motionControlHeight = 50;
		b.push("motionControlHeight");
		this.motionTrails = true;
		b.push("motionTrails");
		this.ellipseBy = false;
		b.push("ellipseBy");
		this.scatterType = false;
		b.push("scatterType");
		this.scatterAxesEqual = false;
		b.push("scatterAxesEqual");
		this.scatterOutlineThreshold = 50000;
		b.push("scatterOutlineThreshold");
		this.functionIntervals = 25;
		b.push("functionIntervals");
		this.selectDataMode = "area";
		b.push("selectDataMode");
		this.selectDataModeDescription = false;
		b.push("selectDataModeDescription");
		this.selectDataPoint = [];
		this.hideDataPoint = [];
		this.isSelectDataPoints = 0;
		this.contourType = "overlay";
		b.push("contourType");
		this.contourXBinSize = false;
		b.push("contourXBinSize");
		this.contourYBinSize = false;
		b.push("contourYBinSize");
		this.contourZBinSize = false;
		b.push("contourZBinSize");
		this.isHistogram = false;
		b.push("isHistogram");
		this.histogramBarWidth = 0.5;
		b.push("histogramBarWidth");
		this.histogramBins = false;
		b.push("histogramBins");
		this.histogramStagger = false;
		b.push("histogramStagger");
		this.showHistogramDensity = false;
		b.push("showHistogramDensity");
		this.histogramDensityKernel = "epanechnikovKernel";
		b.push("histogramDensityKernel");
		this.isCreateHistogram = false;
		this.loessBandwidth = 0.3;
		b.push("loessBandwidth");
		this.loessIterations = 2;
		b.push("loessIterations");
		this.loessAccuracy = 1e-12;
		b.push("loessAccuracy");
		this.showLoessFit = false;
		b.push("showLoessFit");
		this.loessColor = "rgb(255,215,0)";
		b.push("loessColor");
		this.loessDrawOptimizer = 5;
		b.push("loessDrawOptimizer");
		this.maxDOENumber = 8;
		b.push("maxDOENumber");
		this.includeDOE = [];
		b.push("includeDOE");
		this.showDOEData = true;
		b.push("showDOEData");
		this.scatterPlotMatrix = false;
		b.push("scatterPlotMatrix");
		this.scatterPlotMatrixType = "completeBoth";
		b.push("scatterPlotMatrixType");
		this.xRotate = 45;
		b.push("xRotate");
		this.yRotate = 0;
		b.push("yRotate");
		this.zRotate = 0;
		b.push("zRotate");
		this.x3DRatio = 1;
		b.push("x3DRatio");
		this.y3DRatio = 1;
		b.push("y3DRatio");
		this.z3DRatio = 1;
		b.push("z3DRatio");
		this.bar3DInverseWeight = 1;
		b.push("bar3DInverseWeight");
		this.show3DGrid = true;
		b.push("show3DGrid");
		this.rotationDelay = 100;
		b.push("rotationDelay");
		this.rotationSensitivity = 450;
		b.push("rotationSensitivity");
		this.rotationStep = 2;
		b.push("rotationStep");
		this.perspectiveFactor = 2.2;
		b.push("perspectiveFactor");
		this.invMagnificationFactor = 4;
		b.push("invMagnificationFactor");
		this.varIndicesStart = -1;
		this.smpIndicesStart = -1;
		this.isMultidimensionalData = false;
		this.heatmapAutoAdjust = false;
		b.push("heatmapAutoAdjust");
		this.heatmapLabelSizeAutoAdjust = true;
		b.push("heatmapLabelSizeAutoAdjust");
		this.heatmapCellBox = true;
		b.push("heatmapCellBox");
		this.heatmapCellBoxColor = "rgb(220,220,220)";
		b.push("heatmapCellBoxColor");
		this.heatmapCellBoxWidth = 0.5;
		b.push("heatmapCellBoxWidth");
		this.heatmapCellBoxColorHighlight = "rgb(255,215,0)";
		b.push("heatmapCellBoxColorHighlight");
		this.heatmapCellBoxHighlightWidth = 1;
		b.push("heatmapCellBoxHighlightWidth");
		this.heatmapSmpSeparateBy = false;
		b.push("heatmapSmpSeparateBy");
		this.heatmapVarSeparateBy = false;
		b.push("heatmapVarSeparateBy");
		this.heatmapSeparatorWidth = 2.5;
		b.push("heatmapSeparatorWidth");
		this.varTitleLabelOverlayPosition = "bottom";
		b.push("varTitleLabelOverlayPosition");
		this.showHeatmapIndicator = true;
		b.push("showHeatmapIndicator");
		this.heatmapIndicatorHeight = 20;
		b.push("heatmapIndicatorHeight");
		this.heatmapIndicatorWidth = 160;
		b.push("heatmapIndicatorWidth");
		this.heatmapIndicatorPosition = "top";
		b.push("heatmapIndicatorPosition");
		this.heatmapIndicatorHistogram = false;
		b.push("heatmapIndicatorHistogram");
		this.heatmapIndicatorHistogramColor = "rgb(0,255,255)";
		b.push("heatmapIndicatorHistogramColor");
		this.isOncoprint = false;
		b.push("isOncoprint");
		this.oncoprintCode = false;
		b.push("oncoprintCode");
		this.oncoprintAmplification = 3;
		b.push("oncoprintAmplification");
		this.oncoprintDeletion = 1;
		b.push("oncoprintDeletion");
		this.correlationAxis = "samples";
		b.push("correlationAxis");
		this.correlationAnchorLegend = false;
		b.push("correlationAnchorLegend");
		this.correlationAnchorLegendAlignWidth = 40;
		b.push("correlationAnchorLegendAlignWidth");
		this.correlationLabelInterval = 1;
		b.push("correlationLabelInterval");
		this.showSmpDendrogram = true;
		b.push("showSmpDendrogram");
		this.showVarDendrogram = true;
		b.push("showVarDendrogram");
		this.varDendrogramPosition = "top";
		b.push("varDendrogramPosition");
		this.smpDendrogramPosition = "left";
		b.push("smpDendrogramPosition");
		this.dendrogramSpace = 6;
		b.push("dendrogramSpace");
		this.dendrogramHang = false;
		b.push("dendrogramHang");
		this.dendrogramHeight = 50;
		b.push("dendrogramHeight");
		this.dendrogramColor = "rgb(0,0,0)";
		b.push("dendrogramColor");
		this.distance = "euclidian";
		b.push("distance");
		this.linkage = "complete";
		b.push("linkage");
		this.clusterAxis = "samples";
		b.push("clusterAxis");
		this.kmeansVarClusters = 3;
		b.push("kmeansVarClusters");
		this.kmeansSmpClusters = 3;
		b.push("kmeansSmpClusters");
		this.maxIterations = 10;
		b.push("maxIterations");
		this.imputeMethod = "mean";
		b.push("imputeMethod");
		this.samplesClustered = false;
		b.push("samplesClustered");
		this.variablesClustered = false;
		b.push("variablesClustered");
		this.samplesKmeaned = false;
		b.push("samplesKmeaned");
		this.variablesKmeaned = false;
		b.push("variablesKmeaned");
		this.vennLegendColors = false;
		b.push("vennLegendColors");
		this.vennGroups = 4;
		b.push("vennGroups");
		this.vennCompartments = ["A", "B", "AB", "C", "AC", "BC", "ABC", "D", "AD", "BD", "CD", "ABD", "ACD", "BCD", "ABCD"];
		b.push("vennCompartments");
		this.vennColors = [];
		b.push("vennColors");
		this.pieType = "separated";
		b.push("pieType");
		this.pieSegmentPrecision = 0;
		b.push("pieSegmentPrecision");
		this.pieSegmentSeparation = 1;
		b.push("pieSegmentSeparation");
		this.pieSegmentLabels = "inside";
		b.push("pieSegmentLabels");
		this.pieLabelType = "percentage";
		b.push("pieLabelType");
		this.maxPieSectors = 20;
		b.push("maxPieSectors");
		this.showPieGrid = true;
		b.push("showPieGrid");
		this.showPieValues = true;
		b.push("showPieValues");
		this.showPieSampleLabel = true;
		b.push("showPieSampleLabel");
		this.startPieSectors = 0;
		b.push("startPieSectors");
		this.pieInnerRadius = 0;
		b.push("pieInnerRadius");
		this.pieColors = [];
		b.push("pieColors");
		this.circularCenterProportion = 0.3;
		b.push("circularCenterProportion");
		this.arcSegmentsSeparation = 5;
		b.push("arcSegmentsSeparation");
		this.ringSeparation = 12;
		b.push("ringSeparation");
		this.ringsType = [];
		b.push("ringsType");
		this.ringsWeight = [];
		b.push("ringsWeight");
		this.rAxis = false;
		b.push("rAxis");
		this.rAxisZero = false;
		b.push("rAxisZero");
		this.showRingLegend = true;
		b.push("showRingLegend");
		this.showCircularConnections = true;
		b.push("showCircularConnections");
		this.circularLetterSeparationFactor = 1.5;
		b.push("circularLetterSeparationFactor");
		this.circularConnectionsTransparency = 0.5;
		b.push("circularConnectionsTransparency");
		this.smpLabelOrientation = "perpendicular";
		b.push("smpLabelOrientation");
		this.tagCloudTextWeightFactor = 1;
		b.push("tagCloudTextWeightFactor");
		this.tagCloudTextGridSize = 8;
		b.push("tagCloudTextGridSize");
		this.tagCloudTextEllipticity = 0.65;
		b.push("tagCloudTextEllipticity");
		this.tagCloudTextRotateRatio = 0.1;
		b.push("tagCloudTextRotateRatio");
		this.tagCloudGridPoints = [];
		this.showVolume = true;
		b.push("showVolume");
		this.stockIndicators = ["Sma5", "Sma10", "Sma25"];
		b.push("stockIndicators");
		this.sma5Color = "rgb(255,0,0)";
		b.push("sma5Color");
		this.sma10Color = "rgb(0,255,0)";
		b.push("sma10Color");
		this.sma20Color = "rgb(0,0,255)";
		b.push("sma20Color");
		this.sma25Color = "rgb(255,0,255)";
		b.push("sma25Color");
		this.sma50Color = "rgb(0,0,0)";
		b.push("sma50Color");
		this.calculateLayout = true;
		b.push("calculateLayout");
		this.networkFreeze = false;
		b.push("networkFreeze");
		this.networkFreezeOnLoad = false;
		b.push("networkFreezeOnLoad");
		this.networkStack = [];
		this.subNetworks = false;
		this.networkStackStates = 8;
		b.push("networkStackStates");
		this.networkStackIndex = 0;
		this.approximateNodePositions = false;
		b.push("approximateNodePositions");
		this.networkLayoutType = "forceDirected";
		b.push("networkLayoutType");
		this.networkForceConstant = 0;
		b.push("networkForceConstant");
		this.temperature = 0;
		b.push("temperature");
		this.initialTemperature = 0;
		b.push("initialTemperature");
		this.networkNodeMinDistance = 4;
		b.push("networkNodeMinDistance");
		this.attractiveForceFunction = "FruchtermanReingold";
		b.push("attractiveForceFunction");
		this.repulsiveForceFunction = "square";
		b.push("repulsiveForceFunction");
		this.networkRoot = false;
		b.push("networkRoot");
		this.showNetworkRadialLayout = false;
		b.push("showNetworkRadialLayout");
		this.networkDepth = 0;
		this.networkDivisions = 0;
		this.preScaleNetwork = false;
		b.push("preScaleNetwork");
		this.showNetworkNodesLegend = true;
		b.push("showNetworkNodesLegend");
		this.showNetworkEdgesLegend = true;
		b.push("showNetworkEdgesLegend");
		this.showNetworkTextLegend = true;
		b.push("showNetworkTextLegend");
		this.showNetworkDecorationsLegend = true;
		b.push("showNetworkDecorationsLegend");
		this.highlightNode = [];
		b.push("highlightNode");
		this.nodeHighlightColor = "rgb(255,0,0)";
		b.push("nodeHighlightColor");
		this.selectNode = {};
		this.isSelectNodes = 0;
		this.showNodeNameThreshold = 50;
		b.push("showNodeNameThreshold");
		this.showHiddenChildEdges = true;
		b.push("showHiddenChildEdges");
		this.nodeSize = this.preScaleNetwork ? 10 : 20;
		b.push("nodeSize");
		this.edgeWidth = 1;
		b.push("edgeWidth");
		this.layoutTime = 15;
		b.push("layoutTime");
		this.nodeFontStyle = "";
		b.push("nodeFontStyle");
		this.nodeFontSize = this.nodeSize;
		b.push("nodeFontSize");
		this.nodeFontColor = this.foreground;
		b.push("nodeFontColor");
		this.nodeScaleFontFactor = 1;
		b.push("nodeScaleFontFactor");
		this.labelNodePosition = "auto";
		b.push("labelNodePosition");
		this.colorNodeBy = false;
		b.push("colorNodeBy");
		this.shapeNodeBy = false;
		b.push("shapeNodeBy");
		this.sizeNodeBy = false;
		b.push("sizeNodeBy");
		this.colorEdgeBy = false;
		b.push("colorEdgeBy");
		this.shapeEdgeBy = false;
		b.push("shapeEdgeBy");
		this.sizeEdgeBy = false;
		b.push("sizeEdgeBy");
		this.sizeDecorationBy = false;
		b.push("sizeDecorationBy");
		this.is3DNetwork = false;
		b.push("is3DNetwork");
		this.isNetworkCommunities = false;
		b.push("isNetworkCommunities");
		this.calculateNetworkCommunities = true;
		b.push("calculateNetworkCommunities");
		this.networkCommunities = 0;
		this.networkConvexHulls = [];
		this.isNetworkConvexHull = false;
		this.isCoordinateNodeColorsNetworkConvexHull = false;
		b.push("isCoordinateNodeColorsNetworkConvexHull");
		this.network2DRotate = 0;
		this.skipClick = false;
		this.autoHideOnDecorationsCenter = false;
		b.push("autoHideOnDecorationsCenter");
		this.networkNodesOnTop = true;
		b.push("networkNodesOnTop");
		this.overrideEventlessNodes = false;
		b.push("overrideEventlessNodes");
		this.overrideAnchorNodes = false;
		b.push("overrideAnchorNodes");
		this.moveParentsWithChildren = false;
		b.push("moveParentsWithChildren");
		this.nodeConfigurableProperties = ["x", "y", "z", "parentNode", "shape", "color", "outline", "size", "width", "height", "pattern", "rotate", "outlineWidth", "imagePath", "zIndex", "eventless", "hide", "hideLabel", "anchor"];
		b.push("nodeConfigurableProperties");
		this.edgeConfigurableProperties = ["color", "width", "cap", "exact", "type"];
		b.push("edgeConfigurableProperties");
		this.filterNodeBy = [];
		b.push("filterNodeBy");
		this.filterNodeByOp = [];
		b.push("filterNodeByOp");
		this.filterNodeByValue = [];
		b.push("filterNodeByValue");
		this.filterNodeByCase = [];
		b.push("filterNodeByCase");
		this.filterEdgeBy = [];
		b.push("filterEdgeBy");
		this.filterEdgeByOp = [];
		b.push("filterEdgeByOp");
		this.filterEdgeByValue = [];
		b.push("filterEdgeByValue");
		this.filterEdgeByCase = [];
		b.push("filterEdgeByCase");
		this.genomeTicks = 50;
		b.push("genomeTicks");
		this.trackNameFontStyle = "";
		b.push("trackNameFontStyle");
		this.trackNameFontSize = 10;
		b.push("trackNameFontSize");
		this.trackNameFontColor = this.foreground;
		b.push("trackNameFontColor");
		this.trackFillColor = this.background;
		b.push("trackFillColor");
		this.trackDirColor = this.foreground;
		b.push("trackDirColor");
		this.subtracksMaxDefault = 8;
		b.push("subtracksMaxDefault");
		this.showFeatureNameThereshold = 20;
		b.push("showFeatureNameThereshold");
		this.featureNameFontStyle = "";
		b.push("featureNameFontStyle");
		this.featureNameFontSize = 10;
		b.push("featureNameFontSize");
		this.featureNameFontColor = this.foreground;
		b.push("featureNameFontColor");
		this.featureFillColor = this.background;
		b.push("featureFillColor");
		this.featureDirColor = this.foreground;
		b.push("featureDirColor");
		this.maxFeatureStringLen = 30;
		b.push("maxFeatureStringLen");
		this.featureWidthDefault = 3;
		b.push("featureWidthDefault");
		this.featureHeightDefault = 14;
		b.push("featureHeightDefault");
		this.featureTraceHeight = 40;
		b.push("featureTraceHeight");
		this.featureTraceTrim = 1;
		b.push("featureTraceTrim");
		this.featureTracesShow = true;
		b.push("featureTracesShow");
		this.featureQualityHeight = 12;
		b.push("featureQualityHeight");
		this.featureQualityValues = false;
		b.push("featureQualityValues");
		this.featureQualityShow = true;
		b.push("featureQualityShow");
		this.featureSignalToNoiseHeight = 12;
		b.push("featureSignalToNoiseHeight");
		this.featureSignalToNoiseValues = false;
		b.push("featureSignalToNoiseValues");
		this.featureSignalToNoiseShow = true;
		b.push("featureSignalToNoiseShow");
		this.featureCoordinateHeight = 12;
		b.push("featureCoordinateHeight");
		this.featureCoordinateShow = true;
		b.push("featureCoordinateShow");
		this.featureTranslateHeight = 12;
		b.push("featureTranslateHeight");
		this.featureTranslateShow = true;
		b.push("featureTranslateShow");
		this.featureTypeDefault = "line";
		b.push("featureTypeDefault");
		this.featureStaggered = false;
		b.push("featureStaggered");
		this.sequenceFontStyle = "";
		b.push("sequenceFontStyle");
		this.sequenceFontSize = 10;
		b.push("sequenceFontSize");
		this.sequenceFill = false;
		b.push("sequenceFill");
		this.sequenceGAPColor = "rgb(255,0,255)";
		b.push("sequenceGAPColor");
		this.sequenceAColor = "rgb(0,103,0)";
		b.push("sequenceAColor");
		this.sequenceBColor = "rgb(0,0,0)";
		b.push("sequenceBColor");
		this.sequenceCColor = "rgb(0,0,255)";
		b.push("sequenceCColor");
		this.sequenceDColor = "rgb(0,0,0)";
		b.push("sequenceDColor");
		this.sequenceEColor = "rgb(0,0,0)";
		b.push("sequenceEColor");
		this.sequenceFColor = "rgb(0,0,255)";
		b.push("sequenceFColor");
		this.sequenceGColor = "rgb(0,0,0)";
		b.push("sequenceGColor");
		this.sequenceHColor = "rgb(255,0,0)";
		b.push("sequenceHColor");
		this.sequenceIColor = "rgb(0,103,0)";
		b.push("sequenceIColor");
		this.sequenceKColor = "rgb(255,0,0)";
		b.push("sequenceKColor");
		this.sequenceLColor = "rgb(0,103,0)";
		b.push("sequenceLColor");
		this.sequenceMColor = "rgb(0,103,0)";
		b.push("sequenceMColor");
		this.sequenceNColor = "rgb(0,0,0)";
		b.push("sequenceNColor");
		this.sequencePColor = "rgb(255,165,0)";
		b.push("sequencePColor");
		this.sequenceQColor = "rgb(0,0,0)";
		b.push("sequenceQColor");
		this.sequenceRColor = "rgb(255,0,0)";
		b.push("sequenceRColor");
		this.sequenceSColor = "rgb(255,165,0)";
		b.push("sequenceSColor");
		this.sequenceTColor = "rgb(255,0,0)";
		b.push("sequenceTColor");
		this.sequenceUColor = "rgb(255,0,0)";
		b.push("sequenceUColor");
		this.sequenceVColor = "rgb(0,103,0)";
		b.push("sequenceVColor");
		this.sequenceWColor = "rgb(0,0,255)";
		b.push("sequenceWColor");
		this.sequenceXColor = "rgb(0,0,0)";
		b.push("sequenceXColor");
		this.sequenceYColor = "rgb(0,0,255)";
		b.push("sequenceYColor");
		this.sequenceZColor = "rgb(0,0,0)";
		b.push("sequenceZColor");
		this.sequenceStartColor = "rgb(0,204,0)";
		b.push("sequenceStartColor");
		this.sequenceEndColor = "rgb(255,0,0)";
		b.push("sequenceEndColor");
		this.wireColor = "rgba(204,204,204,0.1)";
		b.push("wireColor");
		this.periodTicksLabels = 5;
		b.push("periodTicksLabels");
		this.genomeResolution = "low";
		this.trackConfigurableProperties = ["name", "hideName", "hideFeatureNames", "type", "height", "fill", "outline", "hide", "connect", "subtracksMax", "highlight"];
		b.push("trackConfigurableProperties");
		this.featureConfigurableProperties = ["id", "name", "label", "hideName", "fill", "outline", "dir", "showDir", "connect", "offset", "data", "subtype", "quality", "signalToNoise", "coordinate", "sequence", "trace", "gaps", "translate", "hide", "counter"];
		b.push("featureConfigurableProperties");
		this.filterFeatureBy = [];
		b.push("filterFeatureBy");
		this.filterFeatureByOp = [];
		b.push("filterFeatureByOp");
		this.filterFeatureByValue = [];
		b.push("filterFeatureByValue");
		this.filterFeatureByCase = [];
		b.push("filterFeatureByCase");
		this.errors = [];
		this.debug = false;
		b.push("debug");
		this.showVersion = true;
		b.push("showVersion");
		this.showCode = false;
		b.push("showCode");
		this.codeType = "params";
		b.push("codeType");
		this.disableMenu = false;
		b.push("disableMenu");
		this.disableToolbar = false;
		b.push("disableToolbar");
		this.disableTouchToolbar = false;
		b.push("disableTouchToolbar");
		this.disableDataTable = false;
		b.push("disableDataTable");
		this.disableDataFilters = false;
		b.push("disableDataFilters");
		this.disableConfigurator = false;
		b.push("disableConfigurator");
		this.disableAxisResizer = false;
		b.push("disableAxisResizer");
		this.isLayoutConfigurator = false;
		b.push("isLayoutConfigurator");
		this.resizable = true;
		b.push("resizable");
		this.maxSubMenus = 20;
		b.push("maxSubMenus");
		this.maxItemMenuCheckbox = 10;
		b.push("maxItemMenuCheckbox");
		this.showAdvancedConfiguration = false;
		b.push("showAdvancedConfiguration");
		this.showFadeResizeMoveAnimation = true;
		b.push("showFadeResizeMoveAnimation");
		this.configuratorWidth = 250;
		b.push("configuratorWidth");
		this.configuratorExamplesSize = 400;
		b.push("configuratorExamplesSize");
		this.alignConfiguratorExamples = false;
		b.push("alignConfiguratorExamples");
		this.showConfiguratorExamplesOnSelect = false;
		b.push("showConfiguratorExamplesOnSelect");
		this.dataFilterWidth = 180;
		b.push("dataFilterWidth");
		this.resizeWidthOnLayout = true;
		b.push("resizeWidthOnLayout");
		this.resizeHeightOnLayout = true;
		b.push("resizeHeightOnLayout");
		this.disableEvents = false;
		b.push("disableEvents");
		this.eventKeys = true;
		b.push("eventKeys");
		this.eventArrowKeys = true;
		b.push("eventArrowKeys");
		this.eventPlusMinusKeys = false;
		b.push("eventPlusMinusKeys");
		this.helpKeyEvents = false;
		b.push("helpKeyEvents");
		this.maintainZoomOnDrag = false;
		b.push("maintainZoomOnDrag");
		this.infoTimeOut = 2000; // Baohong
		b.push("infoTimeOut");
		this.infoStartTime = new Date().getTime();
		this.infoTimeIn = 50;
		b.push("infoTimeIn");
		this.dataEvent = [];
		this.broadcast = true;
		b.push("broadcast");
		this.broadcastType = "var";
		b.push("broadcastType");
		this.destroyCanvasXpressZombies = true;
		b.push("destroyCanvasXpressZombies");
		this.monitorCanvasXpressZombiesTime = 30000;
		b.push("monitorCanvasXpressZombiesTime");
		this.resizerBackgroundColor = this.meta.system.isIE ? "rgb(204,204,204)" : "rgba(204,204,204,0.7)";
		b.push("resizerBackgroundColor");
		this.resizerBackgroundColorCurrent = "rgb(237,247,255)";
		b.push("resizerBackgroundColorCurrent");
		this.resizerBackgroundColorOutlineCurrent = "rgb(59,138,229)";
		b.push("resizerBackgroundColorOutlineCurrent");
		this.resizerTransparency = true;
		b.push("resizerTransparency");
		this.resizerType = false;
		b.push("resizerType");
		this.resizerDraw = false;
		b.push("resizerDraw");
		this.resizerPosition = "bottom";
		b.push("resizerPosition");
		this.resizerWidth = 50;
		b.push("resizerWidth");
		this.resizerBackgroundImage = false;
		b.push("resizerBackgroundImage");
		this.resizerDataIndex = 0;
		b.push("resizerDataIndex");
		this.resizerEventData = {};
		this.showAnimation = false;
		b.push("showAnimation");
		this.showAnimationFontStyle = "";
		b.push("showAnimationFontStyle");
		this.showAnimationFontSize = 10;
		b.push("showAnimationFontSize");
		this.showAnimationFontColor = this.background;
		b.push("showAnimationFontColor");
		this.animationTime = 30;
		b.push("animationTime");
		this.animationType = "grow";
		b.push("animationType");
		this.animationCycles = 20;
		b.push("animationCycles");
		this.snapshotCopyChangeOnly = true;
		b.push("snapshotCopyChangeOnly");
		this.snapshots = [];
		this.isAnimation = false;
		this.weight = 1;
		this.scaleX = 1;
		this.scaleY = 1;
		this.translateX = 0;
		this.translateY = 0;
		this.offsetX = 0;
		this.offsetY = 0;
		this.layoutWidth = 0;
		this.layoutHeight = 0;
		this.layout = "1X1";
		b.push("layout");
		this.layoutComb = false;
		b.push("layoutComb");
		this.layoutAdjust = false;
		b.push("layoutAdjust");
		this.layoutCollapse = false;
		b.push("layoutCollapse");
		this.layoutRemoveEmpty = true;
		b.push("layoutRemoveEmpty");
		this.layoutCanvasCompartments = false;
		b.push("layoutCanvasCompartments");
		this.layoutBoxLabelColors = [];
		b.push("layoutBoxLabelColors");
		this.layoutBoxShow = true;
		b.push("layoutBoxShow");
		this.layoutCurrent = 0;
		this.layoutAxis = 3;
		this.imageDir = "";
		b.push("imageDir");
		this.loadingImage = "loading1";
		b.push("loadingImage");
		this.remoteService = false;
		b.push("remoteService");
		this.remoteServiceType = "webService";
		b.push("remoteServiceType");
		this.remoteParams = {};
		b.push("remoteParams");
		this.remoteDirection = "next";
		b.push("remoteDirection");
		this.remoteAutoPlay = false;
		b.push("remoteAutoPlay");
		this.remoteAutoPlayDelay = 3000;
		b.push("remoteAutoPlayDelay");
		this.remoteParamOverride = true;
		b.push("remoteParamOverride");
		this.remoteUpdate = false;
		b.push("remoteUpdate");
		this.remoteUpdateDelay = 10000;
		b.push("remoteUpdateDelay");
		this.remoteParentId = "";
		this.remoteDataIndex = 0;
		this.remoteIds = [];
		this.remoteData = [];
		this.remoteUpdating = false;
		this.RdatasetsURL = "https://raw.githubusercontent.com/neuhausi/Rdatasets/master/";
		this.loadRDatasets = false;
		b.push("loadRDatasets");
		this.skipConfigurableProperties = true;
		b.push("skipConfigurableProperties");
		this.nodesProperties = [];
		b.push("nodesProperties");
		this.edgesProperties = [];
		b.push("edgesProperties");
		this.featuresProperties = [];
		b.push("featuresProperties");
		this.filterType = "and";
		b.push("filterType");
		this.filterSkipNullKeys = false;
		b.push("filterSkipNullKeys");
		this.filterSkipNullValues = false;
		b.push("filterSkipNullValues");
		this.showDataTable = false;
		b.push("showDataTable");
		this.dataTableTransposed = true;
		b.push("dataTableTransposed");
		this.maxRows = 10;
		b.push("maxRows");
		this.maxCols = 6;
		b.push("maxCols");
		this.colWidth = 100;
		b.push("colWidth");
		this.rowHeight = 18;
		b.push("rowHeight");
		this.freezeColLeft = 0;
		b.push("freezeColLeft");
		this.freezeColRight = 0;
		b.push("freezeColRight");
		this.freezeRowTop = 0;
		b.push("freezeRowTop");
		this.freezeRowBottom = 0;
		b.push("freezeRowBottom");
		this.refresehDataTableOnDraw = false;
		b.push("refresehDataTableOnDraw");
		this.showDataTableOnSelect = false;
		b.push("showDataTableOnSelect");
		this.networkShowDataTable = "nodes";
		b.push("networkShowDataTable");
		this.startCol = 0;
		this.startRow = 0;
		this.dataTableColumnWidth = [];
		this.dataTableRowHeight = []
	};
	this.setInitialFonts = function() {
		this.font = this.fontStyle + " " + this.fontSize + "px " + this.fontName;
		this.titleFont = this.titleFontStyle + " " + this.titleFontSize + "px " + this.fontName;
		this.subtitleFont = this.subtitleFontStyle + " " + this.subtitleFontSize + "px " + this.fontName;
		this.citationFont = this.citationFontStyle + " " + this.citationFontSize + "px " + this.fontName;
		this.smpTitleFont = this.smpTitleFontStyle + " " + this.smpTitleFontSize + "px " + this.fontName;
		this.smpLabelFont = this.smpLabelFontStyle + " " + this.smpLabelFontSize + "px " + this.fontName;
		this.varTitleFont = this.varTitleFontStyle + " " + this.varTitleFontSize + "px " + this.fontName;
		this.varLabelFont = this.varLabelFontStyle + " " + this.varLabelFontSize + "px " + this.fontName;
		this.overlayFont = this.overlayFontStyle + " " + this.overlayFontSize + "px " + this.fontName;
		this.legendFont = this.legendFontStyle + " " + this.legendFontSize + "px " + this.fontName;
		this.decorationFont = this.decorationFontStyle + " " + this.decorationFontSize + "px " + this.fontName;
		this.axisTickFont = this.axisTickFontStyle + " " + this.axisTickFontSize + "px " + this.fontName;
		this.axisTitleFont = this.axisTitleFontStyle + " " + this.axisTitleFontSize + "px " + this.fontName;
		this.nodeFont = this.nodeFontStyle + " " + this.nodeFontSize + "px " + this.fontName;
		this.trackNameFont = this.trackNameFontStyle + " " + this.trackNameFontSize + "px " + this.fontName;
		this.featureNameFont = this.featureNameFontStyle + " " + this.featureNameFontSize + "px " + this.fontName;
		this.sequenceFont = this.sequenceFontStyle + " " + this.sequenceFontSize + "px " + this.fontName;
		this.showAnimationFont = this.showAnimationFontStyle + " " + this.showAnimationFontSize + "px " + this.fontName
	};
	this.setInitialConfig = function() {
		if (this.meta.config.user) {
			for (var b in this.meta.config.user) {
				this[b] = this.meta.config.user[b]
			}
		}
	};
	this.resetConfig = function(b) {
		var d = {};
		if (b) {
			for (var c = 0; c < b.length; c++) {
				d[b[c]] = this[b[c]]
			}
		}
		this.setConfigDefaults();
		for (var c in d) {
			this[c] = d[c]
		}
	};
	this.updateConfig = function(c) {
		if (c) {
			this.meta.config.user = c;
			for (var b in c) {
				this[b] = c[b]
			}
		}
	};
	this.getConfig = function() {
		var l = {};
		var c = this.meta.config.keys;
		var g = {
			colors: true,
			images: true,
			xAxisValues: true,
			xAxisMinorValues: true,
			yAxisValues: true,
			yAxisMinorValues: true,
			zAxisValues: true,
			zAxisMinorValues: true,
			stockIndicators: true,
			nodeConfigurableProperties: true,
			edgeConfigurableProperties: true,
			trackConfigurableProperties: true,
			featureConfigurableProperties: true
		};
		if (this.isTransformedData) {
			l.isTransformedData = this.isTransformedData
		}
		for (var f = 0; f < c.length; f++) {
			var e = c[f];
			if (CanvasXpress.doc.P[e] && CanvasXpress.doc.P[e].hasOwnProperty("D")) {
				var h = CanvasXpress.doc.P[e].D;
				if (g[e]) {
					continue
				}
				var b = this[e];
				if (typeof(b) == "object") {
					if (h == "[]") {
						h = []
					}
					if (h == "{}") {
						h = {}
					}
					if (b === null) {
						if (h != "null") {
							l[e] = b
						}
					} else {
						if (!this.isSameObject(b, h)) {
							l[e] = b
						}
					}
				} else {
					if (h.match(/false|true|null/)) {
						if (b.toString() != h) {
							l[e] = b
						}
					} else {
						if (b != h) {
							l[e] = b
						}
					}
				}
			}
		}
		return l
	};
	this.getUserConfig = function() {
		return this.meta.config.user
	};
	this.getNewCanvasContext = function(d) {
		var b = this.$(d);
		if (!b || b.tagName.toLowerCase() != "canvas") {
			b = this.$cX("canvas", {
				id: d
			});
			document.body.appendChild(b)
		}
		return b.getContext("2d")
	};
	this.setCanvasPixelRatio = function() {
		var b = document.createElement("canvas").getContext("2d");
		var c = window.devicePixelRatio || 1;
		var d = b.webkitBackingStorePixelRatio || b.mozBackingStorePixelRatio || b.msBackingStorePixelRatio || b.oBackingStorePixelRatio || b.backingStorePixelRatio || 1;
		this.meta.canvas.canvasPixelRatio = c / d
	};
	this.setCanvas = function() {
		var f = this.$(this.target);
		if (f) {
			this.setCanvasPixelRatio();
			this.checkCanvasXpressOrgSite();
			this.meta.canvas.ctx = f.getContext("2d");
			this.meta.canvas.ctx.setTransform(this.meta.canvas.canvasPixelRatio, 0, 0, this.meta.canvas.canvasPixelRatio, 0, 0);
			if ((this.backgroundType == "video" || this.graphType == "Video") && this.backgroundVideo) {
				if (this.graphType == "Video") {
					this.backgroundType = "video"
				}
				this.isVideo = true;
				var e = this.$cX("script", {
					type: "text/javascript",
					src: "../js/video.js"
				});
				var d = this.$cX("link", {
					type: "text/css",
					rel: "stylesheet",
					href: "../css/video-js.css"
				});
				var b = document.getElementsByTagName("head")[0];
				b.appendChild(d);
				b.appendChild(e);
				this.background = "rgba(255,255,255,0)";
				this.legendBackgroundColor = "rgba(255,255,255,0)";
				this.disableToolbar = true
			} else {
				this.isVideo = false
			}
		}
	};
	this.checkCanvasXpressOrgSite = function() {
		this.meta.siteSrc = false;
		var g = new RegExp("http://canvasxpress.org/js/");
		var d = document.getElementsByTagName("head")[0];
		for (var b = 0; b < d.childNodes.length; b++) {
			var f = d.childNodes[b];
			if (f.type == "text/javascript" && g.test(f.src)) {
				this.meta.siteSrc = true
			}
		}
	};
	this.inititalizeConfig = function() {
		this.setConfigDefaults();
		if (a) {
			for (var b = 0; b < this.meta.config.keys.length; b++) {
				var c = this.meta.config.keys[b];
				if (a.hasOwnProperty(c)) {
					this[c] = a[c]
				}
			}
		}
		this.setInitialFonts();
		this.setCanvas()
	};
	this.inititalizeConfig()
};
CanvasXpress.prototype.initText = function() {
	this.setTextShadow = function(a) {
		if (this.showTextShadow) {
			if (a) {
				this.meta.canvas.ctx.shadowOffsetX = this.shadowOffsetX;
				this.meta.canvas.ctx.shadowOffsetY = this.shadowOffsetY;
				this.meta.canvas.ctx.shadowBlur = this.shadowBlur;
				this.meta.canvas.ctx.shadowColor = this.shadowColor
			} else {
				this.meta.canvas.ctx.shadowOffsetX = 0;
				this.meta.canvas.ctx.shadowOffsetY = 0;
				this.meta.canvas.ctx.shadowBlur = 0;
				this.meta.canvas.ctx.shadowColor = this.background
			}
		}
	};
	this.drawTextMultiple = function(v, u, p, n, o, r, q, d, e, w) {
		var h = v.split(/\n/);
		if (!n) {
			n = this.font
		}
		var k = this.getFontPt(n);
		for (var j = 0; j < h.length; j++) {
			this.drawText(h[j], u, p, n, o, r, q, d, e, w);
			p += k + this.margin
		}
	};
	this.drawArcText = function(k, j, h, o, n, z, w, B, q, C, p, d) {
		var D = ["poly"];
		if (k == null) {
			return
		}
		if (!this.meta.canvas.ctx) {
			if (this.debug) {
				alert("Dude, there is no canvas")
			}
			return
		}
		if (isNaN(j) || isNaN(h)) {
			if (this.debug) {
				alert("Not a valid coordinate (" + j + ", " + h + ") to draw " + k)
			}
			return
		}
		if (!d && !isNaN(k)) {
			k = this.formatNumber(k)
		}
		if (!j) {
			j = 0
		}
		if (!h) {
			h = 0
		}
		if (!w) {
			w = this.font
		}
		if (!B) {
			B = this.foreground
		}
		if (!q) {
			q = this.align
		}
		if (!C) {
			C = this.baseline
		}
		this.meta.canvas.ctx.save();
		this.meta.canvas.ctx.strokeStyle = B;
		this.meta.canvas.ctx.fillStyle = B;
		this.meta.canvas.ctx.font = w;
		this.meta.canvas.ctx.textAlign = q;
		this.meta.canvas.ctx.textBaseline = C;
		this.setTextShadow(true);
		var v = q == "right" ? 1 : -1;
		var a = this.getFontPt(w);
		if (((["left", "center"].indexOf(q) > -1) && p) || (q == "right" && !p)) {
			k = k.split("").reverse().join("")
		}
		this.meta.canvas.ctx.translate(j, h);
		n += (Math.PI * !p);
		n += (Math.PI / 2) + (z / 2);
		if (q == "center") {
			for (var u = 0; u < k.length; u++) {
				var g = this.measureText(k[u], w);
				n += ((g + (u == k.length - 1 ? 0 : this.circularLetterSeparationFactor)) / (o - a)) / 2 * -v
			}
		}
		z = n;
		this.meta.canvas.ctx.rotate(n);
		for (var u = 0; u < k.length; u++) {
			var g = this.measureText(k[u], w);
			z += (g / 2) / (o - a) * v;
			this.meta.canvas.ctx.rotate((g / 2) / (o - a) * v);
			this.meta.canvas.ctx.fillText(k[u], 0, (p ? 1 : -1) * (0 - o + a / 2));
			z += (g / 2 + this.circularLetterSeparationFactor) / (o - a) * v;
			this.meta.canvas.ctx.rotate((g / 2 + this.circularLetterSeparationFactor) / (o - a) * v)
		}
		this.meta.canvas.ctx.restore();
		this.setTextShadow(false);
		var A = this.traceArc(j, h, o + (a / 2), n - (Math.PI / 2), z - (Math.PI / 2), true);
		for (var u = 0; u < A.length; u++) {
			D.push(A[u][0], A[u][1])
		}
		A = this.traceArc(j, h, o - (a / 2), n - (Math.PI / 2), z - (Math.PI / 2));
		for (var u = 0; u < A.length; u++) {
			D.push(A[u][0], A[u][1])
		}
		return D
	};
	this.drawArcTextOld = function(A, z, v, d, B, p, n, q, j, u, g) {
		var o = [];
		if (A == null) {
			return
		}
		if (!this.meta.canvas.ctx) {
			if (this.debug) {
				alert("Dude, there is no canvas")
			}
			return
		}
		if (isNaN(z) || isNaN(v)) {
			if (this.debug) {
				alert("Not a valid coordinate (" + z + ", " + v + ") to draw " + A)
			}
			return
		}
		if (!g && !isNaN(A)) {
			A = this.formatNumber(A)
		}
		if (!z) {
			z = 0
		}
		if (!v) {
			v = 0
		}
		if (!n) {
			n = this.font
		}
		if (!q) {
			q = this.foreground
		}
		if (!j) {
			j = this.align
		}
		if (!u) {
			u = this.baseline
		}
		this.meta.canvas.ctx.save();
		this.meta.canvas.ctx.strokeStyle = q;
		this.meta.canvas.ctx.fillStyle = q;
		this.meta.canvas.ctx.font = n;
		this.meta.canvas.ctx.textAlign = j;
		this.meta.canvas.ctx.textBaseline = u;
		this.setTextShadow(true);
		var m = p / (A.length * this.circularLetterSeparationFactor);
		var w = B + (p / 2) + (m / 2) - (m * (A.length / 2));
		this.meta.canvas.ctx.translate(z, v);
		this.meta.canvas.ctx.rotate(w);
		for (var k = 0; k < A.length; k++) {
			this.meta.canvas.ctx.save();
			this.meta.canvas.ctx.rotate((k * m) + (Math.PI / 2));
			this.meta.canvas.ctx.fillText(A[k], 0, -d);
			this.meta.canvas.ctx.restore()
		}
		this.meta.canvas.ctx.restore();
		this.setTextShadow(false);
		return o
	};
	this.drawText = function(o, l, k, z, B, D, C, g, q, p, j) {
		var i = 0;
		var r = function(t) {
			t.shift();
			var m = [];
			var f = (Math.PI / 2) + g;
			var a = f == 0 || f == Math.PI ? -Math.PI / 2 : g - Math.PI / 2;
			var b = ["poly"];
			var s = t.shift() - l;
			var w = t.shift() - k;
			var c = t.shift() - l;
			var h = t.shift() - k;
			m.push((w * Math.sin(a)) - (s * Math.cos(a)));
			m.push((w * Math.cos(a)) + (s * Math.sin(a)));
			m.push((h * Math.sin(a)) - (s * Math.cos(a)));
			m.push((h * Math.cos(a)) + (s * Math.sin(a)));
			m.push((h * Math.sin(a)) - (c * Math.cos(a)));
			m.push((h * Math.cos(a)) + (c * Math.sin(a)));
			m.push((w * Math.sin(a)) - (c * Math.cos(a)));
			m.push((w * Math.cos(a)) + (c * Math.sin(a)));
			while (m.length > 1) {
				b.push(m.shift() + l);
				b.push(m.shift() + k)
			}
			return b
		};
		var E = [];
		if (o == null) {
			return
		}
		if (this.isMultipleLines(o)) {
			return this.drawTextMultiple(o, l, k, z, B, D, C, g, q, p)
		}
		if (!this.meta.canvas.ctx) {
			if (this.debug) {
				alert("Dude, there is no canvas")
			}
			return
		}
		if (isNaN(l) || isNaN(k)) {
			if (this.debug) {
				alert("Not a valid coordinate (" + l + ", " + k + ") to draw " + o)
			}
			return
		}
		if (j) {
			if (l < this.marginLeft + this.offsetX + this.left || l > this.marginLeft + this.offsetX + this.left + this.x) {
				return
			}
			if (k < this.marginTop + this.offsetY + this.top || k > this.marginTop + this.offsetY + this.top + this.y) {
				return
			}
		}
		if (g < (Math.PI / -2) || g > (Math.PI / 2)) {
			if (this.debug) {
				alert("Dude, you can only rotate between -PI/2 and PI/2")
			}
			return
		}
		if (!l) {
			l = 0
		}
		if (!k) {
			k = 0
		}
		if (!z) {
			z = this.font
		}
		if (!B) {
			B = this.foreground
		}
		if (!D) {
			D = this.align
		}
		if (!C) {
			C = this.baseline
		}
		var n = this.measureText(o, z);
		var u = this.getFontPt(z);
		if (q) {
			while (n > q && i < 10) {
				o = o.substring(0, o.length - 1);
				n = this.measureText(o, z);
				i++
			}
		}
		var A, e, v, d;
		if (D == "left") {
			if (g && g % Math.PI > 0) {
				A = l - n;
				v = l
			} else {
				A = l;
				v = A + n
			}
		} else {
			if (D == "right") {
				if (g && g % Math.PI > 0) {
					A = l;
					v = A + n
				} else {
					A = l - n;
					v = l
				}
			} else {
				A = l - (n / 2);
				v = l + (n / 2)
			}
		}
		if (C == "top") {
			e = k;
			d = e + u
		} else {
			if (C == "bottom") {
				e = k - u;
				d = k
			} else {
				e = k - (u / 2);
				d = k + (u / 2)
			}
		}
		E = ["rect", A, e, v, d];
		if (g) {
			E = r(E)
		}
		this.meta.canvas.ctx.save();
		this.meta.canvas.ctx.strokeStyle = B;
		this.meta.canvas.ctx.fillStyle = B;
		this.meta.canvas.ctx.font = z;
		this.meta.canvas.ctx.translate(l, k);
		this.meta.canvas.ctx.textAlign = D;
		this.meta.canvas.ctx.textBaseline = C;
		this.setTextShadow(true);
		if (g) {
			this.meta.canvas.ctx.rotate(g)
		}
		if (p) {
			this.meta.canvas.ctx.strokeText(o, 0, 0)
		} else {
			this.meta.canvas.ctx.fillText(o, 0, 0)
		}
		this.meta.canvas.ctx.restore();
		this.setTextShadow(false);
		return E
	};
	this.isMultipleLines = function(b) {
		var a = b.toString().split(/\n/);
		return a.length - 1
	};
	this.capitalize = function(a) {
		if (a) {
			return a.charAt(0).toUpperCase() + a.slice(1)
		}
	};
	this.measureTextMultiple = function(d, e) {
		var b = d.split(/\n/);
		var a = 0;
		if (!this.meta.canvas.ctx) {
			return 0
		}
		if (!e) {
			e = this.font
		}
		this.meta.canvas.ctx.font = e;
		for (var c = 0; c < b.length; c++) {
			a = Math.max(a, this.meta.canvas.ctx.measureText(b[c]).width)
		}
		return a
	};
	this.measureText = function(a, b) {
		if (!a || !this.meta.canvas.ctx) {
			return 0
		}
		a = a.toString();
		if (!b) {
			b = this.font
		}
		if (!CanvasXpress.cacheText[b]) {
			CanvasXpress.cacheText[b] = {}
		}
		if (!CanvasXpress.cacheText[b][a]) {
			this.meta.canvas.ctx.font = b;
			if (this.isMultipleLines(a)) {
				CanvasXpress.cacheText[b][a] = this.measureTextMultiple(a, b)
			} else {
				CanvasXpress.cacheText[b][a] = this.meta.canvas.ctx.measureText(a).width
			}
		}
		return CanvasXpress.cacheText[b][a]
	};
	this.scaleTextToFont = function(b, d, a) {
		var c = this.fontStyle + " " + d + "px " + this.fontName;
		if (b) {
			while (this.measureText(b, c) > a && d >= this.minTextSize) {
				d -= 2;
				c = this.fontStyle + " " + d + "px " + this.fontName
			}
		}
		return c
	};
	this.getFontPt = function(a) {
		return Math.max(1, parseInt(a.match(/[\-\d]+/)[0]))
	};
	this.scaleTextToSize = function(a) {
		var d = this.scaleTextConstantMult;
		if (!a) {
			a = 1
		}
		return Math.ceil(1 / Math.sqrt(a) * d)
	};
	this.formatNumber = function(b, a) {
		if (a && Math.abs(b) < 99999) {
			return sprintf("%." + a + "f", Number(b)).toString()
		} else {
			if (Math.abs(b) < 0.0001 || Math.abs(b) > 99999 || b.toString().length >= 8) {
				return Number(b).toExponential(2).toString().replace("e+0", "").replace(".00", "")
			} else {
				return b.toString()
			}
		}
	};
	this.bestFormatNumber = function(b, a) {
		if (typeof b === "number" && b % 1 == 0) {
			return b
		} else {
			if (a != null && a < 1) {
				return sprintf("%.0f", Number(b))
			} else {
				if (Math.abs(b) < 0.001) {
					return sprintf("%.2e", Number(b))
				} else {
					return sprintf("%.3f", Number(b))
				}
			}
		}
	};
	this.getMaxtTextBySampling = function(b, h) {
		var c = {};
		var f = [];
		var g = [];
		for (var e = 0; e < b.length; e++) {
			var d = b[e] != null ? b[e].toString() : "";
			if (!c.hasOwnProperty(d)) {
				c[d] = true;
				f.push([d, d.length])
			}
		}
		f.sort(function(j, i) {
			return j[1] < i[1] ? -1 : j[1] > i[1] ? 1 : 0
		});
		if (!h) {
			h = 10
		}
		if (f.length < h) {
			h = f.length
		}
		for (var e = 0; e < h; e++) {
			g.push(f[e][0])
		}
		return this.getMaxText(g)
	};
	this.getMaxText = function(d) {
		var f = "";
		var b = 0;
		for (var e = 0; e < d.length; e++) {
			var g = this.measureText(d[e].toString(), this.font);
			if (g > b) {
				f = d[e].toString();
				b = g
			}
		}
		return f
	};
	this.shortenText = function(c, b, a) {
		if (!c) {
			return ""
		}
		c = c.toString();
		if (a && c.length > b) {
			return c.substring(0, Math.max(parseInt(a / b) - 2, 1)) + ".."
		} else {
			if (c.length <= b) {
				return c
			} else {
				return c.substring(0, b - 3) + "..."
			}
		}
	};
	this.convertToNumber = function(a) {
		if (!isNaN(a)) {
			return parseFloat(a)
		} else {
			return a
		}
	};
	this.stringToHex = function(c) {
		var b = "";
		for (var a = 0; a < c.length; a++) {
			b += "" + c.charCodeAt(a).toString(16)
		}
		return b
	};
	this.hexToString = function(b) {
		var c = "";
		for (var a = 0; a < b.length; a += 2) {
			c += String.fromCharCode(parseInt(b.substr(a, 2), 16))
		}
		return c
	}
};
CanvasXpress.prototype.initTime = function() {
	Date.prototype.getWeek = function() {
		var a = new Date(this.getFullYear(), 0, 1);
		return Math.ceil((((this - a) / 86400000) + a.getDay() + 1) / 7)
	};
	Date.prototype.getDayYear = function() {
		var a = new Date(this.getFullYear(), 0, 1);
		return Math.ceil((this - a) / 86400000)
	};
	this.getMillisecond = function(a) {
		return a.getMilliseconds()
	};
	this.getSecond = function(a) {
		return a.getSeconds()
	};
	this.getMinuteSecond = function(a) {
		return a.getMinutes() + ":" + a.getSeconds()
	};
	this.getMinute = function(a) {
		return a.getMinutes()
	};
	this.getHourMinute = function(a) {
		return a.getHours() + ":" + a.getMinutes()
	};
	this.getHour = function(a) {
		return a.getHours()
	};
	this.getYearWeek = function(a) {
		return a.getFullYear() + "-" + a.getWeek()
	};
	this.getYearMonth = function(a) {
		return a.getFullYear() + "-" + a.getMonth()
	};
	this.getYear = function(a) {
		return a.getFullYear()
	};
	this.times = {
		second: 1000,
		minute: 60000,
		hour: 3600000,
		day: 86400000,
		week: 604800000,
		month: 2592000000,
		year: 31556952000
	};
	this.parseDate = function(j) {
		var f = 0;
		var c = 0;
		var e = 0;
		var k = parseInt(j.toString().substring(0, 4));
		var a = parseInt(j.toString().substring(4, 6).replace(/^0/, ""));
		var g = parseInt(j.toString().substring(6, 8).replace(/^0/, ""));
		var b = j.toString().match(/\:/) ? j.toString().substring(10).split(":") : false;
		if (b) {
			f = b[0] ? parseInt(b[0].replace(/^0/, "")) : 0;
			c = b[1] ? parseInt(b[1].replace(/^0/, "")) : 0;
			e = b[2] ? parseInt(b[2].replace(/^0/, "")) : 0
		}
		return new Date(k, a - 1, g, f, c, e)
	};
	this.setTimeAxis = function() {
		var h = this.validateTimeAxis();
		if (h) {
			var g = Date.parse(h[h.length - 1]) - Date.parse(h[0]);
			var d;
			var b = {};
			var c = [];
			this.timeValues = [];
			this.timeValueIndices = [];
			if (g > this.times.year * 2) {
				d = "getYear"
			} else {
				if (g > this.times.month * 2) {
					d = "getYearMonth"
				} else {
					if (g > this.times.week * 2) {
						d = "getYearWeek"
					} else {
						if (g < this.times.second) {
							d = "getMillisecond"
						} else {
							if (g < this.times.minute) {
								d = "getSecond"
							} else {
								if (g < this.times.hour / 4) {
									d = "getMinuteSecond"
								} else {
									if (g < this.times.hour) {
										d = "getMinute"
									} else {
										if (g < this.times.day / 4) {
											d = "getHourMinute"
										} else {
											if (g < this.times.day) {
												d = "getHour"
											} else {
												d = false
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (d) {
				if (this.timeTicksFirst) {
					for (var a = 0; a < h.length; a++) {
						var e = this[d](h[a]);
						if (!b.hasOwnProperty(e)) {
							c.push(h[a]);
							this.timeValueIndices.push(a);
							b[e] = true
						}
					}
				} else {
					for (var a = h.length - 1; a >= 0; a--) {
						var e = this[d](h[a]);
						if (!b.hasOwnProperty(e)) {
							c.unshift(h[a]);
							this.timeValueIndices.unshift(a);
							b[e] = true
						}
					}
				}
			} else {
				for (var a = 0; a < h.length; a++) {
					this.timeValues.push(dateFormat(h[a], this.timeFormat));
					this.timeValueIndices.push(a)
				}
			}
			var g = Date.parse(c[c.length - 1]) - Date.parse(c[c.length - 2]);
			if (d == "getYear" && g < this.times.month * 3) {
				this.timeValues.pop();
				this.timeValueIndices.pop()
			} else {
				if (d == "getYearMonth" && g < this.times.week * 4) {
					this.timeValues.pop();
					this.timeValueIndices.pop()
				} else {
					if (d == "getYearWeek" && g < this.times.day * 7) {
						this.timeValues.pop();
						this.timeValueIndices.pop()
					}
				}
			}
			for (var a = 0; a < c.length; a++) {
				this.timeValues.push(dateFormat(c[a], this.timeFormat))
			}
		}
	};
	this.createRandomTimes = function(b) {
		var e;
		var g = new Date();
		var a = g.getTime();
		var f = [new Date(a)];
		var h = this.isGroupedData ? this.data.w : this.data.y;
		if (!b || !this.times[b]) {
			b = "day"
		}
		for (var c = 0; c < h.smps.length; c++) {
			e = Date.parse(h.smps[c]);
			if (!isNaN(e)) {
				a = e
			} else {
				a -= this.times[b]
			}
			f.unshift(new Date(a))
		}
		return f
	};
	this.validateTimeAxis = function() {
		var f = this.isGroupedData ? this.data.w : this.data.y;
		var a = false;
		var e = [];
		for (var b = 0; b < this.smpIndices.length; b++) {
			var c = this.smpIndices.length != f.smps.length ? Date.parse(f.smps[this.smpIndices[b]]) : Date.parse(f.smps[b]);
			if (isNaN(c)) {
				if (this.isExample) {
					e = this.createRandomTimes();
					return e
				} else {
					a = true;
					break
				}
			} else {
				e.push(new Date(c))
			}
		}
		return a ? false : e
	}
};
CanvasXpress.prototype.initColor = function() {
	this.validateColor = function(f, d) {
		if (f) {
			f = f.toString();
			var a = (/rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/).exec(f);
			var b = (/rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),([0-9\.]+)\)/).exec(f);
			var e = (/^#?([0-9abcdef]{6})/i).exec(f);
			if (this.colorNames.hasOwnProperty(f)) {
				f = this.hexToRgb(this.colorNames[f])
			} else {
				if (a != null) {
					f = a[0]
				} else {
					if (b != null) {
						f = b[0]
					} else {
						if (e != null) {
							f = this.hexToRgb(e[0])
						} else {
							f = false
						}
					}
				}
			}
		}
		return f && d != null ? this.addColorTransparency(f, d) : f
	};
	this.darkenLightenColor = function(j, e) {
		j = this.rgbToHex(j).substring(1, 7);
		var i = parseInt(j, 16);
		var h = (i >> 16) + e;
		h = h > 255 ? 255 : h < 0 ? 0 : h;
		var f = ((i >> 8) & 255) + e;
		f = f > 255 ? 255 : f < 0 ? 0 : f;
		var d = (i & 255) + e;
		d = d > 255 ? 255 : d < 0 ? 0 : d;
		j = d | (f << 8) | (h << 16);
		return this.hexToRgb(j.toString(16))
	};
	this.rgbToHex = function(b) {
		var a = function(c) {
			c = parseInt(c, 10);
			if (isNaN(c)) {
				return "00"
			}
			c = Math.max(0, Math.min(c, 255));
			return "0123456789ABCDEF".charAt((c - c % 16) / 16) + "0123456789ABCDEF".charAt(c % 16)
		};
		if (b && b.substr(0, 1) === "#") {
			return b
		}
		if (b && b.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/)) {
			return "#" + a(RegExp.$1) + a(RegExp.$2) + a(RegExp.$3)
		} else {
			return b
		}
	};
	this.complementaryColor = function(j, e) {
		var d = this.validateColor(j.toString());
		if (d.match(/^rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(?:,([0-9\.]+))?/i)) {
			var i = parseInt(255 - RegExp.$1);
			var f = parseInt(255 - RegExp.$2);
			var a = parseInt(255 - RegExp.$3);
			if (i == f && f == a) {
				if (i >= 127) {
					d = "rgb(255,255,255)"
				} else {
					d = "rgb(0,0,0)"
				}
			} else {
				d = "rgb(" + i + "," + f + "," + a + ")"
			}
			return e ? this.rgbToHex(d) : d
		} else {
			return j
		}
	};
	this.hexToRgb = function(c) {
		var b = function() {
			return parseInt(c.substring(0, 2), 16)
		};
		var a = function() {
			return parseInt(c.substring(2, 4), 16)
		};
		var d = function() {
			return parseInt(c.substring(4, 6), 16)
		};
		c = c.charAt(0) == "#" ? c.substring(1, 7) : c;
		return "rgb(" + b() + "," + a() + "," + d() + ")"
	};
	this.addColorTransparency = function(d, b, a) {
		if (!a) {
			d = this.validateColor(d)
		}
		if (d && d.match(/^rgba?\((\d{1,3},\d{1,3},\d{1,3})(?:,([0-9\.]+))?/i)) {
			if (RegExp.$2) {
				return "rgba(" + RegExp.$1 + "," + b + ")"
			} else {
				return "rgba(" + RegExp.$1 + "," + b + ")"
			}
		} else {
			return false
		}
	};
	this.isColorTransparency = function(a) {
		a = this.validateColor(a);
		if (a && a.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),(0.\d+)\)/i)) {
			return RegExp.$4
		}
		return null
	};
	this.disableGradientTransparencyShadow = function() {
		if (!this.gradientTemp) {
			this.gradientTemp = this.gradient
		}
		if (this.transparencyTemp == null) {
			this.transparencyTemp = this.transparency
		}
		if (!this.showShadowTemp) {
			this.showShadowTemp = this.showShadow
		}
		this.gradient = false;
		this.transparency = null;
		this.showShadow = false
	};
	this.enableGradientTransparencyShadow = function() {
		this.gradient = this.gradientTemp;
		this.transparency = this.transparencyTemp;
		this.showShadow = this.showShadowTemp
	};
	this.resetGradientTransparencyShadow = function() {
		delete(this.gradientTemp);
		delete(this.transparencyTemp);
		delete(this.showShadowTemp)
	};
	this.getGradientColor = function(h) {
		if (h.match(/^rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(?:,([0-9\.]+))?/i)) {
			var f = Math.floor(parseInt(RegExp.$1) / this.gradientRatio);
			var e = Math.floor(parseInt(RegExp.$2) / this.gradientRatio);
			var a = Math.floor(parseInt(RegExp.$3) / this.gradientRatio);
			var d = RegExp.$4 ? parseFloat(RegExp.$4) : false;
			if (d) {
				return "rgba(" + f + "," + e + "," + a + "," + d + ")"
			} else {
				return "rgb(" + f + "," + e + "," + a + ")"
			}
		} else {
			return false
		}
	};
	this.getGradient = function(e, d, c, b, a) {
		if (this.gradientType == "radial") {
			return this.getRadialGradient(e, d, c, b, false, false, true)
		} else {
			return this.getLinearGradient(e, d, c, b, a, false, true)
		}
	};
	this.getLinearGradient = function(c, i, a, f, e, b, d) {
		if (!d) {
			this.meta.canvas.ctx.save()
		}
		var h = this.meta.canvas.ctx.createLinearGradient(c, i, a, f);
		if (!e) {
			e = this.foreground
		}
		if (!b) {
			b = this.getGradientColor(e);
			h.addColorStop(0, b);
			h.addColorStop(0.6, e);
			h.addColorStop(1, e)
		} else {
			h.addColorStop(0, e);
			h.addColorStop(1, b)
		}
		return h
	};
	this.getRadialGradient = function(j, h, a, e, d, c, i) {
		if (!i) {
			this.meta.canvas.ctx.save()
		}
		var b = a / 5.5;
		var f = this.meta.canvas.ctx.createRadialGradient(j - b, h - b, 1, j, h, a);
		if (!e) {
			e = this.foreground
		}
		if (!d) {
			if (this.transparency != null) {
				d = "rgba(0,0,0," + this.transparency + ")"
			} else {
				d = "rgb(0,0,0)"
			}
		}
		if (!c) {
			c = "rgba(0,0,0,0)"
		}
		f.addColorStop(0, e);
		f.addColorStop(1, d);
		f.addColorStop(1, c);
		return f
	};
	this.colorRGBfromString = function(b) {
		var a = b.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i);
		if (a) {
			if (a[1].length === 6) {
				this.colorFromRgb(parseInt(a[1].substr(0, 2), 16) / 255, parseInt(a[1].substr(2, 2), 16) / 255, parseInt(a[1].substr(4, 2), 16) / 255)
			} else {
				this.colorFromRgb(parseInt(a[1].charAt(0) + a[1].charAt(0), 16) / 255, parseInt(a[1].charAt(1) + a[1].charAt(1), 16) / 255, parseInt(a[1].charAt(2) + a[1].charAt(2), 16) / 255)
			}
		}
	};
	this.colorFromRgb = function(e, d, a) {
		if (this.colorRGB) {
			if (e != null) {
				this.colorRGB[0] = Math.min(Math.max(0, e), 1)
			}
			if (d != null) {
				this.colorRGB[1] = Math.min(Math.max(0, d), 1)
			}
			if (a != null) {
				this.colorRGB[2] = Math.min(Math.max(0, a), 1)
			}
			var c = this.rgbFromHsv(this.colorRGB[0], this.colorRGB[1], this.colorRGB[2]);
			if (c[0] != null) {
				this.colorHSV[0] = c[0]
			}
			if (c[2] != 0) {
				this.colorHSV[1] = c[1]
			}
			this.colorHSV[2] = c[2]
		}
	};
	this.rgbFromHsv = function(i, f, c) {
		var j = Math.min(Math.min(i, f), c);
		var d = Math.max(Math.max(i, f), c);
		var a = d - j;
		if (a == 0) {
			return [null, 0, d]
		} else {
			var e = i == j ? 3 + (c - f) / a : (f == j ? 5 + (i - c) / a : 1 + (f - i) / a);
			return [e == 6 ? 0 : e, a / d, d]
		}
	};
	this.colorFromHsv = function(c, b, a) {
		if (c != null) {
			this.colorHSV[0] = Math.min(Math.max(0, c), 6)
		}
		if (b != null) {
			this.colorHSV[1] = Math.min(Math.max(0, b), 1)
		}
		if (a != null) {
			this.colorHSV[2] = Math.min(Math.max(0, a), 1)
		}
		this.colorRGB = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], this.colorHSV[2])
	};
	this.hsvFromRgb = function(e, d, b) {
		if (e == null) {
			return [b, b, b]
		}
		var c = Math.floor(e);
		var g = c % 2 ? e - c : 1 - (e - c);
		var a = b * (1 - d);
		var j = b * (1 - d * g);
		switch (c) {
			case 0:
				return [b, j, a];
			case 1:
				return [j, b, a];
			case 2:
				return [a, b, j];
			case 3:
				return [a, j, b];
			case 4:
				return [j, a, b];
			case 5:
				return [b, a, j];
			case 6:
				return [b, a, j]
		}
	};
	this.colorRGBToString = function() {
		if (this.colorRGB) {
			return (256 | Math.round(255 * this.colorRGB[0])).toString(16).substr(1) + (256 | Math.round(255 * this.colorRGB[1])).toString(16).substr(1) + (256 | Math.round(255 * this.colorRGB[2])).toString(16).substr(1)
		}
	};
	this.colorNames = {
		aliceblue: "F0F8FF",
		antiquewhite1: "FFEFDB",
		antiquewhite2: "EEDFCC",
		antiquewhite3: "CDC0B0",
		antiquewhite4: "8B8378",
		antiquewhite: "FAEBD7",
		aqua: "00FFFF",
		aquamarine1: "7FFFD4",
		aquamarine2: "76EEC6",
		aquamarine4: "458B74",
		aquamarine: "7FFFD4",
		azure1: "F0FFFF",
		azure2: "E0EEEE",
		azure3: "C1CDCD",
		azure4: "838B8B",
		azure: "F0FFFF",
		beige: "F5F5DC",
		bisque1: "FFE4C4",
		bisque2: "EED5B7",
		bisque3: "CDB79E",
		bisque4: "8B7D6B",
		bisque: "FFE4C4",
		black: "000000",
		blanchedalmond: "FFEBCD",
		blue: "0000FF",
		blue1: "0000FF",
		blue2: "0000EE",
		blue3: "1874CD",
		blue4: "00008B",
		blueviolet: "8A2BE2",
		brown1: "FF4040",
		brown2: "EE3B3B",
		brown3: "CD3333",
		brown4: "8B2323",
		brown: "A52A2A",
		burlywood1: "FFD39B",
		burlywood2: "EEC591",
		burlywood3: "CDAA7D",
		burlywood4: "8B7355",
		burlywood: "DEB887",
		cadetblue1: "98F5FF",
		cadetblue2: "8EE5EE",
		cadetblue3: "7AC5CD",
		cadetblue4: "53868B",
		cadetblue: "5F9EA0",
		chartreuse1: "7FFF00",
		chartreuse2: "76EE00",
		chartreuse3: "66CD00",
		chartreuse4: "458B00",
		chartreuse: "7FFF00",
		chocolate1: "FF7F24",
		chocolate2: "EE7621",
		chocolate3: "CD661D",
		chocolate: "D2691E",
		coral1: "FF7256",
		coral2: "EE6A50",
		coral3: "CD5B45",
		coral4: "8B3E2F",
		coral: "FF7F50",
		cornflowerblue: "6495ED",
		cornsilk1: "FFF8DC",
		cornsilk2: "EEE8CD",
		cornsilk3: "CDC8B1",
		cornsilk4: "8B8878",
		cornsilk: "FFF8DC",
		crimson: "DC143C",
		cyan: "00FFFF",
		cyan1: "00FFFF",
		cyan2: "00EEEE",
		cyan3: "00CDCD",
		cyan4: "008B8B",
		darkblue: "00008B",
		darkcyan: "008B8B",
		darkgoldenrod1: "FFB90F",
		darkgoldenrod2: "EEAD0E",
		darkgoldenrod3: "CD950C",
		darkgoldenrod4: "8B6508",
		darkgoldenrod4: "8B6508",
		darkgoldenrod: "B8860B",
		darkgray: "A9A9A9",
		darkgreen: "006400",
		darkgrey: "A9A9A9",
		darkkhaki: "BDB76B",
		darkmagenta: "8B008B",
		darkolivegreen1: "CAFF70",
		darkolivegreen2: "BCEE68",
		darkolivegreen3: "A2CD5A",
		darkolivegreen4: "6E8B3D",
		darkolivegreen: "556B2F",
		darkorange1: "FF7F00",
		darkorange2: "EE7600",
		darkorange3: "CD6600",
		darkorange4: "8B4500",
		darkorange: "FF8C00",
		darkorchid1: "BF3EFF",
		darkorchid2: "B23AEE",
		darkorchid3: "9A32CD",
		darkorchid4: "68228B",
		darkorchid: "9932CC",
		darkred: "8B0000",
		darksalmon: "E9967A",
		darkseagreen1: "C1FFC1",
		darkseagreen2: "B4EEB4",
		darkseagreen3: "9BCD9B",
		darkseagreen4: "698B69",
		darkseagreen: "8FBC8F",
		darkslateblue: "483D8B",
		darkslategray1: "97FFFF",
		darkslategray2: "8DEEEE",
		darkslategray: "2F4F4F",
		darkslategray3: "79CDCD",
		darkslategray4: "528B8B",
		darkslategrey: "2F4F4F",
		darkturquoise: "00CED1",
		darkviolet: "9400D3",
		deeppink1: "FF1493",
		deeppink2: "EE1289",
		deeppink3: "CD1076",
		deeppink4: "8B0A50",
		deeppink: "FF1493",
		deepskyblue: "00BFFF",
		deepskyblue1: "00BFFF",
		deepskyblue2: "00B2EE",
		deepskyblue3: "009ACD",
		deepskyblue4: "00688B",
		dimgray: "696969",
		dimgrey: "696969",
		dodgerblue1: "1E90FF",
		dodgerblue: "1E90FF",
		dodgerblue2: "1C86EE",
		dodgerblue3: "1874CD",
		dodgerblue4: "104E8B",
		firebrick1: "FF3030",
		firebrick2: "EE2C2C",
		firebrick3: "CD2626",
		firebrick4: "8B1A1A",
		firebrick: "B22222",
		floralwhite: "FFFAF0",
		forestgreen: "228B22",
		fuchsia: "FF00FF",
		gainsboro: "DCDCDC",
		ghostwhite: "F8F8FF",
		gold1: "FFD700",
		gold2: "EEC900",
		gold3: "CDAD00",
		gold4: "8B7500",
		goldenrod1: "FFC125",
		goldenrod2: "EEB422",
		goldenrod3: "CD9B1D",
		goldenrod4: "8B6914",
		goldenrod: "DAA520",
		goldenrod: "DAA520",
		gold: "FFD700",
		gray10: "1A1A1A",
		gray1: "030303",
		gray11: "1C1C1C",
		gray12: "1F1F1F",
		gray13: "212121",
		gray14: "242424",
		gray15: "262626",
		gray16: "292929",
		gray17: "2B2B2B",
		gray18: "2E2E2E",
		gray19: "303030",
		gray20: "333333",
		gray2: "050505",
		gray21: "363636",
		gray22: "383838",
		gray23: "3B3B3B",
		gray24: "3D3D3D",
		gray25: "404040",
		gray26: "424242",
		gray27: "454545",
		gray28: "474747",
		gray29: "4A4A4A",
		gray30: "4D4D4D",
		gray3: "080808",
		gray31: "4F4F4F",
		gray32: "525252",
		gray33: "545454",
		gray34: "575757",
		gray35: "595959",
		gray36: "5C5C5C",
		gray37: "5E5E5E",
		gray38: "616161",
		gray39: "636363",
		gray40: "666666",
		gray4: "0A0A0A",
		gray41: "696969",
		gray42: "6B6B6B",
		gray43: "6E6E6E",
		gray44: "707070",
		gray45: "737373",
		gray46: "757575",
		gray47: "787878",
		gray48: "7A7A7A",
		gray49: "7D7D7D",
		gray50: "7F7F7F",
		gray5: "0D0D0D",
		gray51: "828282",
		gray52: "858585",
		gray53: "878787",
		gray54: "8A8A8A",
		gray55: "8C8C8C",
		gray56: "8F8F8F",
		gray57: "919191",
		gray58: "949494",
		gray59: "969696",
		gray60: "999999",
		gray6: "0F0F0F",
		gray61: "9C9C9C",
		gray62: "9E9E9E",
		gray63: "A1A1A1",
		gray64: "A3A3A3",
		gray65: "A6A6A6",
		gray66: "A8A8A8",
		gray67: "ABABAB",
		gray68: "ADADAD",
		gray69: "B0B0B0",
		gray70: "B3B3B3",
		gray7: "121212",
		gray71: "B5B5B5",
		gray72: "B8B8B8",
		gray73: "BABABA",
		gray74: "BDBDBD",
		gray75: "BFBFBF",
		gray76: "C2C2C2",
		gray77: "C4C4C4",
		gray78: "C7C7C7",
		gray79: "C9C9C9",
		gray: "808080",
		gray80: "CCCCCC",
		gray8: "141414",
		gray81: "CFCFCF",
		gray82: "D1D1D1",
		gray83: "D4D4D4",
		gray84: "D6D6D6",
		gray85: "D9D9D9",
		gray86: "DBDBDB",
		gray87: "DEDEDE",
		gray88: "E0E0E0",
		gray89: "E3E3E3",
		gray90: "E5E5E5",
		gray9: "171717",
		gray91: "E8E8E8",
		gray92: "EBEBEB",
		gray93: "EDEDED",
		gray94: "F0F0F0",
		gray95: "F2F2F2",
		gray97: "F7F7F7",
		gray98: "FAFAFA",
		gray99: "FCFCFC",
		gray: "BEBEBE",
		green: "008000",
		green1: "00FF00",
		green2: "00EE00",
		green3: "00CD00",
		green4: "008B00",
		greenyellow: "ADFF2F",
		grey: "808080",
		honeydew1: "F0FFF0",
		honeydew2: "E0EEE0",
		honeydew3: "C1CDC1",
		honeydew4: "838B83",
		honeydew: "F0FFF0",
		hotpink1: "FF6EB4",
		hotpink2: "EE6AA7",
		hotpink3: "CD6090",
		hotpink4: "8B3A62",
		hotpink: "FF69B4",
		indianred1: "FF6A6A",
		indianred2: "EE6363",
		indianred3: "CD5555",
		indianred4: "8B3A3A",
		indianred: "CD5C5C",
		indigo: "4B0082",
		ivory1: "FFFFF0",
		ivory2: "EEEEE0",
		ivory3: "CDCDC1",
		ivory4: "8B8B83",
		ivory: "FFFFF0",
		khaki1: "FFF68F",
		khaki2: "EEE685",
		khaki3: "CDC673",
		khaki4: "8B864E",
		khaki: "F0E68C",
		lavenderblush1: "FFF0F5",
		lavenderblush2: "EEE0E5",
		lavenderblush3: "CDC1C5",
		lavenderblush4: "8B8386",
		lavenderblush: "FFF0F5",
		lavender: "E6E6FA",
		lawngreen: "7CFC00",
		lemonchiffon1: "FFFACD",
		lemonchiffon2: "EEE9BF",
		lemonchiffon3: "CDC9A5",
		lemonchiffon4: "8B8970",
		lemonchiffon: "FFFACD",
		lightblue1: "BFEFFF",
		lightblue2: "B2DFEE",
		lightblue3: "9AC0CD",
		lightblue4: "68838B",
		lightblue: "ADD8E6",
		lightcoral: "F08080",
		lightcyan1: "E0FFFF",
		lightcyan2: "D1EEEE",
		lightcyan3: "B4CDCD",
		lightcyan4: "7A8B8B",
		lightcyan: "E0FFFF",
		light: "EEDD82",
		lightgoldenrod1: "FFEC8B",
		lightgoldenrod2: "EEDC82",
		lightgoldenrod3: "CDBE70",
		lightgoldenrod4: "8B814C",
		lightgoldenrodyellow: "FAFAD2",
		lightgray: "D3D3D3",
		lightgreen: "90EE90",
		lightgrey: "D3D3D3",
		lightpink1: "FFAEB9",
		lightpink2: "EEA2AD",
		lightpink3: "CD8C95",
		lightpink4: "8B5F65",
		lightpink: "FFB6C1",
		lightsalmon1: "FFA07A",
		lightsalmon2: "EE9572",
		lightsalmon3: "CD8162",
		lightsalmon4: "8B5742",
		lightsalmon: "FFA07A",
		lightseagreen: "20B2AA",
		lightskyblue1: "B0E2FF",
		lightskyblue2: "A4D3EE",
		lightskyblue3: "8DB6CD",
		lightskyblue4: "607B8B",
		lightskyblue: "87CEFA",
		lightslateblue: "8470FF",
		lightslategray: "778899",
		lightslategrey: "778899",
		lightsteelblue1: "CAE1FF",
		lightsteelblue2: "BCD2EE",
		lightsteelblue3: "A2B5CD",
		lightsteelblue4: "6E7B8B",
		lightsteelblue: "B0C4DE",
		lightyellow1: "FFFFE0",
		lightyellow2: "EEEED1",
		lightyellow3: "CDCDB4",
		lightyellow4: "8B8B7A",
		lightyellow: "FFFFE0",
		lime: "00FF00",
		limegreen: "32CD32",
		linen: "FAF0E6",
		magenta2: "EE00EE",
		magenta3: "CD00CD",
		magenta4: "8B008B",
		magenta: "FF00FF",
		maroon1: "FF34B3",
		maroon2: "EE30A7",
		maroon3: "CD2990",
		maroon4: "8B1C62",
		maroon: "800000",
		maroon: "B03060",
		medium: "66CDAA",
		mediumaquamarine: "66CDAA",
		mediumblue: "0000CD",
		mediumorchid1: "E066FF",
		mediumorchid2: "D15FEE",
		mediumorchid3: "B452CD",
		mediumorchid4: "7A378B",
		mediumorchid: "BA55D3",
		mediumpurple1: "AB82FF",
		mediumpurple2: "9F79EE",
		mediumpurple3: "8968CD",
		mediumpurple4: "5D478B",
		mediumpurple: "9370DB",
		mediumseagreen: "3CB371",
		mediumslateblue: "7B68EE",
		mediumspringgreen: "00FA9A",
		mediumturquoise: "48D1CC",
		mediumvioletred: "C71585",
		midnightblue: "191970",
		mintcream: "F5FFFA",
		mistyrose1: "FFE4E1",
		mistyrose2: "EED5D2",
		mistyrose3: "CDB7B5",
		mistyrose4: "8B7D7B",
		mistyrose: "FFE4E1",
		moccasin: "FFE4B5",
		navajowhite1: "FFDEAD",
		navajowhite2: "EECFA1",
		navajowhite3: "CDB38B",
		navajowhite4: "8B795E",
		navajowhite: "FFDEAD",
		navy: "000080",
		navyblue: "000080",
		oldlace: "FDF5E6",
		olive: "808000",
		olivedrab1: "C0FF3E",
		olivedrab2: "B3EE3A",
		olivedrab4: "698B22",
		olivedrab: "6B8E23",
		orange1: "FFA500",
		orange2: "EE9A00",
		orange3: "CD8500",
		orange4: "8B5A00",
		orange: "FFA500",
		orangered1: "FF4500",
		orangered2: "EE4000",
		orangered3: "CD3700",
		orangered4: "8B2500",
		orangered: "FF4500",
		orchid1: "FF83FA",
		orchid2: "EE7AE9",
		orchid3: "CD69C9",
		orchid4: "8B4789",
		orchid: "DA70D6",
		pale: "DB7093",
		palegoldenrod: "EEE8AA",
		palegreen1: "9AFF9A",
		palegreen2: "90EE90",
		palegreen3: "7CCD7C",
		palegreen4: "548B54",
		palegreen: "98FB98",
		paleturquoise1: "BBFFFF",
		paleturquoise2: "AEEEEE",
		paleturquoise3: "96CDCD",
		paleturquoise4: "668B8B",
		paleturquoise: "AFEEEE",
		palevioletred1: "FF82AB",
		palevioletred2: "EE799F",
		palevioletred3: "CD6889",
		palevioletred4: "8B475D",
		palevioletred: "DB7093",
		papayawhip: "FFEFD5",
		peachpuff1: "FFDAB9",
		peachpuff2: "EECBAD",
		peachpuff3: "CDAF95",
		peachpuff4: "8B7765",
		peachpuff: "FFDAB9",
		peru: "CD853F",
		pink1: "FFB5C5",
		pink2: "EEA9B8",
		pink3: "CD919E",
		pink4: "8B636C",
		pink: "FFC0CB",
		plum1: "FFBBFF",
		plum2: "EEAEEE",
		plum3: "CD96CD",
		plum4: "8B668B",
		plum: "DDA0DD",
		powderblue: "B0E0E6",
		purple1: "9B30FF",
		purple2: "912CEE",
		purple3: "7D26CD",
		purple4: "551A8B",
		purple: "800080",
		purple: "A020F0",
		rebeccapurple: "663399",
		red1: "FF0000",
		red2: "EE0000",
		red3: "CD0000",
		red4: "8B0000",
		red: "FF0000",
		rosybrown1: "FFC1C1",
		rosybrown2: "EEB4B4",
		rosybrown3: "CD9B9B",
		rosybrown4: "8B6969",
		rosybrown: "BC8F8F",
		royalblue1: "4876FF",
		royalblue2: "436EEE",
		royalblue3: "3A5FCD",
		royalblue: "4169E1",
		royalblue4: "27408B",
		saddlebrown: "8B4513",
		salmon1: "FF8C69",
		salmon2: "EE8262",
		salmon3: "CD7054",
		salmon4: "8B4C39",
		salmon: "FA8072",
		sandybrown: "F4A460",
		seagreen1: "54FF9F",
		seagreen2: "4EEE94",
		seagreen: "2E8B57",
		seagreen3: "43CD80",
		seagreen4: "2E8B57",
		seashell1: "FFF5EE",
		seashell2: "EEE5DE",
		seashell3: "CDC5BF",
		seashell4: "8B8682",
		seashell: "FFF5EE",
		sienna1: "FF8247",
		sienna2: "EE7942",
		sienna3: "CD6839",
		sienna4: "8B4726",
		sienna: "A0522D",
		silver: "C0C0C0",
		skyblue1: "87CEFF",
		skyblue2: "7EC0EE",
		skyblue3: "6CA6CD",
		skyblue4: "4A708B",
		skyblue: "87CEEB",
		slateblue1: "836FFF",
		slateblue2: "7A67EE",
		slateblue3: "6959CD",
		slateblue4: "473C8B",
		slateblue: "6A5ACD",
		slategray1: "C6E2FF",
		slategray2: "B9D3EE",
		slategray3: "9FB6CD",
		slategray4: "6C7B8B",
		slategray: "708090",
		slategrey: "708090",
		snow1: "FFFAFA",
		snow2: "EEE9E9",
		snow3: "CDC9C9",
		snow4: "8B8989",
		snow: "FFFAFA",
		springgreen: "00FF7F",
		springgreen1: "00FF7F",
		springgreen2: "00EE76",
		springgreen3: "00CD66",
		springgreen4: "008B45",
		steelblue1: "63B8FF",
		steelblue2: "5CACEE",
		steelblue3: "4F94CD",
		steelblue4: "36648B",
		steelblue: "4682B4",
		tan1: "FFA54F",
		tan2: "EE9A49",
		tan3: "CD853F",
		tan4: "8B5A2B",
		tan: "D2B48C",
		teal: "008080",
		thistle1: "FFE1FF",
		thistle2: "EED2EE",
		thistle3: "CDB5CD",
		thistle4: "8B7B8B",
		thistle: "D8BFD8",
		tomato1: "FF6347",
		tomato2: "EE5C42",
		tomato3: "CD4F39",
		tomato4: "8B3626",
		tomato: "FF6347",
		turquoise1: "00F5FF",
		turquoise2: "00E5EE",
		turquoise3: "00C5CD",
		turquoise4: "00868B",
		turquoise: "40E0D0",
		violet: "EE82EE",
		violetred1: "FF3E96",
		violetred2: "EE3A8C",
		violetred3: "CD3278",
		violetred4: "8B2252",
		violetred: "D02090",
		wheat1: "FFE7BA",
		wheat2: "EED8AE",
		wheat3: "CDBA96",
		wheat4: "8B7E66",
		wheat: "F5DEB3",
		white: "FFFFFF",
		whitesmoke: "F5F5F5",
		yellow1: "FFFF00",
		yellow2: "EEEE00",
		yellow3: "CDCD00",
		yellow4: "8B8B00",
		yellow: "FFFF00",
		yellowgreen: "9ACD32"
	};
	this.getColorNames = function() {
		return this.sortObject(this.colorNames)
	};
	this.colorSchemes = {
		YlGn: {
			3: ["#f7fcb9", "#addd8e", "#31a354"],
			4: ["#ffffcc", "#c2e699", "#78c679", "#238443"],
			5: ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
			6: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"],
			7: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
			8: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
			9: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"]
		},
		YlGnBu: {
			3: ["#edf8b1", "#7fcdbb", "#2c7fb8"],
			4: ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"],
			5: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
			6: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"],
			7: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
			8: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
			9: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"]
		},
		GnBu: {
			3: ["#e0f3db", "#a8ddb5", "#43a2ca"],
			4: ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"],
			5: ["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"],
			6: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca", "#0868ac"],
			7: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
			8: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
			9: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"]
		},
		BuGn: {
			3: ["#e5f5f9", "#99d8c9", "#2ca25f"],
			4: ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"],
			5: ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"],
			6: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#2ca25f", "#006d2c"],
			7: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
			8: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
			9: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"]
		},
		PuBuGn: {
			3: ["#ece2f0", "#a6bddb", "#1c9099"],
			4: ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"],
			5: ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"],
			6: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#1c9099", "#016c59"],
			7: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
			8: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
			9: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"]
		},
		PuBu: {
			3: ["#ece7f2", "#a6bddb", "#2b8cbe"],
			4: ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"],
			5: ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"],
			6: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d"],
			7: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
			8: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
			9: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"]
		},
		BuPu: {
			3: ["#e0ecf4", "#9ebcda", "#8856a7"],
			4: ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"],
			5: ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"],
			6: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8856a7", "#810f7c"],
			7: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
			8: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
			9: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"]
		},
		RdPu: {
			3: ["#fde0dd", "#fa9fb5", "#c51b8a"],
			4: ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"],
			5: ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
			6: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"],
			7: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
			8: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
			9: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"]
		},
		PuRd: {
			3: ["#e7e1ef", "#c994c7", "#dd1c77"],
			4: ["#f1eef6", "#d7b5d8", "#df65b0", "#ce1256"],
			5: ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"],
			6: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#dd1c77", "#980043"],
			7: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
			8: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
			9: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"]
		},
		OrRd: {
			3: ["#fee8c8", "#fdbb84", "#e34a33"],
			4: ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"],
			5: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"],
			6: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#e34a33", "#b30000"],
			7: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
			8: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
			9: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]
		},
		YlOrRd: {
			3: ["#ffeda0", "#feb24c", "#f03b20"],
			4: ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"],
			5: ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
			6: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
			7: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
			8: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
			9: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"]
		},
		YlOrBr: {
			3: ["#fff7bc", "#fec44f", "#d95f0e"],
			4: ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"],
			5: ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
			6: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"],
			7: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
			8: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
			9: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"]
		},
		Purples: {
			3: ["#efedf5", "#bcbddc", "#756bb1"],
			4: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"],
			5: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
			6: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"],
			7: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
			8: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
			9: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"]
		},
		Blues: {
			3: ["#deebf7", "#9ecae1", "#3182bd"],
			4: ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"],
			5: ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
			6: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"],
			7: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
			8: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
			9: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"]
		},
		Greens: {
			3: ["#e5f5e0", "#a1d99b", "#31a354"],
			4: ["#edf8e9", "#bae4b3", "#74c476", "#238b45"],
			5: ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
			6: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"],
			7: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
			8: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
			9: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"]
		},
		Oranges: {
			3: ["#fee6ce", "#fdae6b", "#e6550d"],
			4: ["#feedde", "#fdbe85", "#fd8d3c", "#d94701"],
			5: ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
			6: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"],
			7: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
			8: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
			9: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"]
		},
		Reds: {
			3: ["#fee0d2", "#fc9272", "#de2d26"],
			4: ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"],
			5: ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"],
			6: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"],
			7: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
			8: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
			9: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"]
		},
		Greys: {
			3: ["#f0f0f0", "#bdbdbd", "#636363"],
			4: ["#f7f7f7", "#cccccc", "#969696", "#525252"],
			5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
			6: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
			7: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
			8: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
			9: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"]
		},
		PuOr: {
			3: ["#f1a340", "#f7f7f7", "#998ec3"],
			4: ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"],
			5: ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"],
			6: ["#b35806", "#f1a340", "#fee0b6", "#d8daeb", "#998ec3", "#542788"],
			7: ["#b35806", "#f1a340", "#fee0b6", "#f7f7f7", "#d8daeb", "#998ec3", "#542788"],
			8: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
			9: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
			10: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
			11: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"]
		},
		BrBG: {
			3: ["#d8b365", "#f5f5f5", "#5ab4ac"],
			4: ["#a6611a", "#dfc27d", "#80cdc1", "#018571"],
			5: ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"],
			6: ["#8c510a", "#d8b365", "#f6e8c3", "#c7eae5", "#5ab4ac", "#01665e"],
			7: ["#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"],
			8: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
			9: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
			10: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
			11: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"]
		},
		PRGn: {
			3: ["#af8dc3", "#f7f7f7", "#7fbf7b"],
			4: ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"],
			5: ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"],
			6: ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"],
			7: ["#762a83", "#af8dc3", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#7fbf7b", "#1b7837"],
			8: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
			9: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
			10: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
			11: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"]
		},
		PiYG: {
			3: ["#e9a3c9", "#f7f7f7", "#a1d76a"],
			4: ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"],
			5: ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"],
			6: ["#c51b7d", "#e9a3c9", "#fde0ef", "#e6f5d0", "#a1d76a", "#4d9221"],
			7: ["#c51b7d", "#e9a3c9", "#fde0ef", "#f7f7f7", "#e6f5d0", "#a1d76a", "#4d9221"],
			8: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
			9: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
			10: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
			11: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"]
		},
		RdBu: {
			3: ["#ef8a62", "#f7f7f7", "#67a9cf"],
			4: ["#ca0020", "#f4a582", "#92c5de", "#0571b0"],
			5: ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"],
			6: ["#b2182b", "#ef8a62", "#fddbc7", "#d1e5f0", "#67a9cf", "#2166ac"],
			7: ["#b2182b", "#ef8a62", "#fddbc7", "#f7f7f7", "#d1e5f0", "#67a9cf", "#2166ac"],
			8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
			9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
			10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
			11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"]
		},
		RdGy: {
			3: ["#ef8a62", "#ffffff", "#999999"],
			4: ["#ca0020", "#f4a582", "#bababa", "#404040"],
			5: ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"],
			6: ["#b2182b", "#ef8a62", "#fddbc7", "#e0e0e0", "#999999", "#4d4d4d"],
			7: ["#b2182b", "#ef8a62", "#fddbc7", "#ffffff", "#e0e0e0", "#999999", "#4d4d4d"],
			8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
			9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
			10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
			11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"]
		},
		RdYlBu: {
			3: ["#fc8d59", "#ffffbf", "#91bfdb"],
			4: ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"],
			5: ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"],
			6: ["#d73027", "#fc8d59", "#fee090", "#e0f3f8", "#91bfdb", "#4575b4"],
			7: ["#d73027", "#fc8d59", "#fee090", "#ffffbf", "#e0f3f8", "#91bfdb", "#4575b4"],
			8: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
			9: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
			10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
			11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"]
		},
		Spectral: {
			3: ["#fc8d59", "#ffffbf", "#99d594"],
			4: ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
			5: ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
			6: ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"],
			7: ["#d53e4f", "#fc8d59", "#fee08b", "#ffffbf", "#e6f598", "#99d594", "#3288bd"],
			8: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
			9: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
			10: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
			11: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"]
		},
		RdYlGn: {
			3: ["#fc8d59", "#ffffbf", "#91cf60"],
			4: ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"],
			5: ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"],
			6: ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"],
			7: ["#d73027", "#fc8d59", "#fee08b", "#ffffbf", "#d9ef8b", "#91cf60", "#1a9850"],
			8: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
			9: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
			10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
			11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]
		},
		Accent: {
			3: ["#7fc97f", "#beaed4", "#fdc086"],
			4: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"],
			5: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"],
			6: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f"],
			7: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17"],
			8: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"]
		},
		Dark2: {
			3: ["#1b9e77", "#d95f02", "#7570b3"],
			4: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"],
			5: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"],
			6: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"],
			7: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d"],
			8: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"]
		},
		Paired: {
			3: ["#a6cee3", "#1f78b4", "#b2df8a"],
			4: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"],
			5: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"],
			6: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c"],
			7: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"],
			8: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"],
			9: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6"],
			10: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a"],
			11: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99"],
			12: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"]
		},
		Pastel1: {
			3: ["#fbb4ae", "#b3cde3", "#ccebc5"],
			4: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"],
			5: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"],
			6: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc"],
			7: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"],
			8: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec"],
			9: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
		},
		Pastel2: {
			3: ["#b3e2cd", "#fdcdac", "#cbd5e8"],
			4: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4"],
			5: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"],
			6: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae"],
			7: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc"],
			8: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"]
		},
		Set1: {
			3: ["#e41a1c", "#377eb8", "#4daf4a"],
			4: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"],
			5: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"],
			6: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33"],
			7: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628"],
			8: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"],
			9: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"]
		},
		Set2: {
			3: ["#66c2a5", "#fc8d62", "#8da0cb"],
			4: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"],
			5: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"],
			6: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f"],
			7: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494"],
			8: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"]
		},
		Set3: {
			3: ["#8dd3c7", "#ffffb3", "#bebada"],
			4: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"],
			5: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"],
			6: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462"],
			7: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69"],
			8: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5"],
			9: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9"],
			10: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd"],
			11: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5"],
			12: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]
		},
		Default: {
			36: ["#ff0000", "#0000ff", "#00ff00", "#ffff00", "#00ffff", "#ff00ff", "#993300", "#000080", "#808000", "#ff6600", "#008080", "#660066", "#ff99cc", "#666699", "#333300", "#ffcc99", "#ccffff", "#9999ff", "#ff8080", "#3366ff", "#339966", "#ffcc00", "#00ccff", "#d02090", "#993366", "#0066cc", "#99cc00", "#ff9900", "#33cccc", "#cc99ff", "#800000", "#333399", "#008000", "#ffffcc", "#99ccff", "#800080"]
		},
		Basic: {
			24: ["#0000ff", "#ff004d", "#ffbf00", "#74ff00", "#a400ff", "#ff7400", "#ffff00", "#00ffff", "#ff0000", "#ffd300", "#3d00ff", "#00ff00", "#ff00ff", "#ff9200", "#d3ff00", "#0090ff", "#6d00ff", "#ff4900", "#ffe800", "#00ff92", "#ff0090", "#ffaa00", "#aaff00", "#004dff"]
		},
		Light: {
			24: ["#6565ff", "#ff6593", "#ffd865", "#abff65", "#c865ff", "#ffab65", "#ffff65", "#65ffff", "#ff6565", "#ffe565", "#8965ff", "#65ff65", "#ff65ff", "#ffbd65", "#e5ff65", "#65bcff", "#a765ff", "#ff9165", "#fff165", "#65ffbd", "#ff65bc", "#ffcc65", "#ccff65", "#6593ff"]
		},
		Favorite: {
			1: ["#ff0000"],
			2: ["#ff0000", "#00ffff"],
			3: ["#ff0000", "#00ff00", "#0000ff"],
			4: ["#ff0000", "#80ff00", "#00ffff", "#8000ff"],
			5: ["#ff0000", "#bfff00", "#00ff80", "#0040ff", "#ff00ff"],
			6: ["#ff0000", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#ff00ff"],
			8: ["#ff0000", "#ffbf00", "#80ff00", "#00ff40", "#00ffff", "#0040ff", "#8000ff", "#ff00bf"],
			10: ["#ff0000", "#ff8000", "#ffff00", "#80ff00", "#00ff00", "#00ff80", "#00ffff", "#0080ff", "#0000ff", "#8000ff"],
			12: ["#ff0000", "#ff8000", "#ffff00", "#80ff00", "#00ff00", "#00ff80", "#00ffff", "#0080ff", "#0000ff", "#8000ff", "#ff00ff", "#ff0080"],
			24: ["#ff0000", "#ff4000", "#ff8000", "#ffbf00", "#ffff00", "#bfff00", "#80ff00", "#40ff00", "#00ff00", "#00ff40", "#00ff80", "#00ffbf", "#00ffff", "#00bfff", "#0080ff", "#0040ff", "#0000ff", "#4000ff", "#8000ff", "#bf00ff", "#ff00ff", "#ff00bf", "#ff0080", "#ff0040"]
		},
		Pastel: {
			24: ["#b5b5ff", "#ffb5cb", "#ffedb5", "#d7ffb5", "#e5b5ff", "#ffd7b5", "#ffffb5", "#b5ffff", "#ffb5b5", "#fff2b5", "#c7b5ff", "#b5ffb5", "#ffb5ff", "#ffdfb5", "#f2ffb5", "#b5dfff", "#d5b5ff", "#ffcab5", "#fff8b5", "#b5ffdf", "#ffb5df", "#ffe6b5", "#e6ffb5", "#b5cbff"]
		},
		Balanced: {
			20: ["#fe296c", "#487eb6", "#a7ce31", "#f8cc03", "#ff8c02", "#699696", "#b77844", "#83acd0", "#c2e076", "#fadc5a", "#ff549f", "#ffaf54", "#9ab8b7", "#d2a683", "#3d699b", "#87ac22", "#cda908", "#d02158", "#d07300", "#567676"]
		},
		Rpalette: {
			8: ["#000000", "#ff0000", "#00cd00", "#0000ff", "#00ffff", "#ff00ff", "#ffff00", "#bebebe"]
		},
		RlatticeBackground: {
			7: ["#ffe5cc", "#ccffcc", "#ccffff", "#cce6ff", "#ffccff", "#ffcccc", "#ffffcc"]
		},
		RlatticeShingle: {
			7: ["#ff7f00", "#00ff00", "#00ffff", "#0080ff", "#ff00ff", "#ff0000", "#ffff00"]
		},
		RlatticeLine: {
			7: ["#0080ff", "#ff00ff", "#006400", "#ff0000", "#ffa500", "#00ff00", "#a52a2a"]
		},
		RlatticePolygon: {
			7: ["#ccffff", "#ffccff", "#ccffcc", "#ffe5cc", "#cce6ff", "#ffffcc", "#ffcccc"]
		},
		Bootstrap: {
			1: ["#337ab7"],
			2: ["#337ab7", "#d9534f"],
			3: ["#337ab7", "#5cb85c", "#d9534f"],
			4: ["#337ab7", "#5cb85c", "#f0ad4e", "#d9534f"],
			5: ["#337ab7", "#5cb85c", "#5bc0de", "#f0ad4e", "#d9534f"],
			6: ["#337ab7", "#5cb85c", "#9370db", "#5bc0de", "#f0ad4e", "#d9534f"],
			7: ["#337ab7", "#5cb85c", "#d9534f", "#f0ad4e", "#5bc0de", "#84fe83", "#ff9976"],
			8: ["#337ab7", "#5cb85c", "#d9534f", "#f0ad4e", "#5bc0de", "#84fe83", "#ff9976", "#c86727"]
		},
		ColorSpectrum: {
			1: []
		}
	};
	this.getColorSchemes = function() {
		return this.sortObject(this.colorSchemes)
	};
	this.getHexColor = function(a) {
		var b = /^#?[0-9a-fA-F]{6}$/i;
		if (b.test(a)) {
			return a.substring(a.length - 6, a.length)
		} else {
			var c = a.toLowerCase();
			if (this.colorNames.hasOwnProperty(c)) {
				return this.colorNames[c]
			} else {
				throw new Error(a + " is not a valid color.")
			}
		}
	};
	this.getColorForValue = function(a, c) {
		if (!a) {
			a = this.meta.def.colorBrew
		}
		for (var d = 0; d < a.breaks.length; d++) {
			if (a.breaks[d] >= c) {
				return a.colors[d]
			}
		}
		return a.colors[a.colors.length - 1]
	};
	this.setColorForValues = function(a, d) {
		var g = this;
		var c = function(l) {
			var j = function(t, q) {
				var n = a.grads[l];
				var s = n.min;
				var y = n.max;
				var p = n.scol.substring(t, q);
				var z = n.ecol.substring(t, q);
				var v = d < s ? s : d > y ? y : d;
				var i = y - s;
				var w = parseInt(p, 16);
				var m = parseInt(z, 16);
				var u = (m - w) / i;
				var o = Math.round(u * (v - s) + w);
				var x = o.toString(16);
				return x.length == 1 ? "0" + x : x
			};
			var k = j(0, 2);
			var h = j(2, 4);
			var b = j(4, 6);
			return g.hexToRgb("#" + k + h + b)
		};
		if (!a) {
			a = this.meta.def.colorBrew
		}
		if (a.length == 1) {
			return c(0)
		} else {
			var f = (a.max - a.min) / a.grads.length;
			var e = Math.min(Math.floor((Math.max(d, a.min) - a.min) / f), a.grads.length - 1);
			return c(e)
		}
	};
	this.getColorBrew = function(K, B, E, f, e) {
		var g = K || this.colorSpectrum;
		if (B != null && E != null && B == E) {
			E += 0.1
		}
		var F = B != null ? B : this.minData != null ? this.minData : 0;
		var q = E != null ? E : this.maxData != null ? this.maxData : 100;
		var I = this.setMinX != null ? this.setMinX : null;
		var w = this.setMaxX != null ? this.setMaxX : null;
		var C, u;
		var L = [];
		if (f == null) {
			zero = (F + q) / 2
		} else {
			zero = f;
			var C = f - F;
			var u = q - f;
			if (C > u) {
				q = f + C
			} else {
				F = f - u
			}
		}
		var t = this[this.axisAlgorithm](I || F, w || q, 5, this.axisWilkinsonLoose);
		var G = (t[t.length - 1] - t[0]) / (g.length - 1);
		var a = this.getAxisDecimals(t[1] - t[0]);
		var c = this.getMaxText(t);
		var H = this.measureText(c.toString(), this.font);
		var o = t[t.length - 1] - t[0];
		var d = o / this.colorSpectrumNumber;
		if (e && e.length > 1 && e.length == g.length) {
			for (var D = 0; D < e.length; D++) {
				e[D] = Number(e[D])
			}
			e = e.sort(function(l, i) {
				return l - i
			});
			var x = t[0];
			var A = Math.ceil((this.colorSpectrumNumber - 1) / g.length);
			for (var D = 0; D < e.length; D++) {
				var m = e[D];
				var J = this.seq(x, m, false, A);
				L = L.concat(J);
				var k = L.length - 1;
				x = m + (L[k] - L[k - 1])
			}
		} else {
			L = this.seq(t[0], t[t.length - 1], false, this.colorSpectrumNumber)
		}
		while (L.length < this.colorSpectrumNumber) {
			L.push(t[t.length - 1])
		}
		var y = {
			scol: this.getHexColor(g[0]),
			ecol: this.getHexColor(g[1]),
			min: t[0],
			max: t[0] + G
		};
		var j = {
			spectrum: g,
			stops: e,
			z: f,
			colors: [],
			legend: [],
			grads: [y],
			rmin: F,
			rmax: q,
			min: t[0],
			max: t[t.length - 1],
			range: o,
			zero: zero,
			vals: t,
			incr: G,
			decs: a,
			breaks: L,
			maxLevLen: H,
			maxLevChr: c.toString().length,
			maxLevStr: c
		};
		for (var D = 1; D < g.length - 1; D++) {
			y = {
				scol: this.getHexColor(g[D]),
				ecol: this.getHexColor(g[D + 1]),
				min: t[0] + (G * D),
				max: t[0] + (G * (D + 1))
			};
			j.grads.push(y)
		}
		var h = t[0];
		for (var D = 0; D < this.colorSpectrumNumber; D++) {
			j.colors.push(this.setColorForValues(j, h));
			h += d
		}
		for (var D = 0; D < this.colorSpectrumNumber; D++) {
			h = L[D];
			j.legend.push(this.setColorForValues(j, h))
		}
		return j
	};
	this.setColorBrew = function(b) {
		if (!this.meta.def.colorBrew || b) {
			if (this.meta.vals.colors) {
				this.meta.vals.colors = {}
			}
			if (this.heatmapAutoAdjust || !this.meta.def.colorBrew) {
				this.meta.def.colorBrew = this.getColorBrew(this.colorSpectrum, this.minData, this.maxData, this.colorSpectrumZeroValue, this.colorSpectrumBreaks)
			} else {
				var a = this.meta.def.colorBrew;
				this.meta.def.colorBrew = this.getColorBrew(this.colorSpectrum, a.rmin, a.rmax, a.z, a.stops)
			}
		}
	};
	this.validateUserColors = function() {
		var a = [];
		for (var b = 0; b < this.colors.length; b++) {
			a.push(this.validateColor(this.colors[b]))
		}
		if (a.length > 0) {
			this.colors = a
		}
	};
	this.validateUserColors()
};
CanvasXpress.prototype.initAttributes = function() {
	this.setStyle = function(c, b, d) {
		var a = this.meta.canvas.ctx;
		c = this.validateColor(c);
		if (this.transparency != null) {
			c = this.addColorTransparency(c, this.transparency)
		}
		a.fillStyle = c;
		a.strokeStyle = c;
		a.lineWidth = b ? b : this.outlineWidth;
		a.lineCap = d ? d : this.capType;
		this.setShadow(true)
	};
	this.setClipArea = function(a) {
		var c = this.meta.canvas.ctx;
		c.save();
		if (a) {
			c.rect(a[0], a[1], a[2], a[3])
		} else {
			c.rect(this.marginLeft + this.offsetX + this.left, this.marginTop + this.offsetY + this.top, this.x, this.y + 1)
		}
		c.clip()
	};
	this.resetClipArea = function() {
		this.meta.canvas.ctx.restore()
	};
	this.resetStyle = function() {
		this.setShadow(false)
	};
	this.drawArrowHead = function(D, e, B, c, C, p, d, b, l, j) {
		var x = this.meta.canvas.ctx;
		var z = function(F, I, f, J) {
			var w = [];
			for (var G = 0; G < F.length; G++) {
				w.push([(F[G][0] * Math.cos(I)) - (F[G][1] * Math.sin(I)), (F[G][0] * Math.sin(I)) + (F[G][1] * Math.cos(I))])
			}
			var H = [];
			for (var G = 0; G < w.length; G++) {
				H.push([w[G][0] + f, w[G][1] + J])
			}
			return H
		};
		var t = this.arrowPointSize;
		var g = Math.max((t / 2) - 1, 1);
		var r = p ? p / 2 : this.outlineWidth / 2;
		var s = l ? [
			[0, -t],
			[0, t]
		] : [
			[Math.floor((t / 2.5)), 0],
			[-t, -g * p],
			[-t, g * p]
		];
		var q = B - D;
		var o = c - e;
		if (d) {
			if (d == "Y") {
				if (Math.abs(o) > Math.abs(q)) {
					q = 0
				} else {
					q = B > D ? this.arrowPointSize : -this.arrowPointSize
				}
			} else {
				if (Math.abs(q) > Math.abs(o)) {
					o = 0
				} else {
					o = c > e ? this.arrowPointSize : -this.arrowPointSize
				}
			}
		} else {
			if (b) {
				var n = this.lineLength(D, e, B, c);
				var E = this.shortenLine(D, e, B, c, 0, n / 2, "line");
				var m = E[2];
				var A = E[3];
				var v = n / 2;
				var h = b / v;
				var u = B > D ? Math.asin((A - e) / v) : Math.asin(-(A - e) / v);
				var a = j ? u + (Math.PI / 20) : u - (Math.PI / 20);
				if (B > D) {
					D = m + v * Math.cos(a - h);
					e = A + v * Math.sin(a - h);
					B = m + v * Math.cos(u - h);
					c = A + v * Math.sin(u - h)
				} else {
					D = m + v * Math.cos((a - h) + Math.PI);
					e = A + v * Math.sin((a - h) + Math.PI);
					B = m + v * Math.cos((u - h) + Math.PI);
					c = A + v * Math.sin((u - h) + Math.PI)
				}
				q = B - D;
				o = c - e
			}
		}
		var k = z(s, Math.atan2(o, q), B, c);
		this.setStyle(C, p);
		x.beginPath();
		x.moveTo(k[0][0], k[0][1]);
		for (var y = 1; y < k.length; y++) {
			if (!isNaN(k[y][0]) && !isNaN(k[y][1])) {
				x.lineTo(k[y][0], k[y][1])
			}
		}
		if (!l) {
			if (!isNaN(k[0][0]) && !isNaN(k[0][1])) {
				x.lineTo(k[0][0], k[0][1])
			}
			x.closePath();
			x.fill()
		} else {
			x.closePath();
			x.stroke()
		}
		this.resetStyle()
	};
	this.setShadow = function(a) {
		if (this.showShadow) {
			if (a) {
				this.meta.canvas.ctx.shadowOffsetX = this.shadowOffsetX;
				this.meta.canvas.ctx.shadowOffsetY = this.shadowOffsetY;
				this.meta.canvas.ctx.shadowBlur = this.shadowBlur;
				this.meta.canvas.ctx.shadowColor = this.shadowColor
			} else {
				this.meta.canvas.ctx.shadowOffsetX = 0;
				this.meta.canvas.ctx.shadowOffsetY = 0;
				this.meta.canvas.ctx.shadowBlur = 0;
				this.meta.canvas.ctx.shadowColor = this.background
			}
		}
	};
	this.validateNumbers = function(b) {
		for (var c = 0; c < b.length; c++) {
			if (isNaN(b[c])) {
				return false
			}
		}
		return true
	};
	this.lineTo = function(b, d, a, c) {
		if (b == a) {
			b = (((b + 0.5) << 1) >> 1) + 0.5;
			a = b
		} else {
			if (d == c) {
				d = (((d + 0.5) << 1) >> 1) + 0.5;
				c = d
			}
		}
		this.meta.canvas.ctx.moveTo(b, d);
		this.meta.canvas.ctx.lineTo(a, c);
		this.meta.canvas.ctx.stroke()
	};
	this.clip = function(v, f, k) {
		var d, c, p, n, j, o, v;
		var q, e, a, m;
		var u = [];
		if (k && k.length == 4) {
			e = k[0];
			q = k[1];
			a = e + k[2];
			m = q + k[3] + 1
		} else {
			e = this.marginLeft + this.offsetX + this.left;
			q = this.marginTop + this.offsetY + this.top;
			a = e + this.x;
			m = q + this.y + 1
		}
		switch (v) {
			case "path":
				u[0] = [];
				u[1] = [];
				for (var g = 0; g < f[0].length; g++) {
					c = f[0][g];
					n = f[1][g];
					if (c < e || c > a) {
						c = null
					}
					if (n < q || n > m) {
						n = null
					}
					u[0].push(c);
					u[1].push(n)
				}
				break;
			case "box":
			case "rect":
			case "rectangle":
			case "rect2":
			case "rect3":
			case "roundrect":
				d = this.parseInt(f[0] - (f[2] / 2));
				p = this.parseInt(f[1] - (f[3] / 2));
				c = this.parseInt(d + f[2]);
				n = this.parseInt(p + f[3]);
				if (c > d) {
					if (n > p) {
						if (d > a + this.outlineWidth || p > m + this.outlineWidth || c < e || n < q) {
							return false
						}
						if (d < e) {
							d = e
						}
						if (c > a) {
							c = a
						}
						if (p < q) {
							p = q
						}
						if (n > m) {
							n = m
						}
					} else {
						if (d > a + this.outlineWidth || n > m + this.outlineWidth || c < e || p < q) {
							return false
						}
						if (d < e) {
							d = e
						}
						if (c > a) {
							c = a
						}
						if (p > m) {
							p = m
						}
						if (n < q) {
							n = q
						}
					}
				} else {
					if (n > p) {
						if (c > a + this.outlineWidth || p > m + this.outlineWidth || d < e || n < q) {
							return false
						}
						if (d > a) {
							d = a
						}
						if (c < e) {
							c = e
						}
						if (p < q) {
							p = q
						}
						if (n > m) {
							n = m
						}
					} else {
						if (c > a + this.outlineWidth || n > m + this.outlineWidth || d < e || p < q) {
							return false
						}
						if (d > a) {
							d = a
						}
						if (c < e) {
							c = e
						}
						if (p > m) {
							p = m
						}
						if (n < q) {
							n = q
						}
					}
				}
				u = [d, p, c - d, n - p];
				break;
			case "poly":
				break;
			case "circle":
			case "sphere":
			case "square":
			case "triangle":
			case "triangle2":
			case "equilateral":
			case "equilateral2":
			case "diamond":
			case "rhombus":
			case "hexagon":
			case "octagon":
			case "oval":
			case "oval2":
			case "oval3":
			case "arc":
			case "arc2":
			case "arc3":
			case "ellipse":
			case "ellipse2":
			case "ellipse3":
			case "plus":
			case "minus":
			case "mdavid":
			case "star":
			case "pie":
			case "pie0":
			case "pie1":
			case "pie2":
			case "pie3":
			case "pie4":
			case "pie5":
			case "pie6":
			case "pie7":
			case "pie8":
			case "pie9":
			case "pacman":
			case "pacman2":
				d = parseInt(f[0]);
				p = parseInt(f[1]);
				if (d > a || d < e || p < q || p > m) {
					return false
				}
				u = [d, p];
				break;
			case "line":
				d = parseFloat(f[0]);
				p = parseFloat(f[1]);
				c = parseFloat(f[2]);
				n = parseFloat(f[3]);
				if (d == c) {
					if (d < e || d > a) {
						return false
					} else {
						if (p > n) {
							if (p < q) {
								return false
							} else {
								if (p > m) {
									p = m
								}
							}
							if (n > m) {
								return false
							} else {
								if (n < q) {
									n = q
								}
							}
						} else {
							if (p > m) {
								return false
							} else {
								if (p < q) {
									p = q
								}
							}
							if (n < q) {
								return false
							} else {
								if (n > m) {
									n = m
								}
							}
						}
					}
				} else {
					if (p == n) {
						if (p < q || p > m) {
							return false
						} else {
							if (d > c) {
								if (d < e) {
									return false
								} else {
									if (d > a) {
										d = a
									}
								}
								if (c > a) {
									return false
								} else {
									if (c < e) {
										c = e
									}
								}
							} else {
								if (d > a) {
									return false
								} else {
									if (d < e) {
										d = e
									}
								}
								if (c < e) {
									return false
								} else {
									if (c > a) {
										c = a
									}
								}
							}
						}
					} else {
						if (d > c) {
							if (d < e || c > a) {
								return false
							} else {
								if (p > n) {
									if (p < q || n > m) {
										return false
									} else {
										j = p - n;
										o = d - c;
										if (d > a) {
											p -= (d - a) * j / o;
											d = a
										}
										if (p > m) {
											d -= (p - m) * o / j;
											p = m
										}
										if (c < e) {
											n += (e - c) * j / o;
											c = e
										}
										if (n < q) {
											c += (q - n) * o / j;
											n = q
										}
									}
								} else {
									if (n < q || p > m) {
										return false
									} else {
										j = n - p;
										o = d - c;
										if (d > a) {
											p += (d - a) * j / o;
											d = a
										}
										if (p < q) {
											d -= (q - p) * o / j;
											p = q
										}
										if (c < e) {
											n -= (e - c) * j / o;
											c = e
										}
										if (n > m) {
											c += (n - m) * o / j;
											n = m
										}
									}
								}
							}
						} else {
							if (c < e || d > a) {
								return false
							} else {
								if (p > n) {
									if (p < q || n > m) {
										return false
									} else {
										j = p - n;
										o = c - d;
										if (d < e) {
											p -= (e - d) * j / o;
											d = e
										}
										if (p > m) {
											d += (p - m) * o / j;
											p = m
										}
										if (c > a) {
											n += (c - a) * j / o;
											c = a
										}
										if (n < q) {
											c -= (q - n) * o / j;
											n = q
										}
									}
								} else {
									if (n < q || p > m) {
										return false
									} else {
										j = n - p;
										o = c - d;
										if (d < e) {
											p += (e - d) * j / o;
											d = e
										}
										if (p < q) {
											d += (q - p) * o / j;
											p = q
										}
										if (c > a) {
											n -= (c - a) * j / o;
											c = a
										}
										if (n > m) {
											c -= (n - m) * o / j;
											n = m
										}
									}
								}
							}
						}
					}
				}
				u = [d, p, c, n];
				break;
			default:
				return false
		}
		return u
	};
	this.lineLength = function(b, d, a, c) {
		return Math.sqrt(Math.pow(a - b, 2) + Math.pow(c - d, 2))
	};
	this.shortenLine = function(b, j, a, i, k, f, l) {
		if (this.validateNumbers([b, j, a, i, k, f])) {
			if (l.match(/bezier/i)) {
				if (l.match(/beziery/i)) {
					return i > j ? [b, j + k, a, i - f] : [b, j - k, a, i + f]
				} else {
					return a > b ? [b + k, j, a - f, i] : [b - k, j, a + f, i]
				}
			} else {
				if (l.match(/curved/i)) {
					return [b, j, a, i]
				} else {
					var c = Math.atan2(i - j, a - b);
					var d = Math.cos(c);
					var h = Math.sin(c);
					var g = this.lineLength(b, j, a, i);
					if (g) {
						while (g < (k + f)) {
							k /= 1.1;
							f /= 1.1
						}
						b += d * k;
						j += h * k;
						a -= d * f;
						i -= h * f
					}
				}
			}
			return [b, j, a, i]
		}
	};
	this.errorBar = function(e, g, d, f, a, h) {
		if (this.showErrorBars && this.validateNumbers([a])) {
			var b = this.drawLine("line", e, g, d, f, h, false, false, false, false, true);
			if (Math.abs(a) > this.errorBarsWidth) {
				if (a > 0) {
					this.drawLine("line", d, f - a / 2, d, f + a / 2, h, false, false, false, false, true)
				} else {
					this.drawLine("line", d - a / 2, f, d + a / 2, f, h, false, false, false, false, true)
				}
			}
			return b
		}
	};
	this.traceArc = function(c, b, a, m, h, d) {
		if (m > h) {
			var k = m;
			m = h;
			h = k
		}
		var l = [];
		var g = Math.PI;
		var i = h - m;
		var f = i < g / 8 ? 0 : i < g / 4 ? 2 : i < g / 2 ? 4 : i < g ? 8 : 16;
		var j = i / f;
		l.push([a * Math.cos(m) + c, a * Math.sin(m) + b]);
		m += j;
		while (m < h) {
			l.push([a * Math.cos(m) + c, a * Math.sin(m) + b]);
			m += j
		}
		l.push([a * Math.cos(h) + c, a * Math.sin(h) + b]);
		return d ? l : l.reverse()
	};
	this.traceQuadraticCurve = function(l, k, e, c, j, h, b, f) {
		var m = [];
		var a = function(i, q, p, o) {
			var n = 1 - i;
			return n * n * q + 2 * n * i * p + i * i * o
		};
		var d = function(i) {
			return [a(i, l, e, j), a(i, k, c, h)]
		};
		for (var g = 0; g <= 1; g += b) {
			m.push(d(g))
		}
		return f ? m : m.reverse()
	};
	this.splineControlPoint = function(e, m, d, l, c, k) {
		var n = Math.sqrt(Math.pow(d - e, 2) + Math.pow(l - m, 2));
		var h = Math.sqrt(Math.pow(c - d, 2) + Math.pow(k - l, 2));
		var g = this.tension * n / (n + h);
		var f = this.tension - g;
		var b = d + g * (e - c);
		var a = l + g * (m - k);
		var j = d - f * (e - c);
		var i = l - f * (m - k);
		return [b, a, j, i]
	};
	this.hullControlPoints = function(f) {
		var c = this;
		var f;
		var e = [];
		var g = 0;
		var b, a;
		var d = function(p, n, m) {
			var l = function(r, q) {
				var t = q[0] - r[0];
				var s = q[1] - r[1];
				return Math.sqrt(t * t + s * s)
			};
			var o = l(p, n);
			var k = l(n, m);
			var h = c.tension * o / (o + k);
			var j = [((p[0] - m[0]) * h) + n[0], ((p[1] - m[1]) * h) + n[1]];
			var i = [n[0] - ((p[0] - m[0]) * h), (n[1] - (p[1] - m[1]) * h)];
			return [j, i]
		};
		for (b = 0; b < f.length - 2; b++) {
			e.push.apply(e, d(f[b], f[b + 1], f[b + 2]))
		}
		e.push.apply(e, d(f[b], f[b + 1], f[0]));
		e.push.apply(e, d(f[b + 1], f[0], f[1]));
		return e
	};
	this.drawElbowLine = function(m, y, g, v, d, x, k, r, n, z, B, C, o) {
		if (o && this.isArray(o) && o.length > 0) {
			var l = 2;
			var a, h, j;
			if (m.match(/^arrowheadsquaretail/i)) {
				a = m.replace(/arrowhead/i, "");
				h = m.replace(/arrowheadsquaretail/i, "");
				j = m.replace(/squaretail/i, "")
			} else {
				if (m.match(/^squaretailarrowhead/i)) {
					a = m.replace(/squaretail/i, "");
					h = m.replace(/squaretailarrowhead/i, "");
					j = m.replace(/arrowhead/i, "")
				} else {
					if (m.match(/^arrowtailsquarehead/i)) {
						a = m.replace(/arrowtail/i, "");
						h = m.replace(/arrowtailsquarehead/i, "");
						j = m.replace(/squarehead/i, "")
					} else {
						if (m.match(/^squareheadarrowtail/i)) {
							a = m.replace(/squarehead/i, "");
							h = m.replace(/squareheadarrowtail/i, "");
							j = m.replace(/arrowtail/i, "")
						} else {
							if (m.match(/^arrowhead/i)) {
								a = m.replace(/arrowhead/i, "");
								h = a;
								j = m
							} else {
								if (m.match(/^squarehead/i)) {
									a = m.replace(/squarehead/i, "");
									h = a;
									j = m
								} else {
									if (m.match(/^arrowtail/i)) {
										a = m;
										h = m.replace(/arrowtail/i, "");
										j = h
									} else {
										if (m.match(/^squaretail/i)) {
											a = m;
											h = m.replace(/squaretail/i, "");
											j = h
										} else {
											if (m.match(/^arrow/i)) {
												a = m.replace(/arrow/i, "arrowHead");
												h = m.replace(/arrow/i, "");
												j = m.replace(/arrow/i, "arrowTail")
											} else {
												if (m.match(/^square/i)) {
													a = m.replace(/square/i, "squareHead");
													h = m.replace(/square/i, "");
													j = m.replace(/square/i, "squareTail")
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			var A = [];
			A.push(this.drawLine(a, y, g, o[0][0], o[0][1], x, k, r, n, false, B, C));
			A.push(["rect", o[0][0] - (l / 2), o[0][1] - (l / 2), o[0][0] + (l / 2), o[0][1] + (l / 2)]);
			for (var u = 1; u < o.length; u++) {
				A.push(this.drawLine(h, o[u - 1][0], o[u - 1][1], o[u][0], o[u][1], x, k, r, false, false, B, C));
				A.push(["rect", o[u][0] - (l / 2), o[u][1] - (l / 2), o[u][0] + (l / 2), o[u][1] + (l / 2)])
			}
			A.push(this.drawLine(j, o[o.length - 1][0], o[o.length - 1][1], v, d, x, k, r, false, z, B, C));
			return A
		} else {
			return this.drawLine(m, y, g, v, d, x, k, r, false, z, B, C)
		}
	};
	this.drawLine = function(Y, H, a, E, at, am, X, ad, aa, ao, ap, ar, ab) {
		var I = this.meta.canvas.ctx;
		var ag;
		var O = [];
		var T = false;
		var A = false;
		var z = false;
		var ah = this.lineWidthEvent;
		var h = function() {
			var b;
			b = H;
			H = E;
			E = b;
			b = a;
			a = at;
			at = b
		};
		var K = function() {
			if (H == E && a != at) {
				return ["poly", H - ah, a, H + ah, a, E + ah, at, E - ah, a]
			} else {
				if (a == at && H != E) {
					return ["poly", H, a - ah, E, a - ah, E, at + ah, H, at + ah]
				} else {
					if (((at - a) / (E - H)) < 1) {
						return ["poly", H + ah, a - ah, E + ah, at - ah, E - ah, at + ah, H - ah, a + ah]
					} else {
						return ["poly", H + ah, a + ah, E + ah, at + ah, E - ah, at - ah, H - ah, a - ah]
					}
				}
			}
		};
		if (ab && this.isArray(ab) && ab.length > 0) {
			return this.drawElbowLine(Y, H, a, E, at, am, X, ad, aa, ao, ap, ar, ab)
		} else {
			if (Y == "spline") {
				if (H.length < 3) {
					return H.length < 2 ? false : this.drawLine("line", H[0], a[0], H[1], a[1], am, X, ad, aa, ao, ap, ar)
				}
				var Z = [];
				var aq = [];
				var ac = [];
				var af = 0;
				O = ["poly"];
				for (var ak = 0; ak < H.length; ak++) {
					if (this.validateNumbers([H[ak], a[ak]])) {
						aq.push(H[ak], a[ak]);
						O.push(H[ak], a[ak] - 2);
						ac.push(a[ak] + 2, H[ak]);
						af += 2
					} else {
						return false
					}
				}
				O = O.concat(ac.reverse());
				this.setStyle(am, X, ad);
				for (var ak = 0; ak < af - 4; ak += 2) {
					Z = Z.concat(this.splineControlPoint(aq[ak], aq[ak + 1], aq[ak + 2], aq[ak + 3], aq[ak + 4], aq[ak + 5]))
				}
				I.beginPath();
				I.moveTo(aq[0], aq[1]);
				I.quadraticCurveTo(Z[0], Z[1], aq[2], aq[3]);
				for (var ak = 2; ak < af - 5; ak += 2) {
					I.bezierCurveTo(Z[2 * ak - 2], Z[2 * ak - 1], Z[2 * ak], Z[2 * ak + 1], aq[ak + 2], aq[ak + 3])
				}
				I.moveTo(aq[af - 2], aq[af - 1]);
				I.quadraticCurveTo(Z[2 * af - 10], Z[2 * af - 9], aq[af - 4], aq[af - 3]);
				I.stroke();
				this.resetStyle();
				return O
			} else {
				if (Y == "arch") {
					if (H.length != 3 || a.length != 3) {
						return false
					}
					for (var ak = 0; ak < H.length; ak++) {
						if (!this.validateNumbers([H[ak], a[ak]])) {
							return false
						}
					}
					O = ["poly"];
					this.setStyle(am, X, ad);
					I.beginPath();
					I.moveTo(H[0], a[0]);
					I.quadraticCurveTo(H[1], a[1], H[2], a[2]);
					I.stroke();
					this.resetStyle()
				} else {
					if (this.validateNumbers([H, a, E, at])) {
						if (!aa) {
							aa = 0
						}
						if (!ao) {
							ao = 0
						}
						if (Y.match(/bezier/i)) {
							if (Y.match(/beziery/i)) {
								ag = "bezierLine";
								A = "Y";
								T = "Y";
								if (aa || ao) {
									if (at > a) {
										if (a + aa > at - ao) {
											Y = Y.replace(/beziery/i, "");
											ag = "line";
											A = false;
											T = false
										}
									} else {
										if (a - aa < at + ao) {
											Y = Y.replace(/beziery/i, "");
											ag = "line";
											A = false;
											T = false
										}
									}
								}
							} else {
								ag = "bezierLine";
								A = "X";
								T = "X";
								if (aa || ao) {
									if (E > H) {
										if (H + aa > E - ao) {
											Y = Y.replace(/bezier[x]?/i, "");
											ag = "line";
											A = false;
											T = false
										}
									} else {
										if (H - aa < E + ao) {
											Y = Y.replace(/bezier[x]?/i, "");
											ag = "line";
											A = false;
											T = false
										}
									}
								}
							}
						} else {
							if (Y.match(/curved/i)) {
								if (Y.match(/curvedc/i)) {
									ag = "curvedLine";
									z = true;
									T = true
								} else {
									ag = "curvedLine";
									z = true;
									T = false
								}
							} else {
								if (Y.match(/dashed/i)) {
									ag = "dashedLine"
								} else {
									if (Y.match(/dotted/i)) {
										ag = "dottedLine"
									} else {
										ag = "line"
									}
								}
							}
						}
						if ((aa || ao)) {
							var ae = this.shortenLine(H, a, E, at, aa, ao, Y);
							H = ae[0];
							a = ae[1];
							E = ae[2];
							at = ae[3]
						}
						if (ap) {
							var M = this.clip("line", [H, a, E, at], ar);
							if (M) {
								H = M[0];
								a = M[1];
								E = M[2];
								at = M[3]
							} else {
								return false
							}
						}
						switch (ag) {
							case "dashedLine":
							case "dottedLine":
								var l = Math.atan2(at - a, E - H);
								var S = Math.cos(l);
								var J = Math.sin(l);
								var N = this.lineLength(H, a, E, at);
								var r = ag == "dashedLine" ? this.dashLength : this.dotLength;
								var aj = Math.floor(N / (r * 2)) - 1;
								if (aj) {
									var V = S * r;
									var U = J * r;
									var g = H;
									var an = a;
									var d = E;
									var al = at;
									d = g + V;
									al = an + U;
									for (var ak = 0; ak < aj; ak++) {
										this.drawLine("line", g, an, d, al, am, X, ad);
										g += (V * 2);
										an += (U * 2);
										d = g + V;
										al = an + U
									}
									this.drawLine("line", g, an, d, al, am, X, ad);
									O = K()
								} else {
									return false
								}
								break;
							case "bezierLine":
								if (H == E || a == at) {
									return this.drawLine("line", H, a, E, at, am, X, ad, aa, ao, ap, ar)
								}
								H = parseInt(H) + 0.5;
								a = parseInt(a) + 0.5;
								E = parseInt(E) + 0.5;
								at = parseInt(at) + 0.5;
								T = T == "Y" ? "Y" : "X";
								var Q = E > H ? true : false;
								var o = (H + E) / 2;
								var m = (a + at) / 2;
								if (Q) {
									if (T == "X") {
										O = ["poly", H, a - 2, o + 2, a - 2, o + 2, at - 2, E, at - 2, E, at + 2, o - 2, at + 2, o - 2, a + 2, H, a + 2]
									} else {
										O = ["poly", H - 2, a, H - 2, m + 2, E - 2, m + 2, E - 2, at, E + 2, at, E + 2, m - 2, H + 2, m - 2, H + 2, a]
									}
								} else {
									if (T == "X") {
										O = ["poly", H, a - 2, o - 2, a - 2, o - 2, at - 2, E, at - 2, E, at + 2, o + 2, at + 2, o + 2, a + 2, H, a + 2]
									} else {
										O = ["poly", H - 2, a, H - 2, m - 2, E - 2, m - 2, E - 2, at, E + 2, at, E + 2, m + 2, H + 2, m + 2, H + 2, a]
									}
								}
								this.setStyle(am, X, ad);
								I.moveTo(H, a);
								if (T == "Y") {
									I.bezierCurveTo(H, at, E, a, E, at)
								} else {
									I.bezierCurveTo(E, a, H, at, E, at)
								}
								I.stroke();
								this.resetStyle();
								break;
							case "curvedLine":
								var o = 12;
								var v = 1;
								var N = this.lineLength(H, a, E, at);
								var G = this.shortenLine(H, a, E, at, 0, N / 2, "line");
								var R = G[2];
								var F = G[3];
								var W = N / 2;
								var P = aa / W;
								var L = ao / W;
								var k = (R - H);
								var j = (F - a);
								var D = T && H > E ? false : !T && E >= H ? true : T;
								var u = E >= H ? Math.asin(j / W) : Math.asin(-j / W);
								var ai = u + Math.PI;
								var C = Math.PI / o;
								var B = E >= H ? 0 : Math.PI;
								O = ["poly"];
								for (var ak = v; ak <= o - v; ak++) {
									O.push(R - (W + 2) * Math.cos(u + ((C * ak)) - B));
									O.push(F - (W + 2) * Math.sin(u + ((C * ak)) - B))
								}
								for (var ak = o - v; ak >= v; ak--) {
									O.push(R - (W - 2) * Math.cos(u + ((C * ak)) - B));
									O.push(F - (W - 2) * Math.sin(u + ((C * ak)) - B))
								}
								this.setStyle(am, X, ad);
								I.beginPath();
								if (E >= H) {
									I.arc(R, F, W, u - L, ai + P, D)
								} else {
									I.arc(R, F, W, u + P, ai - L, D)
								}
								I.stroke();
								this.resetStyle();
								break;
							case "line":
								O = K();
								this.setStyle(am, X, ad);
								I.beginPath();
								this.lineTo(H, a, E, at);
								this.resetStyle();
								break
						}
						if (Y.match(/arrowheadsquaretail|squaretailarrowhead/i)) {
							z = z ? ao : false;
							this.drawArrowHead(H, a, E, at, am, X, A, z);
							h();
							if (Y.match(/curve/i)) {
								z = -aa
							}
							this.drawArrowHead(H, a, E, at, am, X, A, z, true)
						} else {
							if (Y.match(/arrowtailsquarehead|squareheadarrowtail/i)) {
								z = z ? ao : false;
								this.drawArrowHead(H, a, E, at, am, X, A, z, true);
								h();
								if (Y.match(/curve/i)) {
									z = -aa
								}
								this.drawArrowHead(H, a, E, at, am, X, A, z, false, true)
							} else {
								if (Y.match(/arrowhead/i)) {
									z = z ? ao : false;
									this.drawArrowHead(H, a, E, at, am, X, A, z)
								} else {
									if (Y.match(/squarehead/i)) {
										z = z ? ao : false;
										this.drawArrowHead(H, a, E, at, am, X, A, z, true)
									} else {
										if (Y.match(/arrowtail/i)) {
											h();
											if (Y.match(/curve/i)) {
												z = -aa
											}
											this.drawArrowHead(H, a, E, at, am, X, A, z, false, true)
										} else {
											if (Y.match(/squaretail/i)) {
												h();
												if (Y.match(/curve/i)) {
													z = -aa
												}
												this.drawArrowHead(H, a, E, at, am, X, A, z, true, true)
											} else {
												if (Y.match(/arrow/i)) {
													z = z ? ao : false;
													this.drawArrowHead(H, a, E, at, am, X, A, z);
													h();
													if (Y.match(/curve/i)) {
														z = -aa
													}
													this.drawArrowHead(H, a, E, at, am, X, A, z, false, true)
												} else {
													if (Y.match(/square/i)) {
														z = z ? ao : false;
														this.drawArrowHead(H, a, E, at, am, X, A, z, true);
														h();
														if (Y.match(/curve/i)) {
															z = -aa
														}
														this.drawArrowHead(H, a, E, at, am, X, A, z, true, true)
													}
												}
											}
										}
									}
								}
							}
						}
						return O
					} else {
						return false
					}
				}
			}
		}
	};
	this.createPatterns = function() {
		var c = this;
		for (var b = 0; b < this.patterns.length; b++) {
			var d = this.patterns[b];
			if (!CanvasXpress.cachePatterns[d]) {
				var a = new Image();
				if (this.meta.system.browser == "Firefox") {
					a.onload = function() {
						CanvasXpress.cachePatterns[d] = c.meta.canvas.ctx.createPattern(a, "repeat")
					};
					a.src = CanvasXpress.images[d]
				} else {
					a.src = CanvasXpress.images[d];
					CanvasXpress.cachePatterns[d] = this.meta.canvas.ctx.createPattern(a, "repeat")
				}
			}
		}
	};
	this.sphere = function(f, e, d, m, h, g, F, E, D) {
		var c = Math.sin(F);
		var A = Math.cos(F);
		var b = Math.sin(E);
		var x = Math.cos(E);
		var a = Math.sin(D);
		var v = Math.cos(D);
		var C = function(j) {
			var k = j.y;
			j.y = (k * A) + (j.z * c * -1);
			j.z = (k * c) + (j.z * A);
			var i = j.x;
			j.x = (i * x) + (j.z * b * -1);
			j.z = (i * b) + (j.z * x);
			var i = j.x;
			j.x = (i * v) + (j.y * a * -1);
			j.y = (i * a) + (j.y * v)
		};
		var l = [];
		var n = Math.PI / 12;
		var t = Math.PI * 2;
		var r = Math.PI / 2;
		for (var B = 1; B >= -1; B -= 2) {
			for (var z = 0; z < r; z += n) {
				var u = Math.cos(z) * m;
				var o = Math.cos(z) * g;
				var q = Math.sin(z) * h * B * -1;
				for (var w = 0; w < t; w += n) {
					var s = {
						x: (Math.cos(w) * u),
						y: q,
						z: (Math.sin(w) * o)
					};
					C(s);
					s.x += f;
					s.y += e;
					s.z += d;
					if (B > 0) {
						l.push([s.x, s.y, s.z])
					} else {
						l.unshift([s.x, s.y, s.z])
					}
				}
			}
		}
		return l
	};
	this.polygon = function(l, k, g, e, d, a, i, h, j) {
		return this.drawShape("polygon", l, k, false, false, g, e, d, a, i, h, j)
	};
	this.circle = function(n, m, q, g, i, e, d, a, k, j, l) {
		return this.drawShape("circle", n, m, q, g, i, e, d, a, k, j, l)
	};
	this.rectangle = function(n, m, q, g, i, e, d, a, k, j, l) {
		return this.drawShape("rectangle", n + (q / 2), m + (g / 2), q, g, i, e, d, a, k, j, l)
	};
	this.roundRectangle = function(n, m, q, g, i, e, d, a, k, j, l) {
		return this.drawShape("roundrect", n + (q / 2), m + (g / 2), q, g, i, e, d, a, k, j, l)
	};
	this.drawShapeSetShapeStyle = function(j, i, k, d, e, c, b, a, g) {
		var l = this.meta.canvas.ctx;
		l.translate(j, i);
		if (a) {
			l.rotate(a)
		}
		if (this.transparency != null) {
			e = this.addColorTransparency(e, this.transparency)
		}
		if (this.gradient) {
			if (this.gradientType == "radial") {
				l.fillStyle = this.getGradient(0, 0, Math.max(Math.abs(k), Math.abs(d)), e)
			} else {
				l.fillStyle = this.getGradient(0, 0, k, d, e)
			}
		} else {
			if (b) {
				switch (b) {
					case "closed":
					case "solid":
						l.fillStyle = e;
						break;
					case "open":
						break;
					default:
						l.fillStyle = CanvasXpress.cachePatterns[b] ? CanvasXpress.cachePatterns[b] : e;
						break
				}
			} else {
				l.fillStyle = e
			}
		}
		l.strokeStyle = c ? c : this.foreground;
		l.lineWidth = g ? g : this.outlineWidth;
		l.lineJoin = this.joinType;
		this.setShadow(true)
	};
	this.drawShapeDraw = function(d, c) {
		var b = this.meta.canvas.ctx;
		if (d && d.length > 1) {
			var a = d.shift();
			while (a[0] == null || a[1] == null) {
				a = d.shift()
			}
			b.beginPath();
			b.moveTo(a[0] + 0.5, a[1] + 0.5);
			while (d.length > 0) {
				a = d.shift();
				while (a[0] == null || a[1] == null) {
					a = d.shift()
				}
				b.lineTo(a[0] + 0.5, a[1] + 0.5)
			}
			if (!c) {
				b.closePath()
			}
		}
	};
	this.drawShapeFillStroke = function(b, d, c) {
		var a = this.meta.canvas.ctx;
		if (c && c == "open") {
			a.stroke()
		} else {
			if (d == b) {
				a.fill()
			} else {
				a.stroke();
				a.fill()
			}
		}
	};
	this.drawShapeRestore = function(a, d, c) {
		var b = this.meta.canvas.ctx;
		this.setShadow(false);
		if (c) {
			b.rotate(-c)
		}
		b.translate(-a, -d)
	};
	this.drawShape = function(V, Q, P, S, ak, al, ab, aa, X, O, aq, at, W, an, T, ao) {
		var M, ar, N, j, au, Y, ae;
		var I = this.meta.canvas.ctx;
		if (aa) {
			switch (aa) {
				case "closed":
				case "solid":
				case "open":
					break;
				default:
					var av = aa;
					aa = "closed";
					this.drawShape(V, Q, P, S, ak, al, al, aa, X, O, aq, at, W, an, T, ao);
					aa = av;
					break
			}
		}
		switch (V) {
			case "polygon":
			case "path":
			case "spline":
			case "arch":
			case "arc2":
			case "hull":
			case "confidence":
			case "violin":
				var ag = Number.MAX_VALUE;
				var L = Number.MAX_VALUE * -1;
				var af = Number.MAX_VALUE;
				var J = Number.MAX_VALUE * -1;
				var Z = [];
				ar = [];
				M = [];
				N = ["poly"];
				if (Q.length == P.length) {
					if (V == "spline" && Q.length < 5) {
						return this.drawShape("polygon", Q, P, S, ak, al, ab, aa, X, O, aq, at, W, an, T, ao)
					}
					if (V == "arch" && (Q.length != 6 || P.length != 6 || S.length != 4 || ak == null)) {
						return false
					}
					if (V == "path" && aq) {}
					if (V == "confidence") {
						if (this.isArray(P[0])) {
							for (var aj = 0; aj < Q.length; aj++) {
								if (Q[aj] != null && P[aj][0] != null && P[aj][1] != null && this.validateNumbers([Q[aj], P[aj][0], P[aj][1]])) {
									ag = Math.min(ag, Q[aj]);
									L = Math.max(L, Q[aj]);
									af = Math.min(af, Math.min(P[aj][0], P[aj][1]));
									J = Math.max(J, Math.max(P[aj][0], P[aj][1]));
									M.push([Q[aj],
										[P[aj][0], P[aj][1]]
									]);
									N.push(Q[aj], P[aj][0] - 2);
									Z.push(P[aj][1] + 2, Q[aj])
								}
							}
							Q = (ag + L) / 2;
							P = (af + J) / 2;
							for (var aj = 0; aj < M.length; aj++) {
								M[aj][0] -= Q;
								M[aj][1][0] -= P;
								M[aj][1][1] -= P;
								ar.push(M[aj][0], [M[aj][1][0], M[aj][1][1]])
							}
						} else {
							for (var aj = 0; aj < P.length; aj++) {
								if (Q[aj][0] != null && Q[aj][1] != null && P[aj] != null && this.validateNumbers([Q[aj][0], Q[aj][1], P[aj]])) {
									ag = Math.min(ag, Math.min(Q[aj][0], Q[aj][1]));
									L = Math.max(L, Math.max(Q[aj][0], Q[aj][1]));
									af = Math.min(af, P[aj]);
									J = Math.max(J, P[aj]);
									M.push([
										[Q[aj][0], Q[aj][1]], P[aj]
									]);
									N.push(Q[aj][0] - 2, P[aj]);
									Z.push(P[aj], Q[aj][1] + 2)
								}
							}
							Q = (ag + L) / 2;
							P = (af + J) / 2;
							for (var aj = 0; aj < M.length; aj++) {
								M[aj][0][0] -= Q;
								M[aj][0][1] -= Q;
								M[aj][1] -= P;
								ar.push([M[aj][0][0], M[aj][0][1]], M[aj][1])
							}
						}
					} else {
						if (V == "arc2") {
							Z = this.traceArc(Q, P, ak, W, an, true);
							for (var aj = 0; aj < Z.length; aj++) {
								N.push(Z[aj][0], Z[aj][1])
							}
							Z = this.traceArc(Q, P, ak - S, W, an);
							for (var aj = 0; aj < Z.length; aj++) {
								N.push(Z[aj][0], Z[aj][1])
							}
						} else {
							if (V == "violin") {
								if (Q[0].length == P[0].length && Q[1].length == P[1].length && Q[0].length == Q[1].length) {
									for (var aj = 0; aj < Q[0].length; aj++) {
										if (this.validateNumbers([Q[0][aj], Q[1][aj], P[0][aj], P[1][aj]])) {
											ag = Math.min(ag, Math.min(Q[0][aj], Q[1][aj]));
											L = Math.max(L, Math.max(Q[0][aj], Q[1][aj]));
											af = Math.min(af, Math.min(P[0][aj], P[1][aj]));
											J = Math.max(J, Math.max(P[0][aj], P[1][aj]));
											M.push([
												[Q[0][aj], Q[1][aj]],
												[P[0][aj], P[1][aj]]
											]);
											N.push(Q[0][aj], P[0][aj]);
											Z.push(Q[1][aj], P[1][aj])
										}
									}
									Q = (ag + L) / 2;
									P = (af + J) / 2;
									for (var aj = 0; aj < M.length; aj++) {
										M[aj][0][0] -= Q;
										M[aj][0][1] -= Q;
										M[aj][1][0] -= P;
										M[aj][1][1] -= P;
										ar.push([M[aj][0][0], M[aj][0][1]], [M[aj][1][0], M[aj][1][1]])
									}
								} else {
									return false
								}
							} else {
								for (var aj = 0; aj < Q.length; aj++) {
									if (Q[aj] && P[aj] && this.validateNumbers([Q[aj], P[aj]])) {
										ag = Math.min(ag, Q[aj]);
										L = Math.max(L, Q[aj]);
										af = Math.min(af, P[aj]);
										J = Math.max(J, P[aj]);
										M.push([Q[aj], P[aj]]);
										if (V == "spline") {
											N.push(Q[aj], P[aj] - 2);
											Z.push(P[aj] + 2, Q[aj])
										} else {
											if (V != "arch") {
												N.push(Q[aj], P[aj])
											}
										}
									}
								}
								if (V == "arch") {
									Z = this.traceQuadraticCurve(Q[0], P[0], Q[1], P[1], Q[2], P[2], 0.25, true);
									for (var aj = 0; aj < Z.length; aj++) {
										N.push(Z[aj][0], Z[aj][1])
									}
									Z = this.traceArc(Q[1], P[1], ak, S[0], S[1], true);
									for (var aj = 0; aj < Z.length; aj++) {
										N.push(Z[aj][0], Z[aj][1])
									}
									Z = this.traceQuadraticCurve(Q[3], P[3], Q[4], P[4], Q[5], P[5], 0.25);
									for (var aj = 0; aj < Z.length; aj++) {
										N.push(Z[aj][0], Z[aj][1])
									}
									Z = this.traceArc(Q[4], P[4], ak, S[2], S[3]);
									for (var aj = 0; aj < Z.length; aj++) {
										N.push(Z[aj][0], Z[aj][1])
									}
								}
								Q = V == "arch" ? Q[1] : (ag + L) / 2;
								P = V == "arch" ? P[1] : (af + J) / 2;
								for (var aj = 0; aj < M.length; aj++) {
									M[aj][0] -= Q;
									M[aj][1] -= P;
									ar.push(M[aj][0], M[aj][1])
								}
							}
						}
					}
					if (V == "spline" || V == "confidence") {
						N = N.concat(Z.reverse())
					}
				} else {
					return false
				}
				break;
			default:
				if (this.validateNumbers([Q, P, S, ak])) {
					if (aq) {
						M = this.clip(V, [Q, P, S, ak], at);
						if (M) {
							if (M.length == 4) {
								S = Math.max(1, M[2]);
								ak = Math.max(1, M[3]);
								Q = M[0] + (S / 2);
								P = M[1] + (ak / 2)
							} else {
								if (M.length == 2) {
									Q = M[0];
									P = M[1]
								}
							}
						} else {
							return false
						}
					} else {
						S = Math.max(1, S);
						ak = Math.max(1, ak)
					}
					j = S / 2;
					au = ak / 2;
					Y = ak / S;
					ae = 1.5;
					N = ["rect", Q - j, P - au, Q + j, P + au]
				} else {
					return false
				}
				break
		}
		switch (V) {
			case "image":
				if (T && (CanvasXpress.cacheImages[this.getFileName(T)] || CanvasXpress.images[T])) {
					N = ["rect", Q - (j * this.zoom), P - (au * this.zoom), Q + (j * this.zoom), P + (au * this.zoom)];
					this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
					if (CanvasXpress.images[T]) {
						this.drawImage(CanvasXpress.images[T], -j * this.zoom, -au * this.zoom, S * this.zoom, ak * this.zoom)
					} else {
						this.drawImage(CanvasXpress.cacheImages[this.getFileName(T)], -j * this.zoom, -au * this.zoom, S * this.zoom, ak * this.zoom)
					}
				} else {
					return this.drawShape("rectangle", Q, P, S, ak, "rgba(0,0,0,0.5)", "rgba(0,0,0,0.5)", aa, X, O, aq, at, W, an, T, ao)
				}
				break;
			case "circle":
			case "sphere":
				N = ["circle", Q, P, S / 2];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.arc(0, 0, S / 2, 0, Math.PI * 2, true);
				I.closePath();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "box":
			case "rect":
			case "rectangle":
				M = [
					[-j, -au],
					[j, -au],
					[j, au],
					[-j, au]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.moveTo(-j + 0.5, -au + 0.5);
				I.lineTo(j + 0.5, -au + 0.5);
				I.lineTo(j + 0.5, au + 0.5);
				I.lineTo(-j + 0.5, au + 0.5);
				I.closePath();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "rect2":
				return this.drawShape("rectangle", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, W, an, T, ao);
				break;
			case "rect3":
				return this.drawShape("rectangle", Q, P, S, S / 3, al, ab, aa, X, O, aq, at, W, an, T, ao);
				break;
			case "roundrect":
				var R = S > ak ? ak / 4 : S / 4;
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.moveTo(-j, -au + R);
				I.lineTo(-j, au - R);
				I.quadraticCurveTo(-j, au, -j + R, au);
				I.lineTo(j - R, au);
				I.quadraticCurveTo(j, au, j, au - R);
				I.lineTo(j, -au + R);
				I.quadraticCurveTo(j, -au, j - R, -au);
				I.lineTo(-j + R, -au);
				I.quadraticCurveTo(-j, -au, -j, -au + R);
				I.closePath();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "square":
				M = [
					[-j, -j],
					[j, -j],
					[j, j],
					[-j, j]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "triangle":
				if (S == ak) {
					return this.drawShape("equilateral", Q, P, S, ak, al, ab, aa, X, O, aq, at, W, an, T, ao)
				}
				N = ["poly", Q, P - au, Q + j, P + au, Q - j, P + au];
				M = [
					[0, -au],
					[j, au],
					[-j, au]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "triangle2":
				if (S == ak) {
					return this.drawShape("equilateral2", Q, P, S, ak, al, ab, aa, X, O, aq, at, W, an, T, ao)
				}
				N = ["poly", Q, P + au, Q + j, P - au, Q - j, P - au];
				M = [
					[0, au],
					[j, -au],
					[-j, -au]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "equilateral":
				var R = S * Math.sqrt(3) / 6;
				var g = R / 2;
				var C = Math.sqrt((R * R) - (g * g));
				N = ["poly", Q, P - R, Q + C, P + g, Q - C, P + g];
				M = [
					[0, -au],
					[j, au],
					[-j, au]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "equilateral2":
				var R = S * Math.sqrt(3) / 6;
				var g = R / 2;
				var C = Math.sqrt((R * R) - (g * g));
				N = ["poly", Q, P + R, Q + C, P - g, Q - C, P - g];
				M = [
					[0, au],
					[j, -au],
					[-j, -au]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "diamond":
			case "rhombus":
				N = ["poly", Q, P - au, Q + j, P, Q, P + au, Q - j, P];
				M = [
					[0, -au],
					[j, 0],
					[0, au],
					[-j, 0]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "hexagon":
				var ap = S / 3;
				var q = ap - j;
				M = [
					[q, -au],
					[-q, -au],
					[j, 0],
					[-q, au],
					[q, au],
					[-j, 0]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "octagon":
				var aw = S / 4;
				var ai = ak / 4;
				M = [
					[-aw, -au],
					[aw, -au],
					[j, -ai],
					[j, ai],
					[aw, au],
					[-aw, au],
					[-j, ai],
					[-j, -ai]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "oval":
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.save();
				I.scale(1, Y);
				I.beginPath();
				I.arc(0, 0, S / 2, 0, Math.PI * 2, true);
				I.closePath();
				I.restore();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "oval2":
				return this.drawShape("oval", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, W, an, T, ao);
				break;
			case "oval3":
				return this.drawShape("oval", Q, P, S, S / 3, al, ab, aa, X, O, aq, at, W, an, T, ao);
				break;
			case "arc":
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.save();
				I.scale(1, Y);
				I.beginPath();
				I.arc(0, 0, S / 2, 0, Math.PI, true);
				if (aa != "open") {
					I.closePath()
				}
				I.restore();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "arc2":
				var E = ak * Math.cos(W);
				var az = ak * Math.sin(W);
				var D = ak * Math.cos(an);
				var ax = ak * Math.sin(an);
				var B = this.shortenLine(0, 0, E, az, 0, S, "line");
				var v = this.shortenLine(0, 0, D, ax, 0, S, "line");
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.moveTo(B[2], B[3]);
				I.lineTo(E, az);
				I.arc(0, 0, ak, W, an, false);
				I.lineTo(v[2], v[3]);
				I.arc(0, 0, ak - S, an, W, true);
				I.closePath();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "arc3":
				aa = "open";
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.arc(0, 0, S, W, an, false);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "arch":
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.moveTo(M[0][0], M[0][1]);
				I.quadraticCurveTo(M[1][0], M[1][1], M[2][0], M[2][1]);
				I.arc(0, 0, ak, S[3], S[2], true);
				I.quadraticCurveTo(M[4][0], M[4][1], M[5][0], M[5][1]);
				I.arc(0, 0, ak, S[1], S[0], true);
				I.closePath();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "path":
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M, open);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "polygon":
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "spline":
				var U = [];
				var ad = [];
				var F = [];
				ad.push(ar.shift());
				ad.push(ar.shift());
				F.push(ar.pop());
				F.unshift(ar.pop());
				var ac = ar.length;
				for (var aj = 0; aj < ac - 4; aj += 2) {
					U = U.concat(this.splineControlPoint(ar[aj], ar[aj + 1], ar[aj + 2], ar[aj + 3], ar[aj + 4], ar[aj + 5]))
				}
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.moveTo(ad[0], ad[1]);
				I.lineTo(ar[0], ar[1]);
				I.quadraticCurveTo(U[0], U[1], ar[2], ar[3]);
				for (var aj = 2; aj < ac - 5; aj += 2) {
					I.bezierCurveTo(U[2 * aj - 2], U[2 * aj - 1], U[2 * aj], U[2 * aj + 1], ar[aj + 2], ar[aj + 3])
				}
				I.quadraticCurveTo(U[2 * ac - 10], U[2 * ac - 9], ar[ac - 2], ar[ac - 1]);
				I.lineTo(F[0], F[1]);
				I.lineTo(ad[0], ad[1]);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "hull":
				var ah;
				var ac = 1;
				var G = [];
				while (ar.length > 1) {
					G.push([ar.shift(), ar.shift()])
				}
				var U = this.hullControlPoints(G);
				var m = [
					[G[0][0], G[0][1], U[U.length - 1][0], U[U.length - 1][1], U[0][0], U[0][1], G[1][0], G[1][1]]
				];
				for (var aj = 1; aj < G.length - 1; aj++) {
					m.push([G[aj][0], G[aj][1], U[ac][0], U[ac][1], U[ac + 1][0], U[ac + 1][1], G[aj + 1][0], G[aj + 1][1]]);
					ac += 2
				}
				m.push([G[aj][0], G[aj][1], U[ac][0], U[ac][1], U[ac + 1][0], U[ac + 1][1], G[0][0], G[0][1]]);
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.moveTo(m[0][0], m[0][1]);
				for (var aj = 0; aj < m.length; aj++) {
					I.bezierCurveTo(m[aj][2], m[aj][3], m[aj][4], m[aj][5], m[aj][6], m[aj][7])
				}
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "violin":
				var ac = ar.length;
				var U = [];
				var K = [];
				for (var aj = 0; aj < ac - 4; aj += 2) {
					var ay = (ac - 1) - aj;
					U = U.concat(this.splineControlPoint(ar[aj][0], ar[aj + 1][0], ar[aj + 2][0], ar[aj + 3][0], ar[aj + 4][0], ar[aj + 5][0]));
					K = K.concat(this.splineControlPoint(ar[ay - 1][1], ar[ay][1], ar[ay - 3][1], ar[ay - 2][1], ar[ay - 5][1], ar[ay - 4][1]))
				}
				if (this.graphOrientation == "vertical") {
					for (var aj = 0; aj < U.length - 1; aj += 2) {
						if (U[aj] > 0) {
							U[aj] = 0
						}
						if (K[aj] < 0) {
							K[aj] = 0
						}
					}
				} else {
					for (var aj = 1; aj < U.length; aj += 2) {
						if (U[aj] > 0) {
							U[aj] = 0
						}
						if (K[aj] < 0) {
							K[aj] = 0
						}
					}
				}
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.moveTo(ar[0][0], ar[1][0]);
				I.quadraticCurveTo(U[0], U[1], ar[2][0], ar[3][0]);
				for (var aj = 2; aj < ac - 5; aj += 2) {
					I.bezierCurveTo(U[2 * aj - 2], U[2 * aj - 1], U[2 * aj], U[2 * aj + 1], ar[aj + 2][0], ar[aj + 3][0])
				}
				I.quadraticCurveTo(U[2 * ac - 10], U[2 * ac - 9], ar[ac - 2][0], ar[ac - 1][0]);
				I.lineTo(ar[ac - 2][1], ar[ac - 1][1]);
				I.quadraticCurveTo(K[0], K[1], ar[ac - 4][1], ar[ac - 3][1]);
				for (var aj = 2; aj < ac - 5; aj += 2) {
					var ay = (ac - 1) - aj;
					I.bezierCurveTo(K[2 * aj - 2], K[2 * aj - 1], K[2 * aj], K[2 * aj + 1], ar[ay - 3][1], ar[ay - 2][1])
				}
				I.quadraticCurveTo(K[2 * ac - 10], K[2 * ac - 9], ar[0][1], ar[1][1]);
				I.lineTo(ar[0][0], ar[1][0]);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "confidence":
				var ac = ar.length;
				var U = [];
				var K = [];
				if (this.isArray(ar[0])) {
					for (var aj = 0; aj < ac - 4; aj += 2) {
						var ay = (ac - 1) - aj;
						U = U.concat(this.splineControlPoint(ar[aj][0], ar[aj + 1], ar[aj + 2][0], ar[aj + 3], ar[aj + 4][0], ar[aj + 5]));
						K = K.concat(this.splineControlPoint(ar[ay - 1][1], ar[ay], ar[ay - 3][1], ar[ay - 2], ar[ay - 5][1], ar[ay - 4]))
					}
					this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
					I.beginPath();
					I.moveTo(ar[0][0], ar[1]);
					I.quadraticCurveTo(U[0], U[1], ar[2][0], ar[3]);
					for (var aj = 2; aj < ac - 5; aj += 2) {
						I.bezierCurveTo(U[2 * aj - 2], U[2 * aj - 1], U[2 * aj], U[2 * aj + 1], ar[aj + 2][0], ar[aj + 3])
					}
					I.quadraticCurveTo(U[2 * ac - 10], U[2 * ac - 9], ar[ac - 2][0], ar[ac - 1]);
					I.lineTo(ar[ac - 2][1], ar[ac - 1]);
					I.quadraticCurveTo(K[0], K[1], ar[ac - 4][1], ar[ac - 3]);
					for (var aj = 2; aj < ac - 5; aj += 2) {
						var ay = (ac - 1) - aj;
						I.bezierCurveTo(K[2 * aj - 2], K[2 * aj - 1], K[2 * aj], K[2 * aj + 1], ar[ay - 3][1], ar[ay - 2])
					}
					I.quadraticCurveTo(K[2 * ac - 10], K[2 * ac - 9], ar[0][1], ar[1]);
					I.lineTo(ar[0][0], ar[1]);
					this.drawShapeFillStroke(al, ab, aa)
				} else {
					for (var aj = 0; aj < ac - 4; aj += 2) {
						var ay = (ac - 1) - aj;
						U = U.concat(this.splineControlPoint(ar[aj], ar[aj + 1][0], ar[aj + 2], ar[aj + 3][0], ar[aj + 4], ar[aj + 5][0]));
						K = K.concat(this.splineControlPoint(ar[ay - 1], ar[ay][1], ar[ay - 3], ar[ay - 2][1], ar[ay - 5], ar[ay - 4][1]))
					}
					this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
					I.beginPath();
					I.moveTo(ar[0], ar[1][0]);
					I.quadraticCurveTo(U[0], U[1], ar[2], ar[3][0]);
					for (var aj = 2; aj < ac - 5; aj += 2) {
						I.bezierCurveTo(U[2 * aj - 2], U[2 * aj - 1], U[2 * aj], U[2 * aj + 1], ar[aj + 2], ar[aj + 3][0])
					}
					I.quadraticCurveTo(U[2 * ac - 10], U[2 * ac - 9], ar[ac - 2], ar[ac - 1][0]);
					I.lineTo(ar[ac - 2], ar[ac - 1][1]);
					I.quadraticCurveTo(K[0], K[1], ar[ac - 4], ar[ac - 3][1]);
					for (var aj = 2; aj < ac - 5; aj += 2) {
						var ay = (ac - 1) - aj;
						I.bezierCurveTo(K[2 * aj - 2], K[2 * aj - 1], K[2 * aj], K[2 * aj + 1], ar[ay - 3], ar[ay - 2][1])
					}
					I.quadraticCurveTo(K[2 * ac - 10], K[2 * ac - 9], ar[0], ar[1][1]);
					I.lineTo(ar[0], ar[1][0]);
					this.drawShapeFillStroke(al, ab, aa)
				}
				break;
			case "ellipse":
				var a = j * 0.5522848;
				var am = au * 0.5522848;
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.moveTo(0, au);
				I.bezierCurveTo(0, au - am, j - a, 0, j, 0);
				I.bezierCurveTo(j + a, 0, S, au - am, S, au);
				I.bezierCurveTo(S, au + am, j + a, ak, j, ak);
				I.bezierCurveTo(j - a, ak, 0, au + am, 0, au);
				I.closePath();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "ellipse2":
				return this.drawShape("ellipse", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, W, an, T, ao);
				break;
			case "ellipse3":
				return this.drawShape("ellipse", Q, P, S, S / 3, al, ab, aa, X, O, aq, at, W, an, T, ao);
				break;
			case "plus":
				M = [
					[-ae, -au],
					[ae, -au],
					[ae, -ae],
					[j, -ae],
					[j, ae],
					[ae, ae],
					[ae, au],
					[-ae, au],
					[-ae, ae],
					[-j, ae],
					[-j, -ae],
					[-ae, -ae],
					[-ae, -au]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "minus":
				M = [
					[-j, -ae],
					[j, -ae],
					[j, ae],
					[-j, ae],
					[-j, -ae]
				];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				this.drawShapeDraw(M);
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "mdavid":
				var ap = S / 3;
				var A = Math.PI / 6;
				N = ["circle", Q, P, S / 2];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.save();
				I.scale(0.8, 0.8);
				I.rotate(H * 0.45);
				I.beginPath();
				I.moveTo(ap, 0);
				for (var aj = 0; aj < 11; aj++) {
					I.rotate(A);
					if (aj % 2 == 0) {
						I.lineTo((ap / 0.55), 0)
					} else {
						I.lineTo(ap, 0)
					}
				}
				I.closePath();
				I.restore();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "star":
				var k = (S / 4);
				var H = Math.PI / 5;
				N = ["circle", Q, P, S / 2];
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.save();
				I.scale(0.7, 0.7);
				I.rotate(H * 0.45);
				I.beginPath();
				I.moveTo(k, 0);
				for (var aj = 0; aj < 9; aj++) {
					I.rotate(H);
					if (aj % 2 == 0) {
						I.lineTo((k / 0.35), 0)
					} else {
						I.lineTo(k, 0)
					}
				}
				I.closePath();
				I.restore();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "pie":
				if (typeof(W) == "undefined") {
					W = 0
				}
				if (typeof(an) == "undefined") {
					an = Math.PI * 2
				}
				this.drawShapeSetShapeStyle(Q, P, S, ak, al, ab, aa, X, O);
				I.beginPath();
				I.arc(0, 0, S / 2, W, an, false);
				I.lineTo(0, 0);
				I.closePath();
				this.drawShapeFillStroke(al, ab, aa);
				break;
			case "pie0":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI / 5, T, ao);
				break;
			case "pie1":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI / 3.5, T, ao);
				break;
			case "pie2":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI / 2, T, ao);
				break;
			case "pie3":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI / 1.5, T, ao);
				break;
			case "pie4":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI, T, ao);
				break;
			case "pie5":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI * 1.2, T, ao);
				break;
			case "pie6":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI * 1.4, T, ao);
				break;
			case "pie7":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI * 1.6, T, ao);
				break;
			case "pie8":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI * 1.8, T, ao);
				break;
			case "pie9":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, 0, Math.PI * 2, T, ao);
				break;
			case "pacman":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, Math.PI * 1 / 4, Math.PI * 7 / 4, T, ao);
				break;
			case "pacman2":
				return this.drawShape("pie", Q, P, S, S / 2, al, ab, aa, X, O, aq, at, Math.PI * 5 / 4, Math.PI * 3 / 4, T, ao);
				break
		}
		this.drawShapeRestore(Q, P, X);
		return N
	};
	this.drawImage = function(d, b, c, a, g, f) {
		try {
			this.meta.canvas.ctx.drawImage(d, b, c, a, g)
		} catch (k) {
			var j = this;
			setTimeout(function() {
				j.draw()
			}, 100)
		}
	};
	this.drawVideo = function(c, b, d) {
		var e = this;
		var a = this.meta.canvas.ctx;
		if (c.paused || c.ended) {
			return false
		}
		a.drawImage(c, 0, 0, b, d);
		this.videoUpdate();
		setTimeout(function() {
			e.drawVideo(c, b, d)
		}, 50)
	};
	this.expandPolygon = function(o, w) {
		var b = function(i) {
			var d = Math.sqrt(i.x * i.x + i.y * i.y);
			return {
				x: i.x / d,
				y: i.y / d
			}
		};
		var s = function(d, i) {
			return {
				x: d.x * i,
				y: d.y * i
			}
		};
		var l = function(i, d) {
			return i.x * d.x + i.y * d.y
		};
		var c = function(d) {
			return {
				x: d.y,
				y: -d.x
			}
		};
		var x = function(d) {
			return {
				x: -d.y,
				y: d.x
			}
		};
		var v = function(F, E) {
			var i = F[1].x - F[0].x;
			var D = E[0].x - E[1].x;
			var B = E[0].x - F[0].x;
			var d = F[1].y - F[0].y;
			var C = E[0].y - E[1].y;
			var p = E[0].y - F[0].y;
			var G = (D * p - C * B) / (d * D - i * C);
			return {
				x: F[0].x + G * (F[1].x - F[0].x),
				y: F[0].y + G * (F[1].y - F[0].y)
			}
		};
		var z = function(d) {
			return l(c({
				x: d[1].x - d[0].x,
				y: d[1].y - d[0].y
			}), {
				x: d[2].x - d[1].x,
				y: d[2].y - d[1].y
			}) >= 0
		};
		var t = [];
		var g = z(o) ? x : c;
		for (var u = 0; u < o.length; ++u) {
			var k = o[(u > 0) ? u - 1 : o.length - 1];
			var h = o[u];
			var f = o[(u < o.length - 1) ? u + 1 : 0];
			var m = {
				x: h[0] - k[0],
				y: h[1] - k[1]
			};
			var y = {
				x: f[0] - h[0],
				y: f[1] - h[1]
			};
			var n = s(b(g(m)), w);
			var A = s(b(g(y)), w);
			var r = {
				x: k[0] + n.x,
				y: k[1] + n.y
			};
			var j = {
				x: h[0] + n.x,
				y: h[1] + n.y
			};
			var e = {
				x: h[0] + A.x,
				y: h[1] + A.y
			};
			var q = {
				x: f[0] + A.x,
				y: f[1] + A.y
			};
			var a = v([r, j], [e, q]);
			t.push([a.x, a.y])
		}
		return t
	};
	this.setGlobalCompositionOperation = function(a) {
		if (!this.meta.system.isIE && a) {
			this.meta.canvas.ctx.globalCompositeOperation = a
		}
	};
	this.rectangleClear = function(a, d, b, c) {
		this.meta.canvas.ctx.clearRect(a, d, b, c)
	};
	this.translateCanvas = function(a, b) {
		this.meta.canvas.ctx.translate(a, b)
	};
	this.rotateCanvas = function(a) {
		this.meta.canvas.ctx.rotate(a)
	};
	this.scaleCanvas = function(a, b) {
		this.meta.canvas.ctx.scale(a, b)
	};
	this.saveCanvas = function() {
		this.meta.canvas.ctx.save()
	};
	this.restoreCanvas = function() {
		this.meta.canvas.ctx.restore()
	};
	this.setLineTypes = function() {
		var e = ["line"];
		var c = ["", "dashed", "dotted", "bezierY", "bezierX", "curved"];
		var a = ["arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"];
		for (var d = 0; d < a.length; d++) {
			e.push(a[d] + "Line")
		}
		for (var d = 1; d < c.length; d++) {
			for (var b = 0; b < a.length; b++) {
				e.push(c[d] + this.capitalize(a[b]) + "Line")
			}
		}
		this.lines = e
	};
	this.setAmbiguityCodes = function() {
		this.ambiguityCodes = {
			"-": ["-"],
			A: ["A"],
			C: ["C"],
			G: ["G"],
			T: ["T"],
			M: ["A", "C"],
			R: ["A", "G"],
			W: ["A", "T"],
			S: ["C", "G"],
			Y: ["C", "T"],
			K: ["G", "T"],
			V: ["A", "C", "G"],
			H: ["A", "C", "T"],
			D: ["A", "G", "T"],
			B: ["C", "G", "T"],
			N: ["A", "C", "G", "T"],
			X: ["A", "C", "G", "T"]
		}
	};
	this.setCodonTable = function() {
		this.codon = {
			TTT: ["F", "Phe", "Phenylalanine"],
			TCT: ["S", "Ser", "Serine"],
			TAT: ["Y", "Tyr", "Tyrosine"],
			TGT: ["C", "Cys", "Cysteine"],
			TTC: ["F", "Phe", "Phenylalanine"],
			TCC: ["S", "Ser", "Serine"],
			TAC: ["Y", "Tyr", "Tyrosine"],
			TGC: ["C", "Cys", "Cysteine"],
			TTA: ["L", "Leu", "Leucine"],
			TCA: ["S", "Ser", "Serine"],
			TAA: ["*", "Stop", "Ochre"],
			TGA: ["*", "Stop", "Opal"],
			TTG: ["L", "Leu", "Leucine"],
			TCG: ["S", "Ser", "Serine"],
			TAG: ["*", "Stop", "Amber"],
			TGG: ["W", "Trp", "Tryptophan"],
			CTT: ["L", "Leu", "Leucine"],
			CCT: ["P", "Pro", "Proline"],
			CAT: ["H", "His", "Histidine"],
			CGT: ["R", "Arg", "Arginine"],
			CTC: ["L", "Leu", "Leucine"],
			CCC: ["P", "Pro", "Proline"],
			CAC: ["H", "His", "Histidine"],
			CGC: ["R", "Arg", "Arginine"],
			CTA: ["L", "Leu", "Leucine"],
			CCA: ["P", "Pro", "Proline"],
			CAA: ["Q", "Gln", "Glutamine"],
			CGA: ["R", "Arg", "Arginine"],
			CTG: ["L", "Leu", "Leucine"],
			CCG: ["P", "Pro", "Proline"],
			CAG: ["Q", "Gln", "Glutamine"],
			CGG: ["R", "Arg", "Arginine"],
			ATT: ["I", "Ile", "Isoleucine"],
			ACT: ["T", "Thr", "Threonine"],
			AAT: ["N", "Asn", "Asparagine"],
			AGT: ["S", "Ser", "Serine"],
			ATC: ["I", "Ile", "Isoleucine"],
			ACC: ["T", "Thr", "Threonine"],
			AAC: ["N", "Asn", "Asparagine"],
			AGC: ["S", "Ser", "Serine"],
			ATA: ["I", "Ile", "Isoleucine"],
			ACA: ["T", "Thr", "Threonine"],
			AAA: ["K", "Lys", "Lysine"],
			AGA: ["R", "Arg", "Arginine"],
			ATG: ["M", "Met", "Methionine"],
			ACG: ["T", "Thr", "Threonine"],
			AAG: ["K", "Lys", "Lysine"],
			AGG: ["R", "Arg", "Arginine"],
			GTT: ["V", "Val", "Valine"],
			GCT: ["A", "Ala", "Alanine"],
			GAT: ["D", "Asp", "Aspartic acid"],
			GGT: ["G", "Gly", "Glycine"],
			GTC: ["V", "Val", "Valine"],
			GCC: ["A", "Ala", "Alanine"],
			GAC: ["D", "Asp", "Aspartic acid"],
			GGC: ["G", "Gly", "Glycine"],
			GTA: ["V", "Val", "Valine"],
			GCA: ["A", "Ala", "Alanine"],
			GAA: ["E", "Glu", "Glutamic acid"],
			GGA: ["G", "Gly", "Glycine"],
			GTG: ["V", "Val", "Valine"],
			GCG: ["A", "Ala", "Alanine"],
			GAG: ["E", "Glu", "Glutamic acid"],
			GGG: ["G", "Gly", "Glycine"]
		}
	};
	this.setReverseComplement = function() {
		this.reverseComplement = {
			A: "T",
			C: "G",
			G: "C",
			T: "A",
			U: "A",
			Y: "R",
			R: "Y",
			W: "W",
			S: "S",
			K: "M",
			M: "K",
			B: "V",
			V: "B",
			D: "H",
			H: "D",
			X: "X",
			N: "N",
			a: "t",
			c: "g",
			g: "c",
			t: "a",
			u: "a",
			y: "r",
			r: "y",
			w: "w",
			s: "s",
			k: "m",
			m: "k",
			b: "v",
			v: "b",
			d: "h",
			h: "d",
			x: "x",
			n: "n",
			" ": " ",
			"-": "-",
			"/": "/",
			"[": "[",
			"]": "]"
		}
	};
	this.initializeAttributes = function() {
		this.setLineTypes();
		this.setCodonTable();
		this.setReverseComplement()
	};
	this.initializeAttributes()
};
CanvasXpress.prototype.initRangeAlgorithms = function() {
	this.heckbert = function(d, j, a) {
		var c = function(i, l) {
			var n;
			var o = Math.floor(Math.log(i) / Math.LN10);
			var m = i / Math.pow(10, o);
			if (l) {
				if (m < 1.5) {
					n = 1
				} else {
					if (m < 3) {
						n = 2
					} else {
						if (m < 7) {
							n = 5
						} else {
							n = 10
						}
					}
				}
			} else {
				if (m < 1) {
					n = 1
				} else {
					if (m < 2) {
						n = 2
					} else {
						if (m < 5) {
							n = 5
						} else {
							n = 10
						}
					}
				}
			}
			return n * Math.pow(10, o)
		};
		var h = [];
		var f = c(j - d, false);
		var k = c(f / (a - 1), true);
		var b = Math.floor(d / k) * k;
		var g = Math.ceil(j / k) * k;
		for (var e = b; e <= g; e += k) {
			h.push(this.correctPrecisionBug(e))
		}
		return h
	};
	this.wilkinson = function(c, g, a) {
		var b = function(z, B, A, y) {
			var u = [10, 1, 5, 2, 2.5, 3, 4, 1.5, 7, 6, 8, 9];
			var w = B - z;
			var r = A - 1;
			var o = 1 - Math.abs(A - y) / y;
			var D = w / r;
			var t = Math.floor(Math.log(D) / Math.LN10);
			var E = Math.pow(10, t);
			var p = null;
			for (var C = 0; C < u.length; C++) {
				var s = u[C] * E;
				var F = Math.floor(z / s) * s;
				var n = F + r * s;
				if (F <= z && n >= B) {
					var v = 1 - (C - (F <= 0 && n >= 0 ? 1 : 0)) / u.length;
					var q = (B - z) / (n - F);
					if (q > 0.8) {
						var x = o + v + q;
						if (p == null || x > p.score) {
							p = {
								lmin: F,
								lmax: n,
								lstep: s,
								score: x
							}
						}
					}
				}
			}
			return p
		};
		var h = [];
		var e = null;
		var j = [];
		for (var f = Math.max(Math.floor(a / 2), 2); f <= Math.ceil(6 * a); f++) {
			j.push(f)
		}
		for (var f = 0; f < j.length; f++) {
			var d = j[f];
			var l = b(c, g, d, a);
			if ((l != null && e == null) || (l && e && l.score > e.score)) {
				e = l
			}
		}
		for (var f = e.lmin; f <= e.lmax; f += e.lstep) {
			h.push(this.correctPrecisionBug(f))
		}
		return h
	};
	this.wilkinsonExtended = function(a, y, R, C) {
		var A = 2.22e-14;
		var f = function(j, g) {
			for (var c = 0; c < g.length; c++) {
				if (j == g[c]) {
					return c
				}
			}
		};
		var J = function(c, w, m, g, z, Y) {
			var k = w.length;
			var s = f(c, w);
			var Z = (g % Y < A || Y - (g % Y) < A) && g <= 0 && z >= 0 ? 1 : 0;
			return 1 - s / (k - 1) - m + Z
		};
		var K = function(s, m, g) {
			var w = m.length;
			var k = f(s, m);
			var c = 1;
			return 1 - k / (w - 1) - g + c
		};
		var h = function(c, i, j, g) {
			return 1 - 0.5 * (Math.pow(i - g, 2) + Math.pow(c - j, 2)) / Math.pow(0.1 * (i - c), 2)
		};
		var r = function(c, k, i) {
			var g = k - c;
			if (i > g) {
				var j = (i - g) / 2;
				return 1 - 0.5 * (Math.pow(j, 2) + Math.pow(j, 2)) / Math.pow(0.1 * g, 2)
			} else {
				return 1
			}
		};
		var o = function(j, c, i, s, w, q) {
			var n = (j - 1) / (q - w);
			var g = (c - 1) / (Math.max(q, s) - Math.min(i, w));
			return 2 - Math.max(n / g, g / n)
		};
		var X = function(g, c) {
			return g >= c ? 2 - (g - 1) / (c - 1) : 1
		};
		var e = [1, 5, 2, 2.5, 4, 3];
		var G = [0.25, 0.2, 0.5, 0.05];
		var P = e.length;
		var L = {
			score: -2
		};
		var H = [];
		if (a > y) {
			var l = a;
			a = y;
			y = l
		}
		if (y - a < A) {
			for (var U = 0; U <= R; U++) {
				H.push(a)
			}
			return H
		}
		var T = 1;
		while (T < Number.POSITIVE_INFINITY) {
			for (var U = 0; U < P; U++) {
				var N = e[U];
				var u = K(N, e, T);
				if ((G[0] * u + G[1] + G[2] + G[3] < L.score)) {
					T = Number.POSITIVE_INFINITY;
					break
				}
				var S = 2;
				while (S < Number.POSITIVE_INFINITY) {
					var p = X(S, R);
					if ((G[0] * u + G[1] + G[2] * p + G[3] < L.score)) {
						break
					}
					var E = (y - a) / (S + 1) / T / N;
					var F = Math.ceil(Math.log(E) / Math.LN10);
					while (F < Number.POSITIVE_INFINITY) {
						var D = T * N * Math.pow(10, F);
						var B = r(a, y, D * (S - 1));
						if ((G[0] * u + G[1] * B + G[2] * p + G[3] < L.score)) {
							break
						}
						var v = Math.floor(y / D) * T - (S - 1) * T;
						var O = Math.ceil(a / D) * T;
						if (v > O) {
							F++;
							continue
						}
						for (var x = v; x <= O; x++) {
							var t = x * (D / T);
							var M = t + D * (S - 1);
							var d = D;
							var I = J(N, e, T, t, M, d);
							var W = h(a, y, t, M);
							var V = o(S, R, a, y, t, M);
							var b = G[0] * I + G[1] * W + G[2] * V + G[3];
							if (b > L.score && (!C || (t <= a && M >= y))) {
								L = {
									lmin: t,
									lmax: M,
									lstep: d,
									score: b
								}
							}
						}
						F++
					}
					S++
				}
			}
			T++
		}
		for (var U = L.lmin; U <= L.lmax; U += L.lstep) {
			H.push(this.correctPrecisionBug(U))
		}
		return H
	};
	this.rPretty = function(o, p, r) {
		var a, e, b;
		var l = [];
		var q = Math.floor(r) - 1;
		var s = Math.floor(q % 3);
		var g = 0.75;
		var v = 1.5;
		var d = 0.5 + 1.5 * v;
		var f = p - o;
		if (f == 0 && p == 0) {
			a = 1;
			e = true;
			b = 1
		} else {
			a = Math.max(Math.abs(o), Math.abs(p));
			b = 1 + d >= 1.5 * v + 0.5 ? 1 / (1 + v) : 1.5 / 1 + d;
			e = f < (a * b * Math.max(1, q) * 1e-7 * 3)
		}
		if (e) {
			if (a > 10) {
				a = 9 + a / 10
			}
			a = a * g;
			if (s > 1) {
				a /= s
			}
		} else {
			a = f;
			if (q > 1) {
				a /= q
			}
		}
		if (a < 20 * 1e-7) {
			a = 20 * 1e-7
		}
		var c = Math.pow(10, Math.floor(Math.log(a) / Math.LN10));
		var j = c;
		if ((2 * c) - a < v * (a - j)) {
			j = 2 * c;
			if ((5 * c) - a < d * (a - j)) {
				j = 5 * c;
				if ((10 * c) - a < v * (a - j)) {
					j = 10 * c
				}
			}
		}
		var x = Math.floor(o / j + 1e-7);
		var w = Math.ceil(p / j - 1e-7);
		while (x * j > o + (1e-7 * j)) {
			x--
		}
		while (w * j < p - (1e-7 * j)) {
			w++
		}
		var t = Math.floor(0.5 + w - x);
		if (t < s) {
			t = s - t;
			if (x >= 0) {
				w += t / 2;
				x = x - t / 2 + t % 2
			} else {
				x -= t / 2;
				w = w + t / 2 + t % 2
			}
			q = s
		} else {
			q = t
		}
		for (var u = x * j; u <= w * j; u += j) {
			l.push(this.correctPrecisionBug(u))
		}
		return l
	};
	this.correctPrecisionBug = function(b) {
		var a = b.toString();
		if (a.match(/\.\d+00000+\d+$/)) {
			a = a.replace(/00000+\d+$/, "")
		} else {
			if (a.match(/\.\d+99999+\d+$/)) {
				a = a.replace(/99999+\d+$/, "9")
			}
		}
		return Number(a)
	};
	this.getAxisDecimals1 = function(a) {
		return a === 0 ? 0 : a.toExponential().replace(/e[\+\-0-9]*$/, "").replace(/^0\.0*|\./, "").length
	};
	this.getAxisDecimals2 = function(b) {
		var a = 1000000;
		var c = (((b * a) - (parseInt(b) * a)) / a).toString().replace(/\./, "").length - 1;
		return c
	};
	this.getAxisDecimals = function(a) {
		a = this.correctPrecisionBug(a);
		var b = a === 0 || a % 1 === 0 ? 0 : a.toExponential().replace(/e[\+\-0-9]+$/, "").replace(/^0\.0+|\./, "").length;
		return Math.min(b, 20)
	}
};
CanvasXpress.prototype.initPrimitives = function() {
	this.initText();
	this.initTime();
	this.initColor();
	this.initAttributes();
	this.initRangeAlgorithms()
};
CanvasXpress.prototype.initGeneralUtils = function() {
	this.modifyObjectArray = function(b, f, g, e, h) {
		this.functionCaller = "modifyObjectArray";
		var d = this[g];
		if (e) {
			var a = {};
			if (this.isArray(b)) {
				for (var c = 0; c < b.length; c++) {
					a[b[c]] = true
				}
			} else {
				a[b] = true
			}
			for (var c in a) {
				if (this.isInArray(c, d)) {
					d = this.removeFromArray(c, d);
					delete(a[c])
				}
			}
			for (var c in a) {
				d.push(c)
			}
			this[g] = d
		} else {
			if (f) {
				var a = {};
				var j = [];
				if (this.isArray(b)) {
					for (var c = 0; c < b.length; c++) {
						a[b[c]] = 1
					}
				} else {
					a[b] = 1
				}
				for (var c = 0; c < d.length; c++) {
					if (!a.hasOwnProperty(d[c])) {
						j.push(d[c])
					}
				}
				this[g] = j
			} else {
				if (this.isArray(b)) {
					for (var c = 0; c < b.length; c++) {
						d.push(b[c])
					}
				} else {
					d.push(b)
				}
			}
		}
		if (h) {
			this.draw()
		}
	};
	this.getObjectArray = function(b) {
		var d = {};
		if (b && this.isArray(b)) {
			for (var c = 0; c < b.length; c++) {
				d[b[c]] = true
			}
		}
		return d
	};
	this.isInArray = function(c, b) {
		return this.isArray(b) ? b.indexOf(c) > -1 : false
	};
	this.removeFromArray = function(e, b) {
		if (this.isArray(b)) {
			var d = [];
			for (var c = 0; c < b.length; c++) {
				if (b[c] != e) {
					d.push(b[c])
				}
			}
		}
		return d
	};
	this.isArray = function(a) {
		return a && !a.propertyIsEnumerable("length") && typeof a === "object" && typeof a.length === "number"
	};
	this.isObject = function(a) {
		return a instanceof Object
	};
	this.toArray = function(a) {
		return this.isArray(a) ? a : [a]
	};
	this.getKeys = function(a) {
		return this.isObject(a) ? Object.keys(a) : []
	};
	this.getUniqueKeys = function(d) {
		var b = [];
		var c = {};
		if (this.isArray(d)) {
			d = this.getObjectArray(d)
		}
		if (this.isObject(d)) {
			for (var a in d) {
				if (!c.hasOwnProperty(a)) {
					c[a] = true;
					b.push(a)
				}
			}
		}
		return b
	};
	this.shuffleArray = function(b) {
		for (var d = b.length; d > 0; d--) {
			var c = Math.floor(this.random() * d);
			var a = b[--d];
			b[d] = b[c];
			b[c] = a
		}
		return b
	};
	this.toNumber = function(b) {
		var e = [];
		var c = this.isArray(b);
		b = this.toArray(b);
		for (var d = 0; d < b.length; d++) {
			e.push(Number(b[d]))
		}
		return c ? e : e[0]
	};
	this.cloneObject = function(a) {
		if (a == null || typeof(a) != "object") {
			return a
		}
		return JSON.parse(JSON.stringify(a))
	};
	this.isSameObject = function(d, c) {
		if (d === c) {
			return true
		}
		if (typeof(d) != "object" || typeof(c) != "object") {
			return false
		}
		return JSON.stringify(d) == JSON.stringify(c)
	};
	this.isNumber = function(a) {
		return !isNaN(parseFloat(a)) && isFinite(a)
	};
	this.isNumeric2DArray = function(a) {
		for (var c = 0; c < a.length; c++) {
			for (var b = 0; b < a[c].length; b++) {
				if (!this.isNumber(a[c][b])) {
					return false
				}
			}
		}
		return true
	};
	this.isNumeric = function(b, a, e) {
		if (a) {
			for (var d = 0; d < this.smpIndices.length; d++) {
				var c = this.smpIndices[d];
				if (!this.isNumber(b[c])) {
					return false
				}
			}
		} else {
			if (e) {
				for (var d = 0; d < this.varIndices.length; d++) {
					var c = this.varIndices[d];
					if (!this.isNumber(b[c])) {
						return false
					}
				}
			} else {
				for (var c = 0; c < b.length; c++) {
					if (!this.isNumber(b[c])) {
						return false
					}
				}
			}
		}
		return true
	};
	this.isEmpty = function(b, a, e) {
		if (a) {
			for (var d = 0; d < this.smpIndices.length; d++) {
				var c = this.smpIndices[d];
				if (b[c] != "") {
					return false
				}
			}
		} else {
			if (e) {
				for (var d = 0; d < this.varIndices.length; d++) {
					var c = this.varIndices[d];
					if (b[c] != "") {
						return false
					}
				}
			} else {
				for (var c = 0; c < b.length; c++) {
					if (b[c] != "") {
						return false
					}
				}
			}
		}
		return true
	};
	this.isDate = function(b, a, f) {
		var d = function(g) {
			if (toString.call(g) === "[object Date]") {
				return true
			}
			if (typeof g.replace === "function") {
				g.replace(/^\s+|\s+$/gm, "")
			}
			var h = /(^\d{1,4}[\.|\\/|-]\d{1,2}[\.|\\/|-]\d{1,4})(\s*(?:0?[1-9]:[0-5]|1(?=[012])\d:[0-5])\d\s*[ap]m)?$/;
			return h.test(g)
		};
		if (a) {
			for (var e = 0; e < this.smpIndices.length; e++) {
				var c = this.smpIndices[e];
				if (b[c] && !d(b[c])) {
					return false
				}
			}
		} else {
			if (f) {
				for (var e = 0; e < this.varIndices.length; e++) {
					var c = this.varIndices[e];
					if (b[c] && !d(b[c])) {
						return false
					}
				}
			} else {
				for (var c = 0; c < b.length; c++) {
					if (b[c] && !d(b[c])) {
						return false
					}
				}
			}
		}
		return true
	};
	this.isPivotable = function() {
		var b = this.data.y.vars.length;
		var c = this.data.x ? this.getKeys(this.data.x) : [];
		var a = c.length;
		return b + a == 3
	};
	this.pivotMatrix = function(h, f, k, c) {
		var a = {};
		var e = [];
		var d = [];
		for (var b = 0; b < h.length; b++) {
			if (!a[h[b][f]]) {
				a[h[b][f]] = {}
			}
			a[h[b][f]][h[b][k]] = h[b][c];
			if (e.indexOf(h[b][k]) == -1) {
				e.push(h[b][k])
			}
		}
		e = this.stringRangeSort(e);
		var j = [];
		j.push("Vars");
		j.push.apply(j, e);
		d.push(j);
		for (var g in a) {
			j = [];
			j.push(g);
			for (var b = 0; b < e.length; b++) {
				j.push(a[g][e[b]] || "")
			}
			d.push(j)
		}
		return d
	};
	this.transposeMatrix = function(a) {
		return a[0].map(function(b, d) {
			return a.map(function(c) {
				return c[d]
			})
		})
	};
	this.filterNumbers = function(a) {
		var c = [];
		for (var b = 0; b < a.length; b++) {
			if (this.isNumber(a[b])) {
				c.push(a[b])
			}
		}
		return c
	};
	this.cleanArray = function(b, a, e) {
		var d = [];
		if (a) {
			for (var c = 0; c < this.smpIndices.length; c++) {
				d.push(b[this.smpIndices[c]])
			}
			d = this.filterNumbers(d)
		} else {
			if (e) {
				for (var c = 0; c < this.varIndices.length; c++) {
					d.push(b[this.varIndices[c]])
				}
				d = this.filterNumbers(d)
			} else {
				d = this.filterNumbers(b)
			}
		}
		return d
	};
	this.cleanArrays = function(e, d, b, j) {
		var h = [];
		var g = [];
		if (b) {
			for (var f = 0; f < this.smpIndices.length; f++) {
				var c = this.filterNumbers([e[this.smpIndices[f]], d[this.smpIndices[f]]]);
				if (c.length == 2) {
					h.push(e[this.smpIndices[f]]);
					g.push(d[this.smpIndices[f]])
				}
			}
		} else {
			if (j) {
				for (var f = 0; f < this.varIndices.length; f++) {
					var c = this.filterNumbers([e[this.varIndices[f]], d[this.varIndices[f]]]);
					if (c.length == 2) {
						h.push(e[this.varIndices[f]]);
						g.push(d[this.varIndices[f]])
					}
				}
			} else {
				for (var f = 0; f < e.length; f++) {
					var c = this.filterNumbers([e[f], d[f]]);
					if (c.length == 2) {
						h.push(e[f]);
						g.push(d[f])
					}
				}
			}
		}
		return [h, g]
	};
	this.reverseArray = function(a) {
		tmp = a.reverse();
		return tmp
	};
	this.parseInt = function(a) {
		return ((a + 0.5) << 1) >> 1
	};
	this.resetStagingDrawingBuffer = function() {
		this.stagingDrawingBuffer = {
			len: 0,
			map: [],
			keys: {},
			data: []
		}
	};
	this.addKeyStagingDrawingBuffer = function(f, c, j, d, g) {
		var e = this.parseInt(c) + ":" + this.parseInt(j) + ":" + this.parseInt(d) + ":" + this.parseInt(g);
		var a = this.stagingDrawingBuffer;
		if (!a.keys.hasOwnProperty(e)) {
			a.keys[e] = []
		}
		a.keys[e].push(f);
		a.map.push(e);
		a.data[f] = []
	};
	this.addDataStagingDrawingBuffer = function(e, g, h, d) {
		var c = this.stagingDrawingBuffer;
		c.len = e;
		c.data[e].push([g, h, d])
	};
	this.drawDataStagingDrawingBuffer = function() {
		var o = this;
		var h = function(c) {
			var b = c.split(":");
			b[0] = this.parseInt(b[0]);
			b[1] = this.parseInt(b[1]);
			b[2] = this.parseInt(b[2]);
			b[3] = this.parseInt(b[3]);
			return b[0] + b[2] > 0 && b[1] + b[3] > 0 && b[0] - b[2] < o.width && b[1] - b[3] < o.height
		};
		var a = 0;
		var r = this.stagingDrawingBuffer;
		for (var m = 0; m <= r.len; m++) {
			var f = r.map[m];
			var e = r.keys[f].length - 1;
			if (m == r.keys[f][e] && h(f)) {
				a++;
				var p = r.data[m];
				for (var g = 0; g < p.length; g++) {
					var q = p[g];
					if (q[2]) {
						this.addArea(this[q[0]].apply(this, q[1]), q[2])
					} else {
						this[q[0]].apply(this, q[1])
					}
				}
			}
		}
		this.resetStagingDrawingBuffer()
	}
};
CanvasXpress.prototype.initPlotUtils = function() {
	this.setVideoControls = function() {
		if (this.isVideo) {
			var b = this;
			if (typeof _V_ == "undefined" || !_V_.autoSetupTimeout) {
				setTimeout(function() {
					b.setVideoControls()
				}, 100)
			} else {
				var e = _V_(this.target + "-cX-Video");
				var a = this.$(this.target + "-cX-Video");
				if (e && a) {
					a.style.position = "absolute";
					a.style.background = "transparent";
					this.video = a.childNodes[0];
					this.video.style.display = "none";
					this.video.style.zIndex = -1;
					this.video.playbackRate = this.videoPlaybackRate;
					b.addEvtListener(this.video, "loadeddata", function() {
						b.addEvtListener(b.video, "play", b.videoPlay, false)
					}, false);
					if (this.videoAutoplay) {
						e.play();
						var c = function() {
							this.play = function() {
								if (b.video.readyState == 4) {
									b.drawVideo(b.video, b.width, b.height);
									clearInterval(d)
								}
							};
							var d = setInterval(this.play, 30)
						};
						c.call()
					}
				}
			}
		}
	};
	this.drawLayoutCanvasCompartments = function() {
		var p = this.canvasBoxColor;
		var n = this.height;
		var v = this.width;
		var i = this.left;
		var d = this.right;
		var s = this.bottom;
		var x = this.top;
		var k = this.marginLeft;
		var e = this.marginRight;
		var u = this.marginBottom;
		var a = this.marginTop;
		var q = this.layoutLeft;
		var m = this.layoutRight;
		var g = this.layoutBottom;
		var j = this.layoutTop;
		var o = this.drawLine;
		this.rectangle(k + this.offsetX, a + this.offsetY, this.layoutWidth, this.layoutHeight, false, p, "open");
		o("line", k, 0, k, n, p);
		o("line", q + k, 0, q + k, n, p);
		o("line", 0, a, v, a, p);
		o("line", 0, a + j, v, a + j, p);
		o("line", v - e, 0, v - e, n, p);
		o("line", v - (e + m), 0, v - (e + m), n, p);
		o("line", 0, n - u, v, n - u, p);
		o("line", 0, n - (u + g), v, n - (u + g), p);
		o("line", q + k + i, 0, q + k + i, n, p);
		o("line", 0, a + j + x, v, a + j + x, p);
		o("line", v - (e + m + d), 0, v - (e + m + d), n, p);
		o("line", 0, n - (u + g + s), v, n - (u + g + s), p)
	};
	this.drawCanvasBox = function(a) {
		if (this.canvasBox && (this.graphType != "Network" || a)) {
			this.disableGradientTransparencyShadow();
			this.rectangle(0, 0, this.width - 1, this.height - 1, false, this.canvasBoxColor, "open");
			this.enableGradientTransparencyShadow()
		}
	};
	this.drawPlotWindow = function() {
		if (this.backgroundType.match("window")) {
			this.disableGradientTransparencyShadow();
			var a = this.marginLeft + this.offsetX;
			var b = this.marginTop + this.offsetY;
			if (this.backgroundType == "windowGradient2" || this.backgroundType == "windowSolidGradient") {
				var c;
				if (this.backgroundWindowGradientOrientation == "horizontal") {
					c = this.getLinearGradient(a + this.left, b, a + this.left + this.x, b, this.backgroundWindowGradient1Color, this.backgroundWindowGradient2Color)
				} else {
					c = this.getLinearGradient(a, b + this.top, a, b + this.top + this.y, this.backgroundWindowGradient1Color, this.backgroundWindowGradient2Color)
				}
				this.rectangle(a + this.left, b + this.top, this.x, this.y, c, c)
			} else {
				this.rectangle(a + this.left, b + this.top, this.x, this.y, this.backgroundWindow, this.backgroundWindow)
			}
			this.enableGradientTransparencyShadow()
		}
	};
	this.validateSegregation = function() {
		var e = "";
		var b = this.segregateVariablesBy;
		var d = this.segregateSamplesBy;
		if (b.length > 0) {
			var a = [];
			for (var c = 0; c < b.length; c++) {
				if ((this.data.z && this.data.z.hasOwnProperty(b[c])) || b[c] == "variable") {
					a.push(b[c])
				}
			}
			b = a
		}
		if (d.length > 0) {
			var a = [];
			for (var c = 0; c < d.length; c++) {
				if ((this.data.x && this.data.x.hasOwnProperty(d[c])) || d[c] == "sample") {
					a.push(d[c])
				}
			}
			d = a
		}
		if (b.length > 0 && d.length > 0) {
			if (d.length > 1) {
				while (d.length > 1) {
					d.pop()
				}
				e += "Only one sample segregation when variable segregation is selected\n";
				e += "segregateSamplesBy was set to: " + d[0] + "\n"
			}
			if (b.length > 1) {
				while (b.length > 1) {
					b.pop()
				}
				e += "Only one variable segregation when sample segregation is selected\n";
				e += "segregateVariblesBy was set to: " + b[0] + "\n"
			}
		} else {
			if (d.length > 0) {
				if (d.length > 2) {
					while (d.length > 2) {
						d.pop()
					}
					e += "Maximum of two sample segregations\n";
					e += "segregateSamplesBy was set to: " + d[0] + "," + d[1] + "\n"
				}
			} else {
				if (b.length > 0) {
					if (b.length > 2) {
						while (b.length > 2) {
							b.pop()
						}
						e += "Maximum of two variable segregations\n";
						e += "segregateVariablesBy was set to: " + b[0] + "," + b[1] + "\n"
					}
				}
			}
		}
		if (e != "") {
			this.removeMenus();
			alert(e);
			return false
		}
		return true
	};
	this.validateOverlays = function() {
		if (this.smpOverlays.length > 0) {
			var a = [];
			for (var b = 0; b < this.smpOverlays.length; b++) {
				if (this.smpOverlays[b] == "-" || (this.data.x && this.data.x.hasOwnProperty(this.smpOverlays[b]))) {
					a.push(this.smpOverlays[b])
				}
			}
			this.smpOverlays = a
		}
		if (this.varOverlays.length > 0) {
			var a = [];
			for (var b = 0; b < this.varOverlays.length; b++) {
				if (this.varOverlays[b] == "-" || (this.data.z && this.data.z.hasOwnProperty(this.varOverlays[b]))) {
					a.push(this.varOverlays[b])
				}
			}
			this.varOverlays = a
		}
	};
	this.setOverlayFont = function() {
		var a = parseInt(Math.max(Math.min(this.overlayScaleFontFactor * this.overlayFontSize, this.maxTextSize), this.minTextSize));
		this.overlayFontSize = Math.max(1, Math.min(this.overlaysThickness - 1, a));
		this.overlayFont = this.overlayFontStyle + " " + this.overlayFontSize + "px " + this.fontName
	}
};
CanvasXpress.prototype.initConfigUtils = function() {
	this.setPixelImage = function() {
		this.beaconImage = this.$cX("img", {
			id: this.target + "-cX-Beacon-Image",
			src: navigator.onLine && this.protocol != "file" ? "http://www.canvasxpress.org/cgi-bin/services.pl?beacon=" + this.meta.client : CanvasXpress.images.canvasXpress
		})
	};
	this.encode = function(a) {
		return btoa(encodeURIComponent(a).replace(/%([0-9A-F]{2})/g, function(b, c) {
			return String.fromCharCode("0x" + c)
		}))
	};
	this.decode = function(a) {
		return decodeURIComponent(Array.prototype.map.call(atob(a), function(b) {
			return "%" + ("00" + b.charCodeAt(0).toString(16)).slice(-2)
		}).join(""))
	};
	this.getFileName = function(a) {
		return a.substring(a.lastIndexOf("/") + 1)
	};
	this.getTitleSubtitleHeight = function() {
		var b = 0;
		var a;
		this.setTitleSubtitleFont();
		if (this.title) {
			a = this.title.split(/\n/);
			b += (this.margin + this.getFontPt(this.titleFont)) * a.length;
			if (this.subtitle) {
				a = this.subtitle.split(/\n/);
				b += (this.margin + this.getFontPt(this.subtitleFont)) * a.length
			}
			b += this.margin
		}
		return b
	};
	this.setTitleSubtitleFont = function() {
		this.setPropertyFontSize(this.width, "titleFont");
		this.adjustFont(this.title, "titleFont", this.width);
		this.setPropertyFontSize(this.width, "subtitleFont");
		this.adjustFont(this.subtitle, "subtitleFont", this.width)
	};
	this.drawTitle = function() {
		this.setTitleSubtitleFont();
		if (this.title) {
			this.drawText(this.title, this.width / 2, this.marginTop + (this.getFontPt(this.titleFont) / 2), this.titleFont, this.titleColor, "center", "middle");
			if (this.subtitle) {
				this.drawText(this.subtitle, this.width / 2, (this.marginTop + this.getFontPt(this.titleFont)) + this.margin + (this.getFontPt(this.subtitleFont) / 2), this.subtitleFont, this.subtitleColor, "center", "middle")
			}
		}
	};
	this.getFontHeight = function() {
		this.setFont();
		return this.getFontPt(this.font)
	};
	this.setFont = function() {
		var b;
		if (this.autoScaleFont) {
			var c = 1 - this.percentAspectRatioPlotArea;
			var a = this.layoutComb ? (this.width / this.layoutCols) * c * 2.5 : this.width * c;
			var e = this.layoutComb ? (this.height / this.layoutRows) * c * 2.5 : this.height * c;
			b = Math.min(Math.max(parseInt((Math.max(a, e) / 30) * this.fontScaleFontFactor), this.minTextSize), this.maxTextSize)
		} else {
			b = Math.min(Math.max(parseInt(this.fontSize * this.fontScaleFontFactor), this.minTextSize), this.maxTextSize)
		}
		this.font = this.fontStyle + " " + b + "px " + this.fontName
	};
	this.setPropertyFontSize = function(g, e) {
		if (!g || !e) {
			return
		}
		var a = 1;
		var c = {
			titleFont: a + 4,
			subtitleFont: a + 2,
			decorationFont: a - 6,
			axisTickFont: a,
			axisTitleFont: a,
			smpLabelFont: a,
			smpTitleFont: a,
			varLabelFont: a,
			varTitleFont: a,
			legendFont: this.graphType == "Circular" ? a - 8 : a,
			citationFont: a - 15
		};
		var f = e.replace("Font", "ScaleFontFactor");
		this[e + "Size"] = Math.min(Math.max(parseInt((g / 30) * this[f]) + c[e], this.minTextSize), this.maxTextSize);
		this[e] = this[e + "Style"] + " " + this[e + "Size"] + "px " + this.fontName
	};
	this.adjustFont = function(b, c, g) {
		if (b && c && g) {
			var e = this.getFontPt(this[c]);
			var a = this.measureText(b, this[c]);
			while (a > g && e > this.minTextSize) {
				e--;
				this[c] = this[c + "Style"] + " " + e + "px " + this.fontName;
				a = this.measureText(b, this[c])
			}
		}
	};
	this.setAspectRatioProperties = function() {
		if (this.adjustAspectRatio) {
			var a = this.meta.config.orig;
			var e = Math.min(this.width, this.height);
			var c = ["margin", "overlaysThickness", "dendrogramSpace", "dendrogramHeight", "heatmapIndicatorHeight", "heatmapIndicatorWidth", "heatmapSeparatorWidth"];
			for (var b = 0; b < c.length; b++) {
				if (!a[c[b]]) {
					a[c[b]] = this[c[b]]
				}
			}
			if (!a.sizes) {
				a.sizes = this.cloneObject(this.sizes);
				for (var b = 0; b < this.sizes.length; b++) {
					this.sizes[b] = Number(Math.max(0.5, e * this.sizes[b] / 833).toFixed(1))
				}
			}
			for (var b = 0; b < c.length; b++) {
				this[c[b]] = Number(Math.max(0.5, e * this[c[b]] / 833).toFixed(1))
			}
		}
	};
	this.resetAspectRatioProperties = function() {
		if (this.adjustAspectRatio) {
			var a = this.meta.config.orig;
			var c = ["margin", "overlaysThickness", "dendrogramSpace", "dendrogramHeight", "heatmapIndicatorHeight", "heatmapIndicatorWidth", "heatmapSeparatorWidth"];
			for (var b = 0; b < c.length; b++) {
				if (a[c[b]]) {
					this[c[b]] = a[c[b]];
					delete(a[c[b]])
				}
			}
		}
	};
	this.drawCitation = function(a, c, b) {
		if (this.citation) {
			this.setPropertyFontSize(this.width, "citationFont");
			this.drawText(this.citation, this.width - this.margin, this.height, this.citationFont, this.citationColor, "right", "bottom")
		}
	};
	this.drawCx = function() {
		var b = this.hexToString("686578546f537472696e67");
		var e = this[b]("6472617754657874");
		var c = this[b]("6d657461");
		if (this[c][this[b]("76616c696463")] != null) {
			switch (this[c][this[b]("76616c696463")]) {
				case 0:
					return;
				case 1:
					var a = this[b]("4e6f7420612076616c696420636f7079206f662063616e766173587072657373");
					this[e](a, this.width / 2, this.height / 2, this.font, "rgba(0,0,0,0.5)", "center", "middle");
					return;
				case 2:
					return;
				case 3:
					var a = this[b]("63616e76617358707265737320522076657273696f6e206f6e6c79");
					this[e](a, this.width / 2, this.height / 2, this.font, "rgba(0,0,0,0.5)", "center", "middle");
					return;
				default:
					return
			}
		}
	};
	this.getGroupColor = function(b, e) {
		if (this.isGroupedData) {
			var a = this.data.w.grps[e];
			var h = this.getPropertyValue(b, a[0], "colorBy");
			for (var d = 1; d < a.length; d++) {
				var f = this.getPropertyValue(b, a[d], "colorBy");
				if (f != h) {
					return this.foreground
				}
			}
			return h
		} else {
			return this.getPropertyValue(b, e, "colorBy")
		}
	};
	this.drawSelectedBackgroundLabel = function(b, c, a, d) {
		if (this.isInSelectedDataPoints(b, c)) {
			if (this.selectDataMode == "name") {
				if (this.selectDataModeDescription && this.data.z && this.data.z[this.selectDataModeDescription]) {
					lab = this.data.z[this.selectDataModeDescription][b] || this.data.y.vars[b]
				} else {
					lab = this.data.y.vars[b]
				}
				this.drawText(lab, a, d, this.varLabelFont, this.foreground, "center", "middle")
			}
			return true
		}
		return false
	};
	this.drawSelectedBackground = function(i, k, l, b, f, g, d, a, j, e, c) {
		if (this.isInSelectedDataPoints(i, k)) {
			if (this.selectDataMode == "area") {
				this.drawShape(l, b, f, g + 5, d + 5, this.selectedBackgroundColor, this.foreground, "closed", a, 1, j, false, e, c)
			}
			return true
		}
		return false
	};
	this.isInSelectedDataPoints = function(a, c) {
		if (this.isSelectDataPoints) {
			if (this.graphType == "Scatter2D" && this.isHistogram) {
				if (this.data.y.histogram[a][c] && this.data.y.histogram[a][c].length > 0) {
					for (var b = 0; b < this.data.y.histogram[a][c].length; b++) {
						var d = this.data.y.histogram[a][c][b];
						if (this.selectDataPoint[d]) {
							if (this.broadcastType == "var") {
								return true
							} else {
								if (this.selectDataPoint[d].hasOwnProperty(c)) {
									return true
								}
							}
						}
					}
				}
			} else {
				if (this.selectDataPoint[a]) {
					if (this.broadcastType == "var") {
						return true
					} else {
						if (this.selectDataPoint[a].hasOwnProperty(c)) {
							return true
						}
					}
				}
			}
		}
		return false
	};
	this.isVisibleSelectedDataPoint = function(a, b) {
		if (this.isSelectDataPoints) {
			if (this.hideDataPoint.length > 0 && this.hideDataPoint[a]) {
				if (this.broadcastType == "var") {
					return false
				} else {
					if (this.hideDataPoint[a].hasOwnProperty(b)) {
						return false
					}
				}
			}
		}
		return true
	};
	this.getVarColor = function(a) {
		if (this.isArray(this.highlightVar)) {
			for (var b = 0; b < this.highlightVar.length; b++) {
				if (this.highlightVar[b] == a) {
					return this.varHighlightColor
				}
			}
		} else {
			if (this.highlightVar == a) {
				return this.varHighlightColor
			}
		}
		return this.varLabelFontColor
	};
	this.getSmpColor = function(b) {
		if (this.isArray(this.highlightSmp)) {
			for (var a = 0; a < this.highlightSmp.length; a++) {
				if (this.highlightSmp[a] == b) {
					return this.smpHighlightColor
				}
			}
		} else {
			if (this.highlightSmp == b) {
				return this.smpHighlightColor
			}
		}
		return this.smpLabelFontColor
	};
	this.getNodeColor = function(c, a) {
		if (this.isArray(this.highlightNode)) {
			for (var b = 0; b < this.highlightNode.length; b++) {
				if (this.highlightNode[b] == c) {
					return this.nodeHighlightColor
				}
			}
		} else {
			if (this.highlightNode == c) {
				return this.nodeHighlightColor
			}
		}
		return this.selectNode.hasOwnProperty(c) ? this.nodeHighlightColor : a ? a : this.nodeFontColor
	};
	this.getTechnicalIndicatorColor = function(a) {
		return this[a.toLowerCase() + "Color"] ? this[a.toLowerCase() + "Color"] : "rgb(255,255,0)"
	};
	this.isStringOverlays = function(c) {
		var a = this.meta.data;
		if ((!c || c == "v") && a.z && this.varOverlays.length > 0) {
			for (var b = 0; b < this.varOverlays.length; b++) {
				var d = this.varOverlays[b];
				if (a.z[d].type != "Numeric") {
					return true
				}
			}
		}
		if ((!c || c == "s") && a.x && this.smpOverlays.length > 0) {
			for (var b = 0; b < this.smpOverlays.length; b++) {
				var d = this.smpOverlays[b];
				if (a.x[d].type != "Numeric") {
					return true
				}
			}
		}
		return false
	};
	this.isNumericFactor = function(b) {
		var a = this.meta.data;
		if ((!b || b == "v") && a.z) {
			for (var c in a.z) {
				if (a.z[c].type == "Numeric") {
					return true
				}
			}
		}
		if ((!b || b == "s") && a.x) {
			for (var c in a.x) {
				if (a.x[c].type == "Numeric") {
					return true
				}
			}
		}
		return false
	};
	this.isStringFactor = function(b) {
		var a = this.meta.data;
		if ((!b || b == "v") && a.z) {
			for (var c in a.z) {
				if (a.z[c].type != "Numeric") {
					return true
				}
			}
		}
		if ((!b || b == "s") && a.x) {
			for (var c in a.x) {
				if (a.x[c].type != "Numeric") {
					return true
				}
			}
		}
		return false
	};
	this.isBinConfigurations = function() {
		for (var a in this.binConfigurations) {
			return true
		}
		return false
	};
	this.initValidity = function() {
		var o = this.hexToString("686578546f537472696e67");
		var y = this[o]("6d657461");
		var j = this[o]("636c69656e74");
		var d = this[o]("656e636f6465");
		var p = this[o]("76616c696463");
		var z = this[o]("7374617274");
		var a = this[o]("73697465537263");
		var q = this[o]("757365724964");
		var a = this[o]("76657273696f6e");
		var g = this[o]("68726566");
		var n = new RegExp(this[o]("63616e7661737870726573732e6f7267"));
		var i = new RegExp(this[o]("5e66696c653a"));
		var k = new RegExp(this[o]("626d732e636f6d"));
		var e = new RegExp(this[o]("6c6f63616c686f7374"));
		this[y][j] = this[d]([this[y][z], this[q], this[y][a], this[g]].join("::"));
		if (this[q] == 1) {
			if (navigator.onLine) {
				if (this[g] && this[y][a]) {
					this[y][p] = 0
				} else {
					if (this[g] && i.test(this[g])) {
						this[y][p] = 0
					} else {
						if (this[g] && e.test(this[g])) {
							this[y][p] = 0
						} else {
							if (this[g] && !n.test(this[g])) {
								this[y][p] = 1
							} else {
								this[y][p] = 0
							}
						}
					}
				}
			} else {
				this[y][p] = 0
			}
		} else {
			if (this[q] == 2 && !this.isR) {
				this[y][p] = 3
			} else {
				if (this[q] == 3 && !k.test(this[g]) && !e.test(this[g]) && !i.test(this[g])) {
					this[y][p] = 1
				} else {
					this[y][p] = 0
				}
			}
		}
	};
	this.getWorstAspectRatio = function(k, j) {
		if (!k || k.length == 0) {
			return Number.MAX_VALUE
		} else {
			var e = 0;
			var f = 0;
			var b = Number.MAX_VALUE;
			for (var c = 0; c < k.length; c++) {
				var g = k[c].area;
				e += g;
				b = (b < g) ? b : g;
				f = (f > g) ? f : g
			}
			var d = j * j;
			var h = e * e;
			return Math.max(d * f / h, h / (d * b))
		}
	};
	this.setTreemapRowVerticalLayout = function(j, g, f) {
		var c = 0;
		for (var b = 0; b < j.length; b++) {
			c += j[b].area
		}
		var a = c / g;
		var e = 0;
		for (var b = 0; b < j.length; b++) {
			var h = j[b].area / a;
			j[b].coords = {
				width: a,
				height: h,
				left: f.left,
				top: f.top + e
			};
			e += h
		}
		var d = {
			width: f.width - a,
			height: f.height,
			left: f.left + a,
			top: f.top
		};
		d.orientation = Math.min(d.width, d.height);
		if (d.orientation != d.height) {
			this.treemapOrientation = this.treemapOrientation == "horizontal" ? "vertical" : "horizontal"
		}
		return d
	};
	this.setTreemapRowHorizontalLayout = function(k, h, g) {
		var d = 0;
		for (var c = 0; c < k.length; c++) {
			d += k[c].area
		}
		var j = d / h;
		var f = g.top;
		var b = 0;
		for (var c = 0; c < k.length; c++) {
			var a = k[c].area / j;
			k[c].coords = {
				width: a,
				height: j,
				left: g.left + b,
				top: f
			};
			b += a
		}
		var e = {
			width: g.width,
			height: g.height - j,
			left: g.left,
			top: g.top + j
		};
		e.orientation = Math.min(e.width, e.height);
		if (e.orientation != e.width) {
			this.treemapOrientation = this.treemapOrientation == "horizontal" ? "vertical" : "horizontal"
		}
		return e
	};
	this.setTreemapRowLayout = function(a, b, c) {
		if (this.treemapOrientation == "horizontal") {
			return this.setTreemapRowVerticalLayout(a, b, c)
		} else {
			return this.setTreemapRowHorizontalLayout(a, b, c)
		}
	};
	this.computeTreemapDimensions = function(a, c, b, f) {
		if (a.length + c.length == 1) {
			var e = (a.length == 1) ? a : c;
			e[0].coords = f;
			return
		}
		if (a.length >= 2 && c.length == 0) {
			c = [a.shift()]
		}
		if (a.length == 0) {
			if (c.length > 0) {
				this.setTreemapRowLayout(c, b, f)
			}
			return
		}
		var d = a[0];
		if (this.getWorstAspectRatio(c, b) >= this.getWorstAspectRatio([d].concat(c), b)) {
			this.computeTreemapDimensions(a.slice(1), c.concat([d]), b, f)
		} else {
			var g = this.setTreemapRowLayout(c, b, f);
			this.computeTreemapDimensions(a, [], g.orientation, g)
		}
	};
	this.squarifyTreemap = function(a, g) {
		var f = g.width * g.height;
		var e = 0;
		var b = [];
		for (var d = 0; d < a.length; d++) {
			b[d] = parseFloat(a[d].area);
			e += b[d]
		}
		for (var d = 0; d < b.length; d++) {
			a[d].area = f * b[d] / e
		}
		var c = this.treemapOrientation == "horizontal" ? g.height : g.width;
		a.sort(function(i, h) {
			return h.area - i.area
		});
		this.computeTreemapDimensions(a.slice(1), [a[0]], c, g)
	};
	this.processTreemap = function(b, d) {
		if (!this.treemapOrientation) {
			this.treemapOrientation = "horizontal"
		}
		if (d.width >= d.height) {
			this.treemapOrientation = "horizontal"
		} else {
			this.treemapOrientation = "vertical"
		}
		if (b.length) {
			this.squarifyTreemap(b, d);
			for (var c = 0; c < b.length; c++) {
				var a = b[c].children ? b[c].children : b[c];
				var d = {
					width: b[c].coords.width,
					height: b[c].coords.height,
					left: b[c].coords.left,
					top: b[c].coords.top
				};
				this.processTreemap(a, d)
			}
		}
		return b
	};
	this.getCloudPointsAtRadius = function(a) {
		if (this.tagCloudGridPoints[a]) {
			return this.tagCloudGridPoints[a]
		}
		var b = a * 8;
		var c = b;
		var d = [];
		if (a == 0) {
			d.push([this.tagCloudGridCenter[0], this.tagCloudGridCenter[1], 0])
		}
		while (c--) {
			d.push([this.tagCloudGridCenter[0] + a * Math.cos(-c / b * 2 * Math.PI), this.tagCloudGridCenter[1] + a * Math.sin(-c / b * 2 * Math.PI) * this.tagCloudTextEllipticity, c / b * 2 * Math.PI])
		}
		this.tagCloudGridPoints[a] = d;
		return d
	};
	this.getCloudRotateDeg = function() {
		if (this.tagCloudTextRotateRatio == 0) {
			return 0
		}
		if (this.random() > this.tagCloudTextRotateRatio) {
			return 0
		}
		return (-Math.PI / 2) + (this.random() * Math.PI)
	};
	this.getCloudTextInfo = function(z, n, o) {
		var a = Math.min(500, Math.floor(this.tagCloudTextWeightFactor * n));
		var s = document.createElement("canvas");
		var A = s.getContext("2d", {
			willReadFrequently: true
		});
		var p = a + "px " + this.fontName;
		A.font = p;
		var b = this.measureText(z, p);
		var m = a;
		var i = b + m * 2;
		var g = m * 3;
		var B = Math.ceil(i / this.tagCloudTextGridSize);
		var c = Math.ceil(g / this.tagCloudTextGridSize);
		i = B * this.tagCloudTextGridSize;
		g = c * this.tagCloudTextGridSize;
		var t = -b * 0.5;
		var q = -m * 0.5;
		var u = Math.ceil((i * Math.abs(Math.sin(o)) + g * Math.abs(Math.cos(o))) / this.tagCloudTextGridSize);
		var d = Math.ceil((i * Math.abs(Math.cos(o)) + g * Math.abs(Math.sin(o))) / this.tagCloudTextGridSize);
		var v = d * this.tagCloudTextGridSize;
		var r = u * this.tagCloudTextGridSize;
		if (v < 1 || r < 1) {
			return {
				occupied: [],
				bounds: [0, 0, 0, 0],
				gw: d,
				gh: u,
				fillTextOffsetX: t,
				fillTextOffsetY: q,
				fillTextWidth: b,
				fillTextHeight: m,
				fontSize: a
			}
		}
		s.setAttribute("width", v);
		s.setAttribute("height", r);
		A.save();
		A.translate(v / 2, r / 2);
		A.rotate(-o);
		A.font = a + "px " + this.fontName;
		A.fillStyle = "#000";
		A.textBaseline = "middle";
		A.fillText(z, t, q + a * 0.5);
		A.restore();
		var w = A.getImageData(0, 0, v, r).data;
		var f = [];
		var l = d,
			k, j, h;
		var e = [u / 2, d / 2, u / 2, d / 2];
		while (l--) {
			k = u;
			while (k--) {
				h = this.tagCloudTextGridSize;
				singleGridLoop: {
					while (h--) {
						j = this.tagCloudTextGridSize;
						while (j--) {
							if (w[((k * this.tagCloudTextGridSize + h) * v + (l * this.tagCloudTextGridSize + j)) * 4 + 3]) {
								f.push([l, k]);
								if (l < e[3]) {
									e[3] = l
								}
								if (l > e[1]) {
									e[1] = l
								}
								if (k < e[0]) {
									e[0] = k
								}
								if (k > e[2]) {
									e[2] = k
								}
								break singleGridLoop
							}
						}
					}
				}
			}
		}
		return {
			occupied: f,
			bounds: e,
			gw: d,
			gh: u,
			fillTextOffsetX: t,
			fillTextOffsetY: q,
			fillTextWidth: b,
			fillTextHeight: m,
			fontSize: a
		}
	};
	this.canFitCloudText = function(g, f, h, b, a) {
		var e = a.length;
		while (e--) {
			var d = g + a[e][0];
			var c = f + a[e][1];
			if (d >= this.tagCloudGridWidth || c >= this.tagCloudGridHeight || d < 0 || c < 0 || !this.tagCloudGrid[d][c]) {
				return false
			}
		}
		return true
	};
	this.fillCloudGridAt = function(a, b) {
		if (a >= this.tagCloudGridWidth || b >= this.tagCloudGridHeight || a < 0 || b < 0) {
			return
		}
		this.tagCloudGrid[a][b] = false
	};
	this.updateCloudGrid = function(e, c, d) {
		var a = d.occupied;
		var b = a.length;
		while (b--) {
			this.fillCloudGridAt(e + a[b][0], c + a[b][1])
		}
	};
	this.drawCloudTag = function(c, h, f, d) {
		var i = this;
		var j = this.getCloudRotateDeg();
		var e = this.getCloudTextInfo(c, h, j);
		if (!e) {
			return false
		}
		var b = e.bounds;
		if ((b[1] - b[3] + 1) > this.tagCloudGridWidth || (b[2] - b[0] + 1) > this.tagCloudGridHeight) {
			return false
		}
		var a = this.tagCloudGridMaxRadius + 1;
		while (a--) {
			var k = this.getCloudPointsAtRadius(this.tagCloudGridMaxRadius - a);
			k = [].concat(k);
			this.shuffleArray(k);
			var g = k.some(function l(o) {
				var q = Math.floor(o[0] - e.gw / 2);
				var p = Math.floor(o[1] - e.gh / 2);
				var r = e.gw;
				var n = e.gh;
				var t = e.fontSize + "px " + i.fontName;
				if (!i.canFitCloudText(q, p, r, n, e.occupied)) {
					return false
				}
				var m = ((q + e.gw / 2) * i.tagCloudTextGridSize);
				var s = ((p + e.gh / 2) * i.tagCloudTextGridSize);
				i.addArea(i.drawText(c, m, s, t, f, "center", "middle", -j), d);
				i.updateCloudGrid(q, p, e);
				return true
			});
			if (g) {
				return true
			}
		}
		return false
	};
	this.setTagCloud = function(b) {
		this.tagCloudTextGridSize = Math.max(this.tagCloudTextGridSize, 4);
		if (this.colorBy && this.legendColorsN) {
			this.tagCloudGridWidth = Math.floor(this.x / this.tagCloudTextGridSize);
			this.tagCloudGridHeight = Math.floor(this.y / this.tagCloudTextGridSize)
		} else {
			this.tagCloudGridWidth = Math.floor(this.width / this.tagCloudTextGridSize);
			this.tagCloudGridHeight = Math.floor(this.height / this.tagCloudTextGridSize)
		}
		this.tagCloudGridCenter = [this.tagCloudGridWidth / 2, this.tagCloudGridHeight / 2];
		this.tagCloudGridMaxRadius = Math.floor(Math.sqrt(this.tagCloudGridWidth * this.tagCloudGridWidth + this.tagCloudGridHeight * this.tagCloudGridHeight));
		this.tagCloudGridPoints = [];
		if (!b) {
			this.setTagCloudTextWeightFactor()
		} else {
			this.tagCloudTextWeightFactor *= b
		}
		this.tagCloudGrid = [];
		var c = this.tagCloudGridWidth;
		var a;
		while (c--) {
			this.tagCloudGrid[c] = [];
			a = this.tagCloudGridHeight;
			while (a--) {
				this.tagCloudGrid[c][a] = true
			}
		}
	};
	this.setTagCloudTextWeightFactor = function() {
		var h = 0;
		var b = 0;
		var k = this.varIndices[0];
		for (var g = 0; g < this.smpIndices.length; g++) {
			var f = this.smpIndices[g];
			var j = this.getDataAtPos(k, f);
			var e = this.data.y.smps[f].length;
			var c = e * j * 0.5 * j;
			b = Math.max(c, b);
			h += c
		}
		if (!this.tagCloudTries) {
			this.tagCloudTries = 1
		}
		b = parseInt(Math.max(this.width, this.height));
		if (h > b) {
			this.tagCloudTextWeightFactor = (this.width * this.height) / (h * this.tagCloudTries)
		} else {
			this.tagCloudTextWeightFactor = (this.width * this.height) / (h * this.tagCloudTries * (b / h))
		}
		this.tagCloudTries += 1
	};
	this.getVariableColor = function(a) {
		for (var b = 0; b < this.data.y.vars.length; b++) {
			if (this.data.y.vars[b] == a) {
				return this.colors[b % this.colors.length]
			}
		}
		return this.colors[0]
	};
	this.getDefaultMetaDataObject = function() {
		var a = this.meta.def.colorBrew;
		return {
			rmin: a.rmin,
			rmax: a.rmax,
			min: a.min,
			max: a.max,
			decs: a.decs,
			vals: a.vals,
			maxLevLen: a.maxLevLen,
			maxLevChr: a.maxLevChr,
			maxLevStr: a.maxLevStr,
			colorBrew: a
		}
	};
	this.setPieData = function(m, o, l) {
		if (!this.cacheColors) {
			this.cacheColors = {
				PIE: {}
			}
		} else {
			if (!this.cacheColors.PIE) {
				this.cacheColors.PIE = {}
			}
		}
		var b = {
			no: 0,
			idso: [],
			ids: [],
			cols: [],
			data: {},
			raw: {},
			oprc: 0,
			tot: this.sum(m)
		};
		for (var h = 0; h < m.length; h++) {
			var g = o ? this.varIndices[h] : h;
			var a = m[g] / b.tot;
			var e = o ? this.data.y.vars[g] : h;
			var n;
			if (l && l[h % l.length]) {
				n = l[h % l.length]
			} else {
				if (this.cacheColors.PIE.hasOwnProperty(e)) {
					n = this.cacheColors.PIE[e]
				} else {
					n = this.pieColors[h % this.pieColors.length] ? this.pieColors[h % this.pieColors.length] : this.colors[h % this.colors.length];
					this.cacheColors.PIE[e] = n
				}
			}
			if (!isNaN(a)) {
				b.data[g] = a;
				b.raw[g] = m[g];
				if (h >= this.maxPieSectors - 1) {
					b.oprc += a;
					b.idso.push(g);
					b.no++
				} else {
					b.ids.push(g)
				}
				b.cols.push(n)
			}
		}
		if (b.no) {
			b.ids.push(-1)
		}
		return b
	};
	this.drawPie = function(u, h, g, t, J, w) {
		var q = function() {
			for (var a = 0; a < u.ids.length; a++) {
				if (u.data[u.ids[a]] && u.data[u.ids[a]] > -1 && isNaN(u.data[u.ids[a]])) {
					return false
				}
			}
			return true
		};
		if (q()) {
			var z, e;
			var o = this.startPieSectors != null ? (this.startPieSectors * Math.PI / 180) % 360 : 0;
			var A = this.pieSegmentLabels == "inside" ? t - (t / 3) : t + (t / 6);
			var H = 0;
			var D = this.layoutComb ? this.smpIndices[0] : this.xAxisIndices ? this.xAxisIndices[0] : 0;
			for (var F = 0; F < u.ids.length; F++) {
				var m = u.ids[F];
				var v = m > -1 ? u.data[m] : u.oprc;
				var f = u.cols[F];
				z = e != null ? parseFloat(e) : parseFloat((Math.PI * (2 * H)) - o);
				e = parseFloat(z + (Math.PI * (2 * (v))));
				var I = (z + e) / 2;
				var C = (e - z) / 32;
				var E = this.pieType == "separated" ? this.background : this.pieType == "solid" ? this.foreground : this.foreground;
				this.drawSelectedBackground(m > -1 ? m : u.idso[0], D, "pie", h, g, (t * 2) + 10, t + 10, false, true, z, e);
				this.drawShape("pie", h, g, (t * 2), t, f, f, "closed", false, 1, false, false, z, e);
				var G = u.ids.length > 1 ? h - Math.sin(I - (Math.PI / 2)) * A : h;
				var d = u.ids.length > 1 ? g + Math.cos(I - (Math.PI / 2)) * A : g;
				if (this.graphType != "Network" && this.showPieValues && (e - z) > 0.05) {
					if (this.pieLabelType == "value") {
						this.drawText(u.raw[m], G, d, this.axisTickFont, this.axisTickColor, "center", "middle")
					} else {
						this.drawText(sprintf("%." + this.pieSegmentPrecision + "f", v * 100) + "%", G, d, this.axisTickFont, this.axisTickColor, "center", "middle")
					}
				}
				if (J) {
					G = h + t * Math.cos(z);
					d = g + t * Math.sin(z);
					var b = ["poly", h, g, G, d];
					var o = z;
					for (var B = 0; B < 32; B++) {
						o += C;
						G = h + t * Math.cos(o);
						d = g + t * Math.sin(o);
						b.push(G);
						b.push(d)
					}
					b.push(h);
					b.push(g);
					if (this.graphType == "Network") {
						this.addAreaNetwork(b, J[F], w)
					} else {
						if (this.graphType != "Pie") {
							this.addArea(b, J[F], w)
						} else {
							if (m > -1) {
								this.addArea(b, [m, D])
							} else {
								u.idso.unshift(D);
								this.addArea(b, u.idso)
							}
						}
					}
				}
				H += v
			}
			H = 0;
			e = null;
			if (u.ids.length > 1) {
				for (var F = 0; F < u.ids.length; F++) {
					var m = u.ids[F];
					var v = m > -1 ? u.data[m] : u.oprc;
					z = e != null ? parseFloat(e) : parseFloat((Math.PI * (2 * H)) - o);
					e = parseFloat(z + (Math.PI * (2 * (v))));
					var E = this.pieType == "separated" ? this.background : this.pieType == "solid" ? this.foreground : this.foreground;
					this.drawShape("pie", h, g, (t * 2), t, false, E, "open", false, this.pieSegmentSeparation, false, false, z, e);
					H += v
				}
			}
			if (this.pieInnerRadius > 0 && this.pieInnerRadius < 1) {
				this.drawShape("circle", h, g, t * this.pieInnerRadius * 2, t * this.pieInnerRadius * 2, this.background, this.background, "closed")
			}
		}
	};
	this.drawBarPlot = function(Y, X, P, H, E, K, D, G, B, O, M, aa, L, ac, N, V, Q) {
		var F, C, W, J;
		var A = this;
		var U = function(c, e, b, d, a) {
			return A.processTreemap(c, {
				width: d,
				height: a,
				left: e,
				top: b
			})
		};
		var ab = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
		var I = this.variableSeparationFactor / 2;
		var T = E / 2;
		if (M == "vertical" || this.graphType == "Network") {
			for (var S = 0; S < Y.length; S++) {
				F = ((Y[S] - O) * G) - B;
				if (!isNaN(F)) {
					if (this.graphType == "Network") {
						var Z;
						if (F < 0) {
							Z = this.rectangle(P + I, H, E - this.variableSeparationFactor, -F, aa[S], aa[S], L[S])
						} else {
							Z = this.rectangle(P + I, H - F, E - this.variableSeparationFactor, F, aa[S], aa[S], L[S])
						}
						this.addAreaNetwork(Z, ac[S], N)
					} else {
						if (F < 0) {
							this.addArea(this.rectangle(P + I, H, E - this.variableSeparationFactor, -F, aa[S], this.objectBorderColor ? this.objectBorderColor : aa[S], L[S], false, false, V), ac[S], N)
						} else {
							if (D) {
								var R = U(D[S], P + I, H - F, E - this.variableSeparationFactor, F);
								this.drawTreemap(R, 0, 0)
							} else {
								this.addArea(this.rectangle(P + I, H - F, E - this.variableSeparationFactor, F, aa[S], this.objectBorderColor ? this.objectBorderColor : aa[S], L[S], false, false, V), ac[S], N)
							}
						}
					}
					W = H - F;
					J = P + T;
					if (X[S] && !isNaN(X[S])) {
						C = (X[S] / 2) * G;
						this.errorBar(J, W, J, W + C, -T, ab);
						this.errorBar(J, W, J, W - C, -T, ab)
					}
					if (this.showDataValues && !D) {
						this.drawText(Y[S], J, H - (F + this.overlayFontSize), this.overlayFont, aa[S], "center", "bottom")
					}
				}
				P += K
			}
		} else {
			for (var S = 0; S < Y.length; S++) {
				F = ((Y[S] - O) * G) - B;
				if (!isNaN(F)) {
					if (F < 0) {
						if (Q) {
							this.addArea(this.rectangle((P + Q) - B, H + I, -F, E - this.variableSeparationFactor, aa[S], this.objectBorderColor ? this.objectBorderColor : aa[S], L[S], false, false, V), ac[S], N)
						} else {
							this.addArea(this.rectangle(P + F, H + I, -F, E - this.variableSeparationFactor, aa[S], this.objectBorderColor ? this.objectBorderColor : aa[S], L[S], false, false, V), ac[S], N)
						}
					} else {
						if (Q) {
							if (D) {
								var R = U(D[S], (P + Q) - (F + B), H + I, F, E - this.variableSeparationFactor);
								this.drawTreemap(R, 0, 0)
							} else {
								this.addArea(this.rectangle((P + Q) - (F + B), H + I, F, E - this.variableSeparationFactor, aa[S], this.objectBorderColor ? this.objectBorderColor : aa[S], L[S], false, false, V), ac[S], N)
							}
						} else {
							if (D) {
								var R = U(D[S], P, H + I, F, E - this.variableSeparationFactor);
								this.drawTreemap(R, 0, 0)
							} else {
								this.addArea(this.rectangle(P, H + I, F, E - this.variableSeparationFactor, aa[S], this.objectBorderColor ? this.objectBorderColor : aa[S], L[S], false, false, V), ac[S], N)
							}
						}
					}
					W = Q ? (P + Q) - (F + B) : P + F;
					J = H + T;
					if (X[S] && !isNaN(X[S])) {
						C = (X[S] / 2) * G;
						this.errorBar(W, J, W + C, J, T, ab);
						this.errorBar(W, J, W - C, J, T, ab)
					}
					if (this.showDataValues && !D) {
						this.drawText(Y[S], W + this.overlayFontSize, J, this.overlayFont, aa[S], "left", "middle")
					}
				}
				H += K
			}
		}
	};
	this.drawLinePlot = function(Y, X, O, G, E, S, F, N, L, Z, J, H, ab, W, U, P) {
		var j = function() {
			var b = [
				[],
				[]
			];
			if (L == "vertical") {
				for (var a = 0; a < A[0].length; a++) {
					b[0].push(A[0][a]);
					b[1].push(A[1][a][0])
				}
				for (var a = A[0].length - 1; a >= 0; a--) {
					b[0].push(A[0][a]);
					b[1].push(A[1][a][1])
				}
			} else {
				for (var a = 0; a < A[1].length; a++) {
					b[0].push(A[0][a][0]);
					b[1].push(A[1][a])
				}
				for (var a = A[1].length - 1; a >= 0; a--) {
					b[0].push(A[0][a][1]);
					b[1].push(A[1][a])
				}
			}
			return b
		};
		var K, V, T, R, x, v, r;
		var D = E / 2;
		var C = E / 3;
		var aa = J == "open" ? Z : this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
		var M = Y.length - 1;
		var B = [
			[],
			[]
		];
		var A = [
			[],
			[]
		];
		if (L == "vertical") {
			V = O;
			T = O + S;
			for (var Q = 1; Q < Y.length; Q++) {
				K = Q - 1;
				x = G - ((Y[K] - N) * F);
				v = G - ((Y[Q] - N) * F);
				if (!isNaN(x)) {
					if (this.lineDecoration && H) {
						this.addArea(this.drawShape(H, V, x, C, C, Z, aa, J[K], false, false, U), ab[K], W)
					}
					if (X[K] != null && !isNaN(X[K])) {
						r = (X[K] / 2) * F;
						if (this.lineErrorType == "bar") {
							this.errorBar(V, x, V, x + r, -D, Z);
							this.errorBar(V, x, V, x - r, -D, Z)
						} else {
							A[0].push(V);
							A[1].push([x + r, x - r])
						}
					}
					if (this.lineType == "spline") {
						B[0].push(V);
						B[1].push(x)
					}
				}
				if ((this.lineType != "spline" && !isNaN(x) && !isNaN(v)) || Y.length < 3) {
					this.drawLine("line", V, x, T, v, Z, this.lineThickness, "butt", false, false, U)
				} else {
					if (this.lineType == "spline" && isNaN(v)) {
						this.drawLine("spline", B[0], B[1], false, false, Z, this.lineThickness, false, false, false, U);
						B = [
							[],
							[]
						]
					}
				}
				if (A[0].length > 0 && isNaN(v)) {
					var I = this.addColorTransparency(Z, 0.3);
					if (this.lineType == "spline") {
						this.drawShape("confidence", A[0], A[1], false, false, I, I, "closed", false, false, true)
					} else {
						var y = j();
						this.drawShape("path", y[0], y[1], false, false, I, I, "closed", false, false, true)
					}
					A = [
						[],
						[]
					]
				}
				V += S;
				T += S
			}
			if (!isNaN(v)) {
				if (this.lineDecoration && H) {
					this.addArea(this.drawShape(H, V, v, C, C, Z, aa, J[M], false, false, U), ab[M], W)
				}
				if (X[M] != null && !isNaN(X[M])) {
					r = (X[M] / 2) * F;
					if (this.lineErrorType == "bar") {
						this.errorBar(V, v, V, v + r, -D, Z);
						this.errorBar(V, v, V, v - r, -D, Z)
					} else {
						if (Q == Y.length) {
							A[0].push(V);
							A[1].push([v + r, v - r])
						}
					}
				}
				if (this.lineType == "spline") {
					B[0].push(V);
					B[1].push(v)
				}
			}
			if (this.lineType == "spline") {
				this.drawLine("spline", B[0], B[1], false, false, Z, this.lineThickness, false, false, false, U)
			}
			if (A[0].length > 0) {
				var I = this.addColorTransparency(Z, 0.3);
				if (this.lineType == "spline") {
					this.drawShape("confidence", A[0], A[1], false, false, I, I, "closed", false, false, true)
				} else {
					var y = j();
					this.drawShape("path", y[0], y[1], false, false, I, I, "closed", false, false, true)
				}
			}
		} else {
			x = G;
			v = G + S;
			for (var Q = 1; Q < Y.length; Q++) {
				K = Q - 1;
				V = P ? O + P - ((Y[K] - N) * F) : O + ((Y[K] - N) * F);
				T = P ? O + P - ((Y[Q] - N) * F) : O + ((Y[Q] - N) * F);
				if (!isNaN(V)) {
					if (this.lineDecoration && H) {
						this.addArea(this.drawShape(H, V, x, C, C, Z, aa, J[K], false, false, U), ab[K], W)
					}
					if (X[K] != null && !isNaN(X[K])) {
						R = (X[K] / 2) * F;
						if (this.lineErrorType == "bar") {
							this.errorBar(V, x, V + R, x, D, Z);
							this.errorBar(V, x, V - R, x, D, Z)
						} else {
							A[0].push([V + R, V - R]);
							A[1].push(x)
						}
					}
					if (this.lineType == "spline") {
						B[0].push(V);
						B[1].push(x)
					}
				}
				if ((this.lineType != "spline" && !isNaN(V) && !isNaN(T)) || Y.length < 3) {
					this.drawLine("line", T, v, V, x, Z, this.lineThickness, "butt", false, false, U)
				} else {
					if (this.lineType == "spline" && isNaN(T)) {
						this.drawLine("spline", B[0], B[1], false, false, Z, this.lineThickness, false, false, false, U);
						B = [
							[],
							[]
						]
					}
				}
				if (A[1].length > 0 && isNaN(T)) {
					var I = this.addColorTransparency(Z, 0.3);
					if (this.lineType == "spline") {
						this.drawShape("confidence", A[0], A[1], false, false, I, I, "closed", false, false, true)
					} else {
						var y = j();
						this.drawShape("path", y[0], y[1], false, false, I, I, "closed", false, false, true)
					}
					A = [
						[],
						[]
					]
				}
				x += S;
				v += S
			}
			if (!isNaN(T)) {
				if (this.lineDecoration && H) {
					this.addArea(this.drawShape(H, T, x, C, C, Z, aa, J[M], false, false, U), ab[M], W)
				}
				if (X[M] != null && !isNaN(X[M])) {
					R = (X[M] / 2) * F;
					if (this.lineErrorType == "bar") {
						this.errorBar(T, x, T + R, x, -D, Z);
						this.errorBar(T, x, T - R, x, -D, Z)
					} else {
						A[0].push([T + R, T - R]);
						A[1].push(x)
					}
				}
				if (this.lineType == "spline") {
					B[0].push(T);
					B[1].push(x)
				}
			}
			if (this.lineType == "spline") {
				this.drawLine("spline", B[0], B[1], false, false, Z, this.lineThickness, false, false, false, U)
			}
			if (A[1].length > 0) {
				var I = this.addColorTransparency(Z, 0.3);
				if (this.lineType == "spline") {
					this.drawShape("confidence", A[0], A[1], false, false, I, I, "closed", false, false, true)
				} else {
					var y = j();
					this.drawShape("path", y[0], y[1], false, false, I, I, "closed", false, false, true)
				}
			}
		}
	};
	this.drawStackedPlot = function(G, A, r, h, I, x, E, m, y, H, s, J, z, B) {
		var f = this;
		var D = function(c, e, b, d, a) {
			return f.processTreemap(c, {
				width: d,
				height: a,
				left: e,
				top: b
			})
		};
		if (y == "vertical") {
			for (var C = 0; C < G.length; C++) {
				if (G[C] > 0) {
					var j = x ? (G[C] * 100 / E) * m : G[C] * m;
					if (this.graphType == "Network") {
						this.addAreaNetwork(this.rectangle(A, r - j, h, j, H[C], this.objectBorderColor ? this.objectBorderColor : this.foreground, s[C]), J[C], z)
					} else {
						if (I) {
							var F = D(I[C], A, r - j, h, j);
							this.drawTreemap(F, 0, 0)
						} else {
							this.addArea(this.rectangle(A, r - j, h, j, H[C], this.objectBorderColor ? this.objectBorderColor : this.foreground, s[C]), J[C], z)
						}
					}
					r -= j
				}
			}
		} else {
			for (var C = 0; C < G.length; C++) {
				if (G[C] > 0) {
					var j = x ? (G[C] * 100 / E) * m : G[C] * m;
					if (B) {
						if (this.graphType == "Network") {
							this.addAreaNetwork(this.rectangle(A + B - j, r, j, h, H[C], this.objectBorderColor ? this.objectBorderColor : this.foreground, s[C]), J[C], z)
						} else {
							if (I) {
								var F = D(I[C], A + B - j, r, j, h);
								this.drawTreemap(F, 0, 0)
							} else {
								this.addArea(this.rectangle(A + B - j, r, j, h, H[C], this.objectBorderColor ? this.objectBorderColor : this.foreground, s[C]), J[C], z)
							}
						}
						A -= j
					} else {
						if (this.graphType == "Network") {
							this.addAreaNetwork(this.rectangle(A, r, j, h, H[C], this.objectBorderColor ? this.objectBorderColor : this.foreground, s[C]), J[C], z)
						} else {
							if (I) {
								var F = D(I[C], A, r, j, h);
								this.drawTreemap(F, 0, 0)
							} else {
								this.addArea(this.rectangle(A, r, j, h, H[C], this.objectBorderColor ? this.objectBorderColor : this.foreground, s[C]), J[C], z)
							}
						}
						A += j
					}
				}
			}
		}
	};
	this.drawAreaPlot = function(ab, S, G, D, Y, H, aa, K, F, X, I, M, Z, ac, L, ae, ad, A) {
		var N = ab.length - 1;
		var U = Z && this.lineType == "rect" ? "path" : this.lineType == "rect" ? "polygon" : "spline";
		var Q = [];
		var T = [];
		var J = [];
		var m = -X * F;
		var P = I * F;
		var O = function(b, a) {
			for (var c = a + 1; c < ab[b].length; c++) {
				if (ab[b][c] > 0) {
					return 1
				} else {
					if (ab[b][c] < 0) {
						return -1
					}
				}
			}
			return 0
		};
		if (M == "vertical") {
			for (var W = 0; W < ab[0].length; W++) {
				Q[W] = aa == "stacked" && X < 0 ? G - P : G;
				T[W] = G - P
			}
			for (var W = 0; W < ab.length; W++) {
				var g = S;
				var C = Z ? [] : [S];
				var B = Z ? [] : [G - m];
				var u = 0;
				for (var V = 0; V < ab[0].length; V++) {
					if (isNaN(ab[W][V])) {
						if (!Z) {
							C.push(g - H);
							B.push(G - m)
						}
						if (Z && this.lineType == "spline") {
							this.addArea(this.drawLine(U, C, B, false, false, ac[W], this.lineThickness), ae[W], ad)
						} else {
							this.addArea(this.drawShape(U, C, B, this.width, this.height, ac[W], this.objectBorderColor ? this.objectBorderColor : ac[W], L[W]), ae[W], ad)
						}
						C = Z ? [] : [g + H];
						B = Z ? [] : [G - m]
					} else {
						var E = aa == "percent" ? ((ab[W][V] - X) * 100 / K[V]) * F : (ab[W][V] - (aa == "stacked" && X < 0 ? 0 : X)) * F;
						C.push(g);
						if (aa && (aa == "stacked" || aa == "percent")) {
							if (ab[W][V] > 0 || u > 0) {
								B.push(Q[V] - E);
								Q[V] -= E;
								u = 1
							} else {
								if (ab[W][V] < 0 || u < 0) {
									B.push(T[V] - E);
									T[V] -= E;
									u = -1
								} else {
									var R = O(W, V);
									if (R < 0) {
										B.push(T[V] - E);
										T[V] -= E;
										u = -1
									} else {
										if (R > 0) {
											B.push(Q[V] - E);
											Q[V] -= E;
											u = 1
										} else {
											B.push(m)
										}
									}
								}
							}
						} else {
							B.push(G - E)
						}
					}
					g += H
				}
				if (!Z) {
					C.push(S + D);
					B.push(G - m)
				}
				J.push([C, B])
			}
		} else {
			for (var W = 0; W < ab[0].length; W++) {
				Q[W] = A ? S + A : aa == "stacked" && X < 0 ? S + P : S;
				T[W] = S + P
			}
			for (var W = 0; W < ab.length; W++) {
				var g = G;
				var C = Z ? [] : A ? [S + A] : [S + m];
				var B = Z ? [] : [G];
				var u = 0;
				for (var V = 0; V < ab[0].length; V++) {
					if (isNaN(ab[W][V])) {
						if (!Z) {
							C.push(A ? S + A : S + m);
							B.push(g - H)
						}
						if (Z && this.lineType == "spline") {
							this.addArea(this.drawLine(U, C, B, false, false, ac[W], this.lineThickness), ae[W], ad)
						} else {
							this.addArea(this.drawShape(U, C, B, this.width, this.height, ac[W], this.objectBorderColor ? this.objectBorderColor : ac[W], L[W]), ae[W], ad)
						}
						C = Z ? [] : [A ? S + A : S + m];
						B = Z ? [] : [g + H]
					} else {
						var E = aa == "percent" ? ((ab[W][V] - X) * 100 / K[V]) * F : (ab[W][V] - (aa == "stacked" && X < 0 ? 0 : X)) * F;
						B.push(g);
						if (aa && (aa == "stacked" || aa == "percent")) {
							if (A) {
								C.push(Q[V] - E);
								Q[V] -= E
							} else {
								if (ab[W][V] > 0 || u > 0) {
									C.push(Q[V] + E);
									Q[V] += E;
									u = 1
								} else {
									if (ab[W][V] < 0 || u < 0) {
										C.push(T[V] + E);
										T[V] += E;
										u = -1
									} else {
										var R = O(W, V);
										if (R < 0) {
											C.push(T[V] + E);
											T[V] += E;
											u = -1
										} else {
											if (R > 0) {
												C.push(Q[V] + E);
												Q[V] += E;
												u = 1
											} else {
												B.push(m)
											}
										}
									}
								}
							}
						} else {
							C.push(A ? S + A - E : S + E)
						}
					}
					g += H
				}
				if (!Z) {
					C.push(A ? S + A : S + m);
					B.push(G + Y)
				}
				J.push([C, B])
			}
		}
		while (N >= 0) {
			var V = J.pop();
			if (Z && this.lineType == "spline") {
				this.addArea(this.drawLine(U, V[0], V[1], false, false, ac[N], this.lineThickness), ae[N], ad)
			} else {
				this.addArea(this.drawShape(U, V[0], V[1], this.width, this.height, ac[N], this.objectBorderColor ? this.objectBorderColor : ac[N], L[N]), ae[N], ad)
			}
			N--
		}
	};
	this.drawBoxPlot = function(Q, K, D, A, G, C, J, I, R, H, T, O) {
		var y = function(a) {
			return I == "vertical" ? D - ((a - J) * C) : K + ((a - J) * C)
		};
		var S = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
		var E = this.variableSeparationFactor / 2;
		var N = A / 2;
		var n = N / 2;
		var k = n / 2;
		var P = A / this.boxPlotOutliersRatio;
		var x = {};
		if (I == "vertical") {
			for (var M = 0; M < Q.length; M++) {
				var F = K + N;
				var B = [];
				var e = this.showBoxplotOriginalData || this.showViolinBoxplot ? O[M] : R[M];
				for (var L = 0; L < 5; L++) {
					B.push(y(Q[M][L]))
				}
				this.addArea(this.rectangle(K + E, B[3], A - this.variableSeparationFactor, B[2] - B[3], R[M], this.objectBorderColor ? this.objectBorderColor : R[M], H[M], false, false, true), T[M]);
				this.drawLine("line", K + E, B[4], K + (A - E), B[4], this.boxplotMedianColor, this.boxplotMedianWidth, "butt", false, false, true);
				this.errorBar(F, B[2], F, B[0], -N, S);
				this.errorBar(F, B[3], F, B[1], -N, S);
				if (this.boxplotMean) {
					this.rectangle(F - k, y(Q[M][6]) - k, n, n, this.boxplotMeanColor, this.boxplotMeanColorBorder)
				}
				if (Q[M][5]) {
					for (var L = 0; L < Q[M][5].length; L++) {
						this.drawShape("sphere", F, y(Q[M][5][L]), P, P, R[M], S, H[M], false, false, true)
					}
				}
				if (!x.hasOwnProperty(e)) {
					x[e] = []
				}
				x[e].push([K + E + (A / 2), B[4]]);
				K += G
			}
		} else {
			for (var M = 0; M < Q.length; M++) {
				var F = D + N;
				var B = [];
				var e = this.showBoxplotOriginalData || this.showViolinBoxplot ? O[M] : R[M];
				for (var L = 0; L < 5; L++) {
					B.push(y(Q[M][L]))
				}
				this.addArea(this.rectangle(B[2], D + E, B[3] - B[2], A - this.variableSeparationFactor, R[M], this.objectBorderColor ? this.objectBorderColor : R[M], H[M], false, false, true), T[M]);
				this.drawLine("line", B[4], D + E, B[4], D + (A - E), this.boxplotMedianColor, this.boxplotMedianWidth, "butt", false, false, true);
				this.errorBar(B[2], F, B[0], F, N, S);
				this.errorBar(B[3], F, B[1], F, N, S);
				if (this.boxplotMean) {
					this.rectangle(y(Q[M][6]) - k, F - k, n, n, this.boxplotMeanColor, this.boxplotMeanColorBorder)
				}
				if (Q[M][5]) {
					for (var L = 0; L < Q[M][5].length; L++) {
						this.drawShape("sphere", y(Q[M][5][L]), F, P, P, R[M], S, H[M], false, false, true)
					}
				}
				if (!x.hasOwnProperty(e)) {
					x[e] = []
				}
				x[e].push([B[4], D + E + (A / 2)]);
				D += G
			}
		}
		if (this.boxplotConnect) {
			for (var e in x) {
				for (var M = 0; M < x[e].length - 1; M++) {
					this.drawLine("line", x[e][M][0], x[e][M][1], x[e][M + 1][0], x[e][M + 1][1], e, this.boxplotConnectWidth, "butt", false, false, true)
				}
			}
		}
	};
	this.drawCandlestickPlot = function(G, B, q, f, F, n, A, x, y, H, J) {
		var e = function(a) {
			return y == "vertical" ? q - ((a - A) * n) : B + ((a - A) * n)
		};
		var I = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
		var E = f / 2;
		if (y == "vertical") {
			for (var D = 0; D < G.length; D++) {
				var s = B + E;
				var k = [];
				for (var C = 0; C < G[D].length; C++) {
					k.push(e(G[D][C]))
				}
				if (x) {
					if (k[0] > k[1]) {
						this.addArea(this.rectangle(B, k[1], f, k[0] - k[1], false, H, "open", false, false, true), J[D]);
						this.drawLine("line", s, k[1], s, k[2], H, false, "butt", false, false, true);
						this.drawLine("line", s, k[3], s, k[0], H, false, "butt", false, false, true)
					} else {
						this.addArea(this.rectangle(B, k[0], f, k[1] - k[0], H, H, "closed", false, false, true), J[D]);
						this.drawLine("line", s, k[3], s, k[1], H, false, "butt", false, false, true);
						this.drawLine("line", s, k[0], s, k[2], H, false, "butt", false, false, true)
					}
				} else {
					this.addArea(this.rectangle(B, k[0], f, q - k[0], H, H, "closed", false, false, true), J[D])
				}
				B += F
			}
		} else {
			for (var D = 0; D < G.length; D++) {
				var s = q + E;
				var k = [];
				for (var C = 0; C < G[D].length; C++) {
					k.push(e(G[D][C]))
				}
				if (x) {
					if (k[1] > k[0]) {
						this.addArea(this.rectangle(k[0], q, k[1] - k[0], f, false, H, "open", false, false, true), J[D]);
						this.drawLine("line", k[1], s, k[2], s, H, false, "butt", false, false, true);
						this.drawLine("line", k[3], s, k[0], s, H, false, "butt", false, false, true)
					} else {
						this.addArea(this.rectangle(k[1], q, k[0] - k[1], f, H, H, "closed", false, false, true), J[D]);
						this.drawLine("line", k[3], s, k[1], s, H, false, "butt", false, false, true);
						this.drawLine("line", k[0], s, k[2], s, H, false, "butt", false, false, true)
					}
				} else {
					this.addArea(this.rectangle(B, q, k[0] - B, f, H, H, "closed", false, false, true), J[D])
				}
				q += F
			}
		}
	};
	this.drawViolin = function(D, w, n, C, k, s, q, E) {
		var b = D.kde;
		var f = [];
		var z = [];
		var e = [];
		var r = [];
		var j, g;
		var a = [];
		if (b.length < 3) {
			b.splice(1, 0, [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2])
		}
		for (var B = 0; B < b.length; B++) {
			a.push(b[B][1])
		}
		var A = this.max(a);
		if (A == 0) {
			for (var B = 1; B < b.length - 1; B++) {
				b[B][1] = 0.000001
			}
			A = 0.000001
		}
		var v = (C / 2.2) / (A);
		var p = this.addColorTransparency(E, 0.5);
		if (q == "vertical") {
			for (var B = 0; B < b.length; B++) {
				j = (b[B][1] * v);
				g = ((b[B][0] - s) * k);
				f.push(w - j);
				z.push(n - g);
				e.push(w + j);
				r.push(n - g)
			}
		} else {
			for (var B = 0; B < b.length; B++) {
				j = ((b[B][0] - s) * k);
				g = (b[B][1] * v);
				f.push(w + j);
				z.push(n - g);
				e.push(w + j);
				r.push(n + g)
			}
		}
		this.drawShape("violin", [f, e], [z, r], false, false, p, this.foreground)
	};
	this.drawDotPlot = function(X, W, P, H, T, K, F, O, I, M, Y, Q, L, V, ab, D, J, C) {
		var E, x, B;
		var aa = [];
		var A = this.jitter ? Math.ceil(Math.log(this.smpIndices.length * 25) / Math.LN10) : 1;
		var U = this.jitter ? V / A : 0;
		var Z = this.backgroundType.match(/window/i) ? this.foregroundWindow : this.foreground;
		if (M == "vertical") {
			if (this.jitter) {
				P -= V / 2
			}
			for (var S = 0; S < X.length; S++) {
				if (this.showBoxplotOriginalData || this.graphType.match(/Dot/)) {
					var N = 0;
					for (var R = 0; R < X[S].length; R++) {
						E = H - ((X[S][R] - O) * F);
						if (!isNaN(E)) {
							this.addArea(this.drawShape(L[S][R], P + N, E, I[S][R], I[S][R], Y[S][R], this.objectBorderColor ? this.objectBorderColor : Z, Q[S][R], false, false, J), ab[S][R], D);
							aa.push([P + N, E]);
							if (!this.isGroupedData) {
								if (W[S] && W[S][R] && !isNaN(W[S][R])) {
									x = (W[S][R] / 2) * F;
									this.errorBar(P + N, E, P + N, E + x, -T, Y[S][R]);
									this.errorBar(P + N, E, P + N, E - x, -T, Y[S][R])
								}
							}
							N = this.jitter && (R + 1) % (A + 1) ? N + U : 0
						}
					}
					if (this.showErrorBars && this.isGroupedData && W[S] && W[S] && !isNaN(W[S][0]) && !isNaN(W[S][1])) {
						E = H - ((W[S][0] - O) * F);
						x = (W[S][1] / 2) * F;
						this.drawShape("diamond", P + (V / 2), E, this.margin * 2, this.margin * 2, this.foreground, this.foreground, "closed", false, false, J);
						this.drawLine("line", P + (V / 2), E - x, P + (V / 2), E + x, this.foreground, this.lineThickness * 2, "butt", false, false, J)
					}
				}
				if (this.showViolinBoxplot) {
					this.drawViolin(this.getViolin(X[S]), this.jitter ? P + (V / 2) : P, H, T, F, O, M, Y[S][0])
				}
				P += K
			}
		} else {
			if (this.jitter) {
				H -= V / 2
			}
			for (var S = 0; S < X.length; S++) {
				if (this.showBoxplotOriginalData || this.graphType.match(/Dot/)) {
					var N = 0;
					for (var R = 0; R < X[S].length; R++) {
						E = C ? P + C - ((X[S][R] - O) * F) : P + ((X[S][R] - O) * F);
						if (!isNaN(E)) {
							this.addArea(this.drawShape(L[S][R], E, H + N, I[S][R], I[S][R], Y[S][R], this.objectBorderColor ? this.objectBorderColor : Z, Q[S][R], false, false, J), ab[S][R], D);
							aa.push([E, H + N]);
							if (!this.isGroupedData) {
								if (W[S] && W[S][R] && !isNaN(W[S][R])) {
									x = (W[S][R] / 2) * F;
									this.errorBar(E, H + N, E + x, H + N, T, Y[S][R]);
									this.errorBar(E, H + N, E - x, H + N, T, Y[S][R])
								}
							}
							N = this.jitter && (R + 1) % (A + 1) ? N + U : 0
						}
					}
				}
				if (this.showErrorBars && this.isGroupedData && W[S] && W[S] && !isNaN(W[S][0]) && !isNaN(W[S][1])) {
					E = P + ((W[S][0] - O) * F);
					x = (W[S][1] / 2) * F;
					this.drawShape("diamond", E, H + (V / 2), this.margin * 2, this.margin * 2, this.foreground, this.foreground, "closed", false, false, J);
					this.drawLine("line", E - x, H + (V / 2), E + x, H + (V / 2), this.foreground, this.lineThickness * 2, "butt", false, false, J)
				}
				if (this.showViolinBoxplot) {
					this.drawViolin(this.getViolin(X[S]), P, this.jitter ? H + (V / 2) : H, T, F, O, M, Y[S][0])
				}
				H += K
			}
		}
		if (this.connectBy && this.data.x.hasOwnProperty(this.connectBy)) {
			var G = this.connectBy == this.colorBy ? this.meta.data.x[this.colorBy] : false;
			for (var S in this.connectByData) {
				X = this.connectByData[S];
				B = G && G.type != "Numeric" ? G.colors[G.order[S] % G.colors.length] : this.getColorForValue(G.colorBrew, S);
				if (X.length > 1) {
					for (var R = 1; R < X.length; R++) {
						E = aa[X[R - 1]];
						x = aa[X[R]];
						this.drawLine("line", E[0], E[1], x[0], x[1], B, this.lineThickness, "butt", false, false, J)
					}
				}
			}
		}
	};
	this.drawHeatmap = function(J, E, x, k, G, I, N, H, B, M, A) {
		var g = this.graphType == "Network" ? false : true;
		var s = 0;
		var j = E;
		var y = A ? 0 : 2;
		var D = this.meta.vals;
		if (!D.colors) {
			D.colors = {}
		}
		for (var F = 0; F < J.length; F++) {
			var n = J[F];
			var L = isNaN(n) ? this.missingDataColor : D.colors[n.toString()] ? D.colors[n.toString()] : this.getColorForValue(M, n);
			var C = I ? L : this.heatmapCellBoxColor;
			D.colors[n.toString()] = L;
			if (this.graphType == "Network") {
				var K;
				if (this.shapeByShape) {
					K = this.drawShape(this.shapeByShape, E + (k / 2), x + (G / 2), k / 2, G / 2, L, C, B[F], false, false, g)
				} else {
					K = this.rectangle(E, x, k, G, L, L, B[F], false, false, g)
				}
				this.addAreaNetwork(K, N[F], H)
			} else {
				if (this.shapeByShape) {
					this.addArea(this.drawShape(this.shapeByShape, E + (k / 2), x + (G / 2), k / 2, G / 2, L, C, B ? B[F] : false, false, false, g), N[F], H)
				} else {
					if (F > 0 && F < J.length - 1) {
						if (s >= 0.5) {
							this.addArea(this.rectangle(E, x, k + 2, G + y, L, L, B ? B[F] : false, false, false, g), N[F], H);
							s = 0
						}
					} else {
						this.addArea(this.rectangle(E, x, k + 2, G + y, L, L, B ? B[F] : false, false, false, g), N[F], H)
					}
				}
			}
			if (this.showDataValues) {
				this.drawText(n, (E + k) - 2, (x + G) - 2, this.overlayFont, this.foreground, "right", "bottom")
			}
			E += k;
			s += k
		}
		if (!I && !this.shapeByShape) {
			this.drawLine("line", j, x, E, x, this.heatmapCellBoxColor, this.heatmapCellBoxWidth)
		}
	};
	this.drawTreemap = function(h, b, n, j, k) {
		this.functionCaller = "drawTreemap";
		var g = this;
		var m = function(c) {
			g.addArea(g.rectangle(c.coords.left + b, c.coords.top + n, c.coords.width, c.coords.height, c.color, this.objectBorderColor ? this.objectBorderColor : false, "closed"), c.index);
			if (c.label) {
				var a = g.measureText(c.label, g.smpLabelFont);
				if (a + g.margin < c.coords.width) {
					g.drawText(c.label, c.coords.left + b + 2, c.coords.top + n, g.smpLabelFont, this.foreground, "left", "top")
				} else {
					if (a + g.margin < c.coords.height) {
						g.drawText(c.label, c.coords.left + b, c.coords.top + n + 2, g.smpLabelFont, this.foreground, "right", "top", -Math.PI / 2)
					}
				}
			}
		};
		var f = function(c) {
			for (var a = 0; a < c.length; a++) {
				if (c[a].children) {
					f(c[a].children)
				} else {
					m(c[a])
				}
			}
		};
		for (var e = 0; e < h.length; e++) {
			if (h[e].children) {
				f(h[e].children)
			} else {
				m(h[e])
			}
		}
	};
	this.zoomOncoprintVariables = function(c) {
		this.functionCaller = "zoomOncoprintVariables";
		var b = [];
		this.setOriginalIndices(false, this.varIndices, this.smpIndices);
		this.varIndicesStart = 0;
		for (var a = 0; a < Math.min(c, this.varIndices.length); a++) {
			b.push(this.varIndices[a])
		}
		this.varIndices = b;
		this.draw()
	}
};
CanvasXpress.prototype.init3dUtils = function() {
	this.setTrigonometry = function() {
		if (!this.meta.math) {
			this.meta.math = {
				sin: [0],
				cos: [1]
			};
			for (var b = 1; b <= 360; b++) {
				var a = Math.PI / (180 / b);
				this.meta.math.sin[b] = Math.sin(a);
				this.meta.math.cos[b] = Math.cos(a)
			}
		}
	};
	this.set3DRotation = function() {
		this.setTrigonometry();
		var a = ["xRotate", "yRotate", "zRotate"];
		for (var b = 0; b < a.length; b++) {
			if (this[a[b]] > 360) {
				this[a[b]] -= 360
			}
			if (this[a[b]] < 0) {
				this[a[b]] = 360
			}
		}
	};
	this.set3DParams = function() {
		var b = this.invMagnificationFactor;
		var c = this.zoom;
		var a = this.x;
		this.perspective = a * this.perspectiveFactor;
		this.lenX = a / b * c * this.x3DRatio;
		this.lenY = a / b * c * this.y3DRatio;
		this.lenZ = a / b * c * this.z3DRatio;
		this.padX = a / 2;
		this.padY = this.y / 2;
		this.padZ = this.padY
	};
	this.get3DTransfrom = function(g, a, k) {
		var f, e, b;
		var h = [];
		var n = this.meta.math.sin;
		var j = this.meta.math.cos;
		var d = this.perspective;
		var m = this.xRotate;
		var l = this.yRotate;
		var i = this.zRotate;
		e = a;
		b = k;
		a = e * j[parseInt(l)] - b * n[parseInt(l)];
		k = e * n[parseInt(l)] + b * j[parseInt(l)];
		f = g;
		b = k;
		g = b * n[parseInt(m)] + f * j[parseInt(m)];
		k = b * j[parseInt(m)] - f * n[parseInt(m)];
		f = g;
		e = a;
		g = f * j[parseInt(i)] - e * n[parseInt(i)];
		a = f * n[parseInt(i)] + e * j[parseInt(i)];
		if (this.perspective) {
			g = g * (d / (k + d));
			a = a * (d / (k + d));
			k = k * (d / (k + d))
		}
		h.push(g + this.padX);
		h.push(a + this.padY);
		h.push(k + this.padZ);
		return h
	}
};
CanvasXpress.prototype.initApiUtils = function() {
	this.getValidGraphTypes = function() {
		return this.validGraphTypes
	};
	this.setHeatmapScheme = function() {
		this.initializeAttributes()
	};
	this.hasIndicator = function() {
		if (this.graphType.match(/Scatter/) || this.graphType == "Bar") {
			return true
		} else {
			return false
		}
	};
	this.hasLegend = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Correlation" && this.graphType != "Heatmap") {
			return true
		} else {
			return false
		}
	};
	this.hasLegendProperties = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Correlation" && this.graphType != "Heatmap" && this.graphType != "Pie") {
			return true
		} else {
			return false
		}
	};
	this.hasData = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
			return true
		} else {
			return false
		}
	};
	this.hasDataSamples = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && !this.graphType.match(/Scatter/)) {
			if (this.graphType == "Correlation" && this.correlationAxis != "samples") {
				return false
			}
			return true
		} else {
			return false
		}
	};
	this.hasDataGroups = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && !this.graphType.match(/Scatter/)) {
			if (this.graphType == "Correlation" && this.correlationAxis != "samples") {
				return false
			}
			if (this.data.x) {
				return true
			} else {
				return false
			}
		} else {
			return false
		}
	};
	this.hasDataVariables = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
			if (this.graphType == "Correlation" && this.correlationAxis != "variables") {
				return false
			}
			return true
		} else {
			return false
		}
	};
	this.hasDataProperties = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Heatmap" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation") {
			return true
		} else {
			return false
		}
	};
	this.hasOrientation = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && this.graphType != "Circular" && !this.graphType.match(/Scatter/)) {
			return true
		} else {
			return false
		}
	};
	this.hasOverlays = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && !this.graphType.match(/Scatter/)) {
			return true
		} else {
			return false
		}
	};
	this.hasDendrograms = function() {
		if (this.graphType != "Heatmap" && (this.data.t.smps || this.data.t.vars)) {
			return true
		} else {
			return false
		}
	};
	this.hasDecorations = function() {
		return this.data.d && (this.data.d.nlfit || this.data.d.line || this.data.d.reg || this.data.d.nor || this.data.d.area) ? true : false
	};
	this.isSegregable = function() {
		if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && !this.graphType.match(/Scatter/)) {
			return true
		} else {
			return false
		}
	};
	this.getLineTypes = function() {
		var e = ["line"];
		var c = ["", "dashed", "dotted", "bezierY", "bezierX", "curved"];
		var a = ["arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"];
		for (var d = 0; d < a.length; d++) {
			e.push(a[d] + "Line")
		}
		for (var d = 1; d < c.length; d++) {
			for (var b = 0; b < a.length; b++) {
				e.push(c[d] + this.capitalize(a[b]) + "Line")
			}
		}
		return e
	};
	this.isValidShape = function(b) {
		for (var a = 0; a < this.shapes.length; a++) {
			if (this.shapes[a] == b) {
				return true
			}
		}
		return false
	};
	this.getHeatmapSchemes = function() {
		var c = [];
		var d = ["blue", "red", "green", "yellow", "cyan", "purple", "white", "black"];
		for (var b = 0; b < d.length; b++) {
			c.push(d[b]);
			for (var a = 0; a < d.length; a++) {
				if (d[b] != d[a]) {
					c.push(d[b] + "-" + d[a])
				}
			}
		}
		return c
	};
	this.isCompatibleGraphType = function(b, a) {
		if (b.match(/^Bar$|^Line$|Boxplot|Dotplot/)) {
			return a.match(/^Bar$|^Line$|Boxplot|Dotplot/) ? true : false
		} else {
			return false
		}
	};
	this.isOneDimensionalGraph = function() {
		return !this.graphType.match(/Scatter|Network|Venn|Genome|Circular|Correlation/)
	};
	this.modifyHighlights = function(c, b, d) {
		var a = d ? "highlightVar" : "highlightSmp";
		this.modifyObjectArray(c, b, a)
	};
	this.getHighlights = function(a) {
		return this.getObjectArray(a ? this.highlightVar : this.highlightSmp)
	};
	this.modifyOverlaysProperties = function(h) {
		this.functionCaller = "modifyOverlaysProperties";
		var e = this;
		var b, a, g;
		var f = false;
		if (!this.isArray(h)) {
			var d = [];
			for (var c = 0; c < arguments.length; c++) {
				d.push(arguments[c])
			}
			h = d;
			f = true
		}
		a = h.shift();
		g = this.cloneObject(h);
		while (g.length > 1) {
			b = g.shift();
			if (!e[b]) {
				e[b] = {}
			}
			e = e[b]
		}
		b = g.shift();
		e[b] = isNaN(a) ? a : Number(a);
		if (!f) {
			h.unshift(a)
		}
		this.draw()
	};
	this.modifySmpOverlays = function(b, a) {
		this.modifyObjectArray(b, a, "smpOverlays")
	};
	this.modifyVarOverlays = function(b, a) {
		this.modifyObjectArray(b, a, "varOverlays")
	};
	this.getSmpOverlays = function() {
		return this.getObjectArray(this.smpOverlays)
	};
	this.getVarOverlays = function() {
		return this.getObjectArray(this.varOverlays)
	};
	this.getXData = function() {
		var b = [];
		if (this.data.x) {
			for (var a in this.data.x) {
				b.push(a)
			}
		}
		return b
	};
	this.getZData = function() {
		var b = [];
		if (this.data.z) {
			for (var a in this.data.z) {
				b.push(a)
			}
		}
		return b
	};
	this.getXZData = function() {
		return this.graphType.match(/Scatter/) ? this.getZData() : this.getXData()
	};
	this.getSamplesAsArray = function() {
		var d = this.getSamples();
		var b = [];
		for (var c = 0; c < d.length; c++) {
			b.push(d[c].name)
		}
		return b
	};
	this.getVariablesAsArray = function() {
		var d = this.getVariables();
		var b = [];
		for (var c = 0; c < d.length; c++) {
			b.push(d[c].name)
		}
		return b
	};
	this.getNodeData = function(a) {
		return this.getNetworkData("nodes", a)
	};
	this.getEdgeData = function(a) {
		return this.getNetworkData("edges", a)
	};
	this.getSampleVariableData = function(g, j) {
		var f = {
			smps: {
				idx: "smpIndices",
				spc: "x"
			},
			vars: {
				idx: "varIndices",
				spc: "z"
			}
		};
		var b = {};
		b[g] = {
			o: {},
			t: "string"
		};
		if (j) {
			b[g]["o"] = this.getObjectArray(this.data.y[g])
		} else {
			for (var d = 0; d < this[f[g]["idx"]].length; d++) {
				b[g]["o"][this.data.y[g][this[f[g]["idx"]][d]]] = true
			}
		}
		if (this.data[f[g]["spc"]]) {
			for (var h in this.data[f[g]["spc"]]) {
				b[h] = {
					o: {},
					t: "numeric"
				};
				if (j) {
					if (this.isNumeric(this.data[f[g]["spc"]][h])) {
						b[h]["t"] = "numeric";
						var a = this.range(this.data[f[g]["spc"]][h]);
						b[h]["o"] = {
							min: a[0],
							max: a[1]
						}
					} else {
						b[h]["t"] = "string";
						b[h]["o"] = this.getObjectArray(this.getUniqueKeys(this.data[f[g]["spc"]][h]))
					}
				} else {
					for (var d = 0; d < this[f[g]["idx"]].length; d++) {
						var c = this.data[f[g]["spc"]][h][this[f[g]["idx"]][d]];
						if (b[h]["o"].hasOwnProperty(c)) {
							b[h]["o"][c]++
						} else {
							b[h]["o"][c] = 1
						}
						if (isNaN(c)) {
							b[h]["t"] = "string"
						}
					}
					if (b[h]["t"] == "numeric") {
						var e = [];
						for (var c in b[h]["o"]) {
							for (var d = 0; d < b[h]["o"][c]; d++) {
								e.push(c)
							}
						}
						var a = this.range(e);
						b[h]["o"] = {
							min: a[0],
							max: a[1]
						}
					}
				}
			}
		}
		return b
	};
	this.getNetworkData = function(d, a) {
		if (this.graphType == "Network" && !this[d + "Data"]) {
			this[d + "Data"] = {};
			var f = this.skipConfigurableProperties ? this.getObjectArray(this[d.replace("s", "") + "ConfigurableProperties"]) : {};
			for (var c = 0; c < this.data[d].length; c++) {
				var e = this.data[d][c];
				for (var b in e) {
					if (!f[b]) {
						if (typeof(e[b]) != "object") {
							if (this[d + "Data"].hasOwnProperty(b)) {
								if (this[d + "Data"][b]["o"].hasOwnProperty(e[b])) {
									this[d + "Data"][b]["o"][e[b]]++
								} else {
									this[d + "Data"][b]["o"][e[b]] = 1
								}
								if (isNaN(e[b])) {
									this[d + "Data"][b]["t"] = "string"
								}
							} else {
								this[d + "Data"][b] = {
									o: {},
									t: isNaN(e[b]) ? "string" : "numeric"
								};
								this[d + "Data"][b]["o"][e[b]] = 1
							}
						}
					}
				}
				if (this[d + "Properties"].length > 0) {
					this.getAdditionalData(e, this[d + "Data"], this[d + "Properties"])
				}
			}
		}
		if (this.graphType == "Network") {
			return a ? this[d + "Data"] : this.getKeys(this[d + "Data"])
		} else {
			return false
		}
	};
	this.getFilteredNetworkData = function(h, k) {
		var b = {
			type: {}
		};
		if (this.graphType == "Network") {
			var d = this.skipConfigurableProperties ? this.getObjectArray(this[h.replace("s", "") + "ConfigurableProperties"]) : {};
			for (var f = 0; f < this.data[h].length; f++) {
				var e = this.data[h][f];
				if (k || (!k && !e.hide)) {
					for (var j in e) {
						if (!d[j]) {
							if (typeof(e[j]) != "object") {
								if (b[h].hasOwnProperty(j)) {
									b[h][j]["o"][e[j]]++;
									if (isNaN(e[j])) {
										b[h][j]["t"] = "string"
									}
								} else {
									b[h][j] = {
										o: {},
										t: isNaN(e[j]) ? "string" : "numeric"
									};
									b[h][j]["o"][e[j]] = 1
								}
							}
						}
					}
				}
				if (this[h + "Properties"].length > 0) {
					this.getAdditionalData(e, b, this[h + "Properties"])
				}
			}
			for (var j in b[h]) {
				if (b[h][j]["t"] == "numeric") {
					var g = [];
					for (var c in b[h][j]["o"]) {
						for (var f = 0; f < b[h][j]["o"][c]; f++) {
							g.push(c)
						}
					}
					var a = this.range(g);
					b[h][j]["o"] = {
						min: a[0],
						max: a[1]
					}
				}
			}
		}
		return b
	};
	this.getFeatureData = function(a) {
		if (!this.featuresData) {
			var h = {};
			var d = this.skipConfigurableProperties ? this.getObjectArray(this.featureConfigurableProperties) : {};
			for (var g = 0; g < this.data.tracks.length; g++) {
				var c = this.data.tracks[g];
				var b = c.data;
				for (var e = 0; e < b.length; e++) {
					var l = b[e];
					for (var k in l) {
						if (!d[k]) {
							if (typeof(l[k]) != "object") {
								if (h.hasOwnProperty(k)) {
									if (h[k]["o"].hasOwnProperty(l[k])) {
										h[k]["o"][l[k]]++
									}
									if (isNaN(l[k])) {
										h[k]["t"] = "string"
									}
								} else {
									h[k] = {
										o: {},
										t: isNaN(l[k]) ? "string" : "numeric"
									};
									h[k]["o"][l[k]] = 1
								}
							}
						}
					}
				}
				if (this.featuresProperties.length > 0) {
					this.getAdditionalData(b, h, this.featuresProperties)
				}
			}
			this.featuresData = h
		}
		return a ? this.featuresData : this.getKeys(this.featuresData)
	};
	this.getAdditionalData = function(d, e, h) {
		for (var f = 0; f < h.length; f++) {
			var b = d;
			var k = false;
			if (h[f].length > 0) {
				for (var c = 0; c < h[f].length; c++) {
					var a = h[f][c];
					if (b[a]) {
						b = b[a]
					} else {
						k = true;
						break
					}
				}
				if (!k) {
					for (var g in b) {
						if (typeof(b[g]) != "object") {
							if (e.hasOwnProperty(g)) {
								if (e[g]["o"].hasOwnProperty(b[g])) {
									e[g]["o"][b[g]]++
								}
								if (isNaN(b[g])) {
									e[g]["t"] = "string"
								}
							} else {
								e[g] = {
									o: {},
									t: isNaN(b[g]) ? "string" : "numeric",
									r: f
								};
								e[g]["o"][b[g]] = 1
							}
						}
					}
				}
			}
		}
	};
	this.getOperators = function() {
		return ["", "like", "not like", ">", ">=", "<", "<=", "==", "null", "not null"]
	};
	this.zoonIn = function(a) {
		this.handleWheelEvent(a, 1)
	};
	this.zoonOut = function(a) {
		this.handleWheelEvent(a, -1)
	};
	this.clusterSamples = function(b, a) {
		this.functionCaller = "clusterSamples";
		this.clusterAxis = "samples";
		if (!this.data.t) {
			this.data.t = {}
		}
		if (b || !this.data.t.smps) {
			this.data.t.smps = this.cluster()
		}
		if (!a) {
			this.draw()
		}
	};
	this.clusterVariables = function(b, a) {
		this.functionCaller = "clusterVariables";
		this.clusterAxis = "variables";
		if (!this.data.t) {
			this.data.t = {}
		}
		if (b || !this.data.t.vars) {
			this.data.t.vars = this.cluster()
		}
		if (!a) {
			this.draw()
		}
	};
	this.kmeansSamples = function(e, d) {
		this.functionCaller = "kmeansSamples";
		this.clusterAxis = "samples";
		if (!this.data.x) {
			this.data.x = {}
		}
		if (e || !this.data.x["k-Means-S"]) {
			var a = this.kmeans();
			this.data.x["k-Means-S"] = [];
			for (var b = 0; b < this.smpIndices.length; b++) {
				var c = this.smpIndices[b];
				this.data.x["k-Means-S"][c] = a[b]
			}
			if (!this.isInArray("k-Means-S", this.smpOverlays)) {
				this.smpOverlays.push("k-Means-S")
			}
			this.updateMetaData("x", "k-Means-S", false, true);
			this.sortSamplesByCategory("k-Means-S", true)
		}
		if (!d) {
			this.draw()
		}
	};
	this.kmeansVariables = function(e, d) {
		this.functionCaller = "kmeansVariables";
		this.clusterAxis = "variables";
		if (!this.data.z) {
			this.data.z = {}
		}
		if (e || !this.data.z["k-Means-V"]) {
			var a = this.kmeans();
			this.data.z["k-Means-V"] = [];
			for (var b = 0; b < this.varIndices.length; b++) {
				var c = this.varIndices[b];
				this.data.z["k-Means-V"][c] = a[b]
			}
			if (!this.isInArray("k-Means-V", this.varOverlays)) {
				this.varOverlays.push("k-Means-V")
			}
			this.updateMetaData("z", "k-Means-V", false, true);
			this.sortVariablesByCategory("k-Means-V", true)
		}
		if (!d) {
			this.draw()
		}
	};
	this.setFunctions = function() {
		var a = this.functions;
		a.push("clusterSamples");
		a.push("clusterVariables");
		a.push("transpose");
		a.push("transform");
		a.push("sortSamplesByCategory");
		a.push("sortSamplesByVariable");
		a.push("sortVariablesByCategory");
		a.push("sortVariablesBySample");
		a.push("hideUnhideSmps");
		a.push("hideUnhideVars");
		a.push("desegregateSamples");
		a.push("segregateSamples");
		a.push("groupSamples");
		a.push("ungroupSamples");
		a.push("desegregateVariables");
		a.push("segregateVariables");
		a.push("kmeansSamples");
		a.push("kmeansVariables");
		a.push("createContour");
		a.push("removeContour");
		a.push("showCodeDiv");
		a.push("hideCodeDiv");
		a.push("showInfoDiv");
		a.push("hideInfoDiv");
		a.push("updateCodeDiv");
		a.push("createHistogram");
		a.push("removeHistogram");
		a.push("addRegressionLine");
		a.push("addNormalDistributionLine");
		a.push("recalculateLayout");
		a.push("createRandomData");
		a.push("draw");
		a.push("reset");
		a.push("print")
	};
	this.initializeApi = function() {
		this.setFunctions()
	};
	this.initializeApi()
};
CanvasXpress.prototype.initDimensionUtils = function() {
	this.resizeCanvas = function(e, b, c) {
		this.disableGradientTransparencyShadow();
		var a = this.margin;
		if (e || b || c) {
			if (b || c) {
				if (b) {
					this.width = b;
					this.originalWidth = b
				}
				if (c) {
					this.height = c;
					this.originalHeight = c
				}
			} else {
				if (e) {
					this.width = this.originalWidth;
					this.height = this.originalHeight
				}
			}
			this.top = a + this.getTitleSubtitleHeight();
			this.left = a;
			this.right = a;
			this.bottom = a;
			this.dataEvent = []
		}
		this.meta.canvas.ctx.canvas.width = this.width;
		this.meta.canvas.ctx.canvas.height = this.height;
		if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
			this.drawImage(CanvasXpress.cacheImages[this.getFileName(this.backgroundImage)], 0, 0, this.width, this.height)
		} else {
			if (this.backgroundType == "solid" || this.backgroundType == "window" || this.backgroundType == "windowSolidGradient" || this.backgroundType == "video") {
				this.rectangle(0, 0, this.width, this.height, this.background, this.background)
			} else {
				var d = this.getLinearGradient(0, 0, 0, this.height, this.backgroundGradient1Color, this.backgroundGradient2Color);
				this.rectangle(0, 0, this.width, this.height, d, d)
			}
		}
		this.enableGradientTransparencyShadow()
	};
	this.setWidth = function(a, b) {
		if (!a) {
			a = 1000
		}
		this.setDimensions(a, this.height, b)
	};
	this.setHeight = function(b, a) {
		if (!b) {
			b = 800
		}
		this.setDimensions(this.width, b, a)
	};
	this.setDimensions = function(a, e, d, b) {
		this.functionCaller = "setDimensions";
		var g = this.meta.canvas.ctx.canvas;
		if (!a) {
			a = 1000
		}
		if (!e) {
			e = 1000
		}
		g.originalWidth = parseInt(a);
		g.originalHeight = parseInt(e);
		a = parseInt(a) - g.widthDecrease;
		e = parseInt(e) - g.heightDecrease;
		this.clickLayoutNoAnimation(d);
		g.width = a;
		g.height = e;
		this.resetAxesResizer();
		this.removeMotionDiv();
		this.draw(a, e);
		this.resizeAcknowledgmentDiv();
		this.updateRemoteNavigationWindow();
		if (b) {
			var f = this;
			setTimeout(function() {
				f.resizeViewport()
			}, b)
		} else {
			this.resizeViewport()
		}
	};
	this.initializeDimensions = function() {
		var b = this.meta.canvas.ctx.canvas;
		var a = this.margin;
		if (b.width) {
			this.originalWidth = b.width;
			this.width = b.width
		} else {
			if (this.width) {
				this.originalWidth = this.width;
				b.width = this.width
			} else {
				this.width = 600;
				this.originalWidth = this.width;
				b.width = this.width
			}
		}
		if (b.height) {
			this.originalHeight = b.height;
			this.height = b.height
		} else {
			if (this.height) {
				this.originalHeight = this.height;
				b.height = this.height
			} else {
				this.height = 600;
				this.originalHeight = this.height;
				b.height = this.height
			}
		}
		this.top = a + this.getTitleSubtitleHeight();
		this.left = a;
		this.right = a;
		this.bottom = a;
		this.x = this.width - (this.leftMargin + this.left + this.rightMargin + this.right);
		this.y = this.height - (this.topMargin + this.top + this.bottomMargin + this.bottom)
	};
	this.initializeDimensions()
};
CanvasXpress.prototype.initUtils = function() {
	this.initGeneralUtils();
	this.initPlotUtils();
	this.initConfigUtils();
	this.init3dUtils();
	this.initApiUtils();
	this.initDimensionUtils()
};
CanvasXpress.prototype.initLegendUtils = function() {
	this.validateLegendPositions = function() {
		if (!this.legendInside) {
			if (this.decorationsPosition != "right" && this.decorationsPosition != "bottom") {
				this.decorationsPosition = "bottom"
			}
			if (this.legendPosition != "right" && this.legendPosition != "bottom") {
				this.legendPosition = "right"
			}
		}
		if (this.layoutValid) {
			var a = this.meta.config.orig;
			a.insideLegend = this.insideLegend;
			this.insideLegend = false;
			if (this.legendPosition != "bottom" && this.legendPosition != "right") {
				a.legendPosition = this.legendPosition;
				this.legendPosition = "right"
			}
		}
	};
	this.setLegendFont = function() {
		if (this.autoScaleFont) {
			var b = 1 - this.percentAspectRatioPlotArea;
			var a = this.min(this.width * b, this.height * b);
			this.setPropertyFontSize(a, "legendFont")
		} else {
			this.legendFont = this.legendFontStyle + " " + parseInt(this.legendFontSize) + "px " + this.fontName
		}
	};
	this.drawLegendBackgroundBox = function(d, e, c, f, a) {
		if (a) {
			if (this.legendBox && this.legendBackgroundColor) {
				this.disableGradientTransparencyShadow();
				this.rectangle(d, e, c, f, this.legendBackgroundColor, this.legendBoxColor);
				this.enableGradientTransparencyShadow()
			}
		} else {
			if (this.legendBox) {
				this.disableGradientTransparencyShadow();
				this.rectangle(d, e, c, f, false, this.legendBoxColor, "open");
				this.enableGradientTransparencyShadow()
			}
		}
	};
	this.getDiameterLegend = function() {
		var a = Math.min(this.width, this.height);
		return Number(Math.max(0.5, a * 12 / 833).toFixed(1))
	};
	this.setPropertyLegendDimensions = function(b, k) {
		var a = b.toLowerCase() + "By";
		if (this[a] && this[a + "ShowLegend"]) {
			var n, e;
			if (k) {
				n = this[a];
				e = k
			} else {
				if (this.data.x && this.data.x.hasOwnProperty(this[a])) {
					n = this[a];
					e = this.meta.data.x[this[a]].maxLevStr
				} else {
					if (this.data.z && this.data.z.hasOwnProperty(this[a])) {
						n = this[a];
						e = this.meta.data.z[this[a]].maxLevStr
					} else {
						n = 0;
						e = 0
					}
				}
			}
			var j = this.getDiameterLegend();
			if (b == "Size") {
				for (var g = 0; g < this["legend" + b + "sN"]; g++) {
					j = Math.max(j, this.sizes[g])
				}
			}
			var h = this.getFontPt(this.legendFont);
			var q = this.legendColumns > this["legend" + (b == "Outline" ? "Color" : b) + "sN"] ? this["legend" + (b == "Outline" ? "Color" : b) + "sN"] : this.legendColumns;
			var c = Math.ceil(this["legend" + (b == "Outline" ? "Color" : b) + "sN"] / q);
			var m = this.measureText(n, this.legendFont);
			var o = (this.measureText(e, this.legendFont) + j + this.margin) * q;
			this["legend" + (b == "Outline" ? "Color" : b) + "Width"] = Math.max(m, o) + (this.margin * (q + 2));
			this["legend" + (b == "Outline" ? "Color" : b) + "Height"] = (c * (Math.max(j, h) + this.margin)) + h + (this.margin * 3)
		}
	};
	this.setPropertyLegendIndicatorDimensions = function(d, a) {
		var i = d.toLowerCase() + "By";
		var c = 0;
		var e = 0;
		var g = this.getFontPt(this.legendFont);
		if (this[i]) {
			switch (d) {
				case "Color":
				case "Outline":
					var b = a.maxLevLen;
					if (this.legendPosition.match(/top|bottom/)) {
						e = this.heatmapIndicatorHeight + (this.margin * 4) + g;
						e += g + this.margin;
						c = this.heatmapIndicatorWidth + b
					} else {
						e = this.heatmapIndicatorWidth + (this.margin * 3) + g;
						c = this.heatmapIndicatorHeight + (this.margin * 2) + b
					}
					break;
				case "Shape":
				case "Size":
					this.setPropertyLegendDimensions(d, a.maxLevStr);
					return;
				case "Pattern":
					c = 0;
					e = 0;
					break
			}
		}
		this["legend" + (d == "Outline" ? "Color" : d) + "Width"] = c;
		this["legend" + (d == "Outline" ? "Color" : d) + "Height"] = e
	};
	this.setDecorationsLegendDimensions = function() {
		this.legendDecorationWidth = 0;
		this.legendDecorationHeight = 0;
		this.legendDecorationMaxLabel = 0;
		if (this.showDecorations && this.showDecorationsLegend && this.data.d) {
			if (!this.legendInside) {
				if (this.decorationsPosition != "right" && this.decorationsPosition != "bottom") {
					this.decorationsPosition = "bottom"
				}
			}
			var f = this.getFontPt(this.decorationFont);
			var h = this.data.d;
			var b = 0;
			if (h.nlfit) {
				var g = this.measureText(sprintf("%96s", "X"), this.decorationFont) + (this.margin * 5);
				var a = 0;
				for (var e = 0; e < h.nlfit.length; e++) {
					var c = this.measureText(h.nlfit[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin + g + this.margin);
				this.legendDecorationHeight = (h.nlfit.length * f * 2) + f + this.margin
			}
			if (h.line) {
				var a = 0;
				for (var e = 0; e < h.line.length; e++) {
					if (h.line[e].label) {
						var c = this.measureText(h.line[e].label, this.decorationFont);
						a = Math.max(c, a);
						this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
					}
				}
				if (a > 0) {
					b = Math.max(b, this.margin + a + this.margin);
					this.legendDecorationHeight += (h.line.length * f * 2) + this.margin
				}
			}
			if (h.reg) {
				var g = this.measureText(sprintf("%45s", "X"), this.decorationFont) + (this.margin * 2);
				var a = 0;
				for (var e = 0; e < h.reg.length; e++) {
					var c = this.measureText(h.reg[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin + g + this.margin);
				this.legendDecorationHeight += (h.reg.length * f * 2) + f + this.margin
			}
			if (h.nor) {
				var g = this.measureText(sprintf("%30s", "X"), this.decorationFont) + (this.margin * 1);
				var a = 0;
				for (var e = 0; e < h.nor.length; e++) {
					var c = this.measureText(h.nor[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin + g + this.margin);
				this.legendDecorationHeight += (h.nor.length * f * 2) + f + this.margin
			}
			if (h.area) {
				var a = 0;
				for (var e = 0; e < h.area.length; e++) {
					var c = this.measureText(h.area[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin);
				this.legendDecorationHeight += (h.area.length * f * 2) + this.margin
			}
			if (h.kaplanMeier) {
				var a = 0;
				for (var e = 0; e < h.kaplanMeier.length; e++) {
					var c = this.measureText(h.kaplanMeier[e].label, this.decorationFont);
					a = Math.max(c, a);
					this.legendDecorationMaxLabel = Math.max(a, this.legendDecorationMaxLabel)
				}
				b = Math.max(b, this.margin + a + this.margin);
				this.legendDecorationHeight += (h.kaplanMeier.length * f * 2) - this.margin
			}
			this.legendDecorationWidth = b
		}
	};
	this.setOncoprintLegendDimension = function() {
		this.legendOncoprintWidth = 0;
		this.legendOncoprintHeight = 0;
		if (this.isOncoprint) {
			var c = this.measureText("Amplification", this.legendFont);
			var e = this.measureText("Deletion", this.legendFont);
			var b = this.measureText("Mutation", this.legendFont);
			this.legendOncoprintWidth = 100 + c + e + b + (this.margin * 2);
			this.legendOncoprintHeight = 30 + (this.margin * 2)
		}
	};
	this.setSampleLegendDimension = function() {
		this.legendSampleWidth = 0;
		this.legendSampleHeight = 0;
		var d = this.getFontPt(this.legendFont);
		var b = 0;
		if (this.graphType.match(/Scatter/)) {
			if (this.xAxisIndices.length != this.yAxisIndices.length || this.xAxisIndices.length > 1) {
				if (this.xAxisIndices.length == this.yAxisIndices.length && this.xAxisIndices.length > 1) {
					for (var c = 0; c < this.xAxisIndices.length; c++) {
						var a;
						if (this.isHistogram) {
							a = this.measureText(this.shortenText(this.xAxis[c], this.maxSmpStringLen), this.legendFont)
						} else {
							a = this.measureText(this.shortenText(this.xAxis[c], this.maxSmpStringLen) + " vs " + this.shortenText(this.yAxis[c], this.maxSmpStringLen), this.legendFont)
						}
						b = Math.max(a, b)
					}
				} else {
					if (this.xAxisIndices.length > this.yAxisIndices.length) {
						b = this.measureText(this.shortenText(this.getMaxText(this.xAxis), this.maxSmpStringLen) + " vs " + this.shortenText(this.yAxis[0], this.maxSmpStringLen), this.legendFont)
					} else {
						if (this.yAxisIndices.length > this.xAxisIndices.length) {
							if (this.isHistogram) {
								b = this.measureText(this.shortenText(this.getMaxText(this.yAxis), this.maxSmpStringLen), this.legendFont)
							} else {
								b = this.measureText(this.shortenText(this.getMaxText(this.yAxis), this.maxSmpStringLen) + " vs " + this.shortenText(this.xAxis[0], this.maxSmpStringLen), this.legendFont)
							}
						}
					}
				}
				this.legendSampleWidth = (d - 1) + b + (this.margin * 3);
				this.legendSampleHeight = (Math.max(this.xAxisIndices.length, this.yAxisIndices.length) * (d + this.margin)) + this.margin
			} else {
				if (this.isHistogram) {
					b = this.measureText(this.shortenText(this.getMaxText(this.yAxis), this.maxSmpStringLen), this.legendFont);
					this.legendSampleWidth = (d - 1) + b + (this.margin * 3);
					this.legendSampleHeight = (Math.max(this.xAxisIndices.length, this.yAxisIndices.length) * (d + this.margin)) + this.margin
				}
			}
		}
	};
	this.setVariableLegendDimension = function() {
		this.legendVariableWidth = 0;
		this.legendVariableHeight = 0;
		var a = this.meta.data.y;
		var e = this.getFontPt(this.legendFont);
		if (this.graphType == "Pie") {
			var f = this.varIndices.length > this.maxPieSectors ? this.maxPieSectors : this.varIndices.length;
			var d = this.shortenText(a.maxVarStr, this.maxVarStringLen);
			var b = this.measureText(d, this.legendFont);
			if (b > this.width / 2) {
				this.legendFont = this.scaleTextToFont(b, e, this.width / 2)
			}
			this.legendVariableWidth = this.measureText(d, this.legendFont) + e + (this.margin * 3);
			this.legendVariableHeight = ((e + this.margin) * f) + this.margin
		} else {
			if (this.layoutValid && this.segregateVariablesBy.length > 0) {
				if (this.segregateVariablesBy[0] == "variable" || (this.segregateVariablesBy.length > 1 && this.segregateVariablesBy[1] == "variable")) {
					return
				} else {
					var c = a.maxVarChr > this.maxVarStringLen ? a.maxVarStr.substring(0, this.maxVarStringLen) : a.maxVarStr;
					this.legendVariableWidth = ((this.margin * 3) + (e * 2) + this.measureText(c, this.legendFont)) * this.legendColumns;
					this.legendVariableHeight = (Math.ceil(this.data.y.vars.length / this.legendColumns) * e * 1.5) + this.margin
				}
			} else {
				if ((this.colorBy && this.colorBy == "variable") || (this.shapeBy && this.shapeBy == "variable") || (this.sizeBy && this.sizeBy == "variable") || (this.patternBy && this.patternBy == "variable")) {
					var c = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], this.getFontPt(this.legendFont)) : this.getFontPt(this.legendFont);
					var d = this.shortenText(a.maxVarStr, this.maxVarStringLen);
					this.legendVariableWidth = ((c - 1) + this.measureText(d, this.legendFont) + (this.margin * 3)) * this.legendColumns;
					this.legendVariableHeight = ((this.varIndices.length / this.legendColumns) * (c + this.margin)) + this.margin
				} else {
					if (this.graphType == "BarLine" || this.graphType == "DotLine" || this.graphType == "AreaLine" || this.graphType == "StackedLine" || this.graphType == "StackedPercentLine") {
						var c = a.maxVarChr > this.maxVarStringLen ? a.maxVarStr.substring(0, this.maxVarStringLen) : a.maxVarStr;
						this.legendVariableWidth = ((this.margin * 3) + (e * 2) + this.measureText(c, this.legendFont)) * this.legendColumns;
						this.legendVariableHeight = (Math.ceil((this.xAxisVarIndices.length + this.xAxis2VarIndices.length) / this.legendColumns) * e * 1.5) + this.margin
					} else {
						if (!this.colorBy && (this.graphType == "Bar" || this.graphType == "Line" || this.graphType == "Area" || this.graphType == "Dotplot" || this.graphType == "Stacked" || this.graphType == "StackedPercent" || this.graphType == "Boxplot")) {
							var c = a.maxVarChr > this.maxVarStringLen ? a.maxVarStr.substring(0, this.maxVarStringLen) : a.maxVarStr;
							this.legendVariableWidth = ((this.margin * 3) + (e * 2) + this.measureText(c, this.legendFont)) * this.legendColumns;
							this.legendVariableHeight = (Math.ceil(this.varIndices.length / this.legendColumns) * e * 1.5) + this.margin
						}
					}
				}
			}
		}
	};
	this.setVennLegendDimension = function() {
		var a = this.data.venn.legend ? this.getMaxText(this.data.venn.legend) : "N/A";
		this.legendWidth = this.measureText(a, this.legendFont) + (this.margin * 6);
		this.legendHeight = this.margin + this.margin + ((this.getFontPt(this.legendFont) + this.margin) * this.vennGroups)
	};
	this.setOverlaysLegendDimensions = function() {
		var b = this.getFontPt(this.legendFont);
		var s = this.getDiameterLegend();
		var k = Math.max(b, s);
		var d = ["varOverlays", "smpOverlays"];
		var e = ["varOverlayProperties", "smpOverlayProperties"];
		var y = ["showVarOverlaysLegend", "showSmpOverlaysLegend"];
		this.legendOverlaysLayout = [];
		this.legendOverlaysWidth = 0;
		this.legendOverlaysHeight = 0;
		var q = this.margin;
		var n = this.margin;
		var a = 0;
		var g = 0;
		var l = 0;
		var B = false;
		if (this.showOverlays && this.showLegend) {
			for (var v = 0; v < d.length; v++) {
				if (this[d[v]].length > 0 && this[y[v]]) {
					for (var t = 0; t < this[d[v]].length; t++) {
						var f = 0;
						var x = 0;
						var p = this[d[v]][t];
						var A = d[v] == "varOverlays" ? "z" : "x";
						var r = this.meta.data[A][p];
						var u = this.measureText(r.maxLevStr, this.legendFont);
						var z = this.measureText(p, this.legendFont);
						if (this[e[v]][p].type == "Default") {
							B = true;
							if (r.type == "String") {
								f = Math.max(z, u + k + (this.margin * 3));
								x = ((Math.max(b, s) + this.margin) * r.levels.length) + b + (this.margin * 3)
							} else {
								if (this.legendPosition.match(/right|left/i)) {
									f = Math.max(this.heatmapIndicatorHeight + (this.margin * 2) + u, z);
									x = this.heatmapIndicatorWidth + (this.margin * 3) + b
								} else {
									f = this.heatmapIndicatorWidth + (this.margin * 3) + b;
									x = Math.max(this.heatmapIndicatorHeight + (this.margin * 2) + u, z)
								}
							}
							this["legend" + p + "Width"] = f;
							this["legend" + p + "Height"] = x;
							if (this.legendPosition.match(/right|left/i)) {
								if (g + this.margin + x > (this.height - (this.top + this.bottom))) {
									q += this.margin + f;
									a = f;
									g = x;
									l++;
									this.legendOverlaysLayout[l] = [
										[A, p, f, x]
									]
								} else {
									if (f > a) {
										q += (f - a);
										a = f
									}
									g += x;
									if (!this.legendOverlaysLayout[l]) {
										this.legendOverlaysLayout[l] = []
									}
									this.legendOverlaysLayout[l].push([A, p, f, x])
								}
							} else {
								if (a + this.margin + f > (this.width - (this.left + this.right))) {
									n += this.margin + x;
									a = f;
									g = x;
									this.legendOverlaysLayout[v] = [
										[A, p, f, x]
									];
									l++
								} else {
									if (x > g) {
										n += (x - g);
										g = x
									}
									a += f;
									if (!this.legendOverlaysLayout[l]) {
										this.legendOverlaysLayout[l] = []
									}
									this.legendOverlaysLayout[l].push([A, p, f, x])
								}
							}
						}
					}
				}
			}
		}
		this.legendOverlaysWidth = B ? q + this.margin : 0;
		this.legendOverlaysHeight = B ? n + this.margin : 0
	};
	this.setLegendDimensions = function() {
		if (this.showDecorations && this.showDecorationsLegend && this.data.d) {
			this.decorationLayout = [0]
		}
		if (this.showLegend) {
			this.legendLayout = [];
			this.legendWidth = 0;
			this.legendHeight = 0;
			var a = this.margin;
			var k = this.margin;
			var b = 0;
			var j = 0;
			var g = 0;
			var e = this.scatterPlotMatrix ? ["Color", "Shape", "Size", "Pattern", "Variable"] : ["Color", "Shape", "Size", "Pattern", "Variable", "Sample"];
			for (var c = 0; c < e.length; c++) {
				var f = this["legend" + e[c] + "Width"];
				var d = this["legend" + e[c] + "Height"];
				if (f > 0) {
					if (this.legendPosition.match(/right|left/i)) {
						if (j + this.margin + d > this.height) {
							a += this.margin + f;
							b = f;
							j = d;
							this.legendLayout[g] = [e[c]];
							g++
						} else {
							if (f > b) {
								a += (f - b);
								b = f
							}
							j += d;
							if (!this.legendLayout[g]) {
								this.legendLayout[g] = []
							}
							this.legendLayout[g].push(e[c])
						}
					} else {
						if (b + this.margin + f > this.width) {
							k += this.margin + d;
							b = f;
							j = d;
							this.legendLayout[c] = [e[c]];
							g++
						} else {
							if (d > j) {
								k += (d - j);
								j = d
							}
							b += f;
							if (!this.legendLayout[g]) {
								this.legendLayout[g] = []
							}
							this.legendLayout[g].push(e[c])
						}
					}
				}
			}
			this.legendWidth = a + this.margin + this.legendOverlaysWidth;
			this.legendHeight = k + this.margin + this.legendOverlaysHeight
		}
	};
	this.setLegends = function() {
		var h = this;
		var g = ["Color", "Shape", "Size", "Pattern", "Outline"];
		var q = ["shapeByData", "sizeByData", "patternByData", "outlineByData"];
		var n = function(a, o, t) {
			var u = o == "Outline" ? "Color" : o;
			var s = u.toLowerCase() + "s";
			h["legend" + u + "Meta"] = a;
			if (t) {
				h["legend" + u + "Meta"].vals = h.rPretty(t[0], t[1], 5);
				h["legend" + u + "Meta"].decs = h.getAxisDecimals(t[1] - t[0]);
				h["legend" + u + "Meta"].maxLevStr = h.getMaxText(h["legend" + (o == "Outline" ? "Color" : o) + "Meta"].vals);
				h["legend" + u + "Meta"].maxLevLen = h.measureText(h["legend" + u + "Meta"].maxLevStr, h.font);
				h["legend" + u + "Meta"].maxLevChr = h["legend" + u + "Meta"].maxLevStr.toString().length
			}
			h["legend" + u + "sMax"] = h["legend" + u + "Meta"].maxLevStr;
			h["legend" + u + "sN"] = h["legend" + u + "Meta"].vals.length;
			for (var p = 0; p < h["legend" + u + "Meta"].vals.length; p++) {
				h["legend" + u + "s"][h["legend" + u + "Meta"].vals[p].toString()] = h[s][p]
			}
			h.setPropertyLegendIndicatorDimensions(o, h["legend" + u + "Meta"])
		};
		var j = function(A, H, w, C, x) {
			var E = 0;
			var u = 0;
			var z = false;
			var B = {};
			var r = {};
			var a = C.toLowerCase() + "s";
			var y = h.isGroupedData && h.graphType != "Dotplot" && h.graphType != "Boxplot" && !h.showBoxplotOriginalData && h.groupingFactors.length == 1;
			if (H == "x") {
				var s = h.isGroupedData ? h.grpIndices : h.smpIndices;
				for (var F = 0; F < s.length; F++) {
					var t = s[F];
					if (h.isGroupedData && (h.graphType == "Dotplot" || (h.graphType == "Boxplot" && h.showBoxplotOriginalData))) {
						for (var D = 0; D < h.data.w.grps[t].length; D++) {
							var v = h.data[H][h[w]][h.data.w.grps[t][D]];
							r[v] = true
						}
					} else {
						var v = h.isGroupedData ? h.getSmpAnnotations(h[w], h.data.w.grps[F], true) : h.data[H][h[w]][t];
						r[v] = true
					}
				}
			} else {
				if (H == "z") {
					for (var F = 0; F < h.varIndices.length; F++) {
						var t = h.varIndices[F];
						var v = h.data[H][h[w]][t];
						r[v] = true
					}
				} else {
					if (H == "m") {
						for (var F = 0; F < h.varIndices.length; F++) {
							for (var D = 0; D < h.smpIndices.length; D++) {
								var v = x[h.varIndices[F]][h.smpIndices[D]];
								r[v] = true
							}
						}
					}
				}
			}
			r = h.getKeys(r);
			r.sort();
			for (var F = 0; F < r.length; F++) {
				var v = r[F];
				var G = h.measureText(v, h.legendFont);
				if (G > E) {
					E = G;
					h["legend" + C + "sMax"] = v
				}
				B[v] = A.order[v] % h[a].length;
				h["legend" + C + "s"][v] = h[a][B[v]];
				u++
			}
			z = H == "m" ? h["legend" + C + "sMax"] : false;
			h["legend" + C + "sN"] = u;
			h["legend" + C + "Meta"] = A;
			h.setPropertyLegendDimensions(C, z)
		};
		if (this.skipSetLegends) {
			return
		}
		this.validateLegendPositions();
		this.setLegendFont();
		if (this.graphType == "Venn") {
			this.setVennLegendDimension();
			return
		} else {
			if (this.isMultidimensionalData) {
				for (var f = 0; f < q.length; f++) {
					if (this.data.y[this[q[f]]]) {
						var c = this.data.y[this[q[f]]];
						var d = this.meta.data[this[q[f]]];
						var e = q[f].replace("ByData", "");
						e = e.charAt(0).toUpperCase() + e.slice(1);
						var k = e.toLowerCase();
						var b = k + "By";
						this["legend" + (e == "Outline" ? "Color" : e) + "s"] = [];
						this["legend" + (e == "Outline" ? "Color" : e) + "sN"] = 0;
						if (d.type == "Numeric") {
							n(d, e, [d.min, d.max])
						} else {
							j(d, "m", b, e, c)
						}
					}
				}
			} else {
				for (var f = 0; f < g.length; f++) {
					var e = g[f];
					var k = g[f].toLowerCase();
					var b = k + "By";
					this["legend" + e + "s"] = {};
					this["legend" + e + "sN"] = 0;
					this["legend" + e + "Width"] = 0;
					this["legend" + e + "Height"] = 0;
					if (this[b]) {
						if (this.data.x && this.data.x.hasOwnProperty(this[b])) {
							var d = this.meta.data.x[this[b]];
							this[k + "ByType"] = "x";
							if (d.type == "Numeric") {
								n(d, e)
							} else {
								j(d, "x", b, e)
							}
						} else {
							if (this.data.z && this.data.z.hasOwnProperty(this[b])) {
								var d = this.meta.data.z[this[b]];
								this[k + "ByType"] = "z";
								if (d.type == "Numeric") {
									n(d, e)
								} else {
									j(d, "z", b, e)
								}
							} else {
								if (this.getSampleIndices(this[b]) > -1 && this.meta.data.y.range[this[b]]) {
									var d = this.meta.data.y.range[this[b]];
									n(d, e, [d.min, d.max])
								} else {
									if (this[b] == "variable") {
										h["legend" + e + "sN"] = this.varIndices.length;
										this.setVariableLegendDimension()
									}
								}
							}
						}
					}
				}
			}
		}
		this.setDecorationsLegendDimensions();
		this.setSampleLegendDimension();
		this.setVariableLegendDimension();
		this.setOncoprintLegendDimension();
		this.setOverlaysLegendDimensions();
		this.setLegendDimensions()
	};
	this.drawDecorationData = function() {
		var am = this.marginLeft + this.offsetX + this.left;
		var ab = this.marginTop + this.offsetY + this.top;
		var av = this.data.d;
		if (this.showDecorations && av) {
			if (av.nlfit) {
				var aq, K, at;
				var o = this.varIndices;
				var G, b;
				for (var ap = 0; ap < av.nlfit.length; ap++) {
					var S = [];
					var R = [];
					var q = ap % this.colors.length;
					var al = this.transformValue(this.yAxisTransform, av.nlfit[ap].param[0]);
					var ai = this.transformValue(this.yAxisTransform, av.nlfit[ap].param[1]);
					var af = av.nlfit[ap].param[2];
					var ac = av.nlfit[ap].param[3];
					var T = this.xAxisIndices.length == 1 ? this.xAxisIndices[0] : this.xAxisIndices[ap];
					var U = this.getDataForSmpGrpAtIndex(T);
					if (this.xAxisTransform == "percentile") {
						aq = this.range(U);
						at = aq[0];
						K = aq[1]
					}
					o.sort(function(i, d) {
						return U[i] - U[d]
					});
					q = av.nlfit[ap].color ? av.nlfit[ap].color : this.colors[q];
					for (var ao = 0; ao < o.length; ao++) {
						var A = o[ao];
						var Y = this.getDataAtPos(A, T);
						var X;
						var D = [];
						if (Y > 0) {
							if (ao > 0) {
								var e = o[ao - 1];
								var V = this.getDataAtPos(e, T);
								if (V > 0) {
									var f = (Y - V) / this.functionIntervals;
									for (var an = 0; an < this.functionIntervals; an++) {
										D.push(V);
										V += f
									}
								}
							} else {
								D = [Y]
							}
							for (var an = 0; an < D.length; an++) {
								if (av.nlfit[ap].type == "reg") {
									X = al + ((ai - al) / (1 + af / (Math.pow(D[an], ac))))
								} else {
									X = al + ((ai - al) / (1 + (Math.pow((D[an] / af), ac))))
								}
								if (this.xAxisTransform) {
									D[an] = this.xAxisTransform == "percentile" ? this.percentile(at, K, D[an]) : this.transformValue(this.xAxisTransform, D[an])
								}
								G = am + ((D[an] - this.xAxisMin) * this.xAxisUnit);
								b = (ab + this.y) - ((X - this.yAxisMin) * this.yAxisUnit);
								S.push(G);
								R.push(b)
							}
						}
					}
					if (S.length > 0) {
						this.drawShape("path", S, R, false, false, q, q, "open", false, false, true);
						if (av.nlfit[ap].type == "reg") {
							X = al + ((ai - al) / (1 + af / (Math.pow(af, ac))))
						} else {
							X = al + ((ai - al) / (1 + (Math.pow((af / af), ac))))
						}
						if (this.xAxisTransform) {
							af = this.xAxisTransform == "percentile" ? this.percentile(at, K, af) : this.transformValue(this.xAxisTransform, af)
						}
						G = am + ((af - this.xAxisMin) * this.xAxisUnit);
						b = (ab + this.y) - ((X - this.yAxisMin) * this.yAxisUnit);
						this.drawLine("dottedLine", am, b, G, b, q);
						this.drawLine("dottedLine", G, b, G, (ab + this.y), q)
					}
				}
			}
			if (av.line) {
				for (var ap = 0; ap < av.line.length; ap++) {
					if (av.line[ap].x != null || av.line[ap].y != null) {
						var q = av.line[ap].color ? av.line[ap].color : this.colors[ap % this.colors.length];
						var aA = av.line[ap].type ? av.line[ap].type : "line";
						var Y = av.line[ap].x != null ? av.line[ap].x : null;
						var X = av.line[ap].y != null ? av.line[ap].y : null;
						var C = av.line[ap].x2 != null ? av.line[ap].x2 : null;
						var ay = av.line[ap].y2 != null ? av.line[ap].y2 : null;
						var Z = av.line[ap].width ? av.line[ap].width : 1;
						var G, b, E, aB;
						if (Y != null && X != null && C != null && ay != null) {
							G = am + ((Y - this.xAxisMin) * this.xAxisUnit);
							E = am + ((C - this.xAxisMin) * this.xAxisUnit);
							b = ab + this.y - ((X - this.yAxisMin) * this.yAxisUnit);
							aB = ab + this.y - ((ay - this.yAxisMin) * this.yAxisUnit);
							this.drawLine(aA, G, b, E, aB, q, Z)
						} else {
							if (Y != null) {
								G = am + ((Y - this.xAxisMin) * this.xAxisUnit);
								b = ab;
								E = G;
								aB = b + this.y;
								this.drawLine(aA, G, b, E, aB, q, Z)
							} else {
								if (X != null) {
									G = am;
									b = ab + this.y - ((X - this.yAxisMin) * this.yAxisUnit);
									E = G + this.x;
									aB = b;
									this.drawLine(aA, G, b, E, aB, q, Z)
								}
							}
						}
					}
				}
			}
			if (av.lines) {
				for (var ap = 0; ap < av.lines.length; ap++) {
					var G, b, E, aB;
					var aw = true;
					var aA = av.lines[ap].type || "line";
					var O = av.lines[ap].color;
					var aa = av.lines[ap].value || 0;
					var ae = av.lines[ap].label || false;
					if (this.graphOrientation == "vertical") {
						G = this.marginLeft + this.offsetX + this.left;
						E = G + this.x;
						b = this.marginTop + this.offsetY + this.top + this.y - ((aa - this.xAxisMin) * this.xAxisUnit);
						aB = b;
						aw = b <= this.marginTop + this.offsetY + this.top + this.y && b >= this.marginTop + this.offsetY + this.top ? true : false
					} else {
						G = this.marginLeft + this.offsetX + this.left + ((aa - this.xAxisMin) * this.xAxisUnit);
						E = G;
						b = this.marginTop + this.offsetY + this.top;
						aB = b + this.y;
						aw = G <= this.marginLeft + this.offsetX + this.left + this.x && this.marginLeft + this.offsetX + this.left ? true : false
					}
					if (aw) {
						if (ae) {
							if (this.graphOrientation == "vertical") {
								this.drawText(ae, E - this.margin, aB - this.margin, this.decorationFont, this.decorationColor, "right", "bottom")
							} else {
								this.drawText(ae, E + this.margin, aB - this.margin, this.decorationFont, this.decorationColor, "left", "bottom")
							}
						}
						this.drawLine(aA, G, b, E, aB, O)
					}
				}
			}
			if (av.reg) {
				for (var ap = 0; ap < av.reg.length; ap++) {
					if (av.reg[ap].slope && av.reg[ap].intercept) {
						var q = av.reg[ap].color ? av.reg[ap].color : this.colors[ap % this.colors.length];
						var r = this.addColorTransparency(this.colors[ap % this.colors.length], 0.5);
						var aA = av.reg[ap].type ? av.reg[ap].type : "line";
						var I = av.reg[ap].slope;
						var ah = av.reg[ap].intercept;
						var m = av.reg[ap].cor;
						var au = "y ~ " + this.formatNumber(I) + "x + " + this.formatNumber(ah) + " (r = " + this.formatNumber(m) + ")";
						var Q = av.reg[ap].ci;
						var G = av.reg[ap].start ? av.reg[ap].start : this.xAxisMin;
						var b = (I * G) + ah;
						var E = av.reg[ap].end ? av.reg[ap].end : this.xAxisMax;
						var aB = (I * E) + ah;
						G = am + (G * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
						b = (ab + this.y) - (b * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						E = am + (E * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
						aB = (ab + this.y) - (aB * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						this.drawLine(aA, G, b, E, aB, q, false, false, false, false, true);
						var a = [];
						var az = [];
						var p = Q.length - 1;
						for (var ao = 0; ao < Q.length; ao++) {
							G = am + (Q[ao][0] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
							b = (ab + this.y) - (Q[ao][1] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							aB = (ab + this.y) - (Q[ao][2] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							a.push(G);
							az.push([b, aB])
						}
						if (this.showDecorationsRegressionConfidence) {
							this.addArea(this.drawShape("confidence", a, az, false, false, r, r, "closed", false, false, true), [au + ":Confidence"])
						}
					}
				}
			}
			if (av.nor) {
				for (var ap = 0; ap < av.nor.length; ap++) {
					if (av.nor[ap].mu && av.nor[ap].sigma) {
						var ak = [];
						var ag = [];
						var P = [];
						var G, b;
						var q = ap % this.colors.length;
						var s = av.nor[ap].mu;
						var h = av.nor[ap].sigma;
						var M = av.nor[ap].start ? av.nor[ap].start : av.nor[ap].yAxis ? this.yAxisMin : this.xAxisMin;
						var H = av.nor[ap].end ? av.nor[ap].end : av.nor[ap].yAxis ? this.yAxisMax : this.xAxisMax;
						var n = 120;
						if (M < s && s < H) {
							var V, F, L, ar;
							var f = (s - M) / n;
							var ax = h * h;
							var ad = ax * 2;
							var N = 1 / Math.sqrt(2 * Math.PI * ax);
							if (av.nor[ap].yAxis) {
								L = av.nor[ap].max ? av.nor[ap].max * this.xAxisUnit : this.x - (this.x * this.axisExtension);
								ar = L / N;
								V = M;
								for (var ao = 0; ao < n - 1; ao++) {
									F = (N * Math.pow(Math.E, -Math.pow(V - s, 2) / ax));
									P.push([V, F]);
									G = am + (F * ar);
									b = (ab + this.y) - (V * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
									ak.push(G);
									ag.push(b);
									V += f
								}
								f = (H - s) / n;
								V = s;
								for (var ao = 0; ao < n; ao++) {
									F = (N * Math.pow(Math.E, -Math.pow(V - s, 2) / ax));
									P.push([V, F]);
									G = am + (F * ar);
									b = (ab + this.y) - (V * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
									ak.push(G);
									ag.push(b);
									V += f
								}
								q = av.nor[ap].color ? av.nor[ap].color : this.colors[q];
								this.drawShape("path", ak, ag, false, false, q, q, "open", false, false, true)
							} else {
								L = av.nor[ap].max ? av.nor[ap].max * this.yAxisUnit : this.y - (this.y * this.axisExtension);
								ar = L / N;
								V = M;
								for (var ao = 0; ao < n - 1; ao++) {
									F = (N * Math.pow(Math.E, -Math.pow(V - s, 2) / ax));
									P.push([V, F]);
									G = am + (V * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
									b = (ab + this.y) - (F * ar);
									ak.push(G);
									ag.push(b);
									V += f
								}
								f = (H - s) / n;
								V = s;
								for (var ao = 0; ao < n; ao++) {
									F = (N * Math.pow(Math.E, -Math.pow(V - s, 2) / ax));
									P.push([V, F]);
									G = am + (V * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
									b = (ab + this.y) - (F * ar);
									ak.push(G);
									ag.push(b);
									V += f
								}
								q = av.nor[ap].color ? av.nor[ap].color : this.colors[q];
								this.drawShape("path", ak, ag, false, false, q, q, "open", false, false, true)
							}
						}
					}
				}
			}
			if (av.area) {
				for (var ap = 0; ap < av.area.length; ap++) {
					if (av.area[ap].type && av.area[ap].x && av.area[ap].y && av.area[ap].width && av.area[ap].height) {
						if (this.isValidShape(av.area[ap].type)) {
							var G = am + (av.area[ap].x * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
							var b = (ab + this.y) - (av.area[ap].y * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
							var q = av.area[ap].color ? av.area[ap].color : this.colors[ap % this.colors.length];
							var g = av.area[ap].width * this.xAxisUnit;
							var aj = av.area[ap].height * this.yAxisUnit;
							this.drawShape(av.area[ap].type, G, b, g, aj, q, av.area[ap].outline, av.area[ap].pattern, av.area[ap].rotate)
						}
					}
				}
			}
			if (av.kaplanMeier) {
				var G, b, E, aB, B, z, v, u, q, r, W, c, J;
				for (var ap = 0; ap < av.kaplanMeier.length; ap++) {
					W = [
						[],
						[]
					];
					c = [
						[],
						[]
					];
					J = [
						[],
						[]
					];
					q = av.kaplanMeier[ap].color;
					r = this.addColorTransparency(q, 0.5);
					G = am;
					b = (ab + this.y) - (this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
					E = am + (av.kaplanMeier[ap].data.times[0] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
					aB = (ab + this.y) - (av.kaplanMeier[ap].data.data[0][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
					z = (ab + this.y) - (av.kaplanMeier[ap].data.data[0][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
					u = (ab + this.y) - (av.kaplanMeier[ap].data.data[0][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
					this.drawLine("line", G, b, E, b, q, false, false, false, false, true);
					this.drawLine("line", E, b, E, aB, q, false, false, false, false, true);
					if (this.showDecorationsKaplanMeierConfidence) {
						W[0].push(G, E, E);
						W[1].push(b, b, z);
						c[0].push(G, E, E);
						c[1].push(b, b, u)
					}
					for (var ao = 1; ao < av.kaplanMeier[ap].data.times.length; ao++) {
						G = am + (av.kaplanMeier[ap].data.times[ao - 1] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
						b = (ab + this.y) - (av.kaplanMeier[ap].data.data[ao - 1][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						B = (ab + this.y) - (av.kaplanMeier[ap].data.data[ao - 1][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						v = (ab + this.y) - (av.kaplanMeier[ap].data.data[ao - 1][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						E = am + (av.kaplanMeier[ap].data.times[ao] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
						aB = (ab + this.y) - (av.kaplanMeier[ap].data.data[ao][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						z = (ab + this.y) - (av.kaplanMeier[ap].data.data[ao][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						u = (ab + this.y) - (av.kaplanMeier[ap].data.data[ao][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
						this.drawLine("line", G, b, E, b, q, false, false, false, false, true);
						this.drawLine("line", E, b, E, aB, q, false, false, false, false, true);
						if (this.showDecorationsKaplanMeierConfidence) {
							W[0].push(G, E, E);
							W[1].push(B, B, z);
							c[0].push(G, E, E);
							c[1].push(v, v, u)
						}
					}
					if (this.showDecorationsKaplanMeierConfidence) {
						J[0] = W[0].concat(c[0].reverse());
						J[1] = W[1].concat(c[1].reverse());
						this.polygon(J[0], J[1], r, r, "closed")
					}
				}
			}
		}
	};
	this.drawOncoprintLegend = function() {
		if (this.isOncoprint) {
			var a = this.marginLeft + this.offsetX + this.left + 15;
			var g = this.marginTop + this.offsetY + this.top + this.y + this.bottom + this.margin - 30;
			var d = this.measureText("Amplification", this.legendFont);
			var i = this.measureText("Deletion", this.legendFont);
			var f = this.measureText("Mutation", this.legendFont);
			if (this.legendOncoprintX && this.legendOncoprintY) {
				a = this.legendOncoprintX;
				g = this.legendOncoprintY
			} else {
				if (this.showLegend) {
					if (!this.legendInside && this.legendPosition == "bottom") {
						g -= this.legendHeight
					}
				}
			}
			this.legendOncoprintCurX = a;
			this.legendOncoprintCurY = g;
			var h = this.legendOncoprintCurX - 10;
			var e = g - 20;
			var c = 100 + d + i + f + (this.margin * 2);
			var b = 30 + (this.margin * 2);
			this.addArea(["rect", h, e, h + c, e + b], [-1], ["-legend-oncoprint"]);
			this.addArea(this.drawShape("rect", a, g, 10, 30, "rgb(255,0,0)"), ["Onc-Amplification"]);
			a = a + 10 + this.margin;
			this.drawText("Amplification", a, g, this.legendFont, this.legendColor, "left", "middle");
			a = a + d + 25;
			this.addArea(this.drawShape("rect", a, g, 10, 30, "rgb(0,0,255)"), ["Onc-Deletion"]);
			a = a + 10 + this.margin;
			this.drawText("Deletion", a, g, this.legendFont, this.legendColor, "left", "middle");
			a = a + i + 25;
			this.addArea(this.drawShape("rect", a, g, 10, 30, "rgb(220,220,220)"), ["Onc-Mutation"]);
			this.drawShape("rect", a, g, 10, 10, "rgb(0,153,0)");
			a = a + 10 + this.margin;
			this.drawText("Mutation", a, g, this.legendFont, this.legendColor, "left", "middle")
		}
	};
	this.drawStockIndicatorsLegend = function() {
		var d = this.marginLeft + this.offsetX + this.left;
		var n = this.marginTop + this.offsetY + this.top;
		if (this.summaryType == "candle" && this.stockIndicators.length > 0) {
			var a = this.getFontPt(this.legendFont);
			var f = a / 2;
			var b = this.measureText(this.getMaxText(this.stockIndicators), this.legendFont) + a + (this.margin * 2);
			var k = this.graphOrientation == "vertical" ? d + (this.margin * 2) : d + this.x - b;
			var j = n + this.margin + a;
			for (var e = 0; e < this.stockIndicators.length; e++) {
				var g = this.getTechnicalIndicatorColor(this.stockIndicators[e]);
				this.drawLine("line", k + f, j + f, k + f + a, j + f, g, false, "butt", false, false, true);
				this.drawText(this.stockIndicators[e], k + a + this.margin, j + f, this.legendFont, g, "left", "middle");
				j += this.margin + a
			}
		}
	};
	this.drawSampleLegend = function(b, k) {
		var j = b;
		var d = k;
		var p = this.getFontPt(this.legendFont);
		var o = (p - 1) / 2;
		k += this.margin + o;
		if (this.legendBox && this.legendBackgroundColor) {
			this.disableGradientTransparencyShadow();
			this.rectangle(j, d, this.legendSampleWidth, this.legendSampleHeight, this.legendBackgroundColor, this.legendBoxColor);
			this.enableGradientTransparencyShadow()
		}
		var m = Math.max(this.xAxisIndices.length, this.yAxisIndices.length);
		for (var f = 0; f < m; f++) {
			var c = f % this.colors.length;
			var n = 0;
			var g = this.xAxisIndices.length == this.yAxisIndices.length ? this.yAxis[f] : this.xAxisIndices.length > this.yAxisIndices.length ? this.yAxis[this.yAxisCurrent] : this.yAxis[f];
			var h = this.xAxisIndices.length == this.yAxisIndices.length ? this.xAxis[f] : this.xAxisIndices.length > this.yAxisIndices.length ? this.xAxis[f] : this.xAxis[this.xAxisCurrent];
			var l = this.isHistogram ? this.shortenText(g, this.maxSmpStringLen) : this.shortenText(g, this.maxSmpStringLen) + " vs " + this.shortenText(h, this.maxSmpStringLen);
			var e = b + o + this.margin;
			var a = k + o + this.margin;
			if (this.colorBy) {
				this.drawShape(this.shapes[n], e, k, p - 1, p - 1, this.background, this.colors[c], "open")
			} else {
				this.drawShape(this.shapes[n], e, k, p - 1, p - 1, this.colors[c], this.foreground, "closed")
			}
			this.drawText(l, e + o + this.margin, k, this.legendFont, this.legendColor, "left", "middle");
			k += p + this.margin
		}
		if (this.legendBox) {
			this.disableGradientTransparencyShadow();
			this.rectangle(j, d, this.legendSampleWidth, this.legendSampleHeight, false, this.legendBoxColor, "open");
			this.enableGradientTransparencyShadow()
		}
		this.addArea(["rect", j, d, j + this.legendSampleWidth, d + this.legendSampleHeight], [-1], "-legend-sample")
	};
	this.drawVariableLegend = function(z, c) {
		var n = z;
		var B = c;
		var m = this.getFontPt(this.legendFont);
		var r = m / 2;
		var a = m * 2;
		var d = m * 1.5;
		var s = 0;
		if (this.legendVariableWidth == 0 || this.legendVariableHeight == 0) {
			return
		} else {
			if (this.graphType == "Pie") {
				this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight, true);
				var y = !this.layoutComb ? this.width - (z + (this.margin * 1.5)) : this.isDOE ? this.layoutWidth - ((z - this.offsetX) + (this.margin * 1.5)) : 999999;
				z += r + this.margin;
				c += m;
				for (var v = 0; v < this.varPie.ids.length; v++) {
					var e = false;
					var l = this.varPie.ids[v];
					var f = this.varPie.cols[v];
					var p = l > -1 ? this.shortenText(this.data.y.vars[l], this.maxVarStringLen) : "Other";
					this.drawShape("square", z, c, m, m, f, this.foreground, "closed");
					if (y > 0) {
						while (this.measureText(p, this.legendFont) > y && p.length > 1) {
							p = p.substring(0, p.length - 1);
							e = true
						}
						if (e) {
							p = p + "..."
						}
						this.drawText(p, z + m, c, this.legendFont, this.legendColor, "left", "middle")
					}
					c += m + this.margin;
					if (this.layoutComb) {
						if ((c - this.offsetY) > this.layoutHeight) {
							this.drawText("...", z + m, c, this.legendFont, this.legendColor, "left", "bottom");
							break
						}
					} else {
						if (c > this.height) {
							this.drawText("...", z + m, c, this.legendFont, this.legendColor, "left", "bottom");
							break
						}
					}
				}
				this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight);
				this.addArea(["rect", n, B, n + this.legendVariableWidth, B + this.legendVariableHeight], [-1], "-legend-variable")
			} else {
				if ((this.colorBy && this.colorBy == "variable") || (this.shapeBy && this.shapeBy == "variable") || (this.sizeBy && this.sizeBy == "variable") || (this.patternBy && this.patternBy == "variable")) {
					this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight, true);
					var u = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], m) : m;
					var A = u / 2;
					var x = this.legendVariableWidth / this.legendColumns;
					var b = Math.ceil(this.varIndices.length / this.legendColumns);
					c += this.margin + this.margin;
					for (var v = 0; v < b; v++) {
						for (var q = 0; q < this.legendColumns; q++) {
							z = n + (this.margin + (x * q));
							if (s < this.varIndices.length) {
								var l = this.varIndices[s];
								var f = this.graphType == "Circular" || (this.colorBy && this.colorBy == "variable") ? s % this.colors.length : 0;
								var o = this.shapeBy && this.shapeBy == "variable" ? s % this.shapes.length : 0;
								var t = this.sizeBy && this.sizeBy == "variable" ? this.sizes[s % this.sizes.length] : u;
								var k = this.patternBy && this.patternBy == "variable" ? s % this.patterns.length : 0;
								var h = z + A;
								var w = c + A;
								var p = this.shortenText(this.data.y.vars[l], this.maxVarStringLen);
								if (this.colorBy && this.colorBy != "variable") {
									this.drawShape(this.shapes[o], h, c, t, t, this.background, this.foreground, this.patterns[k])
								} else {
									this.drawShape(this.shapes[o], h, c, t, t, this.colors[f], this.foreground, "closed")
								}
								this.drawText(p, h + A + this.margin, c, this.legendFont, this.legendColor, "left", "middle")
							} else {
								break
							}
							s++
						}
						c += u + this.margin
					}
					this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight);
					this.addArea(["rect", n, B, n + this.legendVariableWidth, B + this.legendVariableHeight], [-1], "-legend-variable")
				} else {
					if (this.graphType == "BarLine" || this.graphType == "DotLine" || this.graphType == "AreaLine" || this.graphType == "StackedLine" || this.graphType == "StackedPercentLine") {
						this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight, true);
						var g = this.xAxisVarIndices.concat(this.xAxis2VarIndices);
						var x = this.legendVariableWidth / this.legendColumns;
						var b = Math.ceil(g.length / this.legendColumns);
						c += this.margin;
						for (var v = 0; v < b; v++) {
							for (var q = 0; q < this.legendColumns; q++) {
								z = n + this.margin + (x * q);
								if (s < g.length) {
									var l = s < this.xAxisVarIndices.length ? this.xAxisVarIndices[s] : this.xAxis2VarIndices[s - this.xAxisVarIndices.length];
									var f = s < this.xAxisVarIndices.length ? this.getVariableColor(this.data.y.vars[l]) : this.coordinateLineColor ? this.colors[(s - this.xAxisVarIndices.length) % this.colors.length] : this.getVariableColor(this.data.y.vars[l]);
									var k = "closed";
									var p = this.shortenText(this.data.y.vars[l], this.maxVarStringLen);
									if (s < this.xAxisVarIndices.length) {
										this.addArea(this.rectangle(z, c, m, m, f, this.foreground, k), ["Var-" + l]);
										this.addArea(this.drawText(p, z + a, c + r, this.legendFont, this.legendColor, "left", "middle"), ["Var-" + l])
									} else {
										this.addArea(this.drawLine("line", z, c + r, z + m, c + r, f), ["Var-" + l]);
										if (this.lineDecoration) {
											this.drawShape(this.lineDecoration == "symbol" ? this.shapes[(s - this.xAxisVarIndices.length) % this.shapes.length] : "circle", z + r, c + r, r, r, f, this.foreground, k)
										}
										this.addArea(this.drawText(p, z + a, c + r, this.legendFont, this.legendColor, "left", "middle"), ["Var-" + l])
									}
								} else {
									break
								}
								s++
							}
							c += d
						}
						this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight);
						this.addArea(["rect", n, B, n + this.legendVariableWidth, B + this.legendVariableHeight], [-1], "-legend-variable")
					} else {
						if (this.graphType == "Bar" || this.graphType == "Line" || this.graphType == "Area" || this.graphType == "Dotplot" || this.graphType == "Stacked" || this.graphType == "StackedPercent" || this.graphType == "Boxplot") {
							this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight, true);
							var x = this.legendVariableWidth / this.legendColumns;
							var b = Math.ceil(this.varIndices.length / this.legendColumns);
							c += this.margin;
							for (var v = 0; v < b; v++) {
								for (var q = 0; q < this.legendColumns; q++) {
									z = n + this.margin + (x * q);
									if (s < this.varIndices.length) {
										var l = this.varIndices[s];
										var f = this.getVariableColor(this.data.y.vars[l]);
										var k = "closed";
										var p = this.shortenText(this.data.y.vars[l], this.maxVarStringLen);
										if (this.graphType == "Line") {
											this.addArea(this.drawLine("line", z, c + r, z + m, c + r, f), ["Var-" + l]);
											if (this.lineDecoration) {
												this.drawShape(this.lineDecoration == "symbol" ? this.shapes[s % this.shapes.length] : "circle", z + r, c + r, r, r, f, f, k)
											}
										} else {
											if (this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData)) {
												this.addArea(this.drawShape(this.shapes[parseInt(s / this.colors.length)], z + r, c + r, m, m, f, this.foreground, k), ["Var-" + l])
											} else {
												this.addArea(this.rectangle(z, c, m, m, f, this.foreground, k), ["Var-" + l])
											}
										}
										this.addArea(this.drawText(p, z + a, c + r, this.legendFont, this.legendColor, "left", "middle"), ["Var-" + l])
									} else {
										break
									}
									s++
								}
								c += d
							}
							this.drawLegendBackgroundBox(n, B, this.legendVariableWidth, this.legendVariableHeight);
							this.addArea(["rect", n, B, n + this.legendVariableWidth, B + this.legendVariableHeight], [-1], "-legend-variable")
						}
					}
				}
			}
		}
	};
	this.drawVennLegend = function() {
		if (this.showLegend) {
			var j = this.getFontPt(this.legendFont);
			var d = this.vennMarginLeft + this.marginLeft + this.left;
			var c = d + (j * 2);
			var g = this.vennMarginTop + this.marginTop + this.top + this.y + this.margin + (j / 2);
			var h = [];
			var a = [];
			for (var f in this.data.venn.legend) {
				a.push(f)
			}
			a = a.sort();
			if (this.vennGroups == 4) {
				h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
				h.push(this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,153,51)");
				h.push(this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[3]) : "rgb(153,204,0)");
				h.push(this.vennColors.length > 3 && this.validateColor(this.vennColors[3]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)")
			} else {
				if (this.vennGroups == 3) {
					h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
					h.push(this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,255,0)");
					h.push(this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)")
				} else {
					if (this.vennGroups == 2) {
						h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(0,0,255)");
						h.push(this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(255,0,0)")
					} else {
						h.push(this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)")
					}
				}
			}
			for (var f = 0; f < this.vennGroups; f++) {
				if (!this.vennLegendColors) {
					this.drawText(a[f] + ": ", d, g, this.legendFont, this.legendColor, "left", "middle")
				}
				var b = this.data.venn.legend && this.data.venn.legend[a[f]] ? this.data.venn.legend[a[f]] : "N/A";
				var e = (this.measureText(b, this.legendFont) > this.x) ? this.scaleTextToFont(b, j, this.x - this.margin) : this.legendFont;
				if (!this.vennLegendColors) {
					this.drawText(b, c, g, e, this.legendColor, "left", "middle")
				} else {
					this.drawText(b, d, g, e, h[f], "left", "middle")
				}
				g += this.margin + j
			}
		}
	};
	this.drawCircularLegend = function() {
		var c = this.legendVariableCurX || this.width - (this.legendVariableWidth + this.right);
		var o = this.legendVariableCurY || this.height - (this.legendVariableHeight + this.bottom);
		this.legendVariableCurX = c;
		this.legendVariableCurY = o;
		if (this.showLegend) {
			var m = c;
			var e = o;
			var s = this.getFontPt(this.legendFont);
			var n = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], s) : s;
			o += this.margin + (n / 2);
			this.drawLegendBackgroundBox(m, e, this.legendVariableWidth, this.legendVariableHeight, true);
			var p = 0;
			for (var h = 0; h < this.ringsNumber; h++) {
				if (this.rAxisIndex >= 0 && h == this.rAxisIndex) {
					continue
				}
				if (this.rAxisIndex < 0 && this.ringsType[h] == "heatmap") {
					p += this.ringsVarIndices[h].length;
					continue
				}
				for (var g = 0; g < this.ringsVarIndices[h].length; g++) {
					var l = this.ringsVarIndices[h][g];
					var d = p % this.colors.length;
					var r = this.shapeBy && this.shapeBy == "variable" ? p % this.shapes.length : 0;
					var b = this.sizeBy && this.sizeBy == "variable" ? this.sizes[p % 5] : n;
					var q = n / 2;
					var f = c + q + this.margin;
					var a = o + q + this.margin;
					var k = this.shortenText(this.data.y.vars[l], this.maxVarStringLen);
					if (this.colorBy && this.colorBy != "variable") {
						this.drawShape(this.shapes[r], f, o, b, b, this.background, this.foreground, "open")
					} else {
						this.drawShape(this.shapes[r], f, o, b, b, this.colors[d], this.foreground, "closed")
					}
					this.drawText(k, f + q + this.margin, o, this.legendFont, this.legendColor, "left", "middle");
					o += n + this.margin;
					p++
				}
			}
			this.drawLegendBackgroundBox(m, e, this.legendVariableWidth, this.legendVariableHeight);
			this.addArea(["rect", m, e, m + this.legendVariableWidth, e + this.legendVariableHeight], [-1], "-legend-variable")
		}
	};
	this.drawColorIndicator = function(x, d, m, D, A, e) {
		if (e || A || this.colorBy || this.outlineBy || this.colorNodeBy) {
			var k = e ? "-legend-" + e + "-color" : A ? "-legend-indicator-color" : "-legend-color";
			var f = e ? "legendPosition" : A ? "heatmapIndicatorPosition" : "legendPosition";
			var C = e ? e : A ? 0 : this.legendColorWidth ? this.legendColorWidth / 2 : 10;
			var p = x;
			var B = d;
			var w = this.heatmapIndicatorHeight;
			var b = this.heatmapIndicatorHeight;
			var q = m.min;
			var t = m.max;
			var a = m.decs;
			var o = m.vals;
			var n = this.heatmapIndicatorWidth / (t - q);
			var z = this.graphType == "Network" || this.graphType == "Circular" ? m : m.colorBrew;
			var h = this.heatmapIndicatorWidth / this.colorSpectrumNumber;
			if (this[f] && this[f].toString().match(/top|bottom/)) {
				if (D || this.colorBy || this.outlineBy || this.colorNodeBy) {
					this.drawText(D || this.colorBy || this.outlineBy || this.colorNodeBy, x + (this.heatmapIndicatorWidth / 2), d, this.legendFont, this.legendColor, "center", "top");
					d += this.margin + this.getFontPt(this.legendFont)
				}
				for (var s = 0; s < this.colorSpectrumNumber; s++) {
					var l = z.stops && z.stops.length > 0 ? this.getColorForValue(z, z.breaks[s]) : z.legend[s];
					var y = this.transparency != null ? this.addColorTransparency(l, this.transparency) : l;
					this.drawLine("line", x, d, x, d + b, y, h + 0.5);
					x += h
				}
				x = p;
				d += b;
				if (z.stops && z.stops.length > 0) {
					var u = x + (this.measureText(z.breaks[0].toString(), this.legendFont) / 2);
					this.drawText(z.breaks[0], x, d, this.legendFont, this.legendColor, "center", "top");
					for (var s = 0; s < z.stops.length - 1; s++) {
						for (var r = 0; r < this.colorSpectrumNumber; r++) {
							if (z.breaks[r] >= z.stops[s]) {
								x = p + (r * h);
								var g = (this.measureText(z.breaks[s].toString(), this.legendFont) / 2);
								if (x - g > u) {
									this.drawText(z.stops[s], x, d, this.legendFont, this.legendColor, "center", "top");
									u = x + g
								}
								break
							}
						}
					}
					x = p + (this.colorSpectrumNumber * h);
					this.drawText(z.stops[z.stops.length - 1], x, d, this.legendFont, this.legendColor, "center", "top")
				} else {
					this.drawText(q, x, d, this.legendFont, this.legendColor, "center", "top");
					x = p + (this.heatmapIndicatorWidth / 2);
					this.drawText((q + t) / 2, x, d, this.legendFont, this.legendColor, "center", "top");
					x = p + ((this.colorSpectrumNumber - 1) * h);
					this.drawText(t, x, d, this.legendFont, this.legendColor, "center", "top")
				}
				this.addArea(["rect", p - (this.margin * 2), B - this.margin, x + (this.margin * 2), d + this.getFontPt(this.legendFont) + this.margin], [-1], "-legend-indicator-color");
				if (this.graphType == "Heatmap" && this.heatmapIndicatorHistogram) {
					this.drawHeatmapIndicatorHistogram(p, B)
				}
			} else {
				if (D || this.colorBy || this.outlineBy || this.colorNodeBy) {
					this.drawText(D || this.colorBy || this.outlineBy || this.colorNodeBy, x + C, d, this.legendFont, this.legendColor, "center", "top");
					d += (this.margin * 1.5) + this.getFontPt(this.legendFont)
				}
				for (var s = 0; s < this.colorSpectrumNumber; s++) {
					var y = this.transparency != null ? this.addColorTransparency(z.legend[s], this.transparency) : z.legend[s];
					this.drawLine("line", x, d, x + w, d, y, h + 0.5);
					d += h
				}
				x += w;
				if (D || this.colorBy || this.outlineBy || this.colorNodeBy) {
					d = B + (this.margin * 1.5) + this.getFontPt(this.legendFont)
				} else {
					d = B
				}
				for (var s = 0; s < o.length; s++) {
					var b = d + ((o[s] - q) * n);
					this.drawText(o[s], x + this.margin, b, this.legendFont, this.legendColor, "left", "middle")
				}
			}
			this.addArea(["rect", p, B, p + this.legendColorWidth, B + this.legendColorHeight], [-1], k)
		}
	};
	this.drawHeatmapIndicatorHistogram = function(x, b) {
		var w, a;
		var o = x;
		var z = b + this.heatmapIndicatorHeight;
		var y = [];
		for (var u = 0; u < this.data.y.vars.length; u++) {
			for (var s = 0; s < this.data.y.smps.length; s++) {
				var g = this.getDataAtPos(u, s, false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue());
				if (g != null && g != "" && !isNaN(g)) {
					y.push(g)
				}
			}
		}
		var k = this.range(y);
		var m = this.freedmanDiaconis(y);
		var r = k[0];
		var t = k[1];
		var q = Math.ceil((t - r) / m);
		var e = [];
		for (var u = 0; u < q; u++) {
			e[u] = 0
		}
		for (var u = 0; u < this.data.y.vars.length; u++) {
			for (var s = 0; s < this.data.y.smps.length; s++) {
				var g = this.getDataAtPos(u, s, false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue());
				if (g != null && g != "" && !isNaN(g)) {
					var n = parseInt((g - r) / m);
					e[n]++
				}
			}
		}
		r = 0;
		t = 0;
		for (var u = 0; u < q; u++) {
			r = Math.min(r, e[u]);
			t = Math.max(t, e[u])
		}
		var l = this.legendFont;
		var h = this[this.axisAlgorithm](r, t, 3, this.axisWilkinsonLoose);
		var p = this.getMaxText(h);
		var f = (this.heatmapIndicatorWidth - 1) / q;
		var c = this.heatmapIndicatorHeight / h[h.length - 1];
		if (this.heatmapIndicatorPosition == "topLeft") {
			l = this.scaleTextToFont(p, this.getFontPt(this.legendFont), this.left - (this.heatmapIndicatorWidth + (this.margin * 3)))
		}
		for (var u = 0; u < h.length; u++) {
			b = (h[u] * c);
			this.drawLine("line", o - this.margin, z - b, o, z - b, this.foreground);
			this.drawText(h[u], o - (this.margin * 1.5), z - b, l, this.foreground, "right", "middle")
		}
		b = (e[0] * c);
		this.drawLine("line", o, z, o, z - b, this.heatmapIndicatorHistogramColor);
		for (var u = 0; u < q; u++) {
			b = (e[u] * c);
			this.drawLine("line", o, z - b, o + f, z - b, this.heatmapIndicatorHistogramColor);
			if (u < q - 1) {
				a = (e[u + 1] * c);
				this.drawLine("line", o + f, z - b, o + f, z - a, this.heatmapIndicatorHistogramColor)
			}
			o += f
		}
		this.drawLine("line", o, z - a, o, z, this.heatmapIndicatorHistogramColor)
	};
	this.drawColorLegend = function(a, b, c) {
		if ((this.outlineBy && this.isMultidimensionalData) || (this.colorBy && ((this.data.x && this.data.x.hasOwnProperty(this.colorBy)) || (this.data.z && this.data.z.hasOwnProperty(this.colorBy))))) {
			if (c.type == "Numeric") {
				this.drawColorIndicator(a, b, c)
			} else {
				this.drawPropertyLegend("Color", a, b, c)
			}
		}
	};
	this.drawShapeLegend = function(a, b, c) {
		this.drawPropertyLegend("Shape", a, b, c)
	};
	this.drawSizeLegend = function(a, b, c) {
		this.drawPropertyLegend("Size", a, b, c)
	};
	this.drawPatternLegend = function(a, b, c) {
		this.drawPropertyLegend("Pattern", a, b, c)
	};
	this.drawPropertyLegend = function(f, w, h, m) {
		var o = f.toLowerCase();
		if ((this[o + "By"] && this.isMultidimensionalData) || (this[o + "By"] && ((this.data.x && this.data.x.hasOwnProperty(this[o + "By"])) || (this.data.z && this.data.z.hasOwnProperty(this[o + "By"]))))) {
			var x = f == "Size" ? 0 : this.getDiameterLegend();
			if (f == "Size") {
				for (var v = 0; v < this.legendSizesN; v++) {
					x = Math.max(x, this.sizes[v])
				}
			}
			var q = this.getFontPt(this.legendFont);
			var j = q / 2;
			var a = this.legendColumns > this["legend" + f + "sN"] ? this["legend" + f + "sN"] : this.legendColumns;
			var e = Math.ceil(this["legend" + f + "sN"] / a);
			var k = this["legend" + f + "Width"] / a;
			var g = h + this.margin + j;
			var u = Math.max(x, q);
			var t = 0;
			this.disableGradientTransparencyShadow();
			if (this.legendBox && this.legendBackgroundColor) {
				this.rectangle(w, h, this["legend" + f + "Width"], this["legend" + f + "Height"], this.legendBackgroundColor, this.legendBoxColor)
			} else {
				if (this.legendBox) {
					this.rectangle(w, h, this["legend" + f + "Width"], this["legend" + f + "Height"], false, this.legendBoxColor, "open")
				}
			}
			this.enableGradientTransparencyShadow();
			var z = f == "Color" && this.outlineBy ? this.outlineBy : this[o + "By"];
			this.drawText(z, w + (this["legend" + f + "Width"] / 2), g, this.legendFont, this.colorLegend, "center", "middle");
			g += j + this.margin;
			this.disableGradientTransparencyShadow();
			this.drawLine("line", w, g, w + this["legend" + f + "Width"], g, this.legendBoxColor);
			this.enableGradientTransparencyShadow();
			g += this.margin + (u / 2);
			var b = this.sortObject(this["legend" + f + "s"]);
			for (var n = 0; n < e; n++) {
				for (var y = 0; y < a; y++) {
					var l = w + this.margin + x / 2 + (k * y);
					if (t < this["legend" + f + "sN"]) {
						var s = b[t];
						if (f == "Color") {
							if (this.outlineBy) {
								this.drawShape("circle", l, g, x, x, false, this.legendColors[s], "open", false, 2)
							} else {
								this.drawShape("circle", l, g, x, x, this.legendColors[s], this.foreground, "closed")
							}
						} else {
							if (f == "Shape") {
								this.drawShape(this.legendShapes[s], l, g, x, x, this.background, this.foreground, "closed")
							} else {
								if (f == "Size") {
									this.drawShape("circle", l, g, this.legendSizes[s], this.legendSizes[s], this.background, this.foreground, "closed")
								} else {
									if (f == "Pattern") {
										this.drawShape("square", l, g, x, x, this.background, this.foreground, this.legendPatterns[s])
									}
								}
							}
						}
						this.drawText(s, l + (u / 2) + this.margin, g, this.legendFont, this.colorLegend, "left", "middle")
					}
					t++
				}
				g += this.margin + u
			}
			this.addArea(["rect", w, h, w + this["legend" + f + "Width"], h + this["legend" + f + "Height"]], [-1], "-legend-" + o)
		}
	};
	this.drawGenericLegend = function(a, p, k, e, o, j) {
		var f = this.getDiameterLegend();
		var d = this.getFontPt(this.legendFont);
		var n = Math.max(f, d);
		var b = n / 2;
		var g = 0;
		this.disableGradientTransparencyShadow();
		if (this.legendBox && this.legendBackgroundColor) {
			this.rectangle(a, p, k, e, this.legendBackgroundColor, this.legendBoxColor)
		} else {
			if (this.legendBox) {
				this.rectangle(a, p, k, e, false, this.legendBoxColor, "open")
			}
		}
		this.enableGradientTransparencyShadow();
		this.drawText(j, a + (k / 2), p + this.margin + (d / 2), this.legendFont, this.colorLegend, "center", "middle");
		g = p + d + (this.margin * 2);
		if (this.legendBox) {
			this.drawLine("line", a, g, a + k, g, this.legendBoxColor)
		}
		g += this.margin;
		for (var c = 0; c < o.levels.length; c++) {
			var m = o.type == "String" ? o.colors[c] : this.getColorForValue(o.colorBrew, o.levels[c]);
			this.drawShape("square", a + this.margin + (f / 2), g + (n / 2), f, f, m, this.foreground);
			this.drawText(o.levels[c], a + f + (this.margin * 2), g + (n / 2), this.legendFont, this.colorLegend, "left", "middle");
			g += n + this.margin
		}
	};
	this.drawDecorationLegend = function(e, s) {
		var p, o;
		var m = this.data.d;
		var u = this.getFontPt(this.decorationFont);
		var c = this.measureText(sprintf("%15s", "X"), this.decorationFont);
		var r = m.nlfit || m.nor || m.reg ? c : 0;
		var n = e + (r ? this.legendDecorationMaxLabel + c : this.margin);
		var a = n;
		var g = s;
		var q = g;
		this.legendDecorationCurX = e;
		this.legendDecorationCurY = s;
		if (this.decorationsBox) {
			this.disableGradientTransparencyShadow();
			this.addArea(this.rectangle(e, s - ((u / 2) + this.margin), this.legendDecorationWidth, this.legendDecorationHeight + this.margin, this.decorationsBackgroundColor, this.decorationsBoxColor), [-1], "-legend-decorations");
			this.enableGradientTransparencyShadow()
		}
		if (m.nlfit) {
			this.drawText("Min", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			a += c + this.margin;
			this.drawText("Max", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			a += c + this.margin;
			this.drawText("EC50", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			a += c + this.margin;
			this.drawText("Slope", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			a += c + this.margin;
			this.drawText("p-Val", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			a += c + this.margin;
			this.drawText("F-Chg", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			q += u + u;
			for (var k = 0; k < m.nlfit.length; k++) {
				var f = k % this.colors.length;
				f = m.nlfit[k].color ? m.nlfit[k].color : this.colors[f];
				a = (n + this.margin) - c;
				if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
					a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
				}
				this.drawText(m.nlfit[k].label, a, q, this.decorationFont, f, "right", "middle");
				a = n;
				for (var h = 0; h < 6; h++) {
					var b = m.nlfit[k].param[h];
					if (h < 2) {
						b = this.transformValue(this.yAxisTransform, b)
					} else {
						if (h == 2) {}
					}
					this.drawText(this.formatNumber(b), a, q, this.decorationFont, this.decorationsColor, "right", "middle");
					a += c + this.margin
				}
				q += u + u
			}
		}
		if (m.line) {
			for (var k = 0; k < m.line.length; k++) {
				if (m.line[k].label) {
					max = Math.max(max, this.measureText(m.line[k].label, this.decorationFont));
					for (var k = 0; k < m.line.length; k++) {
						var f = m.line[k].color ? m.line[k].color : this.colors[k % this.colors.length];
						if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
							a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
						}
						this.drawText(m.line[k].label, a, q, this.decorationFont, f, "left", "middle");
						q += u + u
					}
				}
			}
		}
		if (m.reg) {
			this.drawText("Slope", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			a += c + this.margin;
			this.drawText("Int", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			a += c + this.margin;
			this.drawText("Cor", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			q += u + u;
			for (var k = 0; k < m.reg.length; k++) {
				var f = m.reg[k].color ? m.reg[k].color : this.colors[k % this.colors.length];
				a = (n + this.margin) - c;
				if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
					a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
				}
				this.drawText(m.reg[k].label, a, q, this.decorationFont, f, "right", "middle");
				a = n;
				this.drawText(this.formatNumber(m.reg[k].slope), a, q, this.decorationFont, this.decorationsColor, "right", "middle");
				a += c + this.margin;
				this.drawText(this.formatNumber(m.reg[k].intercept), a, q, this.decorationFont, this.decorationsColor, "right", "middle");
				a += c + this.margin;
				this.drawText(this.formatNumber(m.reg[k].cor), a, q, this.decorationFont, this.decorationsColor, "right", "middle");
				a += c + this.margin;
				q += u + u
			}
		}
		if (m.nor) {
			this.drawText("Mu", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			a += c + this.margin;
			this.drawText("Sigma", a, q, this.decorationFont, this.decorationsColor, "right", "middle");
			q += u + u;
			for (var k = 0; k < m.nor.length; k++) {
				var f = k % this.colors.length;
				f = m.nor[k].color ? m.nor[k].color : this.colors[f];
				a = (n + this.margin) - c;
				if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
					a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
				}
				this.drawText(m.nor[k].label, a, q, this.decorationFont, f, "right", "middle");
				a = n;
				this.drawText(this.formatNumber(m.nor[k].mu), a, q, this.decorationFont, this.decorationsColor, "right", "middle");
				a += c + this.margin;
				this.drawText(this.formatNumber(m.nor[k].sigma), a, q, this.decorationFont, this.decorationsColor, "right", "middle");
				a += c + this.margin;
				q += u + u
			}
		}
		if (m.area) {
			for (var k = 0; k < m.area.length; k++) {
				if (m.area[k].label) {
					var f = m.area[k].color ? m.area[k].color : this.colors[k % this.colors.length];
					if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
						a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
					}
					this.drawText(m.area[k].label, a, q, this.decorationFont, f, "left", "middle");
					q += u + u
				}
			}
		}
		if (m.kaplanMeier) {
			for (var k = 0; k < m.kaplanMeier.length; k++) {
				if (m.kaplanMeier[k].label) {
					var f = m.kaplanMeier[k].color ? m.kaplanMeier[k].color : this.colors[k % this.colors.length];
					if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
						a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
					}
					this.drawText(m.kaplanMeier[k].label, a, q, this.decorationFont, f, "left", "middle");
					q += u + u
				}
			}
		}
	};
	this.resetLegends = function(c) {
		if (c) {
			delete(this.legendDecorationCurX);
			delete(this.legendDecorationCurY);
			delete(this.legendDecorationX);
			delete(this.legendDecorationY)
		}
		var a = this.scatterPlotMatrix ? ["Color", "Shape", "Size", "Pattern", "Variable"] : ["Color", "Shape", "Size", "Pattern", "Variable", "Sample"];
		for (var b = 0; b < a.length; b++) {
			this["legend" + a[b] + "Width"] = 0;
			this["legend" + a[b] + "Height"] = 0;
			if (c) {
				delete(this["legend" + a[b] + "CurX"]);
				delete(this["legend" + a[b] + "CurY"]);
				delete(this["legend" + a[b] + "X"]);
				delete(this["legend" + a[b] + "Y"])
			}
		}
		delete(this.legendColorIndicatorCurX);
		delete(this.legendColorIndicatorCurY)
	};
	this.getXYLegendCoords = function(u, b, z) {
		var r, p, a;
		var v = -1;
		var g = -1;
		var k = this;
		var n = function() {
			for (var l = 0; l < k.legendLayout.length; l++) {
				if (k.legendLayout[l]) {
					for (var h = 0; h < k.legendLayout[l].length; h++) {
						if (k.legendLayout[l][h] == u) {
							return [l, h]
						}
					}
				}
			}
			return [-1, -1]
		};
		if (this.legendLayout) {
			var m = n();
			v = m[0];
			g = m[1];
			if (v > -1 && g > -1) {
				var o = 0;
				var d = 0;
				if (this.legendPosition.match(/right|left/i)) {
					for (var e = 0; e < v; e++) {
						var s = 0;
						for (var c = 0; c < this.legendLayout[e].length; c++) {
							s = Math.max(s, this["legend" + this.legendLayout[e][c] + "Width"] + this.margin)
						}
						o += s
					}
					for (var c = 0; c < this.legendLayout[v].length; c++) {
						d += this["legend" + this.legendLayout[v][c] + "Height"] + this.margin
					}
				} else {
					for (var e = 0; e < v; e++) {
						var f = 0;
						for (var c = 0; c < this.legendLayout[e].length; c++) {
							f = Math.max(f, this["legend" + this.legendLayout[e][c] + "Height"] + this.margin)
						}
						d += f
					}
					for (var c = 0; c < this.legendLayout[v].length; c++) {
						o += this["legend" + this.legendLayout[v][c] + "Width"] + this.margin
					}
				}
				if (this.legendPosition.match(/right|left/i)) {
					z = g == 0 && (this.scatterPlotMatrix || this.layoutValid) ? this.marginTop + this.layoutTop : g == 0 ? this.marginTop + this.offsetY + this.top : z;
					r = b + o;
					a = this.legendPosition.match(/top/) ? this.margin : this.legendPosition.match(/bottom/) ? this.y - (d + this.margin) : ((this.y - d) / 2);
					p = g == 0 && (this.scatterPlotMatrix || this.layoutValid) ? (this.height - d) / 2 : g == 0 ? this.marginTop + this.offsetY + this.top + a : z;
					b = g == this.legendLayout[v].length - 1 ? b + o : b;
					z = p + this["legend" + this.legendLayout[v][g] + "Height"] + this.margin
				} else {
					b = g == 0 && (this.scatterPlotMatrix || this.layoutValid) ? this.marginLeft + this.layoutLeft : g == 0 ? this.marginLeft + this.offsetX + this.left : b;
					r = g == 0 && (this.scatterPlotMatrix || this.layoutValid) ? (this.width - o) / 2 : g == 0 ? this.marginLeft + this.offsetX + this.left + ((this.x - o) / 2) + this.margin : b + this.margin;
					p = z + d;
					b = r + this["legend" + this.legendLayout[v][g] + "Width"] + this.margin;
					z = g == this.legendLayout[v].length - 1 ? z + d : z
				}
			}
		}
		return [r, p, b, z]
	};
	this.getVariableLegendPosition = function() {
		var d, f;
		if (this.graphType == "Pie") {
			if (this.legendPosition == "right") {
				if (this.isDOE) {
					d = this.marginLeft + this.offsetX + this.left + this.x;
					f = this.marginTop + this.offsetY + this.top + (this.y / 2) - (this.legendVariableHeight / 2)
				} else {
					d = this.width - (this.marginRight + this.legendVariableWidth + this.margin);
					f = (this.height / 2) - (this.legendVariableHeight / 2)
				}
			} else {
				d = (this.width / 2) - (this.legendVariableWidth / 2);
				f = this.height - (this.marginBottom + this.legendVariableHeight + this.margin)
			}
		} else {
			if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
				return [0, 0]
			} else {
				if (this.layoutValid) {
					var g = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
					var e = this.height - (this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom);
					var b = this.legendVariableHeight + this.legendOverlaysHeight + this.margin;
					var h = this.legendVariableWidth + this.legendOverlaysWidth + this.margin;
					d = this.legendPosition == "right" ? this.width - (this.marginRight + h) : this.marginLeft + this.layoutLeft + (g / 2) - (h / 2);
					f = this.legendPosition == "right" ? this.marginTop + this.layoutTop + (e / 2) - (b / 2) : this.height - (this.marginBottom + b)
				} else {
					var a = this.marginLeft + this.offsetX + this.left;
					var c = this.marginTop + this.offsetY + this.top;
					if (this.legendInside) {
						switch (this.legendPosition) {
							case "bottomRight":
								d = a + this.x - (this.legendVariableWidth + this.legendOverlaysWidth + this.margin);
								f = c + this.y - (this.legendVariableHeight + this.legendOverlaysHeight + this.margin);
								break;
							case "bottom":
								d = a + (this.x / 2) - (this.legendVariableWidth / 2);
								f = c + this.y - (this.legendVariableHeight + this.legendOverlaysHeight + this.margin);
								break;
							case "bottomLeft":
								d = a + this.margin;
								f = c + this.y - (this.legendVariableHeight + this.legendOverlaysHeight + this.margin);
								break;
							case "left":
								d = a + this.margin;
								f = c + (this.y / 2) - (this.legendVariableHeight / 2);
								break;
							case "topLeft":
								d = a + this.margin;
								f = c + this.margin;
								break;
							case "top":
								d = a + (this.x / 2) - (this.legendVariableWidth / 2);
								f = c + this.margin;
								break;
							case "topRight":
								d = a + this.x - (this.legendVariableWidth + this.legendOverlaysWidth + this.margin);
								f = c + this.margin;
								break;
							default:
								d = a + this.x - (this.legendVariableWidth + this.legendOverlaysWidth + this.margin);
								f = c + (this.y / 2) - (this.legendVariableHeight / 2)
						}
					} else {
						switch (this.legendPosition) {
							case "bottom":
								d = a + (this.x / 2) - (this.legendVariableWidth / 2);
								f = c + this.y + this.bottom - (this.legendVariableHeight + this.legendOverlaysHeight + this.margin);
								break;
							default:
								d = a + this.x + this.right - (this.legendVariableWidth + this.legendOverlaysWidth + this.margin);
								f = c + (this.y / 2) - (this.legendVariableHeight / 2)
						}
					}
				}
			}
		}
		return [d, f]
	};
	this.getScatterLegendPosition = function() {
		var h = 0;
		var f = 0;
		var e = 0;
		var b = 0;
		var a = 0;
		var g = 0;
		var c = this.marginLeft + this.offsetX + this.left + this.margin;
		var i = this.marginTop + this.offsetY + this.top + this.margin;
		if (this.scatterPlotMatrix || this.layoutValid) {
			e = this.width + this.margin - (this.marginRight + (this.legendWidth || 0));
			b = this.height + this.margin - (this.marginBottom + (this.legendHeight || 0));
			h = e - (this.legendDecorationWidth + this.margin);
			f = b - (this.legendDecorationHeight + this.margin)
		} else {
			if (this.legendInside) {
				if (this.legendDecorationWidth > 0 && this.legendDecorationHeight > 0) {
					var d = this.legendDecorationWidth + (this.margin * 2);
					switch (this.decorationsPosition) {
						case "bottomRight":
							h = c + this.x - d;
							f = i + this.y - (this.legendDecorationHeight + this.margin);
							break;
						case "bottom":
							h = c + (this.x / 2) - (this.legendDecorationWidth / 2);
							f = i + this.y - (this.legendDecorationHeight + this.margin);
							break;
						case "bottomLeft":
							h = c + this.margin;
							f = i + this.y - (this.legendDecorationHeight + this.margin);
							break;
						case "left":
							h = c + this.margin;
							f = i + (this.y / 2) - (this.legendDecorationHeight / 2);
							break;
						case "topLeft":
							h = c + this.margin;
							f = i + (this.margin * 2);
							break;
						case "top":
							h = c + (this.x / 2) - (this.legendDecorationWidth / 2);
							f = i + (this.margin * 2);
							break;
						case "topRight":
							h = c + this.x - d;
							f = i + (this.margin * 2);
							break;
						default:
							h = c + this.x - d;
							f = i + (this.y / 2) - (this.legendDecorationHeight / 2);
							break
					}
				}
				if (this.legendWidth > 0 && this.legendHeight > 0) {
					switch (this.legendPosition) {
						case "bottomRight":
							e = c + this.x - this.legendWidth;
							b = i + this.y - this.legendHeight;
							break;
						case "bottom":
							e = c + (this.x / 2) - (this.legendWidth / 2);
							b = i + this.y - this.legendHeight;
							break;
						case "bottomLeft":
							e = c;
							b = i + this.y - this.legendHeight;
							break;
						case "left":
							e = c;
							b = i + (this.y / 2) - (this.legendHeight / 2);
							break;
						case "topLeft":
							e = c;
							b = i;
							break;
						case "top":
							e = c + (this.x / 2) - (this.legendWidth / 2);
							b = i;
							break;
						case "topRight":
							e = c + this.x - this.legendWidth;
							b = i;
							break;
						default:
							e = c + this.x - this.legendWidth;
							b = i + (this.y / 2) - (this.legendHeight / 2);
							break
					}
				}
			} else {
				switch (this.decorationsPosition) {
					case "bottom":
						h = c + (this.x / 2) - (this.legendDecorationWidth / 2);
						f = i + this.y + this.bottom - this.legendDecorationHeight;
						break;
					default:
						h = c + this.x + this.right - (this.legendDecorationWidth + (this.margin * 2));
						f = i + (this.y / 2) - (this.legendDecorationHeight / 2);
						break
				}
				a = this.legendPosition == this.decorationsPosition ? this.legendDecorationWidth : 0;
				g = this.legendPosition == this.decorationsPosition ? this.legendDecorationHeight : 0;
				switch (this.legendPosition) {
					case "bottom":
						e = c + (this.x / 2) - (this.legendWidth / 2);
						b = i + this.y + this.bottom - (this.legendHeight + (g ? g + this.margin : 0));
						if (this.graphType == "Scatter3D" || this.is3DPlot) {
							b += this.legendHeight
						}
						break;
					default:
						e = c + this.x + this.right - (this.legendWidth + a);
						b = i + (this.y / 2) - (this.legendHeight / 2);
						if (this.graphType == "Scatter3D" || this.is3DPlot) {
							e += this.legendWidth
						}
						break
				}
			}
		}
		return [h, f, e, b]
	};
	this.drawIndicator = function(a, b, c) {
		delete(this.legendColorIndicatorCurX);
		delete(this.legendColorIndicatorCurY);
		this.drawColorIndicator(a, b, false, c)
	};
	this.drawLegend = function() {
		if (this.graphType == "Venn") {
			this.drawVennLegend()
		} else {
			if (this.graphType == "Circular") {
				this.drawCircularLegend()
			} else {
				if (this.graphType.match(/Scatter/) || this.is3DPlot || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|TagCloud|Heatmap/))) {
					this.drawScatterLegend();
					if (this.isOncoprint) {
						this.drawOncoprintLegend()
					}
					this.drawOverlaysLegend()
				} else {
					this.draw1DLegend();
					this.drawOverlaysLegend()
				}
			}
		}
	};
	this.draw1DLegend = function() {
		this.drawStockIndicatorsLegend();
		if (this.showLegend && ((this.graphType != "Heatmap") || (this.graphType == "Heatmap" && (this.colorBy || this.shapeBy || this.sizeBy || this.patternBy)))) {
			if (this.isMultidimensionalData || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|TagCloud|Heatmap/))) {
				if (this.isOncoprint) {
					this.drawOncoprintLegend()
				}
				this.drawScatterLegend()
			} else {
				if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
					return
				}
				var c = this.getVariableLegendPosition();
				var a = c[0];
				var b = c[1];
				if (this.legendVariableX && this.legendVariableY) {
					a = this.legendVariableX;
					b = this.legendVariableY
				}
				this.legendVariableCurX = a;
				this.legendVariableCurY = b;
				this.drawVariableLegend(a, b)
			}
		} else {
			if (this.isOncoprint) {
				this.drawOncoprintLegend()
			}
		}
	};
	this.drawOverlaysLegend = function() {
		var q, d;
		if (this.legendPosition.match(/right|left/i)) {
			q = this.layoutValid ? this.marginTop + this.layoutTop : this.marginTop + this.offsetY + this.top;
			d = this.layoutValid ? this.width - (this.marginRight + this.layoutRight + this.legendOverlaysWidth) : this.width - (this.marginRight + this.legendOverlaysWidth)
		} else {
			q = this.layoutValid ? this.height - (this.marginBottom + this.layoutBottom + this.legendOverlaysHeight) : this.height - (this.marginBottom + this.legendOverlaysHeight);
			d = this.layoutValid ? this.marginLeft + this.layoutLeft : this.marginLeft + this.offsetX + this.left
		}
		var s = q;
		var e = d;
		for (var g = 0; g < this.legendOverlaysLayout.length; g++) {
			var k = this.legendOverlaysLayout[g];
			var p, a, b;
			var r = mw = 0;
			var n = mh = 0;
			for (var f = 0; f < k.length; f++) {
				p = k[f][0];
				a = k[f][1];
				mw = Math.max(r, k[f][2]);
				mh = Math.max(n, k[f][3])
			}
			for (var f = 0; f < k.length; f++) {
				p = k[f][0];
				a = k[f][1];
				b = this.meta.data[p][a];
				r = this["legend" + a + "Width"];
				n = this["legend" + a + "Height"];
				if (b.type == "String") {
					this.drawGenericLegend(e, s, r, n, b, a)
				} else {
					this.drawColorIndicator(e, s, b, a, false, r / 2)
				}
				if (this.legendPosition.match(/right|left/i)) {
					s += n + this.margin
				} else {
					e += r + this.margin
				}
			}
			if (this.legendPosition.match(/right|left/i)) {
				e += mw + this.margin;
				s = q
			} else {
				e = d;
				s += mh + this.margin
			}
		}
	};
	this.drawScatterLegend = function() {
		var j = this.getScatterLegendPosition();
		if (this.showDecorations && this.showDecorationsLegend && this.data.d && !this.scatterPlotMatrix) {
			if (this.legendDecorationX != null && this.legendDecorationY != null) {
				this.drawDecorationLegend(this.legendDecorationX, this.legendDecorationY)
			} else {
				this.drawDecorationLegend(j[0], j[1])
			}
		}
		if (this.showLegend) {
			var f = this.scatterPlotMatrix ? ["Color", "Shape", "Size", "Pattern", "Variable"] : ["Color", "Shape", "Size", "Pattern", "Variable", "Sample"];
			var c = j[2];
			var k = j[3];
			for (var d = 0; d < f.length; d++) {
				var o = this["legend" + f[d] + "Width"];
				var e = this["legend" + f[d] + "Height"];
				var n = this["legend" + f[d] + "X"];
				var g = this["legend" + f[d] + "Y"];
				if (o > 0) {
					var b = "draw" + f[d] + "Legend";
					var a = this["legend" + f[d] + "Meta"];
					var l = this.getXYLegendCoords(f[d], c, k);
					if (n && g) {
						this[b](n, g, a);
						this["legend" + f[d] + "CurX"] = n;
						this["legend" + f[d] + "CurY"] = g
					} else {
						this[b](l[0], l[1], a);
						this["legend" + f[d] + "CurX"] = l[0];
						this["legend" + f[d] + "CurY"] = l[1]
					}
					if (this.legendPosition.match(/right|left/i)) {
						k = l[3] + this.margin
					} else {
						c = l[2] + this.margin
					}
				}
			}
		}
	}
};
CanvasXpress.prototype.initFilterUtils = function() {
	this.filterVariables = function(e, d, a, b) {
		this.filterUserData(["filterVarBy"], ["vars"], [d], [a], null, b)
	};
	this.filterVariablesByCategory = function(e, d, a, b) {
		this.filterUserData(["filterVarBy"], [e], [d], [a], null, b)
	};
	this.filterSamples = function(e, d, a, b) {
		this.filterUserData(["filterSmpBy"], ["smps"], [d], [a], null, b)
	};
	this.filterSamplesByCategory = function(a, e, b, d) {
		this.filterUserData(["filterSmpBy"], [z], [e], [b], null, d)
	};
	this.filterUserData = function(g, f, j, k, a, d) {
		this.functionCaller = "filterUserData";
		if (d) {
			this.resetFilters()
		}
		var e = {
			min: ">=",
			max: "<=",
			like: "like",
			exact: "exact"
		};
		for (var b = 0; b < g.length; b++) {
			this[g[b]].push(a != null && a[b] != null ? f[b] + ":::" + a[b] : f[b]);
			this[g[b] + "Op"].push(e[j[b]]);
			this[g[b] + "Case"].push(false);
			this[g[b] + "Value"].push(k[b])
		}
		this.reset(true);
		this.filterData(true);
		if (this.isGroupedData && this.smpIndices.length > 0) {
			this.groupSamples(this.groupingFactors, false, false, true)
		} else {
			this.draw()
		}
	};
	this.filterData = function(E) {
		if (this.isDOE) {
			return
		}
		var q = {};
		var Q = {};
		var P = {};
		var D = false;
		var o = this;
		var f = function(v, R, h) {
			if (R.hasOwnProperty(v)) {
				return R[v]
			} else {
				if (v.match(":::")) {
					var d = v.split(":::");
					if (h[d[1]]) {
						d[1] = parseInt(d[1]);
						for (var s = 0; s < h[d[1]].length; s++) {
							var k = h[d[1]][s];
							if (R.hasOwnProperty(k)) {
								R = R[k]
							} else {
								return false
							}
						}
						if (R.hasOwnProperty(d[0])) {
							return R[d[0]]
						}
					}
				}
				return false
			}
		};
		var F = function(k, v, j, h) {
			if (!v) {
				return true
			}
			if (o.filterSkipNullValues && (k == null || k == "")) {
				return true
			}
			if (v == ">") {
				return parseFloat(k) - parseFloat(j) > 0
			} else {
				if (v == ">=") {
					return parseFloat(k) - parseFloat(j) > 0 || parseFloat(k) - parseFloat(j) == 0
				} else {
					if (v == "<") {
						return parseFloat(k) - parseFloat(j) < 0
					} else {
						if (v == "<=") {
							return parseFloat(k) - parseFloat(j) < 0 || parseFloat(k) - parseFloat(j) == 0
						} else {
							if (v == "=" || v == "==") {
								return parseFloat(k) - parseFloat(j) == 0
							} else {
								if (v == "null") {
									return k == null
								} else {
									if (v == "not null") {
										return k != null
									} else {
										if (v == "exact") {
											for (var d = 0; d < j.length; d++) {
												if (k == j[d]) {
													return true
												}
											}
											return false
										} else {
											if (v == "like" || v == "not like") {
												var p = false;
												if (h) {
													for (var d = 0; d < j.length; d++) {
														if ((k + "").search(j[d] + "") != -1 || j[d] == k) {
															p = true;
															if (v == "like") {
																break
															}
														}
													}
												} else {
													var a = (k + "").toLowerCase();
													for (var d = 0; d < j.length; d++) {
														var s = (j[d] + "").toLowerCase();
														if (a.search(s) != -1 || a == s) {
															p = true;
															if (v == "like") {
																break
															}
														}
													}
												}
												return v == "like" ? p : !p
											}
										}
									}
								}
							}
						}
					}
				}
			}
		};
		var g = function(a) {
			if (!P[a]) {
				P[a] = 0
			}
			P[a]++
		};
		if (this.graphType == "Genome" && this.filterFeatureBy.length > 0) {
			for (var I = 0; I < this.filterFeatureBy.length; I++) {
				if (this.filterFeatureBy[I]) {
					for (var H = 0; H < this.data.tracks.length; H++) {
						var C = this.data.tracks[H];
						var m = C.data;
						for (var G = 0; G < m.length; G++) {
							var l = m[G];
							if (this.filterSkipNullKeys && !l.hasOwnProperty(this.filterFeatureBy[I])) {
								continue
							}
							var u = f(this.filterFeatureBy[I], l, this.featuresProperties);
							if (!F(u, this.filterFeatureByOp[I], this.filterFeatureByValue[I], this.filterFeatureByCase[I])) {
								l.hide = this.filterType == "and" ? true : q[H + ":" + G] ? false : true;
								Q[H + ":" + G] = true
							} else {
								q[H + ":" + G] = true;
								if (this.filterType == "or" && Q[H + ":" + G]) {
									l.hide = false
								}
							}
						}
					}
				}
			}
		} else {
			if (this.graphType == "Network" && (this.filterNodeBy.length > 0 || this.filterEdgeBy.length)) {
				for (var I = 0; I < this.filterNodeBy.length; I++) {
					if (this.filterNodeBy[I]) {
						for (var H = 0; H < this.data.nodes.length; H++) {
							if (this.filterSkipNullKeys && !this.data.nodes[H].hasOwnProperty(this.filterNodeBy[I])) {
								continue
							}
							if (this.data.nodes[H].hide) {
								continue
							}
							var u = f(this.filterNodeBy[I], this.data.nodes[H], this.nodesProperties);
							if (!F(u, this.filterNodeByOp[I], this.filterNodeByValue[I], this.filterNodeByCase[I])) {
								this.data.nodes[H].hide = this.filterType == "and" ? true : q[this.data.nodes[H].id] ? false : true;
								Q[this.data.nodes[H].id] = true
							} else {
								q[this.data.nodes[H].id] = true;
								if (this.filterType == "or" && Q[this.data.nodes[H].id]) {
									this.data.nodes[H].hide = false
								}
							}
						}
					}
				}
				for (var I = 0; I < this.filterEdgeBy.length; I++) {
					if (this.filterEdgeBy[I]) {
						for (var H = 0; H < this.data.edges.length; H++) {
							var t = this.data.nodes[this.data.nodeIndices[this.data.edges[H].id1]];
							var r = this.data.nodes[this.data.nodeIndices[this.data.edges[H].id2]];
							var B = t.id + ":" + r.id;
							if (this.filterSkipNullKeys && !this.data.edges[H].hasOwnProperty(this.filterEdgeBy[I])) {
								continue
							}
							var u = f(this.filterEdgeBy[I], this.data.edges[H], this.edgesProperties);
							if (!F(u, this.filterEdgeByOp[I], this.filterEdgeByValue[I], this.filterEdgeByCase[I])) {
								this.data.edges[H].hide = this.filterType == "and" ? true : q[B] ? false : true;
								Q[B] = true
							} else {
								q[B] = true;
								if (this.filterType == "or" && Q[B]) {
									this.data.edges[H].hide = false
								}
							}
							if (!this.data.edges[H].hide) {
								g(t.id);
								g(r.id)
							}
						}
					}
				}
				if (this.filterEdgeBy.length > 0) {
					for (var I = 0; I < this.data.nodes.length; I++) {
						var n = this.data.nodes[I];
						if (!P[n.id]) {
							n.hide = true
						}
					}
				}
			} else {
				if (this.isCreateHistogram) {
					if (this.filterVarBy.length > 0) {
						var N = this.dataStndBy;
						var K = this.data.y.histogram;
						var O = this.data.y.all
					}
				} else {
					if (this.filterSmpBy.length > 0) {
						for (var I = 0; I < this.filterSmpBy.length; I++) {
							if (this.filterSmpBy[I]) {
								D = true;
								if (this.isGroupedData && !E) {
									for (var H = 0; H < this.grpIndices.length; H++) {
										var M = this.grpIndices[H];
										var e;
										if (this.filterSmpBy[I] == "smps") {
											var x = false;
											for (var G = 0; G < this.data.w.grps[M].length; G++) {
												e = this.data.y.smps[this.data.w.grps[M][G]];
												if (F(e, this.filterSmpByOp[I], this.filterSmpByValue[I], this.filterSmpByCase[I])) {
													x = true;
													break
												}
											}
											if (!x) {
												this.hiddenGrps[M] = this.filterType == "and" ? true : q[M] ? false : true;
												Q[M] = true
											} else {
												q[M] = true;
												if (this.filterType == "or" && Q[M]) {
													this.hiddenGrps[M] = false
												}
											}
										} else {
											e = this.data.w.factors[this.filterSmpBy[I]][M];
											if (!F(e, this.filterSmpByOp[I], this.filterSmpByValue[I], this.filterSmpByCase[I])) {
												this.hiddenGrps[M] = this.filterType == "and" ? true : q[M] ? false : true;
												Q[M] = true
											} else {
												q[M] = true;
												if (this.filterType == "or" && Q[M]) {
													this.hiddenGrps[M] = false
												}
											}
										}
									}
								} else {
									for (var H = 0; H < this.smpIndices.length; H++) {
										var M = this.smpIndices[H];
										var e = this.filterSmpBy[I] == "smps" ? this.data.y.smps[M] : this.data.x[this.filterSmpBy[I]][M];
										if (!F(e, this.filterSmpByOp[I], this.filterSmpByValue[I], this.filterSmpByCase[I])) {
											this.hiddenSmps[M] = this.filterType == "and" ? true : q[M] ? false : true;
											Q[M] = true
										} else {
											q[M] = true;
											if (this.filterType == "or" && Q[M]) {
												this.hiddenSmps[M] = false
											}
										}
									}
								}
							}
						}
						if (D) {
							var b = [];
							if (this.isGroupedData && !E) {
								for (var I = 0; I < this.grpIndices.length; I++) {
									var w = this.grpIndices[I];
									if (!this.hiddenGrps[w]) {
										b.push(w)
									}
								}
								this.grpIndices = b
							} else {
								for (var I = 0; I < this.smpIndices.length; I++) {
									var w = this.smpIndices[I];
									if (!this.hiddenSmps[w]) {
										b.push(w)
									}
								}
								this.smpIndices = b
							}
						}
					}
					if (this.filterVarBy.length > 0) {
						for (var I = 0; I < this.filterVarBy.length; I++) {
							if (this.filterVarBy[I]) {
								D = true;
								for (var H = 0; H < this.varIndices.length; H++) {
									var M = this.varIndices[H];
									var e = this.filterVarBy[I] == "vars" ? this.data.y.vars[M] : this.data.z[this.filterVarBy[I]][M];
									if (!F(e, this.filterVarByOp[I], this.filterVarByValue[I], this.filterVarByCase[I])) {
										this.hiddenVars[M] = this.filterType == "and" ? true : q[M] ? false : true;
										Q[M] = true
									} else {
										q[M] = true;
										if (this.filterType == "or" && Q[M]) {
											this.hiddenVars[M] = false
										}
									}
								}
							}
						}
						if (D) {
							var b = [];
							for (var I = 0; I < this.varIndices.length; I++) {
								var w = this.varIndices[I];
								if (!this.hiddenVars[w]) {
									b.push(w)
								}
							}
							this.varIndices = b
						}
					}
				}
			}
		}
		if (this.layoutComb && this.graphType != "Candlestick" && !this.graphType.match(/Scatter/)) {
			this.restoreEmptyCompartments();
			var L = this.getObjectArray(this.varIndices);
			var J = this.getObjectArray(this.smpIndices);
			for (var I = 0; I < this.data.l.comp.length; I++) {
				var A = this.layoutParams[I];
				var u = A.startingVarIndices;
				var y = A.startingSmpIndices;
				var O = [];
				if (u) {
					for (var H = 0; H < u.length; H++) {
						if (L.hasOwnProperty(u[H])) {
							O.push(u[H])
						}
					}
					A.varIndices = O
				}
				O = [];
				if (y) {
					for (var H = 0; H < y.length; H++) {
						if (J.hasOwnProperty(y[H])) {
							O.push(y[H])
						}
					}
					A.smpIndices = O
				}
			}
		}
	};
	this.resetSmpFilters = function(a) {
		if (a != null && this.filterSmpBy.length > 0) {
			this.filterSmpBy.splice(a, 1);
			this.filterSmpByOp.splice(a, 1);
			this.filterSmpByValue.splice(a, 1);
			this.filterSmpByCase.splice(a, 1);
			this.filteredSmpIndices.splice(a, 1)
		} else {
			this.filterSmpBy = [];
			this.filterSmpByOp = [];
			this.filterSmpByValue = [];
			this.filterSmpByCase = [];
			this.filteredSmpIndices = []
		}
	};
	this.resetVarFilters = function(a) {
		if (a != null && this.filterVarBy.length > 0) {
			this.filterVarBy.splice(a, 1);
			this.filterVarByOp.splice(a, 1);
			this.filterVarByValue.splice(a, 1);
			this.filterVarByCase.splice(a, 1);
			this.filteredVarIndices.splice(a, 1)
		} else {
			this.filterVarBy = [];
			this.filterVarByOp = [];
			this.filterVarByValue = [];
			this.filterVarByCase = [];
			this.filteredVarIndices = []
		}
	};
	this.resetNodeFilters = function(a) {
		if (a != null && this.filterNodeBy.length > 0) {
			this.filterNodeBy.splice(a, 1);
			this.filterNodeByOp.splice(a, 1);
			this.filterNodeByValue.splice(a, 1);
			this.filterNodeByCase.splice(a, 1)
		} else {
			this.filterNodeBy = [];
			this.filterNodeByOp = [];
			this.filterNodeByValue = [];
			this.filterNodeByCase = []
		}
	};
	this.resetEdgeFilters = function(a) {
		if (a != null && this.filterEdgeBy.length > 0) {
			this.filterEdgeBy.splice(a, 1);
			this.filterEdgeByOp.splice(a, 1);
			this.filterEdgeByValue.splice(a, 1);
			this.filterEdgeByCase.splice(a, 1)
		} else {
			this.filterEdgeBy = [];
			this.filterEdgeByOp = [];
			this.filterEdgeByValue = [];
			this.filterEdgeByCase = []
		}
	};
	this.resetFeatureFilters = function(a) {
		if (a != null && this.filterFeatureBy.length > 0) {
			this.filterFeatureBy.splice(a, 1);
			this.filterFeatureByOp.splice(a, 1);
			this.filterFeatureByValue.splice(a, 1);
			this.filterFeatureByCase.splice(a, 1)
		} else {
			this.filterFeatureBy = [];
			this.filterFeatureByOp = [];
			this.filterFeatureByValue = [];
			this.filterFeatureByCase = []
		}
	};
	this.resetFilters = function(e, d) {
		var a = [];
		if (!e) {
			a = ["filterSmpBy", "filterVarBy", "filterNodeBy", "filterEdgeBy", "filterFeatureBy"]
		} else {
			a = [e]
		}
		for (var b = 0; b < a.length; b++) {
			c = a[b];
			if (c == "filterSmpBy") {
				this.resetSmpFilters(d)
			} else {
				if (c == "filterVarBy") {
					this.resetVarFilters(d)
				} else {
					if (c == "filterNodeBy") {
						this.resetNodeFilters(d)
					} else {
						if (c == "filterEdgeBy") {
							this.resetEdgeFilters(d)
						} else {
							if (c == "filterFeatureBy") {
								this.resetFeatureFilters(d)
							}
						}
					}
				}
			}
		}
	}
};
CanvasXpress.prototype.initClusterUtils = function() {
	this.setTrees = function() {
		if (this.data.t && this.data.t.smps) {
			this.smpDendrogram = {};
			this.smpDendrogram.data = [];
			this.smpDendrogram.nodes = [];
			this.smpDendrogram.idxs = [];
			this.smpDendrogram.heights = [];
			this.parseNewick(this.data.t.smps, "smpDendrogram")
		}
		if (this.data.t && this.data.t.vars) {
			this.varDendrogram = {};
			this.varDendrogram.data = [];
			this.varDendrogram.nodes = [];
			this.varDendrogram.idxs = [];
			this.varDendrogram.heights = [];
			this.parseNewick(this.data.t.vars, "varDendrogram")
		}
	};
	this.parseNewick = function(b, e) {
		var p = b.split(/,/);
		var v = 0;
		var f = 0;
		var g = 0;
		var m = 1;
		var l = 0;
		var u = 0;
		var a = 0;
		var k = 0;
		for (var s = 0; s < p.length; s++) {
			var q = p[s];
			var h = q.split(/:(?=[0-9\.]+)/);
			var w = h.shift().replace(/[\(\)]/g, "");
			var c = e == "smpDendrogram" ? this.getSampleIndices(w) : this.getVariableIndices(w);
			if (c == -1) {
				c = parseInt(w);
				this[e].nodes.push(e == "smpDendrogram" ? this.data.y.smps[w] : this.data.y.vars[w]);
				this[e].idxs.push(w)
			} else {
				this[e].nodes.push(w);
				this[e].idxs.push(c)
			}
			for (var r = 0; r < h.length; r++) {
				var d = h[r].replace(/[\(\)]/g, "");
				u = Math.max(u, d);
				this[e].heights.push(parseFloat(d))
			}
			this[e].max = u;
			var t = p[s].split("");
			f = 0;
			for (var r = 0; r < t.length; r++) {
				if (t[r] == "(") {
					v++;
					f++
				}
				if (t[r] == ")") {
					v--;
					f--
				}
			}
			k += f;
			if (g > v) {
				this[e].data.push([m, g, f, k])
			} else {
				this[e].data.push([m, v, f, k])
			}
			g = v;
			a = Math.max(a, g);
			l += f;
			m++
		}
		this[e].unit = u > 0 ? (a * this.dendrogramSpace) / u : 0;
		this[e].depth = a;
		if (l > 0) {
			alert("Dude! Malformed newick tree. There are " + l + " additional right parenthesis!")
		} else {
			if (l < 0) {
				alert("Dude! Malformed newick tree. There are " + Math.abs(l) + " additional left parenthesis!")
			}
		}
		if (e == "varDendrogram" && this.showVarDendrogram) {
			if (this.varIndicesStart < 0) {
				if (this[e].nodes.length != this.data.y.vars.length) {
					alert("Dude! The length of the variable nodes in the dendrogram (" + this[e].nodes.length + ") is different to that one in the data (" + this.data.y.vars.length + "). This ain't gonna work!");
					this.showVarDendrogram = false
				} else {
					if (this[e].nodes.length != this.varIndices.length) {
						alert("Ooops! Cannot show dendrogram with " + this[e].nodes.length + " nodes when only " + this.varIndices.length + " variables are visible.");
						this.showVarDendrogram = false
					} else {
						this.varIndices = this[e].idxs
					}
				}
			} else {
				var o = this.varIndicesStart + this.varIndices.length;
				this.varIndices = [];
				for (var s = this.varIndicesStart; s < o; s++) {
					this.varIndices.push(this[e].idxs[s])
				}
			}
		} else {
			if (this.showSmpDendrogram) {
				if (this.smpIndicesStart < 0) {
					if (this[e].nodes.length != this.data.y.smps.length) {
						alert("Dude! The length of the sample nodes in the dendrogram (" + this[e].nodes.length + ") is different to that one in the data (" + this.data.y.smps.length + "). This ain't gonna work!");
						this.showSmpDendrogram = false
					} else {
						if (this[e].nodes.length != this.smpIndices.length) {
							alert("Ooops! Cannot show dendrogram with " + this[e].nodes.length + " nodes when only " + this.smpIndices.length + " samples visible.");
							this.showSmpDendrogram = false
						} else {
							this.smpIndices = this[e].idxs
						}
					}
				} else {
					var o = this.smpIndicesStart + this.smpIndices.length;
					this.smpIndices = [];
					for (var s = this.smpIndicesStart; s < o; s++) {
						this.smpIndices.push(this[e].idxs[s])
					}
				}
			}
		}
	};
	this.euclidianDistance = function(b, a, h, g) {
		var e = this.cleanArrays(b, a, h, g);
		b = e[0];
		a = e[1];
		var f = 0;
		if (b.length == a.length) {
			for (var c = 0; c < b.length; c++) {
				f += Math.pow(b[c] - a[c], 2)
			}
			f = Math.sqrt(f)
		}
		return f
	};
	this.manhattanDistance = function(b, a, h, g) {
		var e = this.cleanArrays(b, a, h, g);
		b = e[0];
		a = e[1];
		var f = 0;
		if (b.length == a.length) {
			for (var c = 0; c < b.length; c++) {
				f += Math.abs(b[c] - a[c])
			}
		}
		return f
	};
	this.maxDistance = function(b, a, h, g) {
		var e = this.cleanArrays(b, a, h, g);
		b = e[0];
		a = e[1];
		var f = 0;
		if (b.length == a.length) {
			for (var c = 0; c < b.length; c++) {
				f = Math.max(f, Math.abs(b[c] - a[c]))
			}
		}
		return f
	};
	this.classifyKmeansVector = function(f, c) {
		var e = Number.POSITIVE_INFINITY;
		var a = 0;
		for (var d = 0; d < c.length; d++) {
			var b = this[this.distance + "Distance"](f, c[d]);
			if (b < e) {
				e = b;
				a = d
			}
		}
		return a
	};
	this.addVectors = function(c, b, g, f) {
		var e = this.cleanArrays(c, b, g, f);
		c = e[0];
		b = e[1];
		var a = [];
		if (c.length == b.length) {
			for (var d = 0; d < c.length; d++) {
				a.push(c[d] + b[d])
			}
		}
		return a
	};
	this.compareVectors = function(b, a) {
		if (this.isArray(b) && this.isArray(a)) {
			if (b.length != a.length) {
				return false
			}
			for (var c = 0; c < b.length; c++) {
				if (this.isArray(b[c]) && this.isArray(a[c])) {
					if (!this.compareArrays(b[c], a[c])) {
						return false
					}
				}
				if (b[c] !== a[c]) {
					return false
				}
			}
			return true
		}
	};
	this.vectorDotProduct = function(b, a, g, f) {
		var d = this.cleanArrays(b, a, g, f);
		b = d[0];
		a = d[1];
		var e = 0;
		if (b.length == a.length) {
			for (var c = 0; c < b.length; c++) {
				e += b[c] * a[c]
			}
		}
		return e
	};
	this.multiplyVectorByValue = function(a, d, e, c) {
		a = this.cleanArray(a, e, c);
		for (var b = 0; b < a.length; b++) {
			a[b] *= d
		}
		return a
	};
	this.getCentroid = function(d, g, f, a) {
		var h = [];
		if (g.length == a.length) {
			var e = d + f;
			for (var b = 0; b < g.length; b++) {
				h.push((d * g[b] + f * a[b]) / e)
			}
		}
		return h
	};
	this.createClusterNode = function(i, b, e, f, h, a) {
		var g = {
			id: i,
			left: b,
			right: e,
			dist: f,
			centroid: h
		};
		if (a != null) {
			g.mid = a
		}
		if (b == null && e == null) {
			g.size = 1;
			g.depth = 0
		} else {
			g.size = b.size + e.size;
			g.depth = 1 + Math.max(b.depth, e.depth)
		}
		return g
	};
	this.createRandomCentroids = function(c) {
		var b = this;
		var a = c.slice(0);
		a.sort(function() {
			return (Math.round(b.random()) - 0.5)
		});
		return a.slice(0, this.clusterAxis == "samples" ? this.kmeansSmpClusters : this.kmeansVarClusters)
	};
	this.createRandomVectors = function(d, g) {
		var c = g.length;
		if (d > c) {
			return null
		}
		var l = [];
		var f = [];
		var a = {};
		var m = 0;
		var o = 0;
		var j, b;
		while (o < d) {
			if (m == c) {
				return null
			}
			var h = Math.floor(this.random() * c);
			if (h in a) {
				continue
			}
			a[h] = 1;
			m++;
			j = g[h];
			b = true;
			for (var e = 0; e < o; e++) {
				if (this.compareVectors(j, l[e])) {
					b = false;
					break
				}
			}
			if (b) {
				l[o] = j;
				f[o] = h;
				o++
			}
		}
		return {
			vectors: l,
			indices: f
		}
	};
	this.imputeDatum = function(a) {
		var d = [];
		if (this.clusterAxis == "samples") {
			for (var b = 0; b < this.varIndices.length; b++) {
				var c = this.varIndices[b];
				d.push(this.data.y.data[c][a])
			}
		} else {
			for (var b = 0; b < this.smpIndices.length; b++) {
				var c = this.smpIndices[b];
				d.push(this.data.y.data[a][c])
			}
		}
		return this[this.imputeMethod](d)
	};
	this.getIdsForClustering = function() {
		var e = [];
		if (this.clusterAxis == "samples") {
			for (var b = 0; b < this.smpIndices.length; b++) {
				var c = this.smpIndices[b];
				var a = this.getSampleIndices(c);
				e[b] = a == -1 ? c : this.data.y.smps[c]
			}
		} else {
			for (var b = 0; b < this.varIndices.length; b++) {
				var c = this.varIndices[b];
				var a = this.getVariableIndices(c);
				e[b] = a == -1 ? c : this.data.y.smps[c]
			}
		}
		return e
	};
	this.getDataForClustering = function() {
		var h = [];
		var a = [];
		if (this.clusterAxis == "samples") {
			for (var c = 0; c < this.smpIndices.length; c++) {
				h[c] = []
			}
			for (var c = 0; c < this.varIndices.length; c++) {
				var e = this.varIndices[c];
				for (var b = 0; b < this.smpIndices.length; b++) {
					var f = this.smpIndices[b];
					var g = this.data.y.data[e][f];
					if (isNaN(g)) {
						if (!a[b]) {
							a[b] = this.imputeDatum(f)
						}
						g = a[b]
					}
					h[b][c] = g
				}
			}
		} else {
			for (var c = 0; c < this.varIndices.length; c++) {
				h[c] = []
			}
			for (var c = 0; c < this.varIndices.length; c++) {
				var e = this.varIndices[c];
				for (var b = 0; b < this.smpIndices.length; b++) {
					var f = this.smpIndices[b];
					var g = this.data.y.data[e][f];
					if (isNaN(g)) {
						if (!a[c]) {
							a[c] = this.imputeDatum(e)
						}
						g = a[c]
					}
					h[c][b] = g
				}
			}
		}
		return h
	};
	this.cluster = function() {
		var n = function() {
			var i = a[s][0].id;
			var d = a[r][0].id;
			if (i < 0 && d >= 0) {
				return true
			} else {
				if (i < 0 && d < 0) {
					return d > i
				} else {
					if (i >= 0 && d >= 0) {
						return i > d
					} else {
						return false
					}
				}
			}
		};
		var h;
		var z = this.getDataForClustering();
		var v = this.getIdsForClustering();
		var o = [];
		var e = [];
		var B = [];
		var a = [];
		if (!this.meta.tree) {
			this.meta.tree = {}
		}
		var u = this.meta.tree;
		u[this.clusterAxis] = [];
		for (var y = 0; y < z.length; y++) {
			o[y] = []
		}
		o[0][0] = Number.POSITIVE_INFINITY;
		for (var y = 0; y < z.length - 1; y++) {
			for (var x = y + 1; x < z.length; x++) {
				o[x][x] = Number.POSITIVE_INFINITY;
				o[y][x] = this[this.distance + "Distance"](z[y], z[x]);
				o[x][y] = o[y][x]
			}
		}
		for (var y = 0; y < z.length; y++) {
			e[y] = 0;
			for (var x = 0; x < z.length; x++) {
				if (o[y][e[y]] > o[y][x]) {
					e[y] = x
				}
			}
		}
		for (var y = 0; y < z.length; y++) {
			a[y] = [];
			a[y][0] = this.createClusterNode(v[y], null, null, 0, z[y]);
			B[y] = 1
		}
		var b = -1;
		for (var q = 0; q < z.length - 1; q++) {
			var s = 0;
			for (var y = 0; y < z.length; y++) {
				if (o[y][e[y]] < o[s][e[s]]) {
					s = y
				}
			}
			var r = e[s];
			if (n()) {
				var c = r;
				r = s;
				s = c
			}
			var f = a[s][0];
			var t = a[r][0];
			var g = this.getCentroid(f.size, f.centroid, t.size, t.centroid);
			var A = this.createClusterNode(b, f, t, o[s][r], g);
			a[s].splice(0, 0, A);
			for (var x = 0; x < z.length; x++) {
				if (this.linkage == "single") {
					if (o[s][x] > o[r][x]) {
						o[x][s] = o[s][x] = o[r][x]
					}
				} else {
					if (this.linkage == "complete") {
						if (o[s][x] < o[r][x]) {
							o[x][s] = o[s][x] = o[r][x]
						}
					} else {
						if (this.linkage == "average") {
							o[x][s] = o[s][x] = ((B[s] * o[s][x]) + (B[r] * o[r][x])) / (B[s] + B[r])
						}
					}
				}
			}
			B[s] += B[r];
			o[s][s] = Number.POSITIVE_INFINITY;
			for (var y = 0; y < z.length; y++) {
				o[y][r] = o[r][y] = Number.POSITIVE_INFINITY
			}
			for (var x = 0; x < z.length; x++) {
				if (e[x] == r) {
					e[x] = s
				}
			}
			for (var x = 0; x < z.length; x++) {
				for (var w = 0; w < z.length; w++) {
					if (o[w][x] < o[w][e[w]]) {
						e[w] = x
					}
				}
			}
			h = A;
			u[this.clusterAxis].push([f.id, t.id, h.dist]);
			b--
		}
		return this.writeNewick(h, true)
	};
	this.isLeafNode = function(a) {
		if (a.left == null && a.right == null) {
			return true
		} else {
			return false
		}
	};
	this.writeNewick = function(k, g, j) {
		var h = "";
		var e = "";
		var f = false;
		if (this.isLeafNode(k)) {
			f = true;
			if (isNaN(k.id)) {
				h = this.clusterAxis == "variables" ? this.getVariableIndices(k.id) : this.getSampleIndices(k.id)
			} else {
				h = k.id
			}
		} else {
			var b;
			var c = this.writeNewick(k.left, g, true);
			var a = this.writeNewick(k.right, g, false);
			if (k.mid) {
				for (var d = 0; d < k.mid.length; d++) {
					if (g && k.mid[d].dist) {
						e += "," + k.mid[d].id + ":" + k.mid[d].dist
					} else {
						e += "," + k.mid[d].id
					}
					e += k.mid[d].id
				}
			}
			h = "(" + c + e + "," + a + ")"
		}
		if (g && !f) {
			h += ":" + sprintf("%.1f", k.dist)
		}
		return h
	};
	this.kmeans = function() {
		var p = this.getDataForClustering();
		var q = this.createRandomCentroids(p);
		var m = new Array(p.length);
		var b = this.clusterAxis == "samples" ? this.kmeansSmpClusters : this.kmeansVarClusters;
		var n = new Array(b);
		var s = 0;
		var v = true;
		while (v) {
			for (var e = 0; e < p.length; e++) {
				m[e] = this.classifyKmeansVector(p[e], q)
			}
			v = false;
			for (var c = 0; c < b; c++) {
				var l = [];
				for (var e = 0; e < m.length; e++) {
					if (m[e] == c) {
						l.push(p[e])
					}
				}
				if (!l.length) {
					continue
				}
				var o = q[c];
				var u = new Array(o.length);
				for (var f = 0; f < o.length; f++) {
					var h = 0;
					for (var e = 0; e < l.length; e++) {
						if (!isNaN(l[e][f])) {
							h += l[e][f]
						}
					}
					u[f] = h / l.length;
					if (u[f] != o[f]) {
						v = true
					}
				}
				q[c] = u;
				n[c] = l
			}
			s++;
			if (s > this.maxIterations) {
				v = false
			}
		}
		var r = [];
		for (var e = 0; e < b; e++) {
			r[e] = {
				distance: this[this.distance + "Distance"](q[0], q[e]),
				assign: e
			}
		}
		r = r.sort(function(g, d) {
			return g.distance - d.distance
		});
		var a = {};
		for (var e = 0; e < r.length; e++) {
			a[r[e].assign] = e
		}
		for (var e = 0; e < m.length; e++) {
			var t = a[m[e]] + 1;
			if (t > 9) {
				m[e] = "K" + t
			} else {
				m[e] = "K-0" + t
			}
		}
		return m
	}
};
CanvasXpress.prototype.initSortUtils = function() {
	this.sortNetworkIndices = function(h) {
		this.functionCaller = "sortNetworkIndices";
		var g = this.data[this.networkShowDataTable];
		var c = [h] ? h : this.networkShowDataTable == "nodes" ? "id" : "id1";
		var b = [];
		var f = [];
		for (var e = 0; e < g.length; e++) {
			b.push(e);
			f.push(g[e][c] ? g[e][c] : null)
		}
		if (this.isNumeric(f)) {
			var a = Number.MAX_VALUE * -1;
			b.sort(function(j, i) {
				return (f[j] || a) - (f[i] || a)
			})
		} else {
			b.sort(function(j, i) {
				return f[j] > f[i] ? 1 : f[j] < f[i] ? -1 : 0
			})
		}
		var d = [];
		for (var e = 0; e < g.length; e++) {
			d.push(g[b[e]])
		}
		if (this.sortDir == "ascending") {
			d.reverse()
		}
		this.data[this.networkShowDataTable] = d;
		if (this.networkShowDataTable == "nodes") {
			this.setNodeIndices()
		}
		this.draw()
	};
	this.sortIndices = function(h, c, k, a, m, j, o) {
		var g = this;
		var n = this.meta.def;
		this.tmpAsciiArray = [];
		this.tmpAsciiArray1 = [];
		this.tmpAsciiArray2 = [];
		this.tmpAsciiArrayAscii = false;
		this.tmpAsciiArrayAscii1 = false;
		this.tmpAsciiArrayAscii2 = false;
		if (k) {
			k = this.toArray(k)
		}
		if (a) {
			a = this.toArray(a)
		}
		if (m) {
			m = this.toArray(m)
		}
		if (!c) {
			c = this.sortDir
		}
		if (h == "onc") {
			var b = [];
			for (var f = 0; f < this.data.y.vars.length; f++) {
				b.push(f)
			}
			this.varIndices = b;
			this.tmpAsciiArray = this.data.z.Alterations;
			this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(this.smpIndices[0]);
			this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
			this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
		} else {
			if (k && h == "vars") {
				if (k.length == 1 && this.data.z && this.data.z[k[0]]) {
					this.tmpAsciiArray = this.data.z[k[0]];
					this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray)
				} else {
					if (k.length == 2 && this.data.z && this.data.z[k[0]] && this.data.z[k[1]]) {
						this.tmpAsciiArray = this.data.z[k[0]];
						this.tmpAsciiArray1 = this.data.z[k[1]];
						this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
						this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
					} else {
						if (k.length == 3 && this.data.z && this.data.z[k[0]] && this.data.z[k[1]] && this.data.z[k[2]]) {
							this.tmpAsciiArray = this.data.z[k[0]];
							this.tmpAsciiArray1 = this.data.z[k[1]];
							this.tmpAsciiArray2 = this.data.z[k[2]];
							this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
							this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1);
							this.tmpAsciiArrayAscii2 = this.isAsciiArray(this.tmpAsciiArray2)
						}
					}
				}
				this.smpSort = -1;
				this.varSort = k
			} else {
				if (k && h == "smps") {
					if (this.isGroupedData) {
						this.isGroupedData = false;
						this.sortIndices(h, c, k, a, m, j, o);
						this.isGroupedData = true
					}
					if (k.length == 1 && this.data.x && this.data.x[k[0]]) {
						this.tmpAsciiArray = this.isGroupedData ? this.data.w.factors[k[0]] : this.data.x[k[0]];
						this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray)
					} else {
						if (k.length == 2 && this.data.x && this.data.x[k[0]] && this.data.x[k[1]]) {
							this.tmpAsciiArray = this.isGroupedData ? this.data.w.factors[k[0]] : this.data.x[k[0]];
							this.tmpAsciiArray1 = this.isGroupedData ? this.data.w.factors[k[1]] : this.data.x[k[1]];
							this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
							this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
						} else {
							if (k.length == 3 && this.data.x && this.data.x[k[0]] && this.data.x[k[1]] && this.data.x[k[2]]) {
								this.tmpAsciiArray = this.isGroupedData ? this.data.w.factors[k[0]] : this.data.x[k[0]];
								this.tmpAsciiArray1 = this.isGroupedData ? this.data.w.factors[k[1]] : this.data.x[k[1]];
								this.tmpAsciiArray2 = this.isGroupedData ? this.data.w.factors[k[2]] : this.data.x[k[2]];
								this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
								this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1);
								this.tmpAsciiArrayAscii2 = this.isAsciiArray(this.tmpAsciiArray2)
							}
						}
					}
					this.varSort = -1;
					this.smpSort = k
				} else {
					if (j && o) {
						var f = a ? parseInt(this.getVariableIndices(a[0])) : parseInt(this.getSampleIndices(m[0]));
						this.tmpAsciiArray = this.data.y[j][f];
						this.tmpAsciiArrayAscii = false;
						this.smpSort = [f]
					} else {
						if (a) {
							var d = [];
							for (var f = 0; f < this.varIndices.length; f++) {
								d.push(f)
							}
							if (a.length == 1) {
								this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(a[0] - 1, d, j);
								this.tmpAsciiArrayAscii = false;
								this.smpSort = [a[0] - 1]
							} else {
								if (a.length == 2) {
									this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(a[0] - 1, d, j);
									this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(a[1] - 1, d, j);
									this.tmpAsciiArrayAscii = false;
									this.tmpAsciiArrayAscii1 = false;
									this.smpSort = [a[0] - 1, a[1] - 1]
								} else {
									if (a.length == 3) {
										this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(a[0] - 1, d, j);
										this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(a[1] - 1, d, j);
										this.tmpAsciiArray2 = this.getDataForSmpGrpAtIndex(a[2] - 1, d, j);
										this.tmpAsciiArrayAscii = false;
										this.tmpAsciiArrayAscii1 = false;
										this.tmpAsciiArrayAscii2 = false;
										this.smpSort = [a[0] - 1, a[1] - 1, a[2] - 1]
									}
								}
							}
						} else {
							if (m) {
								if (this.isGroupedData) {
									this.isGroupedData = false;
									this.sortIndices(h, c, k, a, m, j, o);
									this.isGroupedData = true
								}
								var e = this.isGroupedData && this.summaryType == "iqr" ? this.data.w.median : this.isGroupedData ? this.data.w[this.summaryType] : j ? this.data.y[j] : this.data.y.data;
								if (m.length == 1) {
									this.tmpAsciiArray = e[m[0] - 1];
									this.tmpAsciiArrayAscii = false;
									this.smpSort = [m[0] - 1]
								} else {
									if (m.length == 2) {
										this.tmpAsciiArray = e[m[0] - 1];
										this.tmpAsciiArray1 = e[m[1] - 1];
										this.tmpAsciiArrayAscii = false;
										this.tmpAsciiArrayAscii1 = false;
										this.smpSort = [m[0] - 1, m[1] - 1]
									} else {
										if (a.length == 3) {
											this.tmpAsciiArray = e[m[0] - 1];
											this.tmpAsciiArray1 = e[m[1] - 1];
											this.tmpAsciiArray2 = e[m[2] - 1];
											this.tmpAsciiArrayAscii = false;
											this.tmpAsciiArrayAscii1 = false;
											this.tmpAsciiArrayAscii2 = false;
											this.smpSort = [m[0] - 1, m[1] - 1, m[2] - 1]
										}
									}
								}
							} else {
								if (this.isGroupedData) {
									this.isGroupedData = false;
									this.sortIndices(h, c, k, a, m, j, o);
									this.isGroupedData = true
								}
								this.tmpAsciiArray = this.isGroupedData ? this.data.w.smps : h == "vars" ? this.data.y.vars : this.data.y.smps;
								this.tmpAsciiArrayAscii = true;
								if (h == "vars") {
									this.varSort = false
								} else {
									this.smpSort = false
								}
							}
						}
					}
				}
			}
		}
		var l = this.isGroupedData ? this.grpIndices : h == "vars" || h == "onc" ? this.varIndices : this.smpIndices;
		if (this.tmpAsciiArrayAscii) {
			l.sort(function(p, i) {
				return g.sortAsciibetically(p, i)
			})
		} else {
			l.sort(function(p, i) {
				return g.sortNumerically(p, i)
			})
		}
		if (c != "ascending") {
			l.reverse()
		}
		this.tmpAsciiArray = [];
		this.tmpAsciiArray1 = [];
		this.tmpAsciiArray2 = [];
		this.tmpAsciiArrayAscii = false;
		this.tmpAsciiArrayAscii1 = false;
		this.tmpAsciiArrayAscii2 = false;
		if (h == "smps") {
			this.sortingSampleCategories = k
		} else {
			this.sortingVariableCategories = k
		}
		this.sortingSamples = a;
		this.sortingVariables = m;
		if (!n.sort) {
			n.sort = {}
		}
		if (this.isGroupedData && h == "smps") {
			n.sort.grps = l
		} else {
			n.sort[h] = l
		}
	};
	this.isAsciiArray = function(a) {
		for (var b = 0; b < a.length; b++) {
			if (a[b] != null && isNaN(a[b])) {
				return true
			}
		}
		return false
	};
	this.sortAsciibetically = function(d, c) {
		var e = this;
		if (this.tmpAsciiArray[d] == this.tmpAsciiArray[c] && this.tmpAsciiArray1.length > 0) {
			if (this.tmpAsciiArrayAscii1) {
				return e.sortAsciibetically1(d, c)
			} else {
				return e.sortNumerically1(d, c)
			}
		} else {
			return ((this.tmpAsciiArray[d] > this.tmpAsciiArray[c]) ? 1 : (this.tmpAsciiArray[d] < this.tmpAsciiArray[c]) ? -1 : 0)
		}
	};
	this.sortAsciibetically1 = function(d, c) {
		var e = this;
		if (this.tmpAsciiArray1[d] == this.tmpAsciiArray1[c] && this.tmpAsciiArray2.length > 0) {
			if (this.tmpAsciiArrayAscii2) {
				return e.sortAsciibetically2(d, c)
			} else {
				return e.sortNumerically2(d, c)
			}
		} else {
			return ((this.tmpAsciiArray1[d] > this.tmpAsciiArray1[c]) ? 1 : (this.tmpAsciiArray1[d] < this.tmpAsciiArray1[c]) ? -1 : 0)
		}
	};
	this.sortAsciibetically2 = function(d, c) {
		return ((this.tmpAsciiArray2[d] > this.tmpAsciiArray2[c]) ? 1 : (this.tmpAsciiArray2[d] < this.tmpAsciiArray2[c]) ? -1 : 0)
	};
	this.sortNumerically = function(e, d) {
		var f = this;
		var c = Number.MAX_VALUE * -1;
		if ((this.tmpAsciiArray[e] || c) - (this.tmpAsciiArray[d] || c) == 0 && this.tmpAsciiArray1.length > 0) {
			if (this.tmpAsciiArrayAscii1) {
				return f.sortAsciibetically1(e, d)
			} else {
				return f.sortNumerically1(e, d)
			}
		} else {
			return (this.tmpAsciiArray[e] || c) - (this.tmpAsciiArray[d] || c)
		}
	};
	this.sortNumerically1 = function(e, d) {
		var f = this;
		var c = Number.MAX_VALUE * -1;
		if ((this.tmpAsciiArray1[e] || c) - (this.tmpAsciiArray1[d] || c) == 0 && this.tmpAsciiArray2.length > 0) {
			if (this.tmpAsciiArrayAscii2) {
				return f.sortAsciibetically2(e, d)
			} else {
				return f.sortNumerically2(e, d)
			}
		} else {
			return (this.tmpAsciiArray1[e] || c) - (this.tmpAsciiArray1[d] || c)
		}
	};
	this.sortNumerically2 = function(e, d) {
		var c = Number.MAX_VALUE * -1;
		return (this.tmpAsciiArray2[e] || c) - (this.tmpAsciiArray2[d] || c)
	};
	this.sortArray = function(a, b) {
		var d = [];
		if (a.length != b.length) {
			return a
		}
		for (var c = 0; c < a.length; c++) {
			if (a[b[c]]) {
				d[c] = a[b[c]]
			} else {
				return a
			}
		}
		return d
	};
	this.sortObject = function(c) {
		var a = [];
		for (var b in c) {
			a.push(b)
		}
		if (this.isAsciiArray(a)) {
			return a.sort()
		} else {
			return a.sort(function(e, d) {
				return e - d
			})
		}
	};
	this.stringRangeSort = function(d) {
		var c = {};
		var a;
		for (var b = 0; b < d.length; b++) {
			if (d[b].match(/^\d+\-\d+/)) {
				a = d[b].split(/\-/);
				c[b] = Number(a[0])
			} else {
				if (d[b].match(/^\>\d+/)) {
					a = d[b].split(/\>/);
					c[b] = Number(a[1]) + 1e-8
				} else {
					if (d[b].match(/^\<\d+/)) {
						a = d[b].split(/\</);
						c[b] = Number(a[1]) - 1e-8
					} else {
						if (d[b].match(/^\d+/)) {
							a = d[b];
							c[b] = a
						} else {
							return d.sort()
						}
					}
				}
			}
		}
		d.sort(function(f, e) {
			c[f] - c[e]
		});
		return d
	};
	this.radixSort = function(n) {
		var h = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		var e = new Int32Array(n.length);
		var f = [].concat(h);
		var g = [].concat(h);
		var j = [].concat(h);
		var l = [].concat(h);
		var a = 0;
		var i;
		var b = 0;
		var k;
		var c = 0;
		var m;
		var d = 0;
		var o;
		var p;
		for (p = 0; p < n.length; p++) {
			i = n[p] & 255;
			k = (n[p] >> 8) & 255;
			m = (n[p] >> 16) & 255;
			o = (n[p] >> 24) & 255 ^ 128;
			f[i]++;
			g[k]++;
			j[m]++;
			l[o]++
		}
		for (p = 0; p < 256; p++) {
			i = a + f[p];
			k = b + g[p];
			m = c + j[p];
			o = d + l[p];
			f[p] = a;
			g[p] = b;
			j[p] = c;
			l[p] = d;
			a = i;
			b = k;
			c = m;
			d = o
		}
		for (p = 0; p < n.length; p++) {
			i = n[p] & 255;
			e[f[i]] = n[p];
			f[i]++
		}
		for (p = 0; p < n.length; p++) {
			k = (e[p] >> 8) & 255;
			n[g[k]] = e[p];
			g[k]++
		}
		for (p = 0; p < n.length; p++) {
			m = (n[p] >> 16) & 255;
			e[j[m]] = n[p];
			j[m]++
		}
		for (p = 0; p < n.length; p++) {
			o = (e[p] >> 24) & 255 ^ 128;
			n[l[o]] = e[p];
			l[o]++
		}
		return n
	}
};
CanvasXpress.prototype.initMathUtils = function() {
	this.isNaN = function(a) {
		return isNaN(a) ? true : a == Number.POSITIVE_INFINITY ? true : a == Number.NEGATIVE_INFINITY ? true : false
	};
	this.isFinite = function(a) {
		if (this.isArray(a)) {
			for (var b = 0; b < a.length; b++) {
				if (!isFinite(a[b])) {
					return false
				}
			}
			return true
		} else {
			return isFinite(a)
		}
	};
	this.triCube = function(a) {
		return (a = 1 - a * a * a) * a * a
	};
	this.degreesToArcLength = function(b, a) {
		return b * a
	};
	this.radiansToArcLength = function(a, b) {
		return (a * Math.PI * b) / 180
	};
	this.arcLengthToDegrees = function(b, a) {
		return (a * 180) / (b * Math.PI)
	};
	this.arcLengthToRadians = function(b, a) {
		return a / b
	};
	this.radians = function(a) {
		return a * Math.PI / 180
	};
	this.seq = function(e, b, d, a) {
		var c = [];
		if (a || d) {
			if (a) {
				d = (b - e) / (Math.abs(a) - 1)
			} else {
				if (b < e) {
					d = -d
				}
			}
			if (d) {
				while (d > 0 ? b >= e : b <= e) {
					c.push(e);
					e += d
				}
			}
		}
		return c
	};
	this.rnorm = function(h, b, d) {
		var g = this;
		var c = [];
		if (b == null) {
			b = 0
		}
		if (d == null) {
			d = 1
		}
		var f = function() {
			var l, k, j, i;
			var a = 2;
			while (a > 1) {
				j = g.random();
				i = g.random();
				l = 2 * j - 1;
				k = 2 * i - 1;
				a = l * l + k * k
			}
			return (b + Math.sqrt(d) * (Math.sqrt(-2 * Math.log(a) / a) * l))
		};
		for (var e = 0; e < h; e++) {
			c.push(f())
		}
		return c
	};
	this.percentile2 = function(a, f) {
		if (a.length === 0) {
			return 0
		}
		if (typeof f !== "number") {
			throw new TypeError("p must be a number")
		}
		if (f <= 0) {
			return a[0]
		}
		if (f >= 1) {
			return a[a.length - 1]
		}
		var c = a.length * f,
			b = Math.floor(c),
			d = b + 1,
			e = c % 1;
		if (d >= a.length) {
			return a[b]
		}
		return a[b] * (1 - e) + a[d] * e
	};
	this.percentRank = function(a, c) {
		if (typeof c !== "number") {
			throw new TypeError("v must be a number")
		}
		for (var d = 0, b = a.length; d < b; d++) {
			if (c <= a[d]) {
				while (d < b && c === a[d]) {
					d++
				}
				if (d === 0) {
					return 0
				}
				if (c !== a[d - 1]) {
					d += (c - a[d - 1]) / (a[d] - a[d - 1])
				}
				return d / b
			}
		}
		return 1
	};
	this.percentile = function(d, a, e) {
		var b = a - d;
		if (b == 0) {
			return 50
		}
		var c = e - d;
		return c * 100 / b
	};
	this.rank = function(a) {
		var c = [];
		for (var b = 0; b < a.length; b++) {
			c.push(b)
		}
		c.sort(function(e, d) {
			return a[e] - a[d]
		});
		return c
	};
	this.rank2 = function(b) {
		var d = b.slice().sort(function(g, f) {
			return g - f
		});
		var e = b.slice().map(function(f) {
			return d.indexOf(f) + 1
		});
		var c = {};
		e.map(function(f) {
			c[f] = c[f] ? c[f]++ : 1
		});
		var a = e.map(function(f) {
			return f / c[f]
		});
		return a
	};
	this.min = function(b, a, e) {
		if (this.isArray(b)) {
			b = this.cleanArray(b, a, e);
			var d = Number.POSITIVE_INFINITY;
			for (var c = 0; c < b.length; c++) {
				d = Math.min(d, b[c])
			}
			return d
		} else {
			return this.Min(b, a)
		}
	};
	this.max = function(c, b, e) {
		if (this.isArray(c)) {
			c = this.cleanArray(c, b, e);
			var a = Number.NEGATIVE_INFINITY;
			for (var d = 0; d < c.length; d++) {
				a = Math.max(a, c[d])
			}
			return a
		} else {
			return this.Max(c, b)
		}
	};
	this.sum = function(b, a, f, e) {
		b = this.cleanArray(b, a, f);
		var d = 0;
		for (var c = 0; c < b.length; c++) {
			if (e) {
				if (b[c] > 0) {
					d += b[c]
				}
			} else {
				d += b[c]
			}
		}
		return d
	};
	this.sumSquared = function(b, a, f, e) {
		b = this.cleanArray(b, a, f);
		var d = 0;
		for (var c = 0; c < b.length; c++) {
			if (e) {
				if (b[c] > 0) {
					d += b[c] * b[c]
				}
			} else {
				d += b[c] * b[c]
			}
		}
		return d
	};
	this.sumSquaredError = function(b, a, g) {
		b = this.cleanArray(b, a, g);
		var c = this.mean(b);
		var f = 0;
		for (var e = 0; e < b.length; e++) {
			var d = b[e] - c;
			f += d * d
		}
		return f
	};
	this.mean = function(b, a, e) {
		b = this.cleanArray(b, a, e);
		var c = 0;
		var f = 0;
		for (var d = 0; d < b.length; d++) {
			if (!this.isNaN(b[d])) {
				c += Number(b[d]);
				f++
			}
		}
		if (f > 0) {
			c /= f
		}
		return c
	};
	this.range = function(c, b, f) {
		c = this.cleanArray(c, b, f);
		var e = Number.MAX_VALUE;
		var a = Number.MAX_VALUE * -1;
		for (var d = 0; d < c.length; d++) {
			e = Math.min(c[d], e);
			a = Math.max(c[d], a)
		}
		return e == a && e == 0 ? [0, 0.1] : e == a ? [Number(e), Number(a)] : [Number(e), Number(a)]
	};
	this.median = function(b, a, f) {
		b = this.cleanArray(b, a, f);
		var e = [];
		var d = [];
		var g = 0;
		e[0] = Number.NaN;
		e[1] = Number.NaN;
		for (var c = 0; c < b.length; c++) {
			d.push(b[c]);
			g++
		}
		if (g > 0) {
			e[1] = g;
			d.sort(function(i, h) {
				return i - h
			});
			if (g % 2) {
				e[0] = d[parseInt(g / 2)]
			} else {
				e[0] = (d[parseInt((g - 1) / 2)] + d[g / 2]) / 2
			}
		}
		return e
	};
	this.random = function() {
		if (this.pseudoRandom) {
			this.randomSeed = (this.randomSeed * 9301 + 49297) % 233280;
			return this.randomSeed / 233280
		} else {
			return Math.random()
		}
	};
	this.sumarizeErrorData = function(b, a, c) {
		if (this.errorBarsType == "standardErrorMean") {
			return this.meanStandardErrorN(b, a, c)
		} else {
			if (this.errorBarsType == "confidenceInterval95") {
				return this.mean95ConfidenceIntervalN(b, a, c)
			} else {
				return this.meanStandardDeviationN(b, a, c)
			}
		}
	};
	this.meanStandardErrorN = function(b, a, d) {
		var c = this.variance(b, a, d, true);
		if (this.isNaN(c[1])) {
			return [NaN, NaN, NaN]
		}
		return [c[0], Math.sqrt(c[1]) / Math.sqrt(c[2]), c[2]]
	};
	this.mean95ConfidenceIntervalN = function(b, a, d) {
		var c = this.meanStandardErrorN(b, a, d, true);
		if (this.isNaN(c[1])) {
			return [NaN, NaN, NaN]
		}
		return [c[0], c[1] * 1.96, c[2]]
	};
	this.meanStandardDeviationN = function(b, a, d) {
		var c = this.variance(b, a, d, true);
		if (this.isNaN(c[1])) {
			return [NaN, NaN, NaN]
		}
		return [c[0], Math.sqrt(c[1]), c[2]]
	};
	this.quantile = function(b, a) {
		if (a < b[0]) {
			return 0
		} else {
			if (a >= b[0] && a < b[1]) {
				return 1
			} else {
				if (a >= b[1] && a < b[2]) {
					return 2
				} else {
					if (a >= b[2]) {
						return 3
					}
				}
			}
		}
	};
	this.quantiles = function(k, l, f) {
		k = this.cleanArray(k, l, f);
		var o = [];
		var g = [];
		var c = k.length;
// Baohong: calculate quantiles even if there are 2 data points, change "c>2" to "c>1"
		if (c > 1) {
			var p = Math.floor(c * 0.25);
			var j = Math.floor(c * 0.5);
			var b = Math.floor(c * 0.75);
			k.sort(function(n, i) {
				return n - i
			});
			var a;
			var s;
			var q;
			var r = this.mean(k);
			if (c % 2) {
				s = k[j]
			} else {
				s = this.mean([k[j - 1], k[j]])
			}
			if ((c / 2) % 2) {
				a = k[p];
				q = k[b]
			} else {
				a = this.mean([k[p - 1], k[p]]);
				q = this.mean([k[b - 1], k[b]])
			}
			var m = (q - a) * 1.5;
			var e;
			var d;
			for (var h = 0; h <= p; h++) {
				if (k[h] < a - m) {
					g.push(k[h])
				} else {
					e = k[h];
					break
				}
			}
			for (var h = c - 1; h >= b; h--) {
				if (k[h] > q + m) {
					g.push(k[h])
				} else {
					d = k[h];
					break
				}
			}
			o.push(r);
			o.push(a);
			o.push(s);
			o.push(q);
			o.push(e);
			o.push(d);
			o.push(g);
			o.push(c)
		} else {
			if (c > 1) {
				o.push(k[0]);
				o.push(k[0]);
				o.push(k[1]);
				o.push(k[1]);
				o.push(k[0]);
				o.push(k[1]);
				o.push(g);
				o.push(c)
			} else {
				if (c > 0) {
					o.push(k[0]);
					o.push(k[0]);
					o.push(k[0]);
					o.push(k[0]);
					o.push(k[0]);
					o.push(k[0]);
					o.push(g);
					o.push(c)
				} else {
					o.push(NaN);
					o.push(NaN);
					o.push(NaN);
					o.push(NaN);
					o.push(NaN);
					o.push(NaN);
					o.push(NaN)
				}
			}
		}
		return o
	};
	this.quants = function(c, b, e, d) {
		c = this.cleanArray(c, b, e);
		c = c.slice().sort(function(h, g) {
			return h - g
		});
		var f = c.length - 1;
		var a = d || [0.25, 0.5, 0.75];
		return a.map(function(l) {
			if (l === 0) {
				return c[0]
			} else {
				if (l === 1) {
					return c[f]
				} else {
					var i = 1 + l * f;
					var k = Math.floor(i);
					var j = i - k;
					var g = c[k - 1];
					return j === 0 ? g : g + j * (c[k] - g)
				}
			}
		})
	};
	this.medianByQuantile = function(b, a, c) {
		return this.quants(b, a, c, [0.5])
	};
	this.iqr = function(b, a, d) {
		var c = this.quants(b, a, d);
		return c[2] - c[0]
	};
	this.variance = function(e, f, c, a) {
		e = this.cleanArray(e, f, c);
		var b = e.length;
		if (b < 1) {
			return a ? [NaN, NaN, NaN] : NaN
		} else {
			if (b == 1) {
				if (this.standardDeviationType == "unbiased") {
					return a ? [e[0], NaN, 1] : 0
				} else {
					return a ? [e[0], 0, 1] : 0
				}
			} else {
				var j = this.mean(e);
				var h = 0;
				var d = b;
				while (--d >= 0) {
					if (!this.isNaN(e[d])) {
						var g = e[d] - j;
						h += g * g
					}
				}
				if (a) {
					return this.standardDeviationType == "unbiased" ? [j, h / (b - 1), b] : [j, h / b, b]
				} else {
					return this.standardDeviationType == "unbiased" ? h / (b - 1) : h / b
				}
			}
		}
	};
	this.deviation = function(b, a, f) {
		b = this.cleanArray(b, a, f);
		var g = b.length;
		if (g < 1) {
			return [NaN]
		} else {
			if (g == 1) {
				return [0]
			} else {
				var c = this.mean(b);
				var d = [];
				for (var e = 0; e < g; e++) {
					if (!this.isNaN(b[e])) {
						d[e] = b[e] - c
					} else {
						d[e] = NaN
					}
				}
				return d
			}
		}
	};
	this.standardDeviation = function(b, a, d) {
		var c = this.variance(b, a, d);
		if (this.isNaN(c)) {
			return c
		}
		return Math.sqrt(c)
	};
	this.standardError = function(b, a, d) {
		var c = this.variance(b, a, d, true);
		if (this.isNaN(c[1])) {
			return c[1]
		}
		return Math.sqrt(c[1]) / Math.sqrt(c[2])
	};
	this.meanSquaredError = function(b, a, c) {
		b = this.cleanArray(b, a, c);
		return this.sumSquaredError(this.sumSquaredError(b, a, c)) / b.length
	};
	this.confidenceInterval95 = function(c, b, d) {
		var a = this.standardError(c, b, d);
		if (this.isNaN(a)) {
			return a
		}
		return a * 1.96
	};
	this.covariance = function(h, g, e, c) {
		var f = this.cleanArrays(h, g, e, c);
		h = f[0];
		g = f[1];
		var l = 0;
		var a = [];
		var b = 0;
		var k = this.mean(h);
		var j = this.mean(g);
		for (var d = 0; d < h.length; d++) {
			a[d] = (h[d] - k) * (g[d] - j);
			l += a[d];
			b++
		}
		if (b > 0) {
			return l / (this.standardDeviationType == "unbiased" ? b - 1 : b)
		} else {
			return NaN
		}
	};
	this.correlation = function(c, b, a, e, d) {
		if (d && d == "spearman") {
			return this.correlationSpearman(c, b, a, e)
		} else {
			return this.correlationPearson(c, b, a, e)
		}
	};
	this.correlationSpearman = function(m, l, h, f) {
		var k = this.cleanArrays(m, l, h, f);
		m = k[0];
		l = k[1];
		var a = m.length;
		var b = 0;
		var e = this.rank2(m);
		var c = this.rank2(l);
		for (var g = 0; g < m.length; g++) {
			var j = e[g] - c[g];
			b += j * j
		}
		return 1 - (6 * b / (a * (a * a - 1)))
	};
	this.correlationPearson = function(c, b, a, d) {
		return this.covariance(c, b, a, d) / this.standardDeviation(c, a, d) / this.standardDeviation(b, a, d)
	};
	this.regression = function(g, f, h, d, u, A) {
		var l = this;
		var o = function() {
			if (!u) {
				u = l.min(g)
			}
			if (!A) {
				A = l.max(g)
			}
			var n = (A - u) / 10;
			var F = [];
			for (var E = 0; E < 11; E++) {
				F.push(u + (E * n))
			}
			return F
		};
		var v = this.cleanArrays(g, f, h, d);
		g = v[0];
		f = v[1];
		var t = 0;
		var s = 0;
		var r = 0;
		var C = 0;
		var m = 0;
		var x = 0;
		var a = this.covariance(g, f);
		var c = 0;
		var p = 0;
		var k = 0;
		var w = 0;
		var z = 0;
		var e = 0;
		var j = 0;
		var b = o();
		var q = [];
		for (var y = 0; y < g.length; y++) {
			if (!this.isNaN(g[y]) && !this.isNaN(f[y])) {
				s += g[y];
				r += f[y];
				C += g[y] * f[y];
				m += g[y] * g[y];
				x += f[y] * f[y];
				t++
			}
		}
		if (t > 2) {
			p = (t * C - s * r) / (t * m - s * s);
			k = (r - p * s) / t;
			c = (t * t) * a / Math.sqrt(((t * m) - (s * s)) * ((t * x) - (r * r)));
			e = s / t;
			j = this.tinv(0.05, t - 2, true);
			for (var y = 0; y < g.length; y++) {
				if (!this.isNaN(g[y]) && !this.isNaN(f[y])) {
					w += Math.pow(f[y] - ((g[y] * p) + k), 2);
					z += Math.pow(g[y] - e, 2)
				}
			}
			w = Math.sqrt(w / (t - 2));
			for (var y = 0; y < b.length; y++) {
				var D = -j * w * Math.sqrt((1 / t) + Math.pow(b[y] - e, 2) / z);
				var B = p * b[y] + k;
				q.push([b[y], B + D, B - D, D])
			}
		}
		return [p, k, c, q]
	};
	this.confidenceIntervalRegression = function() {};
	this.slope = function(b, d, a, c) {
		return d != c ? (a - b) / (c - d) : 0
	};
	this.intercept = function(a, c, b) {
		return c - (a * b)
	};
	this.slopeIntercept = function(b, e, a, d) {
		var c = this.slope(b, e, a, d);
		return [c, this.intercept(b, e, c)]
	};
	this.normalize = function(f) {
		var e = this.standardDeviationType;
		this.standardDeviationType = "biased";
		for (var c = 0; c < f.length; c++) {
			var a = this.meanStandardDeviationN(f[c]);
			for (var b = 0; b < f[c].length; b++) {
				f[c][b] = (f[c][b] - a[0]) / a[1]
			}
		}
		this.standardDeviationType = e;
		return f
	};
	this.checkLoessCache = function(d) {
		var a = this.meta;
		if (!a.loess) {
			a.loess = []
		}
		for (var e = 0; e < a.loess.length; e++) {
			var b = a.loess[e];
			var f = b.x == d[0] ? 0 : 1;
			f += b.y == d[1] ? 0 : 1;
			f += b.b == this.loessBandwidth ? 0 : 1;
			f += b.i == this.loessIterations ? 0 : 1;
			f += b.a == this.loessAccuracy ? 0 : 1;
			if (f == 0) {
				return b.l
			}
		}
		return false
	};
	this.loess = function(M, G, J) {
		var l = this.checkLoessCache(J);
		if (l) {
			return l
		}
		var F = [];
		var D = [];
		var C = function(V, W, y, U) {
			var T = function(b, X) {
				var x = X + 1;
				while (x < b.length && b[x] === 0) {
					x++
				}
				return x
			};
			var j = U[0];
			var a = U[1];
			var d = T(W, a);
			if ((d < V.length) && (V[d] - V[y]) < (V[y] - V[j])) {
				var k = T(W, j);
				U[0] = k;
				U[1] = d
			}
		};
		M = this.cleanArrays(M[0], M[1]);
		if (M[0].length > 0) {
			var t = this.rank(M[0]);
			for (var L = 0; L < t.length; L++) {
				F.push(M[0][t[L]]);
				D.push(M[1][t[L]])
			}
			if (M[0].length < 2) {
				return [F, D]
			}
			if (!G) {
				G = [];
				for (var L = 0; L < F.length; L++) {
					G.push(1)
				}
			}
			var H = Math.floor(this.loessBandwidth * M[0].length);
			if (H < 2) {
				alert("Bandwidth for loess fitting too small!");
				return false
			} else {
				var m = [];
				var v = [];
				var N = [];
				for (var L = 0; L < F.length; L++) {
					m[L] = 0;
					v[L] = 0;
					N[L] = 1
				}
				var q = 0;
				while (q <= this.loessIterations) {
					var O = [0, H - 1];
					for (var L = 0; L < F.length; L++) {
						if (L > 0) {
							C(F, G, L, O)
						}
						var A = O[0];
						var r = O[1];
						var Q = (F[L] - F[A]) > (F[r] - F[L]) ? A : r;
						var g = 0;
						var u = 0;
						var n = 0;
						var s = 0;
						var c = 0;
						var S = Math.abs(1 / (F[Q] - F[L]));
						for (var K = A; K <= r; ++K) {
							var f = K < L ? F[L] - F[K] : F[K] - F[L];
							var R = this.triCube(f * S) * N[K] * G[K];
							var z = F[K] * R;
							g += R;
							u += z;
							n += F[K] * z;
							s += D[K] * R;
							c += D[K] * z
						}
						var p = u / g;
						var o = s / g;
						var E = c / g;
						var e = n / g;
						var B = (Math.sqrt(Math.abs(e - p * p)) < this.loessAccuracy) ? 0 : ((E - p * o) / (e - p * p));
						var I = o - B * p;
						m[L] = B * F[L] + I;
						v[L] = Math.abs(D[L] - m[L])
					}
					if (q === this.loessIterations) {
						break
					}
					var h = this.medianByQuantile(v);
					if (Math.abs(h) < this.loessAccuracy) {
						break
					}
					for (var L = 0; L < F.length; L++) {
						var P = v[L] / (6 * h);
						N[L] = P >= 1 ? 0 : Math.pow(1 - P * P, 2)
					}
					q++
				}
				this.meta.loess.push({
					x: J[0],
					y: J[1],
					b: this.loessBandwidth,
					i: this.loessIterations,
					a: this.loessAccuracy,
					l: [F, m]
				});
				return [F, m]
			}
		} else {
			alert("Not valid array for loess fitting!");
			return false
		}
	};
	this.errorEllipse = function(a, c, b) {
		if (b) {
			return this.errorEllipse3D(a, c, b)
		} else {
			return this.errorEllipse2D(a, c)
		}
	};
	this.errorEllipse2D = function(k, g) {
		var i = this.variance(k, false, false, true);
		var h = this.variance(g, false, false, true);
		var j = this.covariance(k, g);
		var m = [
			[i[1], j],
			[j, h[1]]
		];
		var n = numeric.eig(m);
		var l = Math.sqrt(2 * this.gammaPinv(this.errorEllipseConfidence, 1));
		var f = n.lambda.x[0] > n.lambda.x[1] ? 0 : 1;
		var e = n.lambda.x[0] < n.lambda.x[1] ? 0 : 1;
		var b = i[1] > h[1] ? Math.sqrt(n.lambda.x[f]) * l : Math.sqrt(n.lambda.x[e]) * l;
		var a = h[1] > i[1] ? Math.sqrt(n.lambda.x[f]) * l : Math.sqrt(n.lambda.x[e]) * l;
		var c = Math.atan2(n.E.x[f][1], n.E.x[f][0]);
		if (c < 0) {
			c += Math.PI / 2
		}
		var d = {
			rx: b,
			ry: a,
			cx: i[0],
			cy: h[0],
			rot: c
		};
		return d
	};
	this.errorEllipse3D = function(m, l, j) {
		var p = this.variance(m, false, false, true);
		var o = this.variance(l, false, false, true);
		var n = this.variance(j, false, false, true);
		var c = this.covariance(m, l);
		var b = this.covariance(m, j);
		var i = this.covariance(l, j);
		var t = [
			[p[1], c, b],
			[c, o[1], i],
			[b, i, n[1]]
		];
		var k = numeric.eig(t);
		var a = Math.sqrt(2 * this.gammaPinv(this.errorEllipseConfidence, 1));
		var f = this.rank(k.lambda.x);
		var s = f[2];
		var q = f[1];
		var r = f[0];
		var h = Math.sqrt(k.lambda.x[s]) * a;
		var e = Math.sqrt(k.lambda.x[q]) * a;
		var d = Math.sqrt(k.lambda.x[r]) * a;
		var w = Math.atan2(k.E.x[2][s] * -1, k.E.x[1][s] * -1);
		var v = Math.atan2(k.E.x[2][s] * -1, k.E.x[0][s] * -1);
		var u = Math.atan2(k.E.x[1][s] * -1, k.E.x[0][s] * -1);
		if (w < 0) {}
		if (v < 0) {
			v += Math.PI / 2
		}
		if (u < 0) {}
		var g = {
			rx: [h],
			ry: [e],
			rz: [d],
			cx: p[0],
			cy: o[0],
			cz: n[0],
			rot: [w, v, u]
		};
		return g
	};
	this.epanechnikovKernel = function(a) {
		return function(b) {
			return Math.abs(b /= a) <= 1 ? 0.75 * (1 - b * b) / a : 0
		}
	};
	this.uniformKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b / a >= -1) {
				return 0.5
			}
			return 0
		}
	};
	this.triangularKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b / a >= -1) {
				return 1 - Math.abs(b / a)
			}
			return 0
		}
	};
	this.quarticKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b / a >= -1) {
				var c = (1 - b * b) / a;
				return (15 / 16) * c * c
			}
			return 0
		}
	};
	this.triweightKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b / a >= -1) {
				var c = (1 - b * b) / a;
				return (35 / 32) * c * c * c
			}
			return 0
		}
	};
	this.gaussianKernel = function(a) {
		return function(b) {
			return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * b * b / a)
		}
	};
	this.cosineKernel = function(a) {
		return function(b) {
			if (b / a <= 1 && b >= -1 / a) {
				return Math.PI / 4 * Math.cos((Math.PI / 2 * b) / a)
			}
			return 0
		}
	};
	this.getBandwidthEstimate = function(e, a) {
		var b = Math.sqrt(this.variance(e));
		var f = this.iqr(e) / 1.34;
		var d = Math.pow(e.length, -0.2);
		var c = Math.min(b, f);
		return !a ? 1.06 * c * d : 0.9 * c * d
	};
	this.kernelDensityEstimator = function(d, b) {
		var c = function(e) {
			return null != e && !this.isNaN(e)
		};
		var a = function(j, l) {
			var k, g = j.length,
				h = 0,
				m = -1,
				f = 0;
			for (; ++m < g;) {
				c(k = l.call(j, j[m], m)) && (h += (k - h) / ++f)
			}
			return f ? h : void 0
		};
		return function(e) {
			return b.map(function(f) {
				return [f, a(e, function(g) {
					return d(f - g)
				})]
			})
		}
	};
	this.kde = function(d, b, f, h, e) {
		var g = f[0];
		var c = f[1];
		var i = [];
		for (var j = g; j <= c; j += h) {
			i.push(j)
		}
		if (!b) {
			b = this.getBandwidthEstimate(e)
		}
		var a = this.kernelDensityEstimator(this[d](b), i);
		return a(e)
	};
	this.freedmanDiaconis = function(b, a, c) {
		if (b && b.length > 1) {
			b = this.cleanArray(b, a, c);
			var d = this.iqr(b);
			return d == 0 ? 1 : this.pretty(2 * d * Math.pow(b.length, -1 / 3))
		} else {
			if (b && b.length == 1) {
				return Number(b[0])
			} else {
				return 1
			}
		}
	};
	this.pretty = function(a) {
		var c = Math.pow(10, Math.floor(Math.log(a / 10) / Math.LN10));
		var b = 10 / a * c;
		if (b <= 0.15) {
			c *= 10
		} else {
			if (b <= 0.35) {
				c *= 5
			} else {
				if (b <= 0.75) {
					c *= 2
				}
			}
		}
		return c * 10
	};
	this.getHistogramBin = function(c, a) {
		var d = a * Math.floor(c / a);
		return parseFloat(d.toFixed(this.getAxisDecimals(a)))
	};
	this.toFixed = function(h, b) {
		var e = b || 0;
		var d = g < 0;
		var a = Math.pow(10, e);
		var g = Math.round(h * a);
		var c = String((d ? Math.ceil : Math.floor)(g / a));
		var i = String((d ? -g : g) % a);
		var f = new Array(Math.max(e - i.length, 0) + 1).join("0");
		return e ? c + "." + f + i : c
	};
	this.bezierCalculatePoints = function(g, e) {
		var b = g[0][0];
		var a = g[0][1];
		var d = g[1][0];
		var c = g[1][1];
		var h = b + (d - b) * e;
		var f = a + (c - a) * e;
		return [h, f]
	};
	this.deCasteljau = function(e, d) {
		if (d === 1) {
			return e[e.length - 1]
		}
		if (d === 0) {
			return e[0]
		}
		if (e.length == 1) {
			return e[0]
		}
		var b = [];
		for (var c = 1, a = e.length; c < a; c++) {
			b.push(this.bezierCalculatePoints([e[c - 1], e[c]], d))
		}
		return this.deCasteljau(b, d)
	};
	this.divideBezierCurve = function(f, e, c, g) {
		c = c || [];
		g = g || [];
		c.push(f[0]);
		g.push(f[f.length - 1]);
		if (f.length === 1) {
			return [c, g]
		}
		var b = [];
		for (var d = 1, a = f.length; d < a; d++) {
			b.push(this.bezierCalculatePoints([f[d - 1], f[d]], e))
		}
		return this.divideBezierCurve(b, e, c, g)
	}
};
CanvasXpress.prototype.initLayout = function() {
	this.isValidLayout = function() {
		var a = this.layout.split(/X/i);
		var f = this.meta.config.orig;
		f.adjustAspectRatio = this.adjustAspectRatio;
		this.adjustAspectRatio = true;
		if (a.length == 2) {
			this.layoutRows = a[0];
			this.layoutCols = a[1]
		} else {
			this.layoutRows = 1;
			this.layoutCols = 1;
			this.layoutValid = false
		}
		if (!this.graphType.match(/Scatter/) && this.layoutComb && this.data.l && (this.data.l.vars || this.data.l.smps) && this.data.l.weight && this.data.l.type) {
			this.data.l.comp = [];
			if (this.data.l.vars && this.data.l.smps) {
				var g = 0;
				for (var d = 0; d < this.data.l.smps.length; d++) {
					for (var b = 0; b < this.data.l.vars.length; b++) {
						this.data.l.comp[g] = [this.getVariableIndices(this.data.l.vars[b]), this.getSampleIndices(this.data.l.smps[d])];
						g++
					}
				}
			} else {
				if (this.data.l.vars) {
					for (var d = 0; d < this.data.l.vars.length; d++) {
						this.data.l.comp[d] = this.getVariableIndices(this.data.l.vars[d])
					}
				} else {
					for (var d = 0; d < this.data.l.smps.length; d++) {
						this.data.l.comp[d] = this.getSampleIndices(this.data.l.smps[d])
					}
				}
			}
			this.layoutValid = true
		} else {
			if (this.layoutComb && this.data.l && this.data.l.smps && this.data.l.weight && this.data.l.type) {
				this.data.l.comp = [];
				var e = this.getVariableIndices(this.data.y.vars);
				for (var d = 0; d < this.data.l.type.length; d++) {
					this.data.l.comp[d] = e
				}
				this.layoutValid = true
			} else {
				if (this.data.l && this.data.l.comp) {
					if (this.data.l.comp.length <= (this.layoutRows * this.layoutCols)) {
						this.layoutValid = true
					} else {
						this.layoutValid = false
					}
				} else {
					this.layoutValid = false
				}
			}
		}
	};
	this.addLayoutResizer = function(b) {
		var a = 0;
		if (this.resizerType && this.resizerPosition == b) {
			a += this.resizerWidth + (this.margin * 2);
			if (this.resizerType == "samples") {
				a += 14 + this.margin
			}
		}
		return a
	};
	this.getLayoutResizerDimensions = function() {
		if (this.resizerType) {
			var u, j, e, d;
			var f = this.data.l.comp.length - 1;
			var k = this.resizerWidth;
			var z = this.resizerWidth;
			var B = this.marginTop + this.layoutTop;
			var c = this.marginRight + this.layoutRight;
			var q = this.marginBottom + this.layoutBottom;
			var g = this.marginLeft + this.layoutLeft;
			var A = this.getAxesVals(0);
			var s = 0;
			var m = 0;
			switch (this.resizerPosition) {
				case "right":
					u = "xAxis";
					j = "y";
					e = "v";
					d = "r";
					B += this.layoutParams[0].top;
					g = this.resizerType == "samples" ? this.width - ((this.margin * 2) + this.resizerWidth + 14) : this.width - (this.margin + this.resizerWidth);
					k = this.height - (B + q + this.layoutParams[f].bottom);
					break;
				case "left":
					u = "xAxis";
					j = "y";
					e = "v";
					d = "l";
					B += this.layoutParams[0].top;
					g = this.resizerType == "samples" && this.graphOrientation == "horizontal" ? (this.margin * 2) : this.margin;
					k = this.height - (B + q + this.layoutParams[f].bottom);
					break;
				case "top":
					u = "xAxis";
					j = "x";
					e = "h";
					d = "t";
					B = this.resizerType == "samples" ? (this.margin * 2) + 14 : this.margin;
					g += this.layoutParams[0].left;
					z = this.width - (g + c + this.layoutParams[f].right);
					m += this.resizerWidth;
					break;
				case "bottom":
					u = "xAxis";
					j = "x";
					e = "h";
					d = "b";
					B = this.resizerType == "samples" && this.graphOrientation == "vertical" ? this.height - ((this.margin * 2) + this.resizerWidth + 14) : this.width - (this.margin + this.resizerWidth);
					g += this.layoutParams[0].left;
					z = this.width - (g + c + this.layoutParams[f].right);
					m += this.resizerWidth;
					break
			}
			if (e == "v") {
				return ([u, g + s, g + s + z, B + m, B + m + k, j, e, d, A, g + 14, B, z, k])
			} else {
				return ([u, g + s, g + s + z, B + m, B + m + k, j, e, d, A, g, B, z, k])
			}
		}
	};
	this.drawLayoutResizer = function() {
		if (this.resizerType) {
			var a = this.getLayoutResizerDimensions();
			this.showAxesResizer(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], "", 0, 0, 0);
			this.drawAxesResizerBackgroundData(a[9], a[10], a[11], a[12]);
			this.drawAxesResizerMasks()
		}
	};
	this.setLayoutFonts = function() {
		this.setLegends();
		if (this.graphType == "Scatter2D") {
			this.set2DFont()
		} else {
			if (this.graphType == "Pie") {
				this.setPieFont()
			} else {
				this.set1DFont()
			}
		}
	};
	this.getLayoutAxisTitleHeight = function(a) {
		var b = 0;
		if (this.graphType == "Treemap" || this.graphType == "TagCloud" || this.graphType == "Pie" || this.graphType == "Heatmap") {
			return 0
		} else {
			if (this.graphType == "Scatter2D") {
				if (a) {
					return this.yAxisTitle ? this.axisTitleFontSize + (this.margin * 2) : 0
				} else {
					return this.xAxisTitle ? this.axisTitleFontSize + (this.margin * 2) : 0
				}
			} else {
				if (this.graphOrientation == "vertical") {
					b = a ? this.getAxisDescription(true) : this.getAxisDescription();
					b = b != "" ? this.axisTitleFontSize + (this.margin * 2) : 0
				} else {
					b = a ? this.getAxisDescription(true) : this.getAxisDescription();
					b = b != "" ? this.axisTitleFontSize + (this.margin * 2) : 0
				}
			}
		}
		return b
	};
	this.setLayoutLeft = function() {
		var a = 0;
		if (this.isDOE) {
			a = 0
		} else {
			if (this.graphType == "Scatter2D") {
				if (!this.layoutAdjust) {
					a = this.get2DYAxisWidth()
				}
				a += this.getLayoutAxisTitleHeight()
			} else {
				if (this.graphType == "Pie") {
					a = (this.margin * 2) + this.measureText("XX", this.smpLabelFont)
				} else {
					if (this.graphType == "Candlestick") {
						if (this.graphOrientation != "vertical") {
							this.setTimeAxis();
							a = this.getSampleLabelLength()
						} else {
							a = 0
						}
					} else {
						if (this.graphType == "Heatmap") {
							a = 0
						} else {
							if (!this.layoutAdjust) {
								if (this.segregateVariablesBy.length > 0) {
									if (this.graphOrientation != "vertical") {
										a = this.getSampleLabelLength()
									} else {
										a = this.getAxisTitleTickLength()
									}
								} else {
									if (this.segregateSamplesBy.length > 0) {
										if (this.graphOrientation == "vertical") {
											a = this.getAxisTitleTickLength()
										}
									}
								}
							} else {
								if (this.graphOrientation != "vertical" && this.segregateVariablesBy.length > 0) {
									a = this.getSampleLabelLength()
								}
							}
							if (this.graphOrientation == "vertical") {
								a += this.getLayoutAxisTitleHeight()
							} else {
								a += this.smpTitle ? this.smpTitleFontSize + (this.margin * 2) : 0
							}
						}
					}
				}
			}
		}
		return a + this.addLayoutResizer("left")
	};
	this.setLayoutRight = function() {
		var a = 0;
		if (this.isDOE) {
			a = 0
		} else {
			if (this.graphType.match(/Scatter/)) {
				if (this.showLegend) {
					a = this.legendWidth;
					if (!this.layoutAdjust) {
						a += this.get2DYAxisWidth(true)
					}
				}
			} else {
				if (this.graphType == "Pie") {
					if (this.showLegend && this.legendPosition == "right") {
						a = this.legendVariableWidth
					}
				} else {
					if (this.graphType == "Heatmap") {
						return 0
					} else {
						if (!this.layoutAdjust) {
							if (this.graphOrientation == "vertical") {
								a = this.getAxisTitleTickLength(true)
							}
						} else {
							a = 0
						}
						if (this.graphOrientation == "vertical") {
							a += this.getLayoutAxisTitleHeight(true)
						}
						if (this.showLegend && this.legendPosition == "right") {
							a += this.getLegendWidth();
							if (this.graphOrientation != "vertical") {
								a += this.margin
							}
						}
					}
				}
			}
		}
		return a + this.addLayoutResizer("right")
	};
	this.setLayoutTop = function() {
		if (this.isDOE) {
			return 0
		}
		var a = this.getTitleSubtitleHeight();
		if (this.graphType == "Pie") {
			a += this.getFontHeight() + (this.margin * 2)
		} else {
			if (this.graphType == "Scatter2D") {
				if (!this.layoutAdjust) {
					a += this.get2DXAxisHeight(true)
				}
			} else {
				if (this.graphType != "Heatmap") {
					if (!this.layoutAdjust) {
						if (this.graphOrientation != "vertical") {
							a += this.getAxisTitleTickLength()
						}
					}
					if (this.graphOrientation != "vertical") {
						a += this.getLayoutAxisTitleHeight()
					}
				}
			}
		}
		return a + this.addLayoutResizer("top")
	};
	this.setLayoutBottom = function() {
		var a = 0;
		if (this.isDOE) {
			a = 0
		} else {
			if (this.graphType == "Scatter2D") {
				if (!this.layoutAdjust) {
					a = this.get2DXAxisHeight()
				}
				if (this.showLegend && this.legendPosition == "bottom") {
					a += this.legendHeight
				}
				a += this.getLayoutAxisTitleHeight()
			} else {
				if (this.graphType == "Pie") {
					if (this.showLegend && this.legendPosition == "bottom") {
						var c = this.getPieLegendDimensions();
						a = c[1]
					}
				} else {
					if (this.graphType == "Candlestick" && this.graphOrientation == "vertical") {
						this.setTimeAxis();
						a = this.getSampleLabelLength()
					} else {
						if (this.graphType == "Heatmap") {
							a = this.getHeatmapIndicatorHeight()
						} else {
							if (!this.layoutAdjust) {
								if (this.graphOrientation != "vertical") {
									a = this.getAxisTitleTickLength(true)
								}
							}
							if (this.graphOrientation == "vertical") {
								if (this.segregateVariablesBy.length > 0) {
									a = this.getSampleLabelLength()
								}
								a += this.smpTitle ? this.smpTitleFontSize + (this.margin * 2) : 0
							} else {
								a += this.getLayoutAxisTitleHeight(true)
							}
							if (this.showLegend && this.legendPosition == "bottom") {
								a += this.getLegendHeight()
							}
						}
					}
				}
			}
		}
		return a + this.addLayoutResizer("bottom")
	};
	this.drawLayoutSampleOverlays = function(b) {
		var a = this.smpIndices;
		this.smpIndices = b;
		this.smpIndices = a;
		this.showSampleNames = true;
		this.showOverlays = true;
		this.draw1DYLayout()
	};
	this.setLayoutDimensions = function() {
		var a = this.isGroupedData;
		this.offsetX = 0;
		this.offsetY = 0;
		this.isGroupedData = false;
		this.setLayoutFonts();
		this.setLayoutLegendDimensions();
		this.isGroupedData = a;
		this.layoutLeft = this.setLayoutLeft();
		this.layoutRight = this.setLayoutRight();
		this.layoutTop = this.setLayoutTop();
		this.layoutBottom = this.setLayoutBottom();
		if (this.layoutCanvasCompartments) {
			this.rectangle(this.marginLeft + this.layoutLeft, this.marginTop + this.layoutTop, this.width - (this.marginLeft + this.layoutLeft + this.marginRight + this.layoutRight), this.height - (this.marginTop + this.layoutTop + this.marginBottom + this.layoutBottom), false, this.canvasBoxColor, "open")
		}
	};
	this.setLayoutLegendDimensions = function() {
		if (this.graphType == "Pie" || this.isDOE) {
			this.setVariableLegendDimension()
		} else {
			if (this.graphType == "Scatter2D" || this.isMultidimensionalData || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|Heatmap/))) {
				this.validatePropertyValues(true)
			} else {
				this.setVariableLegendDimension()
			}
		}
	};
	this.drawLabelsTitlesLayout = function() {
		var g = 0;
		var f = 0;
		var p = 0;
		var A = 0;
		var B = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
		var b = this.height - (this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom);
		if (this.resizerType) {
			if (this.resizerPosition == "top") {
				f = this.resizerType == "samples" ? (this.margin * 2) + this.resizerWidth + 14 : this.margin + this.resizerWidth;
				A = f
			} else {
				if (this.resizerPosition == "left") {
					g = this.resizerType == "samples" ? (this.margin * 2) + this.resizerWidth + 14 : this.margin + this.resizerWidth;
					p = g
				}
			}
		}
		if (this.graphType == "Pie" && (this.showPieGrid || this.showPieSampleLabel)) {
			var v, m;
			var z = 0;
			this.setFont();
			var q = this.getFontPt(this.font);
			var d = this.marginTop + this.layoutTop;
			var a = this.marginLeft + this.layoutLeft;
			var n = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
			for (var u = 0; u < this.layoutRows; u++) {
				v = b * this.layoutParams[z].weight[1];
				g = (this.marginLeft + this.layoutLeft) - this.margin;
				d += v;
				if (this.showPieGrid) {
					this.drawText(n[u], g, (d + (q / 2)) - (v / 2), this.font, this.foreground, "right", "middle")
				}
				for (var t = 0; t < this.layoutCols; t++) {
					if (this.xAxis.length <= z) {
						break
					}
					m = B * this.layoutParams[z].weight[0];
					a += m;
					f = (this.marginTop + this.layoutTop) - this.margin;
					if (u == 0) {
						if (this.showPieGrid) {
							this.drawText(t + 1, (a + (q / 2)) - (m / 2), f, this.font, this.foreground, "center", "bottom")
						}
					}
					if (this.showPieSampleLabel) {
						this.drawText(this.xAxis[z], a - (m / 1.1), d - (v / 5), this.legendFont, this.foreground, "center", "middle")
					}
					z++
				}
				a = this.marginLeft + this.layoutLeft
			}
		} else {
			if (this.graphType == "Scatter2D") {
				if (this.xAxisTitle) {
					this.drawText(this.xAxisTitle, this.marginLeft + this.margin + (this.axisTitleFontSize / 2), this.height / 2, this.axisTitleFont, this.axisTitleFontColor, "center", "middle", -Math.PI / 2)
				}
				if (this.yAxisTitle) {
					var s = this.legendPosition == "bottom" ? this.getLegendHeight() : 0;
					var m = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
					var v = this.marginBottom + this.margin + (this.axisTitleFontSize / 2) + s;
					this.drawText(this.yAxisTitle, this.marginLeft + this.layoutLeft + (m / 2), this.height - v, this.axisTitleFont, this.axisTitleFontColor, "center", "middle")
				}
			} else {
				if (this.graphType == "Heatmap") {
					this.draw1DXLayout()
				}
				if (this.smpTitle && this.graphType != "Heatmap") {
					if (this.graphOrientation == "vertical") {
						var s = this.legendPosition == "bottom" ? this.getLegendHeight() : 0;
						var m = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
						var v = this.marginBottom + this.margin + (this.smpTitleFontSize / 2) + s;
						this.drawText(this.smpTitle, this.marginLeft + this.layoutLeft + (m / 2), this.height - v, this.smpTitleFont, this.smpTitleFontColor, "center", "middle")
					} else {
						this.drawText(this.smpTitle, this.marginLeft + this.margin + (this.smpTitleFontSize / 2), this.height / 2, this.smpTitleFont, this.smpTitleFontColor, "center", "middle", -Math.PI / 2)
					}
				}
				var k = this.getAxisDescription();
				var e = this.getAxisDescription(true);
				if (k != "" && this.graphType != "Heatmap" && this.xAxisShow) {
					if (this.graphOrientation == "vertical") {
						this.drawText(k, this.marginLeft + this.margin + (this.axisTitleFontSize / 2), this.height / 2, this.axisTitleFont, this.axisTitleFontColor, "center", "middle", -Math.PI / 2)
					} else {
						var m = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
						var v = this.margin + (this.axisTitleFontSize / 2) + this.getTitleSubtitleHeight();
						this.drawText(k, this.marginLeft + this.layoutLeft + (m / 2), this.marginTop + v, this.axisTitleFont, this.axisTitleFontColor, "center", "middle")
					}
				}
				if (e != "" && this.graphType != "Heatmap" && this.xAxis2Show) {
					if (this.graphOrientation == "vertical") {
						var s = this.legendPosition == "right" ? this.getLegendWidth() : 0;
						var o = this.marginRight + this.margin + (this.axisTitleFontSize / 2) + s;
						this.drawText(e, this.width - o, this.height / 2, this.axisTitleFont, this.axisTitleFontColor, "center", "middle", Math.PI / 2)
					} else {
						var s = this.legendPosition == "bottom" ? this.getLegendHeight() : 0;
						var m = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
						var v = this.marginBottom + this.margin + (this.axisTitleFontSize / 2) + s;
						this.drawText(e, this.marginLeft + this.layoutLeft + (m / 2), this.height - v, this.axisTitleFont, this.axisTitleFontColor, "center", "middle")
					}
				}
			}
		}
	};
	this.drawDOELabelsLayout = function(m) {
		var g = this.foreground;
		var j = this.font;
		var e = this.measureText(m, j);
		var b = this.getFontPt(j) / 2;
		var l = this.layoutWidth;
		var d = this.layoutHeight;
		var k = this.marginLeft + this.offsetX;
		var i = this.marginTop + this.offsetY;
		var a = k + l - 5;
		var c = i + d - 5;
		this.drawText(m, k + 20, i, j, g, "left", "top");
		this.drawLine("line", k + b, i + b, k + 15, i + b, g);
		this.drawLine("line", k + e + 25, i + b, a, i + b, g);
		this.drawLine("line", a, i + b, a, c, g);
		this.drawLine("line", k + b, c, a, c, g);
		this.drawLine("line", k + b, i + b, k + b, c, g)
	};
	this.setLayoutWeights = function() {
		var a = this.data.l.weight;
		var d = this.layoutParams;
		var e = this.data.l.comp;
		if (a) {
			if (this.isDOE || this.scatterPlotMatrix || (this.data.l.vars && this.data.l.smps) || this.segregateSamplesBy.length > 1 || this.segregateVariablesBy.length > 1) {
				for (var b = 0; b < a.length; b++) {
					d[b].weight = a[b]
				}
			} else {
				if (this.graphType == "Pie") {
					for (var b = 0; b < e.length; b++) {
						d[b].weight = a[b]
					}
				} else {
					for (var b = 0; b < a.length; b++) {
						d[b].weight = a[b]
					}
				}
			}
		} else {
			if (e) {
				a = [];
				for (var b = 0; b < e.length; b++) {
					a[b] = e.length;
					d[b].weight = a[b]
				}
			} else {
				alert("Wuz going on dude? This aint't gonna work!")
			}
		}
	};
	this.setLayoutGraphTypes = function() {
		var b = this.data.l.type;
		if (b) {
			for (var a = 0; a < b.length; a++) {
				this.layoutParams[a].graphType = b && b[a] ? b[a] : this.graphType
			}
		}
	};
	this.setLayoutIndices = function(f) {
		if (!this.layoutIndices) {
			if (this.is1DPlotting) {
				for (var d = 0; d < this.data.l.comp.length; d++) {
					var a;
					var b = this.getObjectArray(this.varIndices);
					var e = this.getObjectArray(this.smpIndices);
					if (this.data.l.vars && this.data.l.smps) {
						a = [];
						for (var c = 0; c < this.data.l.comp[d][0].length; c++) {
							if (b.hasOwnProperty(this.data.l.comp[d][0][c])) {
								a.push(this.data.l.comp[d][0][c])
							}
						}
						this.layoutParams[d].varIndices = a;
						a = [];
						for (var c = 0; c < this.data.l.comp[d][1].length; c++) {
							if (e.hasOwnProperty(this.data.l.comp[d][1][c])) {
								a.push(this.data.l.comp[d][1][c])
							}
						}
						this.layoutParams[d].smpIndices = a;
						this.setOriginalIndices(d, this.layoutParams[d].varIndices, this.layoutParams[d].smpIndices)
					} else {
						if (this.data.l.comp[d]) {
							a = [];
							if (this.data.l.vars) {
								for (var c = 0; c < this.data.l.comp[d].length; c++) {
									if (b.hasOwnProperty(this.data.l.comp[d][c])) {
										a.push(this.data.l.comp[d][c])
									}
								}
								this.layoutParams[d].varIndices = a;
								this.layoutParams[d].smpIndices = this.smpIndices;
								this.setOriginalIndices(d, this.layoutParams[d].varIndices, this.smpIndices)
							} else {
								for (var c = 0; c < this.data.l.comp[d].length; c++) {
									if (e.hasOwnProperty(this.data.l.comp[d][c])) {
										a.push(this.data.l.comp[d][c])
									}
								}
								this.layoutParams[d].varIndices = this.varIndices;
								this.layoutParams[d].smpIndices = a;
								this.setOriginalIndices(d, this.varIndices, this.layoutParams[d].smpIndices)
							}
						} else {
							if (this.data.l.vars) {
								this.layoutParams[d].varIndices = [];
								this.layoutParams[d].smpIndices = this.smpIndices
							} else {
								this.layoutParams[d].varIndices = this.varIndices;
								this.layoutParams[d].smpIndices = []
							}
						}
					}
					this.layoutParams[d].varIndicesStart = -1;
					this.layoutParams[d].smpIndicesStart = -1
				}
			}
			for (var d = 0; d < this.data.l.type.length; d++) {
				for (var c = 0; c < f.length; c++) {
					if (!this.layoutParams[d].hasOwnProperty(f[c])) {
						this.layoutParams[d][f[c]] = this[f[c]]
					}
				}
			}
			this.layoutIndices = true
		}
	};
	this.resetLayout = function() {
		delete(this.data.l);
		delete(this.layoutParams);
		this.offsetX = 0;
		this.offsetY = 0;
		this.layoutValidN = false;
		this.layoutValidR = false;
		this.layoutValidC = false;
		this.layoutCurrent = false;
		this.layoutComb = false;
		this.layoutIndices = false;
		this.layoutRestore = false;
		this.layout = "1X1";
		var a = this.meta.config.orig;
		this.adjustAspectRatio = a.adjustAspectRatio;
		delete(a.adjustAspectRatio)
	};
	this.setDOE = function() {
		this.oneDPlot(true);
		this.Scatter2D(true);
		this.Scatter3D(true);
		this.Pie(true)
	};
	this.setLayoutRestore = function() {
		if (!this.layoutRestore) {
			this.layoutRestore = {};
			var c = ["title", "subtitle", "varIndices", "smpIndices", "grpIndices", "varIndicesStart", "smpIndicesStart", "smpTitle", "showVariableNames", "showSampleNames", "showOverlays", "showLegend", "legendInside", "showDecorationsLegend", "xAxisShow", "xAxis2Show", "xAxisS2Show", "yAxisShow", "yAxisS2Show", "xAxisTitle", "xAxis2Title", "yAxisTitle", "legendLayout"];
			c.push("legendDecorationWidth");
			c.push("legendDecorationHeight");
			var a = ["Color", "Shape", "Size", "Pattern", "Variable", "Sample"];
			for (var b = 0; b < a.length; b++) {
				c.push("legend" + a[b] + "s");
				c.push("legend" + a[b] + "Width");
				c.push("legend" + a[b] + "Height")
			}
			for (var b = 0; b < c.length; b++) {
				this.layoutRestore[c[b]] = this[c[b]]
			}
			if (this.isGroupedData && this.data.w) {
				this.layoutRestore.isGroupedData = this.isGroupedData
			}
		}
	};
	this.setLayoutParams = function() {
		if (!this.layoutParams && this.data.l.comp) {
			this.layoutParams = [];
			for (var a = 0; a < this.data.l.type.length; a++) {
				this.layoutParams[a] = {}
			}
		}
	};
	this.removeEmptyCompartments = function() {
		if (this.layoutRemoveEmpty && this.layoutParams && !this.isDOE) {
			var f = {};
			var d = [];
			var g = ["comp", "desc", "name", "type", "vars", "smps", "weight"];
			var h = 0;
			for (var c = 0; c < g.length; c++) {
				if (this.data.l[g[c]]) {
					f[g[c]] = []
				}
			}
			for (var c = 0; c < this.data.l.weight.length; c++) {
				var b = this.layoutParams[c].varIndices.length;
				var e = this.layoutParams[c].smpIndices.length;
				if (b && e) {
					d.push(this.layoutParams[c]);
					for (var a = 0; a < g.length; a++) {
						if (this.data.l[g[a]]) {
							f[g[a]].push(this.data.l[g[a]][c])
						}
					}
					if (this.data.l.group) {
						f.group = this.data.l.group
					}
					h++
				}
			}
			if (h != this.data.l.weight.length) {
				this.stndByLayoutData = {};
				this.stndByLayoutData.data = this.cloneObject(this.data.l);
				this.stndByLayoutData.pars = this.cloneObject(this.layoutParams);
				this.stndByLayoutData.layoutRows = this.layoutRows;
				this.stndByLayoutData.layoutCols = this.layoutCols;
				this.stndByLayoutData.layout = this.layout;
				this.data.l = f;
				this.layoutParams = d;
				this.layoutRows = Math.ceil(Math.sqrt(h));
				this.layoutCols = this.layoutRows * (this.layoutRows - 1) >= h ? this.layoutRows - 1 : this.layoutRows;
				this.layout = this.layoutRows + "X" + this.layoutCols;
				for (var c = 0; c < this.data.l.weight.length; c++) {
					this.data.l.weight[c] = [1 / this.layoutCols, 1 / this.layoutRows]
				}
			}
		}
	};
	this.restoreEmptyCompartments = function() {
		if (this.stndByLayoutData) {
			this.data.l = this.stndByLayoutData.data;
			this.layoutParams = this.stndByLayoutData.pars;
			this.layoutRows = this.stndByLayoutData.layoutRows;
			this.layoutCols = this.stndByLayoutData.layoutCols;
			this.layout = this.stndByLayoutData.layout;
			delete(this.stndByLayoutData)
		}
	};
	this.drawLayoutCompartments = function(l) {
		var n = ["left", "right", "top", "bottom", "x", "y", "offsetX", "offsetY", "graphType", "summaryType", "transformType", "smpInfo", "varInfo", "minData", "maxData", "xAxisMin", "xAxisMax", "xAxisRange", "xAxis2Min", "xAxis2Max", "xAxis2Range", "yAxisMin", "yAxisMax", "yAxisRange", "zAxisMin", "zAxisMax", "zAxisRange", "xAxisAbsMin", "xAxisAbsMax", "xAxis2AbsMin", "xAxis2AbsMax", "yAxisAbsMin", "yAxisAbsMax", "zAxisAbsMin", "zAxisAbsMax", "xAxisUnit", "xAxis2Unit", "yAxisUnit", "zAxisUnit"];
		var f = ["weight", "graphType", "varIndices", "smpIndices", "grpIndices", "varIndicesStart", "smpIndicesStart", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ"];
		if (this.layoutComb) {
			if (this.isDOE) {
				n.push("data");
				this.setDOE()
			}
			this.removeEmptyCompartments();
			if (this.graphType.match(/Scatter/)) {
				this.xAxis = this.data.y.smps;
				this.yAxis = this.data.y.smps;
				this.initAxes()
			} else {
				if (this.data.l && this.data.l.group) {
					this.groupSamples(this.data.l.group, false, false, true, true);
					this.meta.data.g = this.data.w;
					this.initAxes()
				} else {
					this.initAxes(true)
				}
			}
			this.setLayoutDimensions();
			var u = this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight;
			var r = this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom;
			this.skipSetLegends = true;
			this.setLayoutRestore();
			this.setLayoutParams();
			this.title = "";
			this.subtitle = "";
			this.offsetX = this.layoutLeft;
			this.offsetY = this.layoutTop;
			this.setLayoutWeights();
			this.setLayoutGraphTypes();
			this.setLayoutIndices(f);
			var s = 0;
			for (var q = 0; q < this.layoutRows; q++) {
				for (var o = 0; o < this.layoutCols; o++) {
					this.layoutCurrent = s;
					if (this.isDOE) {
						if (this.dataStndBy.l.smps.length <= s) {
							break
						}
					} else {
						if (this.graphType == "Pie") {
							if (this.data.l.smps.length <= s) {
								break
							}
						} else {
							if (this.layoutParams.length <= s) {
								break
							}
						}
					}
					if (this.layoutParams[s]) {
						for (var m = 0; m < f.length; m++) {
							this[f[m]] = this.layoutParams[s].hasOwnProperty(f[m]) ? this.layoutParams[s][f[m]] : this[f[m]]
						}
					}
					this.setLayoutGraphDimensions(u, r, s);
					if (this.isDOE) {
						this.drawLayoutCompartmentsDOE(u, r, s)
					} else {
						if (this.graphType.match(/Scatter/)) {
							this.drawLayoutCompartmentsScatter(u, r, q, o, s)
						} else {
							if (this.graphType == "Pie") {
								this.drawLayoutCompartmentsPie(u, r, s)
							} else {
								this.drawLayoutCompartmentsOneD(u, r, s)
							}
						}
					}
					if (!this.isDOE && this.varIndices.length > 0 && this.smpIndices.length > 0) {
						l.call(this)
					}
					for (var m = 0; m < n.length; m++) {
						this.layoutParams[s][n[m]] = this.cloneObject(this[n[m]])
					}
					if (this.data.w) {
						this.layoutParams[s].w = this.cloneObject(this.data.w)
					}
					if (this.layoutCanvasCompartments) {
						this.drawLayoutCanvasCompartments()
					}
					if (this.isDOE || this.graphType == "Pie") {} else {
						if (this.graphType.match(/Scatter/)) {
							var g, d;
							if (q == o && this.scatterPlotMatrixType.match(/complete/)) {
								var g = this.scaleTextToFont(this.meta.data.y.maxSmpStr, this.maxTextSize, (this.width - u) * 0.7 / this.layoutCols);
								this.rectangle(this.marginLeft + this.offsetX + this.left, this.marginTop + this.offsetY + this.top, this.x, this.y, false, this.foreground, "open");
								this.drawText(this.data.y.smps[q], this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top + (this.y / 2), g, this.foreground, "center", "middle")
							} else {
								if (!this.scatterPlotMatrixType.match(/complete/) && this.data.y.smps[s + 1]) {
									g = this.scaleTextToFont(this.meta.data.y.maxSmpStr + " & " + this.meta.data.y.maxSmpStr, this.maxTextSize, (this.width - u) * 0.8 / this.layoutCols);
									d = this.axisTitleFontSize + this.margin + this.margin;
									if (this.layoutBoxLabelColors[0]) {
										this.rectangle(this.marginLeft + this.offsetX + this.left, this.marginTop + this.offsetY + this.top - d, this.x, d, this.layoutBoxLabelColors[0], this.foreground)
									} else {
										this.rectangle(this.marginLeft + this.offsetX + this.left, this.marginTop + this.offsetY + this.top - d, this.x, d, false, this.foreground, "open")
									}
									this.drawText(this.data.y.smps[0] + " & " + this.data.y.smps[s + 1], this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top - (d / 2), g, this.foreground, "center", "middle")
								}
							}
						} else {
							if (!this.layoutAdjust) {
								var t = this.graphOrientation == "vertical" ? o : q;
								var b = this.graphOrientation == "vertical" ? this.layoutCols - 1 : this.layoutRows - 1;
								if (t == 0 && this.layoutRestore.xAxisShow && this.graphType != "Heatmap") {
									this.layoutAxis = 1;
									this.xAxisShow = true;
									this.draw1DXLayout()
								}
								if (t == b && this.layoutRestore.xAxis2Show && this.graphType != "Heatmap") {
									this.layoutAxis = 2;
									this.xAxis2Show = true;
									this.draw1DXLayout()
								}
							}
							if (this.segregateVariablesBy.length) {
								var a = false;
								if (this.graphOrientation == "vertical") {
									if (q == this.layoutRows - 1) {
										a = true
									} else {
										if (q == this.layoutRows - 2 && (s + 1 + parseInt(this.layoutCols)) > this.data.l.weight.length) {
											a = true
										}
									}
								} else {
									if (o == 0) {
										a = true
									}
								}
								if (a) {
									this.showSampleNames = this.layoutRestore.showSampleNames;
									this.draw1DYLayout()
								}
							}
							if (this.graphType != "Candlestick") {
								this.draw1DLabels(s)
							}
						}
					}
					this.offsetX += this.layoutWidth;
					s++
				}
				this.offsetX = this.layoutLeft;
				this.offsetY += this.layoutHeight
			}
			this.layoutCurrent = false;
			this.skipSetLegends = false;
			for (var e in this.layoutRestore) {
				this[e] = this.layoutRestore[e]
			}
			if (this.isDOE) {
				this.data = this.dataStndBy;
				this.graphType = this.data.l.type[0]
			} else {
				this.drawTitle();
				this.drawLabelsTitlesLayout();
				this.drawLayoutResizer();
				if (this.showLegend) {
					if (this.isDOE || this.graphType != "Pie") {
						this.drawLegend()
					}
				}
			}
			if (this.meta.data.g) {
				this.data.w = this.meta.data.g;
				delete(this.meta.data.g)
			} else {
				this.isGroupedData = false
			}
		}
	};
	this.setLayoutGraphDimensions = function(a, b, d) {
		this.layoutWidth = (this.width - a) * this.layoutParams[d].weight[0];
		this.layoutHeight = (this.height - b) * this.layoutParams[d].weight[1];
		this.layoutParams[d].width = this.layoutWidth;
		this.layoutParams[d].height = this.layoutHeight
	};
	this.drawLayoutCompartmentsDOE = function(a, b, d) {
		this.legendPosition = "right";
		this.graphOrientation = "vertical";
		if (d == 0 && this.showDOEData) {
			this.isShowDOEData = true;
			this.showLegend = this.layoutRestore.showLegend;
			if (this.graphType.match(/Scatter/i)) {
				this.isHistogram = false;
				this.xAxis = this.configStndBy.xAxis;
				this.yAxis = this.configStndBy.yAxis;
				this.xAxisTitle = this.configStndBy.xAxisTitle;
				this.yAxisTitle = this.configStndBy.yAxisTitle;
				this.initAxes();
				this.initializeData(this.dataStndBy);
				this.varIndices = this.dataStndBy.l.doe
			} else {
				this.initializeData(this.dataStndBy);
				this.smpIndices = this.dataStndBy.l.doe
			}
			this.showLegend = false;
			if (this.graphType == "Scatter3D") {
				this.draw3DPlot()
			} else {
				if (this.graphType.match(/Scatter/i)) {
					this.draw2DPlot()
				} else {
					this.plotByVariable = this.configStndBy.plotByVariable;
					if (this.configStndBy.groupingFactors.length > 0) {
						this.isGroupedData = true;
						if (this.dataStndBy.y.smps.length != this.smpIndices.length) {
							this.layoutComb = false;
							this.groupSamples(this.configStndBy.groupingFactors, false, false, true, true);
							this.layoutComb = true
						}
						this.draw1DPlot();
						this.isGroupedData = false
					} else {
						this.draw1DPlot()
					}
					this.plotByVariable = false
				}
			}
			this.showLegend = true;
			this.isShowDOEData = false
		} else {
			this.drawDOELabelsLayout(this.dataStndBy.l.smps[d][0]);
			this.top = 5;
			this.bottom = 5;
			this.right = 5;
			this.left = 5;
			if (this.dataStndBy.l.type[d] == "Pie") {
				this.showLegend = true;
				this.createPie(this.dataStndBy.l.smps[d][0]);
				this.legendBox = false;
				this.drawPiePlot()
			} else {
				if (this.dataStndBy.l.type[d] == "Treemap") {
					this.createTreemap(this.dataStndBy.l.smps[d][0]);
					this.draw1DPlot()
				} else {
					if (this.dataStndBy.l.type[d] == "Scatter2D") {
						this.createHistogram(false, false, this.dataStndBy.l.smps[d][0]);
						this.initAxes();
						this.showLegend = false;
						this.xAxisTitle = "";
						this.yAxisTitle = "";
						this.draw2DPlot()
					}
				}
			}
		}
	};
	this.drawLayoutCompartmentsScatter = function(a, e, d, b, f) {
		if (this.data.l.smps[f].xAxis && this.data.l.smps[f].yAxis) {
			this.xAxis = this.data.l.smps[f].xAxis;
			this.yAxis = this.data.l.smps[f].yAxis;
			this.xAxisIndices = this.getSampleIndices(this.xAxis);
			this.yAxisIndices = this.getSampleIndices(this.yAxis)
		} else {
			this.xAxis = false;
			this.yAxis = false;
			this.xAxisIndices = false;
			this.yAxisIndices = false
		}
		if (this.layoutAdjust && this.xAxis && this.yAxis) {
			this.initAxes();
			this.layoutAxis = 3
		} else {
			this.layoutAxis = b == 0 ? 2 : 0;
			this.layoutAxis = d == this.layoutRows && this.layoutAxis ? 3 : d == this.layoutRows ? 1 : 0
		}
		if (this.data.l.reg) {
			if (this.data.l.reg[f]) {
				if (this.data.d) {
					delete(this.data.d)
				}
				this.addRegressionDecoration(this.data.l.reg[f].reg, this.data.l.reg[f].lab, this.data.l.reg[f].col)
			}
		}
		this.showLegend = false;
		this.legendInside = true;
		this.showDecorationsLegend = true;
		this.xAxisTitle = "";
		this.yAxisTitle = "";
		if (!this.layoutAdjust) {
			this.xAxisShow = false;
			this.yAxisShow = false;
			this.xAxisS2Show = false;
			this.yAxisS2Show = false;
			if (d == 0 && b % 2 > 0) {
				this.xAxisS2Show = true
			}
			if (d == this.layoutRows - 1 && b % 2 == 0) {
				this.xAxisShow = true
			}
			if (b == 0 && d % 2 > 0) {
				this.yAxisShow = true
			}
			if (b == this.layoutCols - 1 && d % 2 == 0) {
				this.yAxisS2Show = true
			}
		}
	};
	this.drawLayoutCompartmentsPie = function(a, b, d) {
		this.smpIndices = [this.getSampleIndices(this.data.l.smps[d])];
		this.showLegend = true
	};
	this.drawLayoutCompartmentsOneD = function(b, d, e) {
		if (this.graphType == "Candlestick") {
			this.xAxisShow = true;
			this.xAxis2Show = true;
			this.xAxisTitle = true;
			this.xAxis2Title = true;
			if (e == 1) {
				this.summaryType = "volume";
				if (this.showVolume) {
					this.showSampleNames = true
				}
			} else {
				this.summaryType = "candle";
				this.showSampleNames = false
			}
		} else {
			this.showLegend = false;
			this.showOverlays = false;
			this.isGroupedData = false;
			this.xAxisTitle = false;
			this.xAxis2Title = false;
			this.smpTitle = false;
			this.adjustAspectRatioXTries = 0;
			this.adjustAspectRatioYTries = 0;
			this.layoutLabels = [];
			if (this.segregateSamplesBy.length > 0 && this.segregateVariablesBy.length > 0) {
				this.layoutLabels.push(this.data.l.name[e][0]);
				this.layoutLabels.push(this.data.l.name[e][1])
			} else {
				if (this.segregateSamplesBy.length > 1 || this.segregateVariablesBy.length > 1) {
					this.layoutLabels.push(this.data.l.name[e][1]);
					this.layoutLabels.push(this.data.l.name[e][0])
				} else {
					this.layoutLabels.push(this.data.l.name[e])
				}
			}
			if (this.varIndices.length > 0 && this.smpIndices.length > 0) {
				if (this.data.l.group) {
					var a = this.layoutParams[e].dragged ? this.layoutParams[e].grpIndices : false;
					this.groupSamples(this.data.l.group, false, a, true, true, true);
					this.layoutParams[e].grpIndices = this.grpIndices
				} else {
					if (this.smpIndices.length == 1 && this.graphType != "Heatmap") {
						this.showSampleNames = false
					}
				}
				if (this.segregateVariablesBy.length > 0 && this.graphType != "Heatmap") {
					this.showSampleNames = false
				}
				if (this.layoutAdjust) {
					this.layoutAxis = 3;
					if (this.varIndices.length > 0 && this.smpIndices.length > 0) {
						this.initAxes()
					}
				} else {
					if (this.graphOrientation == "vertical") {
						this.xAxisShowLayout = !(e % this.layoutCols) ? true : false
					} else {
						this.xAxisShowLayout = e < this.layoutCols ? true : false;
						this.xAxis2ShowLayout = e >= this.layoutCols * (this.layoutRows - 1) ? true : false
					}
					this.xAxisShow = false;
					this.xAxis2Show = false
				}
			}
		}
	};
	this.draw1DLabels = function(j) {
		if (this.layoutValid) {
			var e = this.layoutCollapse ? this.marginLeft + this.offsetX : this.marginLeft + this.offsetX + this.margin;
			var o = this.marginTop + this.offsetY;
			var k = this.layoutWidth;
			var d = k / 2;
			var g = this.getFontHeight() + (this.margin * 2);
			var b = g / 2;
			var a = this.layoutHeight - ((this.layoutLabels.length * g) + (this.margin * (this.layoutCollapse ? 0 : 1)));
			if (this.graphOrientation != "vertical" && this.graphType != "Heatmap" && !this.layoutAdjust) {
				if (j >= this.layoutCols) {
					a -= this.getAxisTitleTickLength()
				}
			}
			if (!this.layoutCollapse) {
				if (this.layoutAdjust) {
					k = this.x;
					e += this.left - this.margin;
					d = k / 2;
					a = this.y
				} else {
					k -= this.margin * 2
				}
			}
			for (var f = 0; f < this.layoutLabels.length; f++) {
				if (this.layoutBoxLabelColors[f]) {
					this.rectangle(e, o, k, g, this.layoutBoxLabelColors[f], this.layoutBoxShow ? this.foreground : this.layoutBoxLabelColors[f])
				} else {
					if (this.layoutBoxShow) {
						this.rectangle(e, o, k, g, false, this.foreground, "open")
					}
				}
				this.drawText(this.layoutLabels[f], e + d, o + b, this.font, this.foreground, "center", "middle");
				o += g
			}
			if (this.graphOrientation != "vertical" && this.xAxisShow) {
				o = this.marginTop + this.offsetY + this.top
			}
			if (this.layoutBoxShow) {
				this.rectangle(e, o, k, a, false, this.foreground, "open")
			}
		}
	};
	this.initializeLayout = function() {
		this.isValidLayout()
	};
	this.initializeLayout()
};
CanvasXpress.prototype.initViewport = function(a) {
	this.setViewport = function() {
		var d = this.$("container-" + this.target);
		if (!d) {
			var A = this.$(this.target);
			var x = A.getAttribute("responsive");
			var q = A.getAttribute("aspectRatio");
			A.className = "CanvasXpress";
			var u = A.parentNode;
			if (!u.id) {
				u.id = this.target + "ParentNode"
			}
			this.targetParentNode = u.id;
			this.targetParentNodeResponsive = false;
			this.targetParentNodeAspectRatio = [];
			if (x) {
				this.targetParentNodeResponsive = true;
				var h = q ? q.split(/:/) : [];
				var l = this.meta.system.isjQuery ? 16 : 0;
				if (u.clientWidth) {
					A.width = u.clientWidth - l
				} else {
					A.width = 250
				}
				if (h.length == 2) {
					h[0] = h[0] ? parseInt(h[0]) : 1;
					h[1] = h[1] ? parseInt(h[1]) : 1;
					A.height = parseInt(A.width * h[1] / h[0])
				} else {
					if (u.clientHeight) {
						A.height = u.clientHeight - l
					} else {
						A.height = 250
					}
				}
				this.targetParentNodeAspectRatio = [A.width, A.height]
			}
			A.widthDecrease = 18;
			A.heightDecrease = 18;
			A.originalWidth = parseInt(A.width);
			A.originalHeight = parseInt(A.height);
			A.width = A.originalWidth - A.widthDecrease;
			A.height = A.originalHeight - A.heightDecrease;
			var d = this.$cX("div", {
				id: "container-" + this.target,
				className: "CanvasXpressContainer"
			});
			if (a) {
				d.style.display = "none"
			}
			var g = this.$cX("div", {
				id: "north-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: A.width + "px",
				height: "0px",
				clear: "left"
			});
			var B = this.$cX("div", {
				id: "north-wrapper-" + this.target,
				className: "CanvasXpressWrapper"
			}, {
				width: A.width + "px",
				height: "0px"
			});
			var D = this.$cX("div", {
				id: "middle-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: (A.width + 4) + "px",
				height: (A.height + 4) + "px",
				clear: "left",
				margin: "-1px"
			});
			var j = this.$cX("div", {
				id: "west-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: "0px",
				height: A.height + "px",
				cssFloat: "left"
			});
			var C = this.$cX("div", {
				id: "west-wrapper-" + this.target,
				className: "CanvasXpressWrapper"
			}, {
				width: "0px",
				height: A.height + "px"
			});
			var e = this.$cX("div", {
				id: "center-wrapper-" + this.target,
				className: "CanvasXpressWrapper"
			});
			var f = this.$cX("div", {
				id: "east-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: "0px",
				height: A.height + "px"
			});
			var z = this.$cX("div", {
				id: "east-wrapper-" + this.target,
				className: "CanvasXpressWrapper"
			}, {
				width: "0px",
				height: A.height + "px"
			});
			var b = this.$cX("div", {
				id: "south-container-" + this.target,
				className: "CanvasXpressContainer"
			}, {
				width: A.width + "px",
				height: "0px",
				clear: "left"
			});
			var r = this.$cX("div", {
				id: "south-wrapper-" + this.target,
				className: "CanvasXpressWrapper",
				state: "open"
			}, {
				width: A.width + "px",
				height: "0px"
			});
			g.appendChild(B);
			j.appendChild(C);
			f.appendChild(z);
			b.appendChild(r);
			D.appendChild(j);
			D.appendChild(e);
			D.appendChild(f);
			d.appendChild(g);
			d.appendChild(D);
			d.appendChild(b);
			if (this.isVideo) {
				var k = this.$(this.target + "-cX-Video");
				if (!k) {
					k = this.$cX("video", {
						id: this.target + "-cX-Video",
						autoplay: false,
						controls: this.videoControls,
						loop: this.videoLoop,
						preload: this.videoPreload,
						poster: this.videoPoster,
						dataSet: this.videoData,
						width: this.meta.canvas.ctx.canvas.width,
						height: this.meta.canvas.ctx.canvas.height,
						className: this.videoClassName
					});
					var m = [];
					var w = this.backgroundVideo;
					if (w && !(w.propertyIsEnumerable("length")) && typeof w === "object" && typeof w.length === "number") {
						m = w
					} else {
						m.push(this.backgroundVideo)
					}
					for (var y = 0; y < m.length; y++) {
						var n = this.$cX("source", {
							src: m[y],
							type: m[y].match(/mp4$/) ? "video/mp4" : m[y].match(/webm$/) ? "video/webm" : "video/ogv"
						});
						k.appendChild(n)
					}
				}
				A.parentNode.insertBefore(d, A);
				e.appendChild(A.parentNode.appendChild(A));
				A.parentNode.insertBefore(k, A)
			} else {
				A.parentNode.insertBefore(d, A);
				e.appendChild(A.parentNode.appendChild(A))
			}
		}
	};
	this.resizeViewportNorth = function() {
		var d = this.$("west-container-" + this.target);
		var c = this.$("east-container-" + this.target);
		var e = this.$("north-container-" + this.target);
		var b = this.$("north-wrapper-" + this.target);
		if (d && c && e && b) {
			e.style.width = (parseInt(d.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(c.style.width)) + "px";
			b.style.width = (parseInt(d.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(c.style.width)) + "px";
			e.style.height = "0px";
			b.style.height = "0px"
		}
	};
	this.resizeViewportWest = function() {
		var e = this.$(this.target + "-cX-Configurator");
		var b = this.$("west-container-" + this.target);
		var d = this.$("west-wrapper-" + this.target);
		if (b && d) {
			b.style.width = "0px";
			d.style.width = "0px";
			b.style.height = this.meta.canvas.ctx.canvas.height + "px";
			d.style.height = this.meta.canvas.ctx.canvas.height + "px"
		}
	};
	this.resizeViewportEast = function() {
		var d = this.$(this.target + "-cX-DataFilter");
		var b = this.$("east-container-" + this.target);
		var c = this.$("east-wrapper-" + this.target);
		if (b && c) {
			b.style.width = "0px";
			c.style.width = "0px";
			b.style.height = this.meta.canvas.ctx.canvas.height + "px";
			c.style.height = this.meta.canvas.ctx.canvas.height + "px"
		}
	};
	this.resizeViewportSouth = function(c) {
		var h = this.$(this.target + "-cX-DataTable");
		var f = this.$("west-container-" + this.target);
		var e = this.$("east-container-" + this.target);
		var g = this.$("south-container-" + this.target);
		var b = this.$("south-wrapper-" + this.target);
		if (h && f && e && g && b) {
			if (c) {
				g.style.height = parseInt(h.style.height) + "px";
				b.style.height = parseInt(h.style.height) + "px";
				g.style.width = parseInt(h.style.width) + "px";
				b.style.width = parseInt(h.style.width) + "px"
			} else {
				g.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(e.style.width)) + "px";
				b.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(e.style.width)) + "px";
				g.style.height = "0px";
				b.style.height = "0px"
			}
		}
	};
	this.resizeViewport = function(h) {
		if (h) {
			var b = this.getTargetEvent(h);
			if (this.Ext) {
				for (var d = 0; d < CanvasXpress.instances.length; d++) {
					CanvasXpress.instances[d].resizeViewport()
				}
			}
			if (b.className && b.className.match(/x-tab-strip-text/)) {
				return
			}
		}
		var g = this.$("middle-container-" + this.target);
		var c = this.$("east-container-" + this.target);
		var f = this.$("west-container-" + this.target);
		if (g && c && f) {
			this.resizeViewportWest();
			this.resizeViewportEast();
			this.resizeViewportNorth();
			this.resizeViewportSouth();
			g.style.width = (parseInt(f.style.width) + this.meta.canvas.ctx.canvas.width + parseInt(c.style.width) + 0) + "px";
			g.style.height = (this.meta.canvas.ctx.canvas.height + 0) + "px"
		}
	};
	this.resizeViewportMiddle = function(b, d) {
		var f = this.$("middle-container-" + this.target);
		var c = this.$("east-container-" + this.target);
		var e = this.$("west-container-" + this.target);
		if (f && c && e) {
			this.resizeViewportWest();
			this.resizeViewportEast();
			this.resizeViewportNorth();
			this.resizeViewportSouth();
			f.style.width = (parseInt(e.style.width) + b + parseInt(c.style.width) + 0) + "px";
			f.style.height = (d + 0) + "px"
		}
	};
	this.resetViewportOverflow = function(c) {
		if (c) {
			var b = this.$(c + "-wrapper-" + this.target);
			if (b) {
				b.style.overflow = "visible"
			}
		}
	};
	this.initializeViewport = function() {
		this.setViewport()
	};
	this.initializeViewport()
};
CanvasXpress.prototype.initMenus = function() {
	this.addMenu = function(A, a, n, b, g, d, t, z) {
		if (this.disableMenu) {
			return
		}
		var p;
		var o;
		var j = this.$("north-wrapper-" + this.target);
		var c = this.$("west-container-" + this.target);
		this.resetLinkDiv();
		if (j && c) {
			if (a) {
				o = this.newId("-cX-Menu-");
				p = this.$cX("div", {
					id: o,
					className: "CanvasXpressMenu draggable",
					par: n
				}, {
					left: "0px",
					top: "0px",
					zIndex: this.menuIndex++,
					display: "none"
				})
			} else {
				this.removeMenus();
				if (b) {
					a = b;
					g += c.offsetWidth
				} else {
					a = this.setMenu();
					var v = this.getTargetEvent(A);
					var B = this.adjustedCoordinates(A, v);
					if (z) {
						g = 8;
						d = 8
					} else {
						g = B.x + c.offsetWidth;
						d = B.y
					}
				}
				o = this.newId("-cX-Menu-");
				p = this.$cX("div", {
					id: o,
					className: "CanvasXpressMenu draggable"
				}, {
					left: g + "px",
					top: d + "px",
					zIndex: this.menuIndex++
				})
			}
			var k = this.$cX("ul", {
				id: this.newId("-cX-List-"),
				className: "CanvasXpressList",
				header: t
			});
			p.appendChild(k);
			j.appendChild(p);
			var s = this.maxSubMenus;
			var q = a.length > s ? s : a.length;
			if (a.length > s) {
				k.rawMenu = a;
				k.rawMenuIndex = 0;
				this.addMenuItemScroller(k, "Top")
			}
			for (var r = 0; r < q; r++) {
				if (a[r][0] == "-") {
					this.addMenuItemSep(k)
				} else {
					if (a[r][0] == "-text-") {
						this.addMenuItemText(a[r], k)
					} else {
						if (a[r][0] == "-color-") {
							this.addMenuItemColor(a[r], k)
						} else {
							if (a[r][0] == "-slider-") {
								this.addMenuItemSlider(a[r], k)
							} else {
								this.addMenuItem(a[r], k)
							}
						}
					}
				}
			}
			if (a.length > s) {
				this.addMenuItemScroller(k, "Bottom")
			}
		}
		return o
	};
	this.pageMenuItem = function(e, f) {
		var g, j, a, i;
		var h = e.rawMenuMatch || e.rawMenu;
		if (h) {
			var d = e.childNodes.length - 2;
			if (f == "Top" && e.rawMenuIndex > 0) {
				g = e.childNodes[e.childNodes.length - 2];
				j = h[e.rawMenuIndex - 1];
				a = e.childNodes[2];
				i = true;
				e.rawMenuIndex--
			} else {
				if (f == "Bottom" && h.length > (e.rawMenuIndex + d)) {
					g = e.childNodes[2];
					j = h[e.rawMenuIndex + d];
					a = e.childNodes[e.childNodes.length - 1];
					i = true;
					e.rawMenuIndex++
				}
			}
			if (i) {
				this.addRemoveItemListeners("removeEvtListener", g);
				g.parentNode.removeChild(g);
				if (j[0] == "-") {
					this.addMenuItemSep(e, a)
				} else {
					if (j[0] == "-text-") {
						this.addMenuItemText(j, e, a)
					} else {
						if (j[0] == "-color-") {
							this.addMenuItemColor(j, e, a)
						} else {
							if (j[0] == "-slider-") {
								this.addMenuItemSlider(j, e, a)
							} else {
								this.addMenuItem(j, e, a)
							}
						}
					}
				}
			}
		}
	};
	this.filterScrollSearch = function(b) {
		var k = this.$(b);
		if (k) {
			var c = k.value;
			var n = new RegExp(k.value, "i");
			var h = k.parentNode.parentNode;
			var j = h.rawMenu;
			var f = [];
			for (var e = 0; e < j.length; e++) {
				if (j[e][0].match(n)) {
					f.push(j[e])
				}
			}
			if (f.length != j.length) {
				h.rawMenuMatch = f
			} else {
				delete(h.rawMenuMatch)
			}
			while (h.childNodes.length > 0) {
				var d = h.childNodes[0];
				this.addRemoveItemListeners("removeEvtListener", d);
				h.removeChild(d)
			}
			var m = this.maxSubMenus;
			var g = f.length > m ? m : f.length;
			h.rawMenuIndex = 0;
			var a = this.addMenuItemScroller(h, "Top", c);
			for (var e = 0; e < g; e++) {
				this.addMenuItem(f[e], h)
			}
			this.addMenuItemScroller(h, "Bottom");
			a.focus();
			a.value = c
		}
	};
	this.addMenuItemSep = function(d, a) {
		var c = this.$cX("li", {
			id: this.newId("-cX-List-Item-Sep-"),
			className: "CanvasXpressListItemSep"
		});
		var e = this.$cX("span", {
			id: this.newId("-cX-List-Item-Text-Sep-"),
			className: "CanvasXpressListItemTextSep",
			innerHTML: "&nbsp;"
		});
		c.appendChild(e);
		if (a) {
			a.parentNode.insertBefore(c, a)
		} else {
			d.appendChild(c)
		}
	};
	this.addMenuItemScroller = function(c, d) {
		var b = this.$cX("li", {
			id: this.newId("-cX-List-Item-Scroll-" + d),
			className: "CanvasXpressListItemScroll" + d
		});
		var f = this.$cX("span", {
			id: this.newId("-cX-List-Item-Text-Scroll-" + d),
			className: "CanvasXpressListItemTextScroll" + d,
			innerHTML: "&nbsp;"
		});
		b.appendChild(f);
		c.appendChild(b);
		this.addRemoveItemListeners("addEvtListener", b);
		if (d == "Top") {
			var a = this.$cX("li", {
				id: this.newId("-cX-List-Item-Scroll-Search"),
				className: "CanvasXpressListItemScrollSearch" + d
			});
			var e = this.$cX("input", {
				id: this.newId("-cX-List-Item-Scroll-Search-Input"),
				className: "CanvasXpressListItemScrollSearch",
				type: "text",
				placeholder: " Search menu"
			});
			a.appendChild(e);
			c.appendChild(a);
			return e
		}
	};
	this.getMenuItemValue = function(d) {
		if (d[2][2]) {
			var c = this.cloneObject(d[2][2]);
			var b = this;
			while (c.length > 0) {
				var a = c.shift();
				if (b[a]) {
					b = b[a]
				} else {
					return ""
				}
			}
			return b != null ? b : ""
		} else {
			return this[d[2][0]] || ""
		}
	};
	this.addMenuItem = function(d, n, k) {
		var j = this.newId("-cX-List-Item-");
		var e = this.$cX("li", {
			id: j,
			className: "CanvasXpressListItem",
			click: d[2],
			params: d[3] || [],
			upload: d[0] && d[0] == "Load" ? true : false,
			uploadParams: d[0] && d[0] == "Load Parameters" ? true : false
		});
		var m;
		if (d[5]) {
			m = this.$cX("a", {
				id: this.newId("-cX-List-Item-A-"),
				className: "CanvasXpressListItemAArrow",
				hidefocus: "true",
				unselectable: "on",
				href: "#",
				menu: j,
				menuId: "false",
				menuFunc: d[5],
				menuParm: d[6],
				title: "Drag to position menu"
			})
		} else {
			m = this.$cX("a", {
				id: this.newId("-cX-List-Item-A-"),
				className: "CanvasXpressListItemA",
				hidefocus: "true",
				unselectable: "on",
				href: "#",
				menuFunc: d[2],
				menuParm: d[3]
			})
		}
		var g = this.$cX("img", {
			id: this.newId("-cX-List-Icon-"),
			className: "CanvasXpressListIcon",
			src: d[1] && CanvasXpress.images[d[1]] ? CanvasXpress.images[d[1]] : CanvasXpress.images.canvasXpress,
			key: d[1]
		});
		var p;
		if (d[0] && (d[0] == "Load" || d[0] == "Load Parameters")) {
			p = this.$cX("span", {
				id: this.newId("-cX-List-Item-Text-"),
				className: "CanvasXpressListItemText"
			}, {
				marginRight: 0
			});
			var h = this.$cX("input", {
				id: this.newId("-cX-List-Item-Text-File-Upload"),
				className: "CanvasXpressListItemText",
				type: "file"
			}, {
				color: "transparent",
				width: "100px"
			});
			p.appendChild(h)
		} else {
			p = this.$cX("span", {
				id: this.newId("-cX-List-Item-Text-"),
				className: "CanvasXpressListItemText",
				innerHTML: d[0] || ""
			})
		}
		var c = this.$cX("span", {
			className: "CanvasXpressListItemTextShort",
			innerHTML: d[4] || ""
		});
		m.appendChild(g);
		m.appendChild(p);
		m.appendChild(c);
		e.appendChild(m);
		if (k) {
			k.parentNode.insertBefore(e, k)
		} else {
			n.appendChild(e)
		}
		this.addRemoveItemListeners("addEvtListener", e)
	};
	this.addMenuItemText = function(c, m, j) {
		var h = this.newId("-cX-List-Item-Text-");
		var f = this.newId("-cX-List-Item-Text-Input-");
		var d = this.getMenuItemValue(c);
		var e = this.$cX("li", {
			id: h,
			className: "CanvasXpressListItem",
			click: c[1],
			params: [c[2], f]
		});
		var n = this.$cX("input", {
			id: f,
			className: "CanvasXpressList",
			type: "text",
			value: d
		});
		var k = this.$cX("a", {
			id: this.newId("-cX-List-Text-Item-A-"),
			className: "CanvasXpressListItemA",
			hidefocus: "true",
			unselectable: "on",
			href: "#"
		});
		var g = this.$cX("img", {
			id: this.newId("-cX-List-Text-Icon-"),
			className: "CanvasXpressListIcon",
			src: CanvasXpress.images.refreshForm,
			key: "refreshForm"
		}, {
			marginTop: "4px"
		});
		k.appendChild(g);
		k.appendChild(n);
		e.appendChild(k);
		if (j) {
			j.parentNode.insertBefore(e, j)
		} else {
			m.appendChild(e)
		}
		this.addRemoveItemListeners("addEvtListener", e)
	};
	this.addMenuItemColor = function(E, v, L) {
		var m = this.newId("-cX-List-Item-Color-");
		var n = this.newId("-cX-List-Item-Color-Container-");
		var g = this.newId("-cX-List-Item-Color-Current-");
		var B = this.newId("-cX-List-Item-Color-Palete-");
		var f = this.newId("-cX-List-Item-Color-Palete-Current-");
		var k = this.newId("-cX-List-Item-Color-Saturation-");
		var w = this.newId("-cX-List-Item-Color-Saturation-Current-");
		var N = this[E[2][0]] || "";
		var G = this.$cX("li", {
			id: m,
			className: "CanvasXpressListItem",
			click: E[1],
			params: [E[2], g],
			palete: B,
			paleteCurrent: f,
			colorCurrent: g,
			saturation: k,
			saturationCurrent: w
		});
		var M = this.$cX("a", {
			id: this.newId("-cX-List-Color-Item-A-"),
			className: "CanvasXpressListItemA",
			hidefocus: "true",
			unselectable: "on",
			href: "#"
		}, {
			height: "126px"
		});
		var I = this.$cX("img", {
			id: this.newId("-cX-List-Color-Icon-"),
			className: "CanvasXpressListIcon",
			src: CanvasXpress.images.refreshForm,
			key: "refreshForm"
		}, {
			marginTop: "2px"
		});
		var J = N ? this.rgbToHex(this.validateColor(N.replace(/[\'\"]/g, ""))) : this.foreground;
		this.colorRGBfromString(J);
		var t = Math.round(this.colorHSV[0] / 6 * 180);
		var r = Math.round((1 - this.colorHSV[1]) * 100);
		var q = Math.round((1 - this.colorHSV[2]) * 100);
		var K = this.$cX("div", {
			id: n
		}, {
			width: "188px",
			height: "130px",
			cssFloat: "left"
		});
		var C = this.$cX("div", {
			id: g,
			parentItem: m,
			className: "CanvasXpressConfiguratorColor",
			value: N
		}, {
			width: "203px",
			height: "16px",
			cssFloat: "left",
			marginBottom: "5px",
			cursor: "default"
		});
		var D = this.$cX("div", {
			id: B,
			parentItem: m,
			className: "CanvasXpressConfiguratorColorMain"
		}, {
			position: "relative",
			left: "0px",
			top: "0px",
			width: "181px",
			height: "101px"
		});
		var d = this.$cX("div", {
			id: f,
			parentItem: m,
			className: "CanvasXpressConfiguratorColorExtra"
		}, {
			position: "relative",
			left: (t - 7) + "px",
			top: (r - 7) + "px",
			width: "195px",
			height: "115px"
		});
		D.appendChild(d);
		var A = this.$cX("div", {
			id: k,
			parentItem: m,
			className: "CanvasXpressConfiguratorColor"
		}, {
			position: "relative",
			left: "188px",
			top: "-102px",
			width: "15px",
			height: "100px",
			border: "1px solid rgb(51,122,183)",
			clear: "left",
			cursor: "crosshair"
		});
		for (var H = 0; H < 100; H += 4) {
			var F = this.$cX("div", false, {
				height: "4px",
				position: "relative",
				left: "0px",
				cursor: "crosshair"
			});
			A.appendChild(F)
		}
		var e = this.$cX("div", {
			id: w,
			parentItem: m,
			className: "CanvasXpressConfiguratorColorExtra"
		}, {
			position: "relative",
			left: "0px",
			top: (q - 108) + "px",
			width: "29px",
			height: "115px"
		});
		A.appendChild(e);
		K.appendChild(C);
		K.appendChild(D);
		K.appendChild(A);
		M.appendChild(I);
		M.appendChild(K);
		G.appendChild(M);
		if (L) {
			L.parentNode.insertBefore(G, L)
		} else {
			v.appendChild(G)
		}
		this.colorizeCurrentItemColor(G);
		this.colorizeSaturationItemColor(G);
		this.addRemoveItemListeners("addEvtListener", G)
	};
	this.colorizeCurrentItemColor = function(a) {
		var e = this.$(a.colorCurrent);
		if (e) {
			var d = this.colorRGBToString();
			var b = this.hexToRgb("#" + d);
			e.style.backgroundColor = "#" + d;
			e.innerHTML = "&nbsp;&nbsp;" + b;
			e.style.color = this.complementaryColor(b, true);
			e.value = b
		}
	};
	this.colorizeSaturationItemColor = function(a) {
		var d = function(m, k, c, j, h) {
			return "rgb(" + (m * (1 - j / h) * 100) + "%," + (k * (1 - j / h) * 100) + "%," + (c * (1 - j / h) * 100) + "%)"
		};
		var f = this.$(a.saturation);
		if (f && this.colorHSV) {
			var g = f.childNodes;
			var b = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], 1);
			if (b) {
				for (var e = 0; e < g.length - 1; e++) {
					g[e].style.backgroundColor = d(b[0], b[1], b[2], e, g.length - 1)
				}
			}
		}
	};
	this.updateColorItemValue = function(b, c) {
		if (!b) {
			var g = this.getMenuItemComp(c);
			if (g) {
				b = g[0]
			} else {
				return false
			}
		}
		if (this.changingColorItemOn) {
			if (this.changingColorItemOn == "palette") {
				var a = this.$(b.palete);
				var h = this.$(b.paleteCurrent);
				if (a && h) {
					var j = this.adjustedCoordinates(c, a);
					if (j) {
						var i = Math.min(Math.max(0, j.x), 181);
						var f = Math.min(Math.max(0, j.y - 25), 101);
						h.style.left = (i - 7) + "px";
						h.style.top = (f - 7) + "px";
						this.colorFromHsv(i * 6 / 180, 1 - f / 100, null);
						this.colorizeCurrentItemColor(b);
						this.colorizeSaturationItemColor(b)
					}
				}
			} else {
				var k = this.$(b.saturation);
				var d = this.$(b.saturationCurrent);
				if (k && d) {
					var j = this.adjustedCoordinates(c, k);
					if (j) {
						var f = Math.min(Math.max(0, j.y - 25), 101);
						d.style.top = (f - 108) + "px";
						this.colorFromHsv(null, null, 1 - f / 100);
						this.colorizeCurrentItemColor(b)
					}
				}
			}
		}
		return false
	};
	this.endColorItemChange = function(a) {
		this.changingColorItemOn = false
	};
	this.addMenuItemSlider = function(q, m, I) {
		var f = this.newId("-cX-List-Item-Slider-");
		var e = this.newId("-cX-List-Item-Slider-Container-");
		var E = this.newId("-cX-List-Item-Slider-Table-");
		var K = q[2][0] || "";
		var D = this.formatNumber(this.binConfigurations[K]["max"], this.binConfigurations[K]["dec"]);
		var v = this.$cX("li", {
			id: f,
			className: "CanvasXpressListItem",
			click: q[1],
			params: [q[2][0], e],
			slider: K
		});
		var J = this.$cX("a", {
			id: this.newId("-cX-List-Slider-Item-A-"),
			className: "CanvasXpressListItemA",
			hidefocus: "true",
			unselectable: "on",
			href: "#"
		});
		var H = this.$cX("div", {
			id: e,
			className: "CanvasXpressList"
		});
		var n = this.$cX("table", {
			id: E,
			className: "CanvasXpressListItemTable"
		}, {
			width: "100%"
		});
		var g = this.$cX("tbody");
		var h = D.length * 8;
		for (var B = 0; B < this.binConfigurations[K]["n"]; B++) {
			var s = Number(B > 0 ? this.binConfigurations[K]["bins"][B - 1]["value"] : this.binConfigurations[K]["min"]);
			var A = Number(B < this.binConfigurations[K]["n"] - 1 ? this.binConfigurations[K]["bins"][B + 1]["value"] : this.binConfigurations[K]["max"]);
			var k = this.$cX("input", {
				id: E + "-Range-" + B,
				className: "CanvasXpressListItem",
				type: "range",
				value: this.binConfigurations[K]["bins"][B]["value"],
				min: s,
				max: A,
				step: Number(this.formatNumber((A - s) / 20, this.binConfigurations[K]["dec"])),
				slider: K,
				sliderRange: B,
				sliderNumber: false
			}, {
				width: "120px"
			});
			var j = this.$cX("input", {
				id: E + "-Number-" + B,
				className: "CanvasXpressListItem",
				type: "number",
				value: this.binConfigurations[K]["bins"][B]["value"],
				min: s,
				max: A,
				step: Number(this.formatNumber((A - s) / 20, this.binConfigurations[K]["dec"])),
				slider: K,
				sliderRange: B,
				sliderNumber: true
			}, {
				width: (h + 18) + "px",
				textAlign: "right"
			});
			var c = this.$cX("tr");
			var G = this.$cX("th", {
				innerHTML: this.binConfigurations[K]["bins"][B]["name"]
			}, {
				paddingRight: "5px"
			});
			var F = this.$cX("td", {
				id: E + "-Min-" + B,
				innerHTML: this.formatNumber(s, this.binConfigurations[K]["dec"])
			}, {
				width: h + "px",
				textAlign: "right"
			});
			var C = this.$cX("td");
			C.appendChild(k);
			var z = this.$cX("td", {
				id: E + "-Max-" + B,
				innerHTML: this.formatNumber(A, this.binConfigurations[K]["dec"])
			}, {
				width: h + "px"
			});
			var w = this.$cX("td", false, {
				paddingLeft: "5px"
			});
			w.appendChild(j);
			c.appendChild(G);
			c.appendChild(F);
			c.appendChild(C);
			c.appendChild(z);
			c.appendChild(w);
			g.appendChild(c)
		}
		n.appendChild(g);
		H.appendChild(n);
		H.appendChild(this.$cX("br"));
		var p = this.$cX("img", {
			id: this.newId("-cX-List-Icon-"),
			className: "CanvasXpressListIcon",
			src: CanvasXpress.images.refreshForm,
			key: "refreshForm"
		}, {
			marginTop: "4px"
		});
		J.appendChild(p);
		J.appendChild(H);
		v.appendChild(J);
		if (I) {
			I.parentNode.insertBefore(v, I)
		} else {
			m.appendChild(v)
		}
		this.addRemoveItemListeners("addEvtListener", v)
	};
	this.updateSliderItemValue = function(h) {
		var a = this.changingSliderItemOn.slider;
		var g = this.changingSliderItemOn.sliderRange;
		var c = Number(this.formatNumber(this.changingSliderItemOn.value, this.binConfigurations[a]["dec"]));
		var d = this.$(this.changingSliderItemOn.id.replace("-Range-", "-Number-"));
		var f = this.$(this.changingSliderItemOn.id.replace("-Range-" + g, "-Range-" + (g - 1)));
		var j = this.$(this.changingSliderItemOn.id.replace("-Range-" + g, "-Max-" + (g - 1)));
		var b = this.$(this.changingSliderItemOn.id.replace("-Range-" + g, "-Range-" + (g + 1)));
		var i = this.$(this.changingSliderItemOn.id.replace("-Range-" + g, "-Min-" + (g + 1)));
		this.binConfigurations[a]["bins"][g]["value"] = c;
		if (d) {
			d.value = c
		}
		if (f && j) {
			f.max = c;
			f.step = (f.max - f.min) / 20;
			j.innerHTML = c
		}
		if (b && i) {
			b.min = c;
			b.step = (b.max - b.min) / 20;
			i.innerHTML = c
		}
		this.applySliderItemValue(a);
		return false
	};
	this.endSliderItemChange = function(g) {
		if (this.changingSliderItemOn.sliderNumber) {
			var a = this.changingSliderItemOn.slider;
			var f = this.changingSliderItemOn.sliderRange;
			var c = Number(this.formatNumber(this.changingSliderItemOn.value, this.binConfigurations[a]["dec"]));
			var i = this.$(this.changingSliderItemOn.id.replace("-Number-", "-Range-"));
			var d = this.$(this.changingSliderItemOn.id.replace("-Number-" + f, "-Range-" + (f - 1)));
			var j = this.$(this.changingSliderItemOn.id.replace("-Number-" + f, "-Max-" + (f - 1)));
			var b = this.$(this.changingSliderItemOn.id.replace("-Number-" + f, "-Range-" + (f + 1)));
			var h = this.$(this.changingSliderItemOn.id.replace("-Number-" + f, "-Min-" + (f + 1)));
			this.binConfigurations[a]["bins"][f]["value"] = c;
			if (i) {
				i.value = c
			}
			if (d && j) {
				d.max = c;
				d.step = (d.max - d.min) / 20;
				j.innerHTML = c
			}
			if (b && h) {
				b.min = c;
				b.step = (b.max - b.min) / 20;
				h.innerHTML = c
			}
			this.applySliderItemValue(a)
		}
		this.changingSliderItemOn = false
	};
	this.applySliderItemValue = function(f) {
		var a = this.binConfigurations[f]["name"];
		var e = this.binConfigurations[f]["vi"];
		this.data.x[a] = [];
		for (var d = 0; d < this.data.y.data[e].length; d++) {
			var b = this.data.y.data[e][d];
			if (!isNaN(b) && b != "" && b != null) {
				for (var c = 0; c < this.binConfigurations[f]["n"]; c++) {
					if (b <= this.binConfigurations[f]["bins"][c].value) {
						this.data.x[a][d] = this.binConfigurations[f]["bins"][c].name;
						break
					}
				}
			} else {
				this.data.x[a][d] = ""
			}
		}
		if (this.isGroupedData) {
			this.ungroupSamples(true)
		}
		this.updateData(this.data);
		this.groupSamples([a]);
		this.sortSamplesByCategory([a])
	};
	this.addRemoveItemListeners = function(b, a) {
		if (!a) {
			return this.removeMenus()
		} else {
			if (a.className == "CanvasXpressListItemSep") {
				return
			}
		}
		var e = a.parentNode.parentNode;
		var f = a.id.match("-cX-List-Item-Color-");
		if (this.hasClass(e, "draggable") && !f) {
			this[b](e, "mousedown", this.registerMousemove, false)
		}
		if (a.upload) {
			var d = a.childNodes[0].childNodes[1].childNodes[0];
			this[b](d, "change", this.loadFile, false)
		} else {
			if (a.uploadParams) {
				var d = a.childNodes[0].childNodes[1].childNodes[0];
				this[b](d, "change", this.loadParamsFile, false)
			} else {
				this[b](a, "click", this.clickMenuItem, false)
			}
		}
		this[b](a, "mouseover", this.mouseoverMenuItem, false);
		this[b](a, "mouseout", this.mouseoutMenuItem, false);
		this[b](a, "mousewheel", this.mousewheelMenuItem, false);
		this[b](a, "contextmenu", this.contextMenuItem, false);
		if (a.className.match(/Scroll/)) {
			this[b](a, "mousedown", this.mousedownMenuItem, false);
			this[b](a, "mouseup", this.mouseupMenuItem, false)
		}
		if (a.paleteCurrent && a.saturation) {
			this[b](a, "mousedown", this.mousedownMenuItemColor, false)
		}
		if (a.slider) {
			this[b](a, "mousedown", this.mousedownMenuItemSlider, false)
		}
	};
	this.contextMenuItem = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			a.cancelEvent(h);
			var b = a.getTargetEvent(h);
			var n = a.getMenuItemComp(h);
			var f = n[1].childNodes[0];
			var g = n[1].childNodes[1].innerText;
			var k = n[1].menuFunc;
			var j = n[1].menuParm;
			var p = n[1].menuId;
			var q = n[2].offsetLeft;
			var l = n[2].offsetTop + n[1].offsetTop;
			a.removeMenus();
			var o = [
				["Pin " + g + " to Toolbar", "pin", "pinToToolbar", [f, g, k, j, p]]
			];
			var d = a.addMenu(h, o);
			var c = a.$(d);
			c.style.left = q + "px";
			c.style.top = l + "px";
			c.style.display = "block";
			return false
		}
	}(this);
	this.pinToToolbar = function(d, a, c, f, e) {
		this.removeMenus();
		var b = this.$(this.target + "-cX-Toolbar-Custom");
		if (b) {
			var g = this.target + "-cX-Custom-Toolbar-Menu-" + c;
			if (!this.$(g)) {
				d.id = g;
				d.style.cssFloat = "left";
				d.style.marginLeft = "10px";
				d.style.position = "relative";
				d.title = a;
				d.fun = c;
				d.par = f;
				d.mid = e;
				b.appendChild(d);
				this.addRemoveEvtListener("addEvtListener", d, "click", this.addCustomToolbarMenu, false);
				this.addRemoveEvtListener("addEvtListener", d, "contextmenu", this.unpinFromToolbar, false);
				CanvasXpress.stack[this.target].afterRender.push(["addImageToToolbar", [d.key, a, c, f, e]])
			}
		}
	};
	this.unpinFromToolbar = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			a.cancelEvent(j);
			var c = a.getTargetEvent(j);
			var g = c.offsetLeft;
			var h = c.offsetTop;
			var f = [
				["Unpin " + c.title + "from Toolbar", "unpin", "removeImageFromToolbar", [c.id]]
			];
			var d = a.addMenu(j, f);
			var b = a.$(d);
			b.style.left = g + "px";
			b.style.top = h + "px";
			b.style.display = "block";
			return false
		}
	}(this);
	this.addCustomToolbarMenu = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			a.cancelEvent(f);
			var c = a.getTargetEvent(f);
			var g = a[c.fun].apply(a, c.par);
			if (c.mid) {
				var d = a.addMenu(false, g);
				var b = a.$(d);
				b.style.left = c.offsetLeft + "px";
				b.style.top = "10px";
				b.style.display = "block"
			}
		}
	}(this);
	this.addImageToToolbar = function(e, a, b, f, d) {
		var c = this.$cX("img", {
			className: "CanvasXpressListIcon",
			src: CanvasXpress.images[e],
			key: e
		});
		this.pinToToolbar(c, a, b, f, d)
	};
	this.removeImageFromToolbar = function(b) {
		var a = this.$(b);
		if (a) {
			this.addRemoveEvtListener("removeEvtListener", a, "click", this.addCustomToolbarMenu, false);
			this.addRemoveEvtListener("removeEvtListener", a, "contextmenu", this.unpinFromToolbar, false);
			a.parentNode.removeChild(a);
			this.removeMenus();
			CanvasXpress.stack[this.target].afterRender.push(["removeImageFromToolbar", [b]])
		}
	};
	this.clickMenuItem = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			a.cancelEvent(h);
			var b = a.getTargetEvent(h);
			var m = a.getMenuItemComp(h);
			if (m && !/input|textarea|select/i.test(b.tagName)) {
				if (m[0].className.match(/Scroll/) || m[1].className.match(/Scroll/)) {
					var c = m[0].className.match(/Scroll/) ? m[0] : m[1];
					var n = c.parentNode;
					var j = c.className.match(/ScrollTop/) ? "Top" : "Bottom";
					a.pageMenuItem(n, j)
				} else {
					var f = [];
					if (m[0].params) {
						for (var g = 0; g < m[0].params.length; g++) {
							if (m[0].params[g] == "event") {
								f.push(h)
							} else {
								if (m[0].params[g] == "component") {
									f.push(m)
								} else {
									f.push(m[0].params[g])
								}
							}
						}
					}
					if (a[m[0].click]) {
						a[m[0].click].apply(a, f);
						var d = m[1].firstChild.key;
						var o = m[1].firstChild.src;
						if (d) {
							if (d.match("unchecked")) {
								m[1].firstChild.key = "checked";
								m[1].firstChild.src = CanvasXpress.images.checked
							} else {
								if (d.match("checked")) {
									m[1].firstChild.key = "unchecked";
									m[1].firstChild.src = CanvasXpress.images.unchecked
								} else {
									if (d.match("eyeMinusIcon")) {
										m[1].firstChild.key = "eyePlusIcon";
										m[1].firstChild.src = CanvasXpress.images.eyePlusIcon
									} else {
										if (d.match("eyePlusIcon")) {
											m[1].firstChild.key = "eyeMinusIcon";
											m[1].firstChild.src = CanvasXpress.images.eyeMinusIcon
										} else {
											if (d == "lightbulb") {
												m[1].firstChild.key = "lightbulbOff";
												m[1].firstChild.src = CanvasXpress.images.lightbulbOff
											} else {
												if (d == "lightbulbOff") {
													m[1].firstChild.key = "lightbulb";
													m[1].firstChild.src = CanvasXpress.images.lightbulb
												} else {
													if (d.match("radioOn")) {
														a.resetRadioMenuItem(m[2].firstChild.childNodes);
														if (f[1] && f[1].match(/xAxis|yAxis|zAxis/)) {
															m[1].firstChild.key = "radioOn";
															m[1].firstChild.src = CanvasXpress.images.radioOn
														} else {
															m[1].firstChild.key = "radioOff";
															m[1].firstChild.src = CanvasXpress.images.radioOff
														}
													} else {
														if (d.match("radioOff")) {
															a.resetRadioMenuItem(m[2].firstChild.childNodes);
															m[1].firstChild.key = "radioOn";
															m[1].firstChild.src = CanvasXpress.images.radioOn
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				return false
			} else {
				return false
			}
		}
	}(this);
	this.resetRadioMenuItem = function(b) {
		for (var c = 0; c < b.length; c++) {
			var a = b[c].firstChild.firstChild;
			if (a && a.nodeName.match(/img/i)) {
				a.src = CanvasXpress.images.radioOff;
				a.key = "refreshForm"
			}
		}
	};
	this.adjustMenuItemPosition = function(f, p, o) {
		var g, x;
		var q = this.remoteParentId ? this.$(this.remoteParentId) : this.$("container-" + this.target);
		var i = window.innerWidth;
		var b = window.innerHeight;
		var u = q.offsetLeft;
		var k = q.offsetTop;
		var s = q.clientWidth;
		var j = q.clientHeight;
		var a = i - u;
		var v = f.clientWidth;
		var n = f.clientHeight;
		if (p) {
			g = p.offsetLeft + p.offsetWidth - 5;
			if (g + v + 5 > a) {
				g = p.offsetLeft - v + 5
			}
			x = p.offsetTop + o.offsetTop
		} else {
			g = f.offsetLeft;
			x = f.offsetTop
		}
		f.style.left = g + "px";
		f.style.top = x + "px"
	};
	this.mouseoverMenuItem = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			var h = a.getMenuItemComp(j);
			if (!h) {
				return false
			}
			if (h[0].className.match(/Scroll/) || h[1].className.match(/Scroll/)) {
				var n = h[0].className.match(/Scroll/) ? h[0] : h[1];
				n.className += "Active";
				return false
			}
			var f = h[2].firstChild.childNodes;
			a.hideMenusRecursively(f);
			h[0].className = "CanvasXpressListItemActive";
			if (h[1].menu) {
				var l = a[h[1].menuFunc].apply(a, h[1].menuParm);
				var g = a.addMenu(false, l, h[1].menu);
				var b = a.$(g);
				var k = h[2];
				b.style.left = "0px";
				b.style.top = "0px";
				b.style.display = "block";
				a.adjustMenuItemPosition(b, k, h[1]);
				h[1].className = "CanvasXpressListItemAArrowActive";
				h[1].menuId = g
			} else {
				h[1].className = "CanvasXpressListItemAActive"
			}
			return false
		}
	}(this);
	this.mouseoutMenuItem = function(a) {
		return function(i) {
			if (!i) {
				i = window.event
			}
			if (a.fastScrollMenuOn) {
				a.fastScrollMenuOn = false;
				clearInterval(a.fastScrollMenu)
			}
			var d, c, b, q, o, n, k, j;
			var p = a.adjustedCoordinates(i);
			if (p) {
				var h = a.$("north-container-" + a.target);
				var g = a.$("west-container-" + a.target);
				p.x += g.offsetWidth;
				p.y += h.offsetHeight;
				var l = a.getMenuItemComp(i);
				if (!l) {
					return false
				} else {
					if (l[1] && l[1].menu) {
						var f = a.$(l[1].menuId);
						d = f.offsetLeft;
						o = f.offsetTop;
						c = d + f.offsetWidth;
						n = o + f.offsetHeight;
						if (p.x >= d && p.x <= c && p.y >= o && p.y <= n) {
							return false
						}
						a.hideMenu(l, f)
					} else {
						a.hideMenu(l)
					}
				}
			}
			return false
		}
	}(this);
	this.mousedownMenuItemColor = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = a.getTargetEvent(d);
			var c = a.getMenuItemComp(d);
			if (!c) {
				return false
			} else {
				if (b.id && b.id.match(/-cX-List-Item-Color-Palete-/)) {
					a.changingColorItemOn = "palette";
					if (a.colorHSV[2] == 0) {
						a.colorFromHsv(null, null, 1);
						a.colorizeCurrentItemColor(c[0]);
						var f = a.$(c[0].saturationCurrent);
						if (f) {
							f.style.top = "-108px"
						}
					}
					a.updateColorItemValue(c[0], d);
					a.colorizeSaturationItemColor(c[0])
				} else {
					if (b.parentNode.id && b.parentNode.id.match(/-cX-List-Item-Color-Saturation-/)) {
						a.changingColorItemOn = "saturation";
						a.updateColorItemValue(c[0], d)
					}
				}
			}
			a.cancelEvent(d);
			return false
		}
	}(this);
	this.mousedownMenuItemSlider = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.changingSliderItemOn = a.getTargetEvent(b);
			return false
		}
	}(this);
	this.mousedownMenuItem = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.fastScrollMenuOn = true;
			a.fastScrollMenu = setInterval(function() {
				a.clickMenuItem(b)
			}, 100);
			return false
		}
	}(this);
	this.mouseupMenuItem = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.fastScrollMenuOn) {
				a.fastScrollMenuOn = false;
				clearInterval(a.fastScrollMenu)
			}
		}
	}(this);
	this.mousewheelMenuItem = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			a.cancelEvent(g);
			var h = 0;
			if (g.wheelDelta) {
				h = g.wheelDelta;
				if (window.opera) {
					h = -h
				}
			} else {
				if (g.detail) {
					h = -g.detail
				}
			}
			if (h) {
				var b = a.getTargetEvent(g);
				var f = a.getMenuItemComp(g);
				if (!f) {
					return false
				}
				var c = f[0].parentNode;
				if (h > 0) {
					a.pageMenuItem(c, "Top")
				} else {
					a.pageMenuItem(c, "Bottom")
				}
			}
			return false
		}
	}(this);
	this.getMenuItemComp = function(b) {
		var a = this.getTargetEvent(b);
		while (a && a.tagName && !a.tagName.match(/li/i)) {
			a = a.parentNode
		}
		return a.parentNode && a.parentNode.parentNode ? [a, a.firstChild, a.parentNode.parentNode] : false
	};
	this.hideMenu = function(e, f) {
		if (e) {
			if (e[0].className.match(/Scroll/) || e[1].className.match(/Scroll/)) {
				var g = e[0].className.match(/Scroll/) ? e[0] : e[1];
				g.className = g.className.replace("Active", "")
			} else {
				if (e[1].menu) {
					e[1].className = "CanvasXpressListItemAArrow"
				} else {
					e[1].className = "CanvasXpressListItemA"
				}
				e[0].className = "CanvasXpressListItem"
			}
		}
		if (f) {
			var b = f.firstChild.childNodes;
			for (var d = 0; d < b.length; d++) {
				var a = b[d];
				if (!a.className.match(/Scroll|ItemSep/)) {
					this.addRemoveItemListeners("removeEvtListener", a)
				}
			}
			f.parentNode.removeChild(f)
		}
	};
	this.hideMenusRecursively = function(e) {
		for (var f = 0; f < e.length; f++) {
			var c = e[f];
			if (!c.className.match(/Scroll|ItemSep/)) {
				var d = c.firstChild;
				var b = d.menu ? this.$(d.menuId) : false;
				if (b) {
					this.hideMenusRecursively(b.firstChild.childNodes)
				}
				this.hideMenu([c, d], b)
			}
		}
	};
	this.removeMenus = function(k) {
		var f = [];
		if (this.skipHeaderMouseout) {
			this.skipHeaderMouseout.className = "CanvasXpressTableCellHead";
			this.skipHeaderMouseout.firstChild.firstChild.className = "CanvasXpressTableCellHead";
			this.skipHeaderMouseout = false
		}
		if (!k) {
			var c = this.$("north-wrapper-" + this.target);
			if (c) {
				var h = c.getElementsByTagName("div");
				for (var g = 0; g < h.length; g++) {
					if (this.hasClass(h[g], "CanvasXpressMenu")) {
						f.unshift(this.$(h[g].id))
					}
				}
			}
			this.menuIndex = 10000
		} else {
			f.push(this.$(this.target + "-cX-Menu-" + k))
		}
		if (f.length > 0) {
			for (g in this.meta.ids) {
				if (g.match(/cX-Menu-|cX-Menu/)) {
					delete(this.meta.ids[g])
				}
			}
			for (var g = 0; g < f.length; g++) {
				var a = f[g];
				var b = a.getElementsByTagName("li");
				for (var e = 0; e < b.length; e++) {
					if (b[e].className != "CanvasXpressListItemSep") {
						this.addRemoveItemListeners("removeEvtListener", b[e])
					}
				}
				a.parentNode.removeChild(a)
			}
		}
	};
	this.changeTextColorAttributeMenu = function(a, b) {
		return this.isArray(b) ? [
			[a, "changeTextColorAttribute", b]
		] : [
			[a, "changeTextColorAttribute", [b]]
		]
	};
	this.getAxisLayoutTypeMenu = function() {
		var a = [];
		a.push(["Complete - Both", this.scatterPlotMatrixType == "completeBoth" ? "radioOn" : "radioOff", "changeLayoutType", ["completeBoth"]]);
		a.push(["Complete - Upper", this.scatterPlotMatrixType == "completeUpper" ? "radioOn" : "radioOff", "changeLayoutType", ["completeUpper"]]);
		a.push(["Complete - Lower", this.scatterPlotMatrixType == "completeLower" ? "radioOn" : "radioOff", "changeLayoutType", ["completeLower"]]);
		a.push(["First", this.scatterPlotMatrixType == "first" ? "radioOn" : "radioOff", "changeLayoutType", ["first"]]);
		return a
	};
	this.getAxisLayoutMenu = function() {
		var a = [];
		a.push(["Auto-Adjust", this.layoutAdjust ? "lightbulb" : "lightbulbOff", "toggleAttribute", ["layoutAdjust"]]);
		a.push(["Type", false, false, false, false, "getAxisLayoutTypeMenu", []]);
		return a
	};
	this.getAxisSampleMenu = function(c) {
		var d = [];
		var a = this.getObjectArray(this[c + "Axis"]);
		for (var b = 0; b < this.data.y.smps.length; b++) {
			d.push([this.data.y.smps[b], a[this.data.y.smps[b]] ? "checked" : "unchecked", "changeSampleInAxis", [this.data.y.smps[b], c + "Axis"]])
		}
		return d
	};
	this.getAxisMenu = function(e, d) {
		var c = e.toUpperCase();
		var b = d ? "2" : "";
		var a = [];
		a.push([this[e + "Axis" + b + "Show"] ? "Hide Axis" : "Show Axis", this[e + "AxisShow"] ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", [e + "Axis" + b + "Show"]]);
		a.push(["Set Min", "minimumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMin" + c + b]]);
		a.push(["Set Max", "maximumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMax" + c + b]]);
		a.push(["Transform", "transform", false, false, false, "getAxisTransformMenu", [e]]);
		a.push(["Exact Range", "exactValue", "toggleAttribute", [e + "Axis" + b + "Exact"]]);
		a.push(["Format", "format", false, false, false, "changeTextColorAttributeMenu", ["-text-", e + "Axis" + b + "TickFormat"]]);
		a.push(["Samples", "samples", false, false, false, "getAxisSampleMenu", [e]]);
		return a
	};
	this.getFirstAxisMenu = function() {
		return [
			[this.xAxisShow ? "Hide Axis" : "Show Axis", this.xAxisShow ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["xAxisShow"]]
		]
	};
	this.getSecondAxisMenu = function() {
		return [
			[this.xAxis2Show ? "Hide Axis" : "Show Axis", this.xAxis2Show ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["xAxis2Show"]]
		]
	};
	this.getRangeAxisMenu = function() {
		var a = [];
		a.push(["Set Min", "minimumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMinX"]]);
		a.push(["Set Max", "maximumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMaxX"]]);
		a.push(["Exact Range", "exactValue", "toggleAttribute", ["xAxisExact"]]);
		return a
	};
	this.getAxesMenu = function() {
		var a = [];
		if (this.graphType == "Scatter2D") {
			a.push(["X-Axis", "xAxis", false, false, false, "getAxisMenu", ["x"]]);
			a.push(["Y-Axis", "yAxis", false, false, false, "getAxisMenu", ["y"]]);
			a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTickColor"]]);
			a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTick"]]);
			if (this.scatterPlotMatrix) {
				a.push(["Axes Layout", false, false, false, false, "getAxisLayoutMenu", []])
			}
		} else {
			if (this.graphType == "Scatter3D" || this.graphType == "ScatterBubble2D" || this.is3DPlot) {
				a.push(["X-Axis", "xAxis", false, false, false, "getAxisMenu", ["x"]]);
				a.push(["Y-Axis", "yAxis", false, false, false, "getAxisMenu", ["y"]]);
				a.push(["Z-Axis", "zAxis", false, false, false, "getAxisMenu", ["z"]]);
				a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTickColor"]]);
				a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTick"]])
			} else {
				if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
					a.push(["First Axis", "firstAxis", false, false, false, "getAxisMenu", ["x"]]);
					a.push(["Second Axis", "secondAxis", false, false, false, "getAxisMenu", ["x", true]]);
					a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTickColor"]]);
					a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTick"]])
				} else {
					a.push(["First Axis", "firstAxis", false, false, false, "getFirstAxisMenu", []]);
					a.push(["Second Axis", "secondAxis", false, false, false, "getSecondAxisMenu", []]);
					a.push(["Range", "range", false, false, false, "getRangeAxisMenu", []]);
					a.push(["Format", "format", false, false, false, "changeTextColorAttributeMenu", ["-text-", "xAxisTickFormat"]]);
					a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTickColor"]]);
					a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTick"]]);
					if (this.layoutValid) {
						a.push(["Auto-Adjust", this.layoutAdjust ? "lightbulb" : "lightbulbOff", "toggleAttribute", ["layoutAdjust"]])
					}
				}
			}
		}
		return a
	};
	this.getHeatmapBoxMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "heatmapCellBoxColor"]]);
		a.push(["Width", "widthSpace", false, false, false, "changeTextColorAttributeMenu", ["-text-", "heatmapCellBoxWidth"]]);
		a.push([this.heatmapCellBox ? "Hide Box" : "Show Box", this.heatmapCellBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["heatmapCellBox"]]);
		return a
	};
	this.getHeatmapHighlightMenu = function() {
		return [
			["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "heatmapCellBoxColorHighlight"]]
		]
	};
	this.getHeatmapVarSmpSeparatorsMenu = function(h, d, j) {
		var e = this.meta.data;
		var k = [];
		if (e[h] && d.length > 0) {
			var f = {};
			for (var g = 0; g < d.length; g++) {
				var a = d[g];
				if (e[h][a].type != "Numeric") {
					f[a] = true
				}
			}
			var b = this.sortObject(f);
			for (var g = 0; g < b.length; g++) {
				k.push([b[g], b[g] == this[j] ? "radioOn" : "radioOff", "changeAttribute", [j, b[g]]])
			}
		}
		return k
	};
	this.getHeatmapSeparatorsMenu = function() {
		var a = [];
		if (this.isStringOverlays("v")) {
			a.push(["Variables", "variables", false, false, false, "getHeatmapVarSmpSeparatorsMenu", ["z", this.varOverlays, "heatmapVarSeparateBy"]])
		}
		if (this.isStringOverlays("s")) {
			a.push(["Samples", "samples", false, false, false, "getHeatmapVarSmpSeparatorsMenu", ["x", this.smpOverlays, "heatmapSmpSeparateBy"]])
		}
		return a
	};
	this.getHeatmapMenu = function() {
		var a = [];
		a.push(["Cell Boxes", "border", false, false, false, "getHeatmapBoxMenu", []]);
		a.push(["Highlight", "heatmapHighlight", false, false, false, "getHeatmapHighlightMenu", []]);
		if (this.isStringOverlays()) {
			a.push(["Separators", "heatmapSeparate", false, false, false, "getHeatmapSeparatorsMenu", []])
		}
		return a
	};
	this.getPlotAreaMajorTicksMenu = function(a) {
		return [
			[this[a] ? "Hide Major Ticks" : "Show Major Ticks", this[a] ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", [a]]
		]
	};
	this.getPlotAreaMinorTicksMenu = function(a) {
		return [
			[this[a] ? "Hide Minor Ticks" : "Show Minor Ticks", this[a] ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", [a]]
		]
	};
	this.getPlotAreaTickTypeMenu = function(a) {
		var b = [];
		b.push(["Solid", "axesTickTypeSolid", "changeAttribute", [a, "solid"]]);
		b.push(["Dotted", "axesTickTypeDotted", "changeAttribute", [a, "dotted"]]);
		return b
	};
	this.getPlotAreaGridMenu = function(b) {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", b + "AxisTickColor"]]);
		if (this.graphType != "Scatter3D" && !this.is3DPlot) {
			a.push(["Major Ticks", "axesMinorTicks", false, false, false, "getPlotAreaMajorTicksMenu", [b + "AxisMajorTicks"]]);
			a.push(["Minor Ticks", "axesMinorTicks", false, false, false, "getPlotAreaMinorTicksMenu", [b + "AxisMinorTicks"]]);
			a.push(["Number", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", b + "AxisTicks"]])
		}
		a.push(["Style", "axesTickType", false, false, false, "getPlotAreaTickTypeMenu", [b + "AxisTickStyle"]]);
		return a
	};
	this.getPlotAreaScatterGridMenu = function() {
		var a = [];
		if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
			a.push(["X-Axis", "xGridS", false, false, false, "getPlotAreaGridMenu", ["x"]]);
			a.push(["Y-Axis", "yGridS", false, false, false, "getPlotAreaGridMenu", ["y"]])
		} else {
			if (this.graphType == "Scatter3D" || this.is3DPlot) {
				a.push(["X-Axis", "xGridS", false, false, false, "getPlotAreaGridMenu", ["x"]]);
				a.push(["Y-Axis", "yGridS", false, false, false, "getPlotAreaGridMenu", ["y"]]);
				a.push(["Z-Axis", "zGridS", false, false, false, "getPlotAreaGridMenu", ["z"]])
			}
		}
		return a
	};
	this.getPlotAreaAxisAlgorithmMenu = function() {
		var a = [];
		a.push(["Default", this.axisAlgorithm == "default" ? "radioOn" : "radioOff", "changeAttribute", ["axisAlgorithm", "default"]]);
		a.push(["Heckbert", this.axisAlgorithm == "heckbert" ? "radioOn" : "radioOff", "changeAttribute", ["axisAlgorithm", "heckbert"]]);
		a.push(["R Pretty", this.axisAlgorithm == "rPretty" ? "radioOn" : "radioOff", "changeAttribute", ["axisAlgorithm", "rPretty"]]);
		a.push(["Wilkinson", this.axisAlgorithm == "wilkinson" ? "radioOn" : "radioOff", "changeAttribute", ["axisAlgorithm", "wilkinson"]]);
		a.push(["Wilkinson Extended", this.axisAlgorithm == "wilkinsonExtended" ? "radioOn" : "radioOff", "changeAttribute", ["axisAlgorithm", "wilkinsonExtended"]]);
		return a
	};
	this.getPlotAreaBarsTypeMenu = function() {
		var a = [];
		a.push(["Standard Deviation", this.errorBarsType == "standardDeviation" ? "radioOn" : "radioOff", "changeAttribute", ["errorBarsType", "standardDeviation"]]);
		a.push(["Standard Error of Mean", this.errorBarsType == "standardErrorMean" ? "radioOn" : "radioOff", "changeAttribute", ["errorBarsType", "standardErrorMean"]]);
		a.push(["95% Confidence Interval", this.errorBarsType == "confidenceInterval95" ? "radioOn" : "radioOff", "changeAttribute", ["errorBarsType", "confidenceInterval95"]]);
		return a
	};
	this.getPlotAreaErrorBarsMenu = function() {
		var a = [];
		a.push(["Error Bars Type", false, false, false, false, "getPlotAreaBarsTypeMenu", []]);
		a.push([this.showErrorBars ? "Hide Error Bars" : "Show Error Bars", this.showErrorBars ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showErrorBars"]]);
		return a
	};
	this.getPlotAreaOneSampleSpaceMenu = function() {
		var a = [];
		a.push(["Farther", "spaceFarther", "setFontAttributeSize", ["variableSeparationFactor", "increase"]]);
		a.push(["Closer", "spaceCloser", "setFontAttributeSize", ["variableSeparationFactor", "decrease"]]);
		return a
	};
	this.getPlotAreaOneSampleWidthMenu = function() {
		var a = [];
		a.push(["Wider", "widthSpaceWider", "setFontAttributeSize", ["widthFactor", "increase"]]);
		a.push(["Thinner", "widthSpaceThinner", "setFontAttributeSize", ["widthFactor", "decrease"]]);
		return a
	};
	this.getPlotAreaOneMenu = function() {
		var b = [];
		b.push(["Axis Algorithm", "gridS", false, false, false, "getPlotAreaAxisAlgorithmMenu", []]);
		b.push(["Error Bars", "errorBars", false, false, false, "getPlotAreaErrorBarsMenu", []]);
		b.push(["Border Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "plotBoxColor"]]);
		b.push([this.plotBox ? "Hide Border" : "Show Border", this.plotBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["plotBox"]]);
		if (this.graphType.match(/Dot|Boxplot/)) {
			b.push(["Jitter", "jitter", "toggleAttribute", ["jitter"]])
		}
		if (this.graphType == "Boxplot") {
			b.push(["Plot Data", "bpdata", "toggleAttribute", ["showBoxplotOriginalData"]]);
			b.push(["Violin", "violinOn", "toggleAttribute", ["showViolinBoxplot"]]);
			b.push(["Connect Boxplot", "connects", "toggleAttribute", ["boxplotConnect"]])
		}
		b.push(["Sample Space", "spaceWidth", false, false, false, "getPlotAreaOneSampleSpaceMenu", []]);
		b.push(["Sample Width", "widthSpace", false, false, false, "getPlotAreaOneSampleWidthMenu", []]);
		return b
	};
	this.getPlotAreaScatterMenu = function() {
		var b = [];
		b.push(["Axis Algorithm", "gridS", false, false, false, "getPlotAreaAxisAlgorithmMenu", []]);
		b.push(["Error Bars", "errorBars", false, false, false, "getPlotAreaErrorBarsMenu", []]);
		b.push(["Border Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "plotBoxColor"]]);
		b.push([this.plotBox ? "Hide Border" : "Show Border", this.plotBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["plotBox"]]);
		return b
	};
	this.getAxesTitleXMenu = function() {
		return [
			["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "xAxisTitle"]]
		]
	};
	this.getAxesTitleX2Menu = function() {
		return [
			["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "xAxis2Title"]]
		]
	};
	this.getAxesTitleYMenu = function() {
		return [
			["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "yAxisTitle"]]
		]
	};
	this.getAxesTitleZMenu = function() {
		return [
			["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "zAxisTitle"]]
		]
	};
	this.getAxesTitleMenu = function() {
		var a = [];
		if (this.graphType.match(/scatter/i) || this.is3DPlot) {
			a.push(["X-Axis", "xAxisTitleS", false, false, false, "getAxesTitleXMenu", []]);
			a.push(["Y-Axis", "yAxisTitleS", false, false, false, "getAxesTitleYMenu", []]);
			if (this.graphType == "Scatter3D" || this.is3DPlot) {
				a.push(["Z-Axis", "zAxisTitleS", false, false, false, "getAxesTitleZMenu", []])
			}
		} else {
			if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
				a.push(["First Axis", "firstAxisTitle", false, false, false, "getAxesTitleXMenu", []]);
				a.push(["Second Axis", "secondAxisTitle", false, false, false, "getAxesTitleX2Menu", []])
			} else {
				a.push(["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "xAxisTitle"]])
			}
		}
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "axisTitleColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["axisTitle"]]);
		return a
	};
	this.getTitleMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "titleColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["title"]]);
		a.push(["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "title"]]);
		return a
	};
	this.getSubtitleMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "subtitleColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["subtitle"]]);
		a.push(["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", "subtitle"]]);
		return a
	};
	this.getTitleSubtitleMenu = function() {
		var a = [];
		if (this.graphType.match(/scatter/i) || this.is3DPlot) {
			a.push(["Title", "titleS", false, false, false, "getTitleMenu", []]);
			a.push(["Subtitle", "subtitleS", false, false, false, "getSubtitleMenu", []])
		} else {
			a.push(["Title", this.graphType == "Heatmap" ? "titleH" : "title", false, false, false, "getTitleMenu", []]);
			a.push(["Subtitle", this.graphType == "Heatmap" ? "subtitleH" : "subtitle", false, false, false, "getSubtitleMenu", []])
		}
		return a
	};
	this.getLegendLocationMenu = function() {
		var a = [];
		a.push(["Inside Plot", "legendInside", "changeAttribute", ["legendInside", true]]);
		a.push(["Outside Plot", "legendOutside", "changeAttribute", ["legendInside", false]]);
		return a
	};
	this.getLegendPositionMenu = function() {
		var a = [];
		if (this.legendInside) {
			a.push(["Top", "legendInsideTop", "changeAttribute", ["legendPosition", "top"]]);
			a.push(["Top Right", "legendInsideTopRight", "changeAttribute", ["legendPosition", "topRight"]]);
			a.push(["Right", "legendInsideRight", "changeAttribute", ["legendPosition", "right"]]);
			a.push(["Bottom Right", "legendInsideBottomRight", "changeAttribute", ["legendPosition", "bottomRight"]]);
			a.push(["Bottom", "legendInsideBottom", "changeAttribute", ["legendPosition", "bottom"]]);
			a.push(["Bottom Left", "legendInsideBottomLeft", "changeAttribute", ["legendPosition", "bottomLeft"]]);
			a.push(["Left", "legendInsideLeft", "changeAttribute", ["legendPosition", "left"]]);
			a.push(["Top Left", "legendInsideTopLeft", "changeAttribute", ["legendPosition", "topLeft"]])
		} else {
			a.push(["Bottom", "bottom", "changeAttribute", ["legendPosition", "bottom"]]);
			a.push(["Right", "right", "changeAttribute", ["legendPosition", "right"]])
		}
		return a
	};
	this.getLegendBorderMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "legendBoxColor"]]);
		a.push([this.legendBox ? "Hide Border" : "Show Border", this.legendBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["legendBox"]]);
		return a
	};
	this.getLegendMenu = function() {
		var a = [];
		a.push(["Border", "border", false, false, false, "getLegendBorderMenu", []]);
		a.push(["Background", "background", false, false, false, "changeTextColorAttributeMenu", ["-color-", "legendBackgroundColor"]]);
		a.push(["Color", "colors", false, false, false, false, "changeTextColorAttributeMenu", ["-color-", "legendColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["legend"]]);
		a.push(["Position", this.legendInside ? "legendInsidePosition" : "positionRightBottom", false, false, false, "getLegendPositionMenu", []]);
		a.push(["Location", "legendLocation", false, false, false, "getLegendLocationMenu", []]);
		a.push(["Columns", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", "legendColumns"]]);
		a.push(["Reset Positions", "refreshForm", "resetLegendPosition"]);
		a.push([this.showLegend ? "Hide Legend" : "Show Legend", this.showLegend ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showLegend"]]);
		return a
	};
	this.getIndicatorPositionMenu = function() {
		var a = [];
		a.push(["Right", "legendInsideRight", "changeAttribute", ["heatmapIndicatorPosition", "right"]]);
		a.push(["Top Right", "legendInsideTopRight", "changeAttribute", ["heatmapIndicatorPosition", "topRight"]]);
		a.push(["Top", "legendInsideTop", "changeAttribute", ["heatmapIndicatorPosition", "top"]]);
		a.push(["Top Left", "legendInsideTopLeft", "changeAttribute", ["heatmapIndicatorPosition", "topLeft"]]);
		return a
	};
	this.getIndicatorMenu = function() {
		var a = [];
		a.push(["Position", "legendInsidePosition", false, false, false, "getIndicatorPositionMenu", []]);
		a.push(["Height", "heightSpace", false, false, false, "changeTextColorAttributeMenu", ["-text-", "heatmapIndicatorHeight"]]);
		a.push(["Width", "widthSpace", false, false, false, "changeTextColorAttributeMenu", ["-text-", "heatmapIndicatorWidth"]]);
		a.push(["Histogram", "indicatorHistogram", "toggleAttribute", ["heatmapIndicatorHistogram"]]);
		a.push([this.showHeatmapIndicator ? "Hide Indicator" : "Show Indicator", this.showHeatmapIndicator ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showHeatmapIndicator"]]);
		return a
	};
	this.getDecorationsBorderMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "decorationsBoxColor"]]);
		a.push([this.decorationsBox ? "Hide Border" : "Show Border", this.decorationsBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["decorationsBox"]]);
		return a
	};
	this.getDecorationsPositionMenu = function() {
		var a = [];
		if (this.legendInside) {
			a.push(["Top", "legendInsideTop", "changeAttribute", ["decorationsPosition", "top"]]);
			a.push(["Top Right", "legendInsideTopRight", "changeAttribute", ["decorationsPosition", "topRight"]]);
			a.push(["Right", "legendInsideRight", "changeAttribute", ["decorationsPosition", "right"]]);
			a.push(["Bottom Right", "legendInsideBottomRight", "changeAttribute", ["decorationsPosition", "bottomRight"]]);
			a.push(["Bottom", "legendInsideBottom", "changeAttribute", ["decorationsPosition", "bottom"]]);
			a.push(["Bottom Left", "legendInsideBottomLeft", "changeAttribute", ["decorationsPosition", "bottomLeft"]]);
			a.push(["Left", "legendInsideLeft", "changeAttribute", ["decorationsPosition", "left"]]);
			a.push(["Top Left", "legendInsideTopLeft", "changeAttribute", ["decorationsPosition", "topLeft"]])
		} else {
			a.push(["Bottom", "bottom", "changeAttribute", ["decorationsPosition", "bottom"]]);
			a.push(["Right", "right", "changeAttribute", ["decorationsPosition", "right"]])
		}
		return a
	};
	this.getDecorationsDataMenu = function() {
		return [
			[this.showDecorations ? "Hide Decorations" : "Show Decorations", this.showDecorations ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showDecorations"]]
		]
	};
	this.getDecorationsLegendMenu = function() {
		return [
			[this.showDecorationsLegend ? "Hide Decorations Legend" : "Show Decorations Legend", this.showDecorationsLegend ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showDecorationsLegend"]]
		]
	};
	this.getDecorationsConfidenceIntervalsMenu = function() {
		var b = this.data.d;
		var a = b.reg ? "correlationConfidence" : "kaplanMeier";
		var c = b.reg ? "showDecorationsRegressionConfidence" : "showDecorationsKaplanMeierConfidence";
		return [
			[this[c] ? "Hide Confidence Intervals" : "Show Confidence Intervals", this[c] ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", [c]]
		]
	};
	this.getDecorationsMenu = function() {
		var b = this.data.d;
		var a = [];
		a.push(["Border", "border", false, false, false, "getDecorationsBorderMenu", []]);
		a.push(["Background", "background", false, false, false, "changeTextColorAttributeMenu", ["-color-", "decorationsBackgroundColor"]]);
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "decorationsColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["decoration"]]);
		a.push(["Position", this.legendInside ? "legendInsidePosition" : "positionRightBottom", false, false, false, "getDecorationsPositionMenu", []]);
		a.push(["Data and Legend", "data", false, false, false, "getDecorationsDataMenu", []]);
		a.push(["Legend", "legendS", false, false, false, "getDecorationsLegendMenu", []]);
		if (b.reg || b.kaplanMeier) {
			a.push(["Confidence Intervals", ic, false, false, false, "getDecorationsConfidenceIntervalsMenu", []])
		}
		return a
	};
	this.getOverlaysMemebersMenu = function(g, b) {
		var f = [];
		var e = {};
		for (var a = 0; a < this[b + "Overlays"].length; a++) {
			e[this[b + "Overlays"][a]] = true
		}
		var d = this.sortObject(this.data[g]);
		for (var a = 0; a < d.length; a++) {
			f.push([d[a], e[d[a]] ? "checked" : "unchecked", b == "var" ? "showVariableOverlays" : "showSampleOverlays", [d[a]]])
		}
		return f
	};
	this.getOverlaysPositionMemberMenu = function(a, b) {
		var c = [];
		if (a == "var") {
			c.push(["Bottom", "bottom", "modifyOverlaysProperties", ["bottom", a + "OverlayProperties", b, "position"]]);
			c.push(["Top", "top", "modifyOverlaysProperties", ["top", a + "OverlayProperties", b, "position"]])
		} else {
			if (this.graphType == "Heatmap" || this.graphOrientation == "horizontal") {
				c.push(["Left", "left", "modifyOverlaysProperties", ["left", a + "OverlayProperties", b, "position"]]);
				c.push(["Right", "right", "modifyOverlaysProperties", ["right", a + "OverlayProperties", b, "position"]])
			} else {
				c.push(["Bottom", "bottom", "modifyOverlaysProperties", ["bottom", a + "OverlayProperties", b, "position"]]);
				c.push(["Top", "top", "modifyOverlaysProperties", ["top", a + "OverlayProperties", b, "position"]])
			}
		}
		return c
	};
	this.getOverlaysPositionMenu = function(f, b) {
		var e = [];
		var d = this.sortObject(this.data[f]);
		for (var a = 0; a < d.length; a++) {
			e.push([d[a], false, false, false, false, "getOverlaysPositionMemberMenu", [b, d[a]]])
		}
		return e
	};
	this.getOverlaysThicknessMenu = function(f, b) {
		var e = [];
		var d = this.sortObject(this.data[f]);
		for (var a = 0; a < d.length; a++) {
			e.push([d[a], false, false, false, false, "changeTextColorAttributeMenu", ["-text-", [false, "modifyOverlaysProperties", [b + "OverlayProperties", d[a], "thickness"]]]])
		}
		return e
	};
	this.getOverlaysColorSchemesMenu = function(g, f) {
		var e = [];
		var b = this.meta.data[g];
		var a = this.getColorSchemes();
		for (var d = 0; d < a.length; d++) {
			e.push([a[d], b[f].spectrum == a[d] ? "radioOn" : "radioOff", "modifyColorProperties", [a[d], f, g, "String"]])
		}
		return e
	};
	this.getOverlaysColorMenu = function(g, d) {
		var f = [];
		var a = this.meta.data[g];
		var e = this.sortObject(this.data[g]);
		for (var b = 0; b < e.length; b++) {
			if (this.isNumeric(this.data[g][e[b]])) {
				if (this[d + "OverlayProperties"][e[b]] && this[d + "OverlayProperties"][e[b]].type && this[d + "OverlayProperties"][e[b]].type == "Heatmap") {
					f.push([e[b], false, false, false, false, "getColorSpectrumMenu", [a[e[b]].colorBrew.spectrum, "modifyColorProperties", e[b], g, "Numeric"]])
				} else {
					f.push([e[b], false, false, false, false, "changeTextColorAttributeMenu", ["-color-", [false, "modifyOverlaysProperties", [d + "OverlayProperties", e[b], "color"]]]])
				}
			} else {
				f.push([e[b], false, false, false, false, "getOverlaysColorSchemesMenu", [g, e[b]]])
			}
		}
		return f
	};
	this.getOverlaysGraphTypeMenu = function(d, f) {
		var e = [];
		var b = ["Area", "AreaLine", "Bar", "BarLine", "Dotplot", "DotLine", "Heatmap", "Line", "Pie", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine"];
		var a = ["area", "areaLine", "bar", "barLine", "dotplot", "dotplotLine", "heatmap", "line", "pie", "stacked", "stackedPercent", "stackedPercent", "stackedPercentLine"];
		for (var c = 0; c < b.length; c++) {
			e.push([b[c], a[c], "modifyOverlaysProperties", [b[c], d + "OverlayProperties", f, "type"]])
		}
		return e
	};
	this.getOverlaysGraphDefaultMenu = function(a, b) {
		var b = [];
		b.push(["Default", "heatmap", "modifyOverlaysProperties", ["Heatmap", a + "OverlayProperties", b, "type"]]);
		b.push(["Text", "ut", "modifyOverlaysProperties", ["Text", a + "OverlayProperties", b, "type"]]);
		return b
	};
	this.getOverlaysGraphMenu = function(g, d) {
		var f = [];
		var a = this.meta.data[g];
		var e = this.sortObject(this.data[g]);
		for (var b = 0; b < e.length; b++) {
			if (this.isNumeric(this.data[g][e[b]])) {
				f.push([e[b], false, false, false, false, "getOverlaysGraphTypeMenu", [d, e[b]]])
			} else {
				f.push([e[b], false, false, false, false, "getOverlaysGraphDefaultMenu", [d, e[b]]])
			}
		}
		return f
	};
	this.getOverlaysPropertiesMenu = function(d, a) {
		var b = [];
		if (a == "var") {
			b.push(["Position", "positionTopBottom", false, false, false, "getOverlaysPositionMenu", [d, a]])
		} else {
			if (this.graphType == "Heatmap" || this.graphOrientation == "vertical") {
				b.push(["Position", "positionLeftRight", false, false, false, "getOverlaysPositionMenu", [d, a]])
			} else {
				b.push(["Position", "positionTopBottom", false, false, false, "getOverlaysPositionMenu", [d, a]])
			}
		}
		b.push(["Thickness", "widthSpace", false, false, false, "getOverlaysThicknessMenu", [d, a]]);
		b.push(["Color", "colors", false, false, false, "getOverlaysColorMenu", [d, a]]);
		b.push(["Type", "graphType", false, false, false, "getOverlaysGraphMenu", [d, a]]);
		return b
	};
	this.getOverlaysMenu = function() {
		var a = [];
		if (this.graphType == "Heatmap" && this.data.z) {
			a.push(["Variable Overlays", "overlaysVariables", false, false, false, "getOverlaysMemebersMenu", ["z", "var"]]);
			a.push(["Variable Overlays Properties", "overlaysVariablesEdit", false, false, false, "getOverlaysPropertiesMenu", ["z", "var"]]);
			a.push(["-"])
		}
		if (this.data.x) {
			a.push(["Sample Overlays", this.graphType == "Heatmap" ? "overlaysSamplesH" : "overlaysSamples1", false, false, false, "getOverlaysMemebersMenu", ["x", "smp"]]);
			a.push(["Sample Overlays Properties", this.graphType == "Heatmap" ? "overlaysSamplesHEdit" : "overlaysSamples1Edit", false, false, false, "getOverlaysPropertiesMenu", ["x", "smp"]]);
			a.push(["-"])
		}
		a.push(["Label Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "overlayFontColor"]]);
		a.push(["Label Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["overlay"]]);
		a.push(["Default Thickness", "widthSpace", false, false, false, "changeTextColorAttributeMenu", ["-text-", "overlaysThickness"]]);
		if (this.data.x || this.data.z) {
			a.push([this.showOverlays ? "Hide Overlays" : "Show Overlays", this.showOverlays ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showOverlays"]])
		}
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Overlays"]]);
		return a
	};
	this.getBinDataPercentileMenu = function(d) {
		var b = [];
		for (var a = 0; a < this.data.y.vars.length; a++) {
			if (d) {
				b.push([this.data.y.vars[a], "radioOff", "binDataByPercentile", [a, true]])
			} else {
				b.push([this.data.y.vars[a], "radioOff", "binDataByPercentile", [a]])
			}
		}
		return b
	};
	this.getBinDataQuantileMenu = function(d) {
		var b = [];
		for (var a = 0; a < this.data.y.vars.length; a++) {
			if (d) {
				b.push([this.data.y.vars[a], "radioOff", "binDataByQuantile", [a, true]])
			} else {
				b.push([this.data.y.vars[a], "radioOff", "binDataByQuantile", [a]])
			}
		}
		return b
	};
	this.getBinDataCustomBinMenu = function(b) {
		var c = [];
		for (var a = 2; a < 9; a++) {
			c.push([a + " bins", "radioOff", "binDataCustom", [b, a]])
		}
		return c
	};
	this.getBinDataCustomMenu = function() {
		var b = [];
		for (var a = 0; a < this.data.y.vars.length; a++) {
			b.push([this.data.y.vars[a], false, false, false, false, "getBinDataCustomBinMenu", [a]])
		}
		return b
	};
	this.getBinDataMenu = function() {
		var a = [];
		a.push(["By Percentile Discrete", "prcnt", false, false, false, "getBinDataPercentileMenu", []]);
		a.push(["By Percentile Continuous", "prcnt", false, false, false, "getBinDataPercentileMenu", [true]]);
		a.push(["By Quantile Discrete", "uq", false, false, false, "getBinDataQuantileMenu", []]);
		a.push(["By Quantile Continuous", "uq", false, false, false, "getBinDataQuantileMenu", [true]]);
		a.push(["Custom", "uc", false, false, false, "getBinDataCustomMenu", []]);
		return a
	};
	this.getGroupSamplesMenu = function() {
		if (this.data.x) {
			var d = [];
			var b = {};
			var a = this.sortObject(this.data.x);
			for (var c = 0; c < this.groupingFactors.length; c++) {
				b[this.groupingFactors[c]] = true
			}
			for (var c = 0; c < a.length; c++) {
				d.push([a[c], b[a[c]] ? "checked" : "unchecked", "showSampleGroups", [a[c]]])
			}
			return d
		} else {
			return false
		}
	};
	this.getSmpLabelHighlightLevelMenu = function() {
		var c = [];
		var b = {};
		var d = this.isGroupedData ? this.data.w : this.data.y;
		for (var a = 0; a < this.highlightSmp.length; a++) {
			b[this.highlightSmp[a]] = true
		}
		for (var a = 0; a < d.smps.length; a++) {
			c.push([d.smps[a], b[d.smps[a]] ? "checked" : "unchecked", "modifyObjectArray", [d.smps[a], false, "highlightSmp", true, true]])
		}
		return c
	};
	this.getSmpLabelHighlightMenu = function() {
		var a = [];
		a.push(["Samples", "samples", false, false, false, "getSmpLabelHighlightLevelMenu", []]);
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "smpHighlightColor"]]);
		return a
	};
	this.getSmpLabelMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "smpLabelFontColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["smpLabel"]]);
		a.push(["Highlight", this.graphType == "Heatmap" ? "highlightSampleLabelsH" : "highlightSampleLabels1", false, false, false, "getSmpLabelHighlightMenu", []]);
		a.push(["Interval", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", "smpLabelInterval"]]);
		a.push(["Rotate", "rotateClockwise", false, false, false, "changeTextColorAttributeMenu", ["-text-", "smpLabelRotate"]]);
		a.push([this.showSampleNames ? "Hide Labels" : "Show Labels", this.showSampleNames ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showSampleNames"]]);
		return a
	};
	this.getVarLabelHighlightLevelMenu = function() {
		var d = [];
		var c = {};
		var a = this.data.y.vars;
		for (var b = 0; b < this.highlightVar.length; b++) {
			c[this.highlightVar[b]] = true
		}
		for (var b = 0; b < a.length; b++) {
			d.push([a[b], c[a[b]] ? "checked" : "unchecked", "modifyObjectArray", [a[b], false, "highlightVar", true, true]])
		}
		return d
	};
	this.getVarLabelHighlightMenu = function() {
		var a = [];
		a.push(["Variables", "variables", false, false, false, "getVarLabelHighlightLevelMenu", []]);
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "varHighlightColor"]]);
		return a
	};
	this.getVarLabelMenu = function(b) {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "varLabelFontColor"]]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", ["varLabel"]]);
		a.push(["Highlight", "highlightVariableLabelsH", false, false, false, "getVarLabelHighlightMenu", []]);
		a.push(["Interval", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", "varLabelInterval"]]);
		a.push(["Rotate", "rotateClockwise", false, false, false, "changeTextColorAttributeMenu", ["-text-", "varLabelRotate"]]);
		a.push([this.showVariableNames ? "Hide Labels" : "Show Labels", this.showVariableNames ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showVariableNames"]]);
		return a
	};
	this.getGraphPartMenu = function(b, a) {
		var b = [];
		b.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", b + (a ? "FontColor" : "Color")]]);
		b.push(["Font", "fontSizeStyle", false, false, false, "getFontStyleMenu", [b]]);
		b.push(["Text", "normalFont", false, false, false, "changeTextColorAttributeMenu", ["-text-", b]]);
		return b
	};
	this.getFontStyleMenu = function(c) {
		var b = [];
		var a = "ScaleFontFactor";
		b.push(["Bigger", "biggerFont", "setFontAttributeSize", [c + a, "increase"]]);
		b.push(["Smaller", "smallerFont", "setFontAttributeSize", [c + a, "decrease"]]);
		b.push(["Normal", "normalFont", "setFontAttributeStyle", [c + "FontStyle", "normal"]]);
		b.push(["Bold", "boldFont", "setFontAttributeStyle", [c + "FontStyle", "bold"]]);
		b.push(["Italic", "italicFont", "setFontAttributeStyle", [c + "FontStyle", "italic"]]);
		return b
	};
	this.getDataPointAttributesPropertyMenu = function(d) {
		var e = [];
		var c = this.graphType.match(/scatter/i) ? this.sortObject(this.data.z) : this.sortObject(this.data.x);
		for (var a = 0; a < c.length; a++) {
			e.push([c[a], c[a] == this[d] ? "radioOn" : "radioOff", "changeAttribute", [d, c[a]]])
		}
		e.push(["-"]);
		var a = "variable";
		if (d != "connectBy") {
			e.push(["Variable", a == this[d] ? "radioOn" : "radioOff", "changeAttribute", [d, a]])
		}
		if (!this.graphType.match(/scatter/i) && this.data.z) {
			var b = this.sortObject(this.data.z);
			if (d != "connectBy") {
				e.push(["-"])
			}
			for (var a = 0; a < b.length; a++) {
				if (d != "connectBy") {
					e.push([b[a], b[a] == this[d] ? "radioOn" : "radioOff", "changeAttribute", [d, b[a]]])
				}
			}
		}
		return e
	};
	this.getDataPointAttributesMenu = function() {
		var a = [];
		a.push(["Color By", "colors", false, false, false, "getDataPointAttributesPropertyMenu", ["colorBy"]]);
		if (this.graphType.match(/scatter/i) || this.is3DPlot || this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData)) {
			a.push(["Shape By", "shapes", false, false, false, "getDataPointAttributesPropertyMenu", ["shapeBy"]]);
			a.push(["Size By", "sizes", false, false, false, "getDataPointAttributesPropertyMenu", ["sizeBy"]])
		}
		a.push(["Pattern By", "patterns", false, false, false, "getDataPointAttributesPropertyMenu", ["patternBy"]]);
		if (this.graphType.match(/scatter/i) || this.is3DPlot || this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData)) {
			a.push(["Connect By", "connects", false, false, false, "getDataPointAttributesPropertyMenu", ["connectBy"]])
		}
		if (this.graphType.match(/scatter/i)) {
			a.push(["Ellipse By", "ellipses", false, false, false, "getDataPointAttributesPropertyMenu", ["ellipseBy"]])
		}
		return a
	};
	this.getDendrogramsMenu = function() {
		var a = [];
		if (this.graphType == "Heatmap") {
			a.push(["Cluster Variable", "clusterVariables", "clusterVariables", [true]]);
			a.push(["K-Means Variable", "kmeansVariables", "kmeansVariables", [true]]);
			if (this.varDendrogram) {
				if (this.showVarDendrogram) {
					a.push(["Hide Dendrogram", "eyeMinusIcon", "showHideDendrogram", ["showVarDendrogram"]])
				} else {
					a.push(["Show Dendrogram", "eyePlusIcon", "showHideDendrogram", ["showVarDendrogram"]])
				}
			}
			a.push(["-"])
		}
		a.push(["Cluster Samples", "clusterSamples", "clusterSamples", [true]]);
		a.push(["K-Means Samples", "kmeansSamples", "kmeansSamples", [true]]);
		if (this.smpDendrogram) {
			if (this.showSmpDendrogram) {
				a.push(["Hide Dendrogram", "eyeMinusIcon", "showHideDendrogram", ["showSmpDendrogram"]])
			} else {
				a.push(["Show Dendrogram", "eyePlusIcon", "showHideDendrogram", ["showSmpDendrogram"]])
			}
		}
		a.push(["-"]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Clustering"]]);
		return a
	};
	this.getGraphTypeMenu = function() {
		var a = [];
		a.push(["Area", "area", "changeAttribute", ["graphType", "Area"], "Shit + Alt + A"]);
		a.push(["Area Line", "areaLine", "changeAttribute", ["graphType", "AreaLine"], "Shit + Alt + F"]);
		a.push(["Bar", "bar", "changeAttribute", ["graphType", "Bar"], "Shit + Alt + B"]);
		a.push(["Bar Line", "barLine", "changeAttribute", ["graphType", "BarLine"], "Shit + Alt + C"]);
		a.push(["Boxplot", "boxplot", "changeAttribute", ["graphType", "Boxplot"], "Shit + Alt + I"]);
		a.push(["Circular", "circular", "changeAttribute", ["graphType", "Circular"]]);
		a.push(["Correlation", "correlation", "changeAttribute", ["graphType", "Correlation"], "Shit + Alt + X"]);
		a.push(["Dot Line", "dotplotLine", "changeAttribute", ["graphType", "DotLine"], "Shit + Alt + E"]);
		a.push(["Dotplot", "dotplot", "changeAttribute", ["graphType", "Dotplot"], "Shit + Alt + D"]);
		a.push(["Heatmap", "heatmap", "changeAttribute", ["graphType", "Heatmap"], "Shit + Alt + H"]);
		a.push(["Line", "line", "changeAttribute", ["graphType", "Line"], "Shit + Alt + L"]);
		a.push(["Pie Chart", "pie", "changeAttribute", ["graphType", "Pie"], "Shit + Alt + P"]);
		if (this.data.y.smps.length > 1) {
			a.push(["Scatter 2D", "scatter2d", "changeAttribute", ["graphType", "Scatter2D"], "Shit + Alt + 2"])
		}
		if (this.data.y.smps.length > 2) {
			a.push(["Scatter Bubble 2D", "scatterBubble2d", "changeAttribute", ["graphType", "ScatterBubble2D"], "Shit + Alt + 4"]);
			a.push(["Scatter 3D", "scatter3d", "changeAttribute", ["graphType", "Scatter3D"], "Shit + Alt + 3"])
		}
		a.push(["Stacked", "stacked", "changeAttribute", ["graphType", "Stacked"], "Shit + Alt + S"]);
		a.push(["Stacked Line", "stackedLine", "changeAttribute", ["graphType", "StackedLine"], "Shit + Alt + U"]);
		a.push(["Stacked Percent", "stackedPercent", "changeAttribute", ["graphType", "StackedPercent"], "Shit + Alt + T"]);
		a.push(["Stacked Percent Line", "stackedPercentLine", "changeAttribute", ["graphType", "StackedPercentLine"], "Shit + Alt + W"]);
		a.push(["Tag Cloud", "tagCloud", "changeAttribute", ["graphType", "TagCloud"]]);
		a.push(["Treemap", "treemap", "changeAttribute", ["graphType", "Treemap"]]);
		return a
	};
	this.getGraphOrientationMenu = function() {
		var a = [];
		a.push(["Horizontal", "graphOrientationHorizontal", "changeAttribute", ["graphOrientation", "horizontal"]]);
		a.push(["Vertical", "graphOrientationVertical", "changeAttribute", ["graphOrientation", "vertical"]]);
		return a
	};
	this.getMarginsMenu = function() {
		var a = [];
		a.push(["General", "margin", false, false, false, "changeTextColorAttributeMenu", ["-text-", "margin"]]);
		a.push(["-"]);
		a.push(["Bottom", "marginBottom", false, false, false, "changeTextColorAttributeMenu", ["-text-", "marginBottom"]]);
		a.push(["Left", "marginLeft", false, false, false, "changeTextColorAttributeMenu", ["-text-", "marginLeft"]]);
		a.push(["Top", "marginTop", false, false, false, "changeTextColorAttributeMenu", ["-text-", "marginTop"]]);
		a.push(["Right", "marginRight", false, false, false, "changeTextColorAttributeMenu", ["-text-", "marginRight"]]);
		return a
	};
	this.getShadesMenu = function() {
		var a = [];
		a.push(["Objects", "shadow", "toggleAttribute", ["showShadow"]]);
		a.push(["Text", "textShadow", "toggleAttribute", ["showTextShadow"]]);
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "shadowColor"]]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Shadows"]]);
		return a
	};
	this.getCanvasBorderMenu = function() {
		var a = [];
		a.push(["Color", "colors", false, false, false, "changeTextColorAttributeMenu", ["-color-", "canvasBoxColor"]]);
		a.push([this.canvasBox ? "Hide Border" : "Show Border", this.canvasBox ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["canvasBox"]]);
		return a
	};
	this.getGradientsOrientationMenu = function() {
		var a = [];
		a.push(["Horizontal", "gradientHorizontal", "changeAttribute", ["gradientOrientation", "horizontal"]]);
		a.push(["Vertical", "gradientVertical", "changeAttribute", ["gradientOrientation", "vertical"]]);
		return a
	};
	this.getGradientsTypeMenu = function() {
		var a = [];
		a.push(["Linear", "gradientVertical", "changeAttribute", ["gradientType", "linear"]]);
		a.push(["Radial", "gradientRadial", "changeAttribute", ["gradientType", "radial"]]);
		return a
	};
	this.getGradientsMenu = function() {
		var a = [];
		a.push(["Gradient", "gradientToggle", "toggleAttribute", ["gradient"]]);
		a.push(["Orientation", "gradientOrientation", false, false, false, "getGradientsOrientationMenu", []]);
		a.push(["Type", "gradientType", false, false, false, "getGradientsTypeMenu", []]);
		a.push(["-"]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Gradients"]]);
		return a
	};
	this.getBackgroundTypeMenu = function() {
		var a = [];
		a.push(["Solid", "background", "changeAttribute", ["backgroundType", "solid", "solid"]]);
		a.push(["Gradient", "backgroundGradient", "changeAttribute", ["backgroundType", "gradient", "gradient"]]);
		a.push(["Solid Window", "backgroundWindow", "changeAttribute", ["backgroundType", "window", "window"]]);
		a.push(["Solid Window on Gradient", "backgroundWindowGradient", "changeAttribute", ["backgroundType", "windowGradient", "windowGradient"]]);
		a.push(["Gradient Window on Solid", "backgroundGradientWindow", "changeAttribute", ["backgroundType", "windowSolidGradient", "windowSolidGradient"]]);
		return a
	};
	this.getBackgroundMenu = function() {
		var a = [];
		a.push(["Type", "backgroundType", false, false, false, "getBackgroundTypeMenu", []]);
		a.push(["-"]);
		a.push(["Area Solid", "background", false, false, false, "changeTextColorAttributeMenu", ["-color-", "background"]]);
		a.push(["Area Gradient Start Color", "backgroundGradient", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundGradient1Color"]]);
		a.push(["Area Gradient End Color", "backgroundGradient", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundGradient2Color"]]);
		a.push(["-"]);
		a.push(["Window Solid", "backgroundWindow", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundWindow"]]);
		a.push(["Window Gradient Start Color", "backgroundGradientWindow", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundWindowGradient1Color"]]);
		a.push(["Window Gradient End Color", "backgroundGradientWindow", false, false, false, "changeTextColorAttributeMenu", ["-color-", "backgroundWindowGradient2Color"]]);
		a.push(["-"]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Background"]]);
		return a
	};
	this.getFontsSizeStyleMenu = function() {
		var a = [];
		a.push(["Bigger", "biggerFont", "setFontAttributeSize", ["fontScaleFontFactor", "increase"]]);
		a.push(["Smaller", "smallerFont", "setFontAttributeSize", ["fontScaleFontFactor", "decrease"]]);
		a.push(["Normal", "normalFont", "setFontAttributeStyle", ["fontStyle", "normal"]]);
		a.push(["Bold", "boldFont", "setFontAttributeStyle", ["fontStyle", "bold"]]);
		a.push(["Italic", "italicFont", "setFontAttributeStyle", ["fontStyle", "italic"]]);
		return a
	};
	this.getFontsMenu = function() {
		var a = [];
		a.push(["Size and Style", "fontSizeStyle", false, false, false, "getFontsSizeStyleMenu", []]);
		a.push(["Courier", false, "changeAttribute", ["fontName", "Courier", "Courier"]]);
		a.push(["Arial", false, "changeAttribute", ["fontName", "Arial", "Arial"]]);
		a.push(["Verdana", false, "changeAttribute", ["fontName", "Verdana", "Verdana"]]);
		a.push(["Indie Flower", false, "changeAttribute", ["fontName", "Indie Flower", "Indie Flower"]]);
		a.push(["Ubuntu", false, "changeAttribute", ["fontName", "Ubuntu", "Ubuntu"]]);
		a.push(["-"]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Text"]]);
		return a
	};
	this.getLayoutVarMenu = function() {
		var d = [];
		var a = {};
		for (var b = 0; b < this.segregateVariablesBy.length; b++) {
			a[this.segregateVariablesBy[b]] = true
		}
		if (this.data.z) {
			var c = this.sortObject(this.data.z);
			for (var b = 0; b < c.length; b++) {
				d.push([c[b], a[c[b]] ? "checked" : "unchecked", "showVariableSegregation", [c[b]]])
			}
			d.push(["-"])
		}
		d.push(["variable", a.variable ? "checked" : "unchecked", "showVariableSegregation", ["variable"]]);
		return d
	};
	this.getLayoutSmpMenu = function() {
		var a = [];
		var d = {};
		for (var c = 0; c < this.segregateSamplesBy.length; c++) {
			d[this.segregateSamplesBy[c]] = true
		}
		if (this.data.x) {
			var b = this.sortObject(this.data.x);
			for (var c = 0; c < b.length; c++) {
				a.push([b[c], d[b[c]] ? "checked" : "unchecked", "showSampleSegregation", [b[c]]])
			}
			a.push(["-"])
		}
		a.push(["sample", d.sample ? "checked" : "unchecked", "showSampleSegregation", ["sample"]]);
		return a
	};
	this.getLayoutMenu = function() {
		var a = [];
		if (!this.graphType.match(/Scatter/) && !this.is3DPlot) {
			a.push(["Segregate Samples By", "samples", false, false, false, "getLayoutSmpMenu", []]);
			a.push(["Segregate Variables By", "variables", false, false, false, "getLayoutVarMenu", []])
		}
		return a
	};
	this.getSegregationMenu = function() {
		var d = [];
		var c = {};
		var d = [];
		if (this.data.z) {
			var e = this.sortObject(this.data.z);
			for (var b = 0; b < this.segregateVariablesBy.length; b++) {
				c[this.segregateVariablesBy[b]] = true
			}
			for (var b = 0; b < e.length; b++) {
				d.push([e[b], c[e[b]] ? "checked" : "unchecked", "showVariableSegregation", [e[b]]])
			}
			d.push(["-"])
		}
		if (this.data.x) {
			var a = this.sortObject(this.data.x);
			for (var b = 0; b < this.segregateSamplesBy.length; b++) {
				c[this.segregateSamplesBy[b]] = true
			}
			for (var b = 0; b < a.length; b++) {
				d.push([a[b], c[a[b]] ? "checked" : "unchecked", "showSampleSegregation", [a[b]]])
			}
			d.push(["-"])
		}
		d.push(["variable", c.variable ? "checked" : "unchecked", "showVariableSegregation", ["variable"]]);
		d.push(["sample", c.sample ? "checked" : "unchecked", "showSampleSegregation", ["sample"]]);
		if (!this.graphType.match(/Scatter/) && !this.is3DPlot && d.length > 0) {
			return d
		} else {
			return false
		}
	};
	this.getColorSpectrumMenu = function(b, g, m, l, k) {
		var c = [];
		var a = this.getObjectArray(b);
		var f = this.getColorNames();
		for (var e = 0; e < f.length; e++) {
			if (a[f[e]]) {
				var h = 0;
				for (var d = 0; d < b.length; d++) {
					if (f[e] == b[d]) {
						h = d;
						break
					}
				}
				if (m && l && k) {
					c.push([f[e] + " (" + (h + 1) + ")", "checked", g, [f[e], m, l, k]])
				} else {
					c.push([f[e] + " (" + (h + 1) + ")", "checked", g, [f[e]]])
				}
			} else {
				if (m && l && k) {
					c.push([f[e], "unchecked", g, [f[e], m, l, k]])
				} else {
					c.push([f[e], "unchecked", g, [f[e]]])
				}
			}
		}
		return c
	};
	this.getColorSchemeMenu = function(e, f) {
		var d = [];
		var a = this.getColorSchemes();
		for (var b = 0; b < a.length; b++) {
			d.push([a[b], this[e] == a[b] ? "radioOn" : "radioOff", "changeAttribute", [e, a[b], false, f]])
		}
		return d
	};
	this.getColorsSpectrumCompMenu = function() {
		var a = [];
		a.push(["Colors", "colors", false, false, false, "getColorSpectrumMenu", [this.colorSpectrum, "changeColorSpectrum"]]);
		a.push(["Zero-Center", "z", false, false, false, "changeTextColorAttributeMenu", ["-text-", [false, "changeColorSpectrumZeroValue", []]]]);
		return a
	};
	this.getColorsMenu = function() {
		var a = [];
		a.push(["Scheme", "palette", false, false, false, "getColorSchemeMenu", ["colorScheme", "changeColorScheme"]]);
		a.push(["Spectrum", "indicatorCenterRainbow", false, false, false, "getColorsSpectrumCompMenu", []]);
		return a
	};
	this.getGeneralMenu = function() {
		var a = [];
		a.push(["Background", "background", false, false, false, "getBackgroundMenu", []]);
		a.push(["Border", "border", false, false, false, "getCanvasBorderMenu", []]);
		a.push(["Color", "colors", false, false, false, "getColorsMenu", []]);
		a.push(["Font", "fontSizeStyle", false, false, false, "getFontsMenu", []]);
		a.push(["Gradients", "gradientDiagonal", false, false, false, "getGradientsMenu", []]);
		if (!this.graphType.match(/Scatter/) && !this.is3DPlot) {
			a.push(["Graph Orientation", "graphOrientation", false, false, false, "getGraphOrientationMenu", []])
		}
		a.push(["Graph Type", "graphType", false, false, false, "getGraphTypeMenu", []]);
		if (!this.graphType.match(/Scatter/) && !this.is3DPlot) {
			a.push(["Layout", "segregate", false, false, false, "getLayoutMenu", []])
		}
		a.push(["Margins", "margin", false, false, false, "getMarginsMenu", []]);
		a.push(["Shadows", "shadow", false, false, false, "getShadesMenu", []]);
		a.push(["Transparency", "transparency", false, false, false, "changeTextColorAttributeMenu", ["-text-", "transparency"]]);
		return a
	};
	this.getSwitchSmpToAnnotationMenu = function() {
		var b = [];
		for (var a = 0; a < this.data.y.smps.length; a++) {
			b.push([this.data.y.smps[a], "radioOff", "switchSmpToAnnotation", [this.data.y.smps[a]]])
		}
		return b
	};
	this.getSwitchAnnotationToSmpMenu = function() {
		var c = [];
		var b = this.sortObject(this.data.z);
		for (var a = 0; a < b.length; a++) {
			if (this.meta.data.z[b[a]] && this.meta.data.z[b[a]].type == "Numeric") {
				c.push([b[a], "radioOff", "switchAnnotationToSmp", [b[a]]])
			}
		}
		return c
	};
	this.getSwitchVarToAnnotationMenu = function() {
		var a = [];
		for (var b = 0; b < this.data.y.vars.length; b++) {
			a.push([this.data.y.vars[b], "radioOff", "switchVarToAnnotation", [this.data.y.vars[b]]])
		}
		return a
	};
	this.getSwitchAnnotationToVarMenu = function() {
		var b = [];
		var a = this.sortObject(this.data.x);
		for (var c = 0; c < a.length; c++) {
			if (this.meta.data.x[a[c]] && this.meta.data.x[a[c]].type == "Numeric") {
				b.push([a[c], "radioOff", "switchAnnotationToVar", [a[c]]])
			}
		}
		return b
	};
	this.getSwitchSamplesMenu = function() {
		var a = [];
		a.push(["Sample to Annotation", "switchb", false, false, false, "getSwitchSmpToAnnotationMenu", []]);
		if (this.data.z && this.isNumericFactor("v")) {
			a.push(["Annotation to Sample", "switchu", false, false, false, "getSwitchAnnotationToSmpMenu", []])
		}
		return a
	};
	this.getSwitchVariablesMenu = function() {
		var a = [];
		a.push(["Variable to Annotation", "switchb", false, false, false, "getSwitchVarToAnnotationMenu", []]);
		if (this.data.x && this.isNumericFactor("s")) {
			a.push(["Annotation to Variable", "switchu", false, false, false, "getSwitchAnnotationToVarMenu", []])
		}
		return a
	};
	this.getSwitchMenu = function() {
		var a = [];
		a.push(["Samples", "samples", false, false, false, "getSwitchSamplesMenu", []]);
		a.push(["Variables", "variables", false, false, false, "getSwitchVariablesMenu", []]);
		return a
	};
	this.getConvertNumericToStringMenu = function(e) {
		var b = [];
		var d = this.sortObject(this.data[e]);
		for (var a = 0; a < d.length; a++) {
			if (this.meta.data[e][d[a]] && this.meta.data[e][d[a]].type == "Numeric") {
				b.push([d[a], "radioOff", "switchNumericToString", [d[a], true]])
			}
		}
		return b
	};
	this.getConvertStringToNumericMenu = function(e) {
		var b = [];
		var d = this.sortObject(this.data[e]);
		for (var a = 0; a < d.length; a++) {
			if (this.meta.data[e][d[a]] && this.meta.data[e][d[a]].type != "Numeric") {
				b.push([d[a], "radioOff", "switchStringToNumeric", [d[a], true]])
			}
		}
		return b
	};
	this.getConvertVarSmpMenu = function(d, a) {
		var b = [];
		if (this.isNumericFactor(a)) {
			b.push(["Numeric to String", "convertNumberString", false, false, false, "getConvertNumericToStringMenu", [d]])
		}
		if (this.isStringFactor(a)) {
			b.push(["String to Numeric", "convertStringNumber", false, false, false, "getConvertStringToNumericMenu", [d]])
		}
		return b
	};
	this.getConvertMenu = function() {
		var a = [];
		if (this.data.x) {
			a.push(["Samples", "samples", false, false, false, "getConvertVarSmpMenu", ["x", "s"]])
		}
		if (this.data.z) {
			a.push(["Variables", "variables", false, false, false, "getConvertVarSmpMenu", ["z", "v"]])
		}
		return a
	};
	this.getTransformLogMenu = function() {
		var a = [];
		a.push([2, this.transformBase == "2" ? "radioOn" : "radioOff", "changeAttribute", ["transformBase", "2", 2]]);
		a.push([10, this.transformBase == "10" ? "radioOn" : "radioOff", "changeAttribute", ["transformBase", "10", 2]]);
		return a
	};
	this.getTransformPercentMenu = function() {
		var a = [];
		a.push(["By Sample", "samples", "transform", ["percentile", "samples"]]);
		a.push(["By Variable", "variables", "transform", ["percentile", "variables"]]);
		return a
	};
	this.getTransformZScoreMenu = function() {
		var a = [];
		a.push(["By Sample", "samples", "transform", ["zscore", "samples"]]);
		a.push(["By Variable", "variables", "transform", ["zscore", "variables"]]);
		return a
	};
	this.getTransformRatioMenu = function() {
		var a = [];
		a.push(["To Sample", "samples", false, false, false, "getTransformRatioSmpMenu", []]);
		if (this.data.x && this.isGroupedData) {
			a.push(["To Group", "groups", false, false, false, "getTransformRatioGrpMenu", []]);
			if (this.ratioGroupReference && this.data.x.hasOwnProperty(this.ratioGroupReference)) {
				a.push(["To Level", "levels", false, false, false, "getTransformRatioLevMenu", []])
			}
		}
		a.push(["-"]);
		a.push(["Log Base", this.transformBase == "2" ? "log2" : "log10", false, false, false, "getTransformLogMenu", []]);
		return a
	};
	this.getTransformRatioLevMenu = function() {
		var c = [];
		var a = this.sortObject(this.getObjectArray(this.data.x[this.ratioGroupReference]));
		for (var b = 0; b < a.length; b++) {
			if (a[b] != null) {
				c.push([a[b], this.ratioLevelReference == a[b] ? "radioOn" : "radioOff", "changeTransformRatio", ["level", a[b]]])
			}
		}
		return c
	};
	this.getTransformRatioGrpMenu = function() {
		var b = [];
		var a = this.sortObject(this.data.x);
		for (var c = 0; c < a.length; c++) {
			b.push([a[c], this.ratioGroupReference == a[c] ? "radioOn" : "radioOff", "changeTransformRatio", ["group", a[c]]])
		}
		return b
	};
	this.getTransformRatioSmpMenu = function() {
		var c = [];
		for (var a = 0; a < this.data.y.smps.length; a++) {
			var b = this.data.y.smps[a];
			c.push([b, this.ratioSampleReference == b ? "radioOn" : "radioOff", "changeTransformRatio", ["sample", b]])
		}
		return c
	};
	this.getTransformMenu = function() {
		var a = [];
		a.push(["Log Base 2", "log2", "transform", ["log2"]]);
		a.push(["Log Base 10", "log10", "transform", ["log10"]]);
		a.push(["Exp Base 2", "exp2", "transform", ["exp2"]]);
		a.push(["Exp Base 10", "exp10", "transform", ["exp10"]]);
		a.push(["Ceil data", "ceil", false, false, false, "changeTextColorAttributeMenu", ["-text-", [false, "modifyTransform", ["tceil"]]]]);
		a.push(["Floor data", "floor", false, false, false, "changeTextColorAttributeMenu", ["-text-", [false, "modifyTransform", ["tfloor"]]]]);
		a.push(["Percentile", "percent2", false, false, false, "getTransformPercentMenu", []]);
		a.push(["Z-Score", "zScore", false, false, false, "getTransformZScoreMenu", []]);
		a.push(["Ratio", "ratio", false, false, false, "getTransformRatioMenu", []]);
		a.push(["-"]);
		a.push(["Reset", "refreshForm", "transform", ["reset"]]);
		a.push(["-"]);
		a.push(["Overwrite data", "disk", "transform", ["save"]]);
		return a
	};
	this.getAxisTransformMenu = function(b) {
		var c = [];
		b = b.toLowerCase();
		c.push(["Log Base 2", "log2", "changeAttribute", [b + "AxisTransform", "log2"]]);
		c.push(["Log Base 10", "log10", "changeAttribute", [b + "AxisTransform", "log10"]]);
		c.push(["Exp Base 2", "exp2", "changeAttribute", [b + "AxisTransform", "exp2"]]);
		c.push(["Exp Base 10", "exp10", "changeAttribute", [b + "AxisTransform", "exp10"]]);
		c.push(["Percentile", "percent2", "changeAttribute", [b + "AxisTransform", "exp10"]]);
		c.push(["-"]);
		c.push(["Reset", "refreshForm", "changeAttribute", [b + "AxisTransform", false]]);
		return c
	};
	this.getSortSmpIntensityMenu = function() {
		var c = [];
		var a = {};
		if (this.sortingSamples) {
			for (var b = 0; b < this.sortingSamples.length; b++) {
				a[this.sortingSamples[b]] = true
			}
		}
		for (var b = 0; b < this.data.y.smps.length; b++) {
			c.push([this.data.y.smps[b], a[b + 1] ? "radioOn" : "radioOff", "showSorting", ["smp", "var", this.data.y.smps[b]]])
		}
		return c
	};
	this.getSortVarIntensityMenu = function() {
		var c = [];
		var a = {};
		if (this.sortingVariables) {
			for (var b = 0; b < this.sortingVariables.length; b++) {
				a[this.sortingVariables[b]] = true
			}
		}
		for (var b = 0; b < this.data.y.vars.length; b++) {
			c.push([this.data.y.vars[b], a[b + 1] ? "radioOn" : "radioOff", "showSorting", ["var", "smp", this.data.y.vars[b]]])
		}
		return c
	};
	this.getSortSmpCatMenu = function() {
		var d = [];
		var b = {};
		var a = this.sortObject(this.data.x);
		if (this.sortingSampleCategories) {
			for (var c = 0; c < this.sortingSampleCategories.length; c++) {
				b[this.sortingSampleCategories[c]] = true
			}
		}
		for (var c = 0; c < a.length; c++) {
			d.push([a[c], b[a[c]] ? "checked" : "unchecked", "showSorting", ["cat", "smp", a[c]]])
		}
		return d
	};
	this.getSorVarCatMenu = function() {
		var d = [];
		var a = {};
		var c = this.sortObject(this.data.z);
		if (this.sortingVariableCategories) {
			for (var b = 0; b < this.sortingVariableCategories.length; b++) {
				a[this.sortingVariableCategories[b]] = true
			}
		}
		for (var b = 0; b < c.length; b++) {
			d.push([c[b], a[c[b]] ? "checked" : "unchecked", "showSorting", ["cat", "var", c[b]]])
		}
		return d
	};
	this.getSortSmpMenu = function() {
		var a = [];
		a.push(["By Variable Intensity", "variables", false, false, false, "getSortVarIntensityMenu", []]);
		if (this.data.x) {
			a.push(["By Sample Category", "X", false, false, false, "getSortSmpCatMenu", []])
		}
		return a
	};
	this.getSortVarMenu = function() {
		var a = [];
		a.push(["By Sample Intensity", "samples", false, false, false, "getSortSmpIntensityMenu", []]);
		if (this.data.z) {
			a.push(["By Variable Category", "z", false, false, false, "getSorVarCatMenu", []])
		}
		return a
	};
	this.getSortMenu = function() {
		var a = [];
		a.push(["Sort Samples", "samples", false, false, false, "getSortSmpMenu", []]);
		a.push(["Sort Variables", "variables", false, false, false, "getSortVarMenu", []]);
		return a
	};
	this.getSliderMenu = function() {
		var a = [];
		for (var b in this.binConfigurations) {
			a.push([b, false, false, false, false, [
				["-slider-", "changeBin", [b]]
			]])
		}
		return a
	};
	this.getPivotMenu = function() {
		var b = [];
		if (this.isPivotable()) {
			if (this.data.y.vars.length == 3) {
				var c = this.data.y.vars;
				b.push([c[0] + " as Variables; " + c[1] + " as Samples", "radioOff", "pivotYY", [c[0], c[1]]]);
				b.push([c[0] + " as Variables; " + c[2] + " as Samples", "radioOff", "pivotYY", [c[0], c[2]]]);
				b.push([c[1] + " as Variables; " + c[0] + " as Samples", "radioOff", "pivotYY", [c[1], c[0]]]);
				b.push([c[1] + " as Variables; " + c[2] + " as Samples", "radioOff", "pivotYY", [c[1], c[2]]]);
				b.push([c[2] + " as Variables; " + c[0] + " as Samples", "radioOff", "pivotYY", [c[2], c[0]]]);
				b.push([c[2] + " as Variables; " + c[1] + " as Samples", "radioOff", "pivotYY", [c[2], c[1]]])
			} else {
				if (this.data.y.vars.length == 2) {
					var c = this.data.y.vars;
					var a = this.getKeys(this.data.x);
					b.push([a[0] + " as Variables; " + c[0] + " as Samples", "radioOff", "pivotXY", [a[0], c[0]]]);
					b.push([a[0] + " as Variables; " + c[1] + " as Samples", "radioOff", "pivotXY", [a[0], c[1]]]);
					b.push([c[0] + " as Variables; " + a[0] + " as Samples", "radioOff", "pivotXY", [c[0], a[0]]]);
					b.push([c[1] + " as Variables; " + a[0] + " as Samples", "radioOff", "pivotXY", [c[1], a[0]]])
				} else {
					var a = this.getKeys(this.data.x);
					b.push([a[0] + " as Variables; " + a[1] + " as Samples", "radioOff", "pivotXX", [a[0], a[1]]]);
					b.push([a[1] + " as Variables; " + a[0] + " as Samples", "radioOff", "pivotXX", [a[1], a[0]]])
				}
			}
		}
		return b
	};
	this.getRdatasetsMenu = function() {
		var a = [];
		if (this.Rdatasets) {
			var c = this.sortObject(this.Rdatasets);
			c = c.sort(function(e, d) {
				return e.toLowerCase() > d.toLowerCase()
			});
			for (var b = 0; b < c.length; b++) {
				a.push([c[b], "radioOff", "getRLibraryDataSets", [c[b]]])
			}
		}
		return a
	};
	this.getRangeMenu = function() {
		var a = [];
		a.push(["Set Min", "minimumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMinX"]]);
		a.push(["Set Max", "maximumValue", false, false, false, "changeTextColorAttributeMenu", ["-text-", "setMaxX"]]);
		a.push(["Exact Range", "exactValue", "toggleAttribute", ["xAxisExact"]]);
		return a
	};
	this.getDataMenu = function() {
		var a = [];
		if (this.isBinConfigurations()) {
			a.push(["Configure Bins", "ub", false, false, false, "getSliderMenu", []])
		}
		if (this.data.x || this.data.z) {
			a.push(["Convert Annotations", "convert", false, false, false, "getConvertMenu", []])
		}
		if (this.graphType == "Heatmap") {
			a.push(["Range", "range", false, false, false, "getRangeMenu", []])
		}
		a.push(["Switch Data", "switch", false, false, false, "getSwitchMenu", []]);
		if (!this.graphType.match(/Scatter/i)) {
			a.push(["Sort", "sortAsciiAsc", false, false, false, "getSortMenu", []])
		}
		a.push(["Transform", "transform", false, false, false, "getTransformMenu", []]);
		if (!this.layoutValid) {
			a.push(["Transpose", "transposeData", "transpose"])
		}
		if (this.isPivotable()) {
			a.push(["Pivot", "pivot", false, false, false, "getPivotMenu", []])
		}
		if (!this.layoutValid) {
			a.push(["Bin Data", "binData", false, false, false, "getBinDataMenu", []])
		}
		return a
	};
	this.getLoessMenu = function() {
		return [
			[this.showLoessFit ? "Hide Loess Fit" : "Show Loess Fit", this.showLoessFit ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showLoessFit"]]
		]
	};
	this.getHistogramDensityMenu = function() {
		var b = ["epanechnikovKernel", "uniformKernel", "triangularKernel", "quarticKernel", "triweightKernel", "gaussianKernel", "cosineKernel"];
		var a = [];
		for (var d = 0; d < b.length; d++) {
			var c = b[d].replace("Kernel", "");
			a.push([c, b[d] == this.histogramDensityKernel ? "radioOn" : "radioOff", "changeAttribute", ["histogramDensityKernel", b[d], false, "modifyHistogram"]])
		}
		return a
	};
	this.getHistogramMenu = function() {
		var a = [];
		a.push(["Bin Number", "editNumber", false, false, false, "changeTextColorAttributeMenu", ["-text-", ["histogramBins", "modifyHistogram"]]]);
		a.push(["Density Kernel", "kernelHistogram", false, false, false, "getHistogramDensityMenu", []]);
		a.push(["Remove Histogram", "removeHistogram", "removeHistogram"]);
		a.push([this.showHistogramDensity ? "Hide Density" : "Show Density", this.showHistogramDensity ? "eyeMinusIcon" : "eyePlusIcon", "toggleAttribute", ["showHistogramDensity", "modifyHistogram"]]);
		a.push(["Stagger Histograms", "histogramStagger", "toggleAttribute", ["histogramStagger", "modifyHistogram"]]);
		a.push(["More", "more", "showConfiguratorCategory", ["event", "Histograms"]]);
		return a
	};
	this.getDOEMenu = function() {
		var d = [];
		var c = this.initialGraphType.match(/Scatter/) ? this.getKeys(this.dataStndBy.z) : this.getKeys(this.dataStndBy.x);
		var a = this.getObjectArray(this.includeDOE);
		for (var b = 0; b < c.length; b++) {
			d.push([c[b], a[c[b]] ? "checked" : "unchecked", "modifyDOE", [c[b]]])
		}
		return d
	};
	this.getCorrelationCatMenu = function(f, d) {
		var b = [];
		var e = this.sortObject(this.data[f]);
		for (var a = 0; a < e.length; a++) {
			if (this.isNumeric(this.data[f][e[a]])) {
				b.push([e[a], "radioOff", "correlateData", [d, e[a]]])
			}
		}
		return b
	};
	this.getCorrelationMenu = function() {
		var b = [];
		var a = [];
		if (this.data.y.vars.length > 3) {
			b.push(["Samples", "samples", "correlateData"])
		}
		if (this.data.y.smps.length > 3 && this.data.x && this.isNumericFactor("s")) {
			b.push(["Sample Annotation", "samples", false, false, false, "getCorrelationCatMenu", ["x", true]])
		}
		if (this.data.y.smps.length > 3) {
			b.push(["Variables", "variables", "correlateData", [true]])
		}
		if (this.data.y.vars.length > 3 && this.data.z && this.isNumericFactor("v")) {
			b.push(["Variable Annotation", "variables", false, false, false, "getCorrelationCatMenu", ["z", false]])
		}
		return b
	};
	this.getParametersMenu = function() {
		var a = [];
		a.push(["Load Parameters", "add2", true, []]);
		a.push(["Save as JSON", "disk", "save", []]);
		return a
	};
	this.getFileMenu = function() {
		var a = [];
		a.push(["Save as PNG", "camera", "print", [], "Ctrl + P"]);
		a.push(["Save as JSON", "disk", "save", []]);
		a.push(["-"]);
		a.push(["Reproducible Research", "RepRsrch", "clickRepResearch", []]);
		a.push(["Show JSON code", "purpleCode", "clickShowCode", []]);
		a.push(["Reproduce", "redo", "reproduce", [], "Ctrl + Alt + R"]);
		if (this.remoteService && this.remoteServiceType == "webService") {
			a.push(["Save parameters to server", "disk", "saveRemote", ["params"]]);
			a.push(["Clear parameters from server", "deleteSaved", "clearRemote", []])
		}
		a.push(["-"]);
		a.push(["Load", "add2", true, []]);
		if (this.Rdatasets) {
			a.push(["R Datasets", "CRAN", false, false, false, "getRdatasetsMenu", []])
		}
		a.push(["-"]);
		a.push(["Parameters", "cog", false, false, false, "getParametersMenu", []]);
		a.push(["-"]);
		a.push(["Reset", "refreshForm", "masterReset", [], "ESC"]);
		return a
	};
	this.getExploreMenu = function() {
		var a = [];
		a.push(["Filters", "funnel", "clickDataFilters", []]);
		a.push(["Table", "table", "clickDataTable", []]);
		a.push(["Explorer", "data", "clickDataExplorer", []]);
		a.push(["-"]);
		a.push(["Search Parameters", "find", "addConfiguratorCloseMenus"]);
		return a
	};
	this.getConfigurationMenu = function() {
		var e = this.data.d;
		var b = {
			Bar: true,
			Line: true,
			Area: true,
			AreaLine: true,
			BarLine: true,
			Boxplot: true,
			Dotplot: true,
			DotLine: true,
			Heatmap: true,
			Treemap: true,
			TagCloud: true,
			Stacked: true,
			StackedLine: true,
			StackedPercent: true,
			StackedPercentLine: true,
			Candlestick: true
		};
		var a = [];
		if (b[this.graphType] && !this.is3DPlot) {
			if (this.graphType != "Heatmap") {
				a.push(["Axes", "axis1", false, false, false, "getAxesMenu", []]);
				a.push(["Axes Titles", "axisTitle1", false, false, false, "getAxesTitleMenu", []])
			}
			a.push(["Citation", this.graphType == "Heatmap" ? "citationH" : "citation1", false, false, false, "getGraphPartMenu", ["citation"]]);
			a.push(["General", this.graphType == "Heatmap" ? "generalH" : "general1", false, false, false, "getGeneralMenu", []]);
			a.push(["Grid", "grid", false, false, false, "getPlotAreaGridMenu", ["x"]]);
			if (this.graphType != "Heatmap") {
				a.push(["Plot Area", "plotArea", false, false, false, "getPlotAreaOneMenu", []]);
				a.push(["Legend", "legends", false, false, false, "getLegendMenu", []]);
				if (this.data.x) {
					a.push(["Overlays", "overlaysSamplesH", false, false, false, "getOverlaysMenu", []])
				}
			}
			if (this.graphType == "Heatmap") {
				a.push(["Indicator", "indicator", false, false, false, "getIndicatorMenu", []]);
				a.push(["Heatmap", "heatmap", false, false, false, "getHeatmapMenu", []]);
				if (this.data.x || this.data.z) {
					a.push(["Overlays", "overlaysSamplesH", false, false, false, "getOverlaysMenu", []])
				}
			}
			a.push(["Sample Labels", this.graphType == "Heatmap" ? "sampleLabelsH" : "sampleLabels1", false, false, false, "getSmpLabelMenu", []]);
			a.push(["Samples Title", this.graphType == "Heatmap" ? "sampleTitleH" : "sampleTitle1", false, false, false, "getGraphPartMenu", ["smpTitle", true]]);
			if (this.graphType == "Heatmap") {
				a.push(["Variable Labels", "variableLabelsH", false, false, false, "getVarLabelMenu", []]);
				a.push(["Variables Title", "variableTitleH", false, false, false, "getGraphPartMenu", ["varTitle", true]])
			}
			a.push(["Title / Subtitle", this.graphType == "Heatmap" ? "titleSubtitleH" : "titleSubtitle", false, false, false, "getTitleSubtitleMenu", []])
		} else {
			if (this.graphType.match(/scatter/i) || this.is3DPlot) {
				a.push(["Axes", "axesS", false, false, false, "getAxesMenu", []]);
				a.push(["Axes Titles", "axesTitlesS", false, false, false, "getAxesTitleMenu", []]);
				a.push(["Citation", "citationS", false, false, false, "getGraphPartMenu", ["citation"]]);
				a.push(["General", "generalS", false, false, false, "getGeneralMenu", []]);
				a.push(["Grid", "gridS", false, false, false, "getPlotAreaScatterGridMenu", []]);
				a.push(["Plot Area", "plotArea", false, false, false, "getPlotAreaScatterMenu", []]);
				if (e) {
					var c = e.nlfit ? "nonlinearFit" : e.line ? "decorationLine" : e.lines ? "decorationLines" : e.reg ? "regressionLine" : e.nor ? "normalDistribution" : e.area ? "decorationArea" : e.kaplanMeier ? "kaplanMeier" : false;
					a.push(["Decorations", c, false, false, false, "getDecorationsMenu", []])
				}
				a.push(["Legend", "legendS", false, false, false, "getLegendMenu", []]);
				a.push(["Title / Subtitle", "titleSubtitleS", false, false, false, "getTitleSubtitleMenu", []]);
				if (this.isSelectDataPoints) {
					a.push(["Show hidden data points", "showSelected", "showHideSelectedDataPoint", [false, 45], "Ctrl + Insert"]);
					a.push(["Hide data points", "hideSelected", "showHideSelectedDataPoint", [false, 46], "Ctrl + Delete"])
				}
			}
		}
		return a
	};
	this.getAlignNetworkMenu = function() {
		var a = [];
		a.push(["Top", "alignTop", "alignDistributeSelectedNodes", [false, 84]]);
		a.push(["Right", "alignRight", "alignDistributeSelectedNodes", [false, 82]]);
		a.push(["Bottom", "alignBottom", "alignDistributeSelectedNodes", [false, 66]]);
		a.push(["Left", "alignLeft", "alignDistributeSelectedNodes", [false, 76]]);
		return a
	};
	this.getDistributeNetworkMenu = function() {
		var a = [];
		a.push(["Vertically", "distributeVertical", "alignDistributeSelectedNodes", [false, 86]]);
		a.push(["Horozontally", "distributeHorizontal", "alignDistributeSelectedNodes", [false, 72]]);
		return a
	};
	this.getRotateNetworkMenu = function() {
		var a = [];
		a.push(["Clockwise", "rotateClockwise", "arrowMove", [34]]);
		a.push(["Clockwise - Animate", "rotateClockwiseCont", "arrowMove", [39, true]]);
		a.push(["Anticlockwise", "rotateAnticlockwise", "arrowMove", [33]]);
		a.push(["Anticlockwise - Animate", "rotateAnticlockwiseCont", "arrowMove", [37, true]]);
		return a
	};
	this.getOrderNetworkMenu = function() {
		var a = [];
		a.push(["Send to back", "moveBack", "orderNodes", ["sendNodeToBack"]]);
		a.push(["Send backward", "moveBackwards", "orderNodes", ["sendNodeBackward"]]);
		a.push(["Bring to front", "moveFront", "orderNodes", ["bringNodeToFront"]]);
		a.push(["Bring forward", "moveForwards", "orderNodes", ["bringNodeForward"]]);
		return a
	};
	this.setMenu = function() {
		var a = {
			Bar: true,
			Line: true,
			Area: true,
			AreaLine: true,
			BarLine: true,
			Boxplot: true,
			Dotplot: true,
			DotLine: true,
			Heatmap: true,
			Treemap: true,
			TagCloud: true,
			Stacked: true,
			StackedLine: true,
			StackedPercent: true,
			StackedPercentLine: true,
			Candlestick: true
		};
		this.menu = [];
		this.menu.push(["File", "file", false, false, false, "getFileMenu", []]);
		this.menu.push(["-"]);
		this.menu.push(["Explore", "find", false, false, false, "getExploreMenu", []]);
		this.menu.push(["-"]);
		if (this.graphType == "Network") {
			if (this.isNetworkConvexHull) {
				this.menu.push(["Remove Communities", "communitiesOff", "unsetNetworkCommunities"])
			} else {
				this.menu.push(["Show Communities", "communitiesOn", "drawNetworkCommunities"])
			}
			if (this.isSelectNodes) {
				this.menu.push(["Align", "alignBottom", false, false, false, "getAlignNetworkMenu", []]);
				this.menu.push(["Distribute", "distributeVertical", false, false, false, "getDistributeNetworkMenu", []]);
				this.menu.push(["Rotate", "rotateAnticlockwise", false, false, false, "getRotateNetworkMenu", []]);
				this.menu.push(["Order", "moveFront", false, false, false, "getOrderNetworkMenu", []]);
				this.menu.push(["-"]);
				this.menu.push(["Show conections", "connections", "showHideSelectedDataPoint", [false, 36], "Ctrl + Home"]);
				this.menu.push(["-"]);
				this.menu.push(["Show hidden nodes", "showSelected", "showHideSelectedDataPoint", [false, 45], "Ctrl + Insert"]);
				this.menu.push(["Hide nodes", "hideSelected", "showHideSelectedDataPoint", [false, 46], "Ctrl + Delete"]);
				this.menu.push(["-"]);
				this.menu.push(["Undo", "undo", "alignDistributeSelectedNodes", [false, 90], "Ctrl + z"]);
				this.menu.push(["Redo", "redo", "alignDistributeSelectedNodes", [false, 90, true], "Ctrl + y"]);
				this.menu.push(["-"]);
				this.menu.push(["Recalculate Layout", "network2", "recalculateLayoutSelectedNodes"])
			} else {
				this.menu.push(["Rotate", "rotateAnticlockwise", false, false, false, "getRotateNetworkMenu", []])
			}
		}
		if (this.isDOE) {
			this.menu.push(["Modify Meta-Data Plots", "doe", false, false, false, "getDOEMenu", []]);
			this.menu.push(["Remove Meta-Data Plots", "removeDoe", "removeDOE"]);
			this.menu.push(["-"])
		} else {
			if (a[this.graphType] && !this.is3DPlot) {
				this.menu.push(["Customize", "cog", false, false, false, "getConfigurationMenu", []]);
				this.menu.push(["-"]);
				this.menu.push(["Data", "data", false, false, false, "getDataMenu", []]);
				this.menu.push(["-"]);
				if (this.data.x) {
					this.menu.push(["Data Point Attributes", "colorShapeSize", false, false, false, "getDataPointAttributesMenu", []]);
					this.menu.push(["-"])
				}
				if (this.data.x || this.data.z) {
					if (this.data.x) {
						this.menu.push(["Group Samples", "groupSamples", false, false, false, "getGroupSamplesMenu", []])
					}
					if (this.data.x || this.data.z) {
						this.menu.push(["Segregate Data", "segregate", false, false, false, "getSegregationMenu", []])
					}
					this.menu.push(["-"])
				}
				if (!this.layoutValid) {
					this.menu.push(["Cluster", "cluster", false, false, false, "getDendrogramsMenu", []]);
					this.menu.push(["-"]);
					if (this.isHistogram) {
						this.menu.push(["Histogram", "histogram", false, false, false, "getHistogramMenu", []])
					} else {
						if (!this.isCorrelate) {
							this.menu.push(["Correlate", "regressionLine", false, false, false, "getCorrelationMenu", []]);
							if (this.data.x) {
								this.menu.push(["Explore Meta-Data", "doe", "createDOE"])
							}
							this.menu.push(["Histogram", "histogram", "createHistogramTr"])
						}
					}
				}
			} else {
				if (this.graphType == "Circular") {
					this.menu.push(["Data", "data", false, false, false, "getDataMenu", []]);
					this.menu.push(["-"]);
					if (this.data.x || this.data.z) {
						if (this.data.x || this.data.z) {
							this.menu.push(["Segregate Data", "segregate", false, false, false, "getSegregationMenu", []])
						}
						this.menu.push(["-"])
					}
				} else {
					if (this.graphType.match(/scatter/i) || this.is3DPlot) {
						this.menu.push(["Customize", "cog", false, false, false, "getConfigurationMenu", []]);
						this.menu.push(["-"]);
						this.menu.push(["Data", "data", false, false, false, "getDataMenu", []]);
						this.menu.push(["-"]);
						if (this.graphType == "Scatter2D") {
							if (this.isHistogram) {
								this.menu.push(["Histogram", "histogram", false, false, false, "getHistogramMenu", []])
							} else {
								if (this.isCorrelate) {
									this.menu.push(["Remove Correlation", "removeRegressionLine", "removeCorrelation"])
								} else {
									if (this.data.d && this.data.d.reg) {
										this.menu.push(["Remove Correlation", "removeRegressionLine", "removeCorrelation"])
									} else {
										this.menu.push(["Loess", "nonlinearFit", false, false, false, "getLoessMenu", []]);
										this.menu.push(["Correlate", "regressionLine", "correlateData"])
									}
									if (this.data.z && !this.scatterPlotMatrix) {
										this.menu.push(["Explore Meta-Data", "doe", "createDOE"])
									}
									if (!this.scatterPlotMatrix) {
										this.menu.push(["Create Histogram", "histogram", "createHistogram"])
									}
								}
							}
						}
						if (this.data.z) {
							this.menu.push(["Data Point Attributes", "colorShapeSize", false, false, false, "getDataPointAttributesMenu", []])
						}
					}
				}
			}
		}
		return this.menu
	};
	this.resetMenus = function() {
		this.removeMenus()
	}
};
CanvasXpress.prototype.initLinks = function() {
	this.addLinkDiv = function() {
		if (this.$(this.target + "-cX-Link")) {
			this.resetLinkDiv();
			return
		}
		var b = this.$cX("div", {
			id: this.target + "-cX-Link",
			className: "CanvasXpressLink"
		}, {
			zIndex: 10002,
			display: "none"
		});
		var a = this.$cX("ul", {
			id: this.target + "-cX-Link-Content",
			className: "CanvasXpressList"
		});
		var c = this.$("north-wrapper-" + this.target);
		if (c) {
			b.appendChild(a);
			c.appendChild(b)
		}
	};
	this.showLinkDiv = function(J, b, D) {
		var K = this.$(this.target + "-cX-Link-Content");
		var k = this.$("west-container-" + this.target);
		var M = false;
		if (K) {
			this.resetLinkDiv();
			var L = this.adjustedCoordinates(J);
			if (L) {
				var h = L.x + k.offsetWidth;
				var f = L.y;
				for (var H = 0; H < b.length; H++) {
					var o = b[H].url;
					var C = b[H].name;
					var r = b[H].title;
					var E = b[H].icon;
					var v = b[H].source;
					var B = b[H].params;
					if (o) {
						M = true
					} else {
						if (v && this.data.links && this.data.links[v]) {
							o = this.data.links[v].url;
							M = true;
							if (B) {
								for (var G in B) {
									o = o.replace("$" + G + "$", B[G])
								}
							}
						}
					}
					var F = this.$cX("li", {
						className: "CanvasXpressListItem"
					});
					var c = r ? r : this.data.links && v && this.data.links[v] && this.data.links[v].title ? this.data.links[v].title : "";
					var N = this.$cX("a", {
						className: "CanvasXpressListItemA",
						href: o,
						alt: c,
						title: c,
						target: "_blank"
					});
					var I = this.$cX("img", {
						className: "CanvasXpressListIcon",
						src: E ? E : this.data.links && v && this.data.links[v] && this.data.links[v].icon ? this.data.links[v].icon : CanvasXpress.images.canvasXpress
					});
					var A = this.$cX("span", {
						className: "CanvasXpressListItemText",
						innerHTML: C ? C : this.data.links && v && this.data.links[v] && this.data.links[v].name ? this.data.links[v].name : H
					});
					N.appendChild(I);
					N.appendChild(A);
					F.appendChild(N);
					this.addRemoveLinkListeners("addEvtListener", F);
					K.appendChild(F)
				}
				K.parentNode.style.left = h + "px";
				K.parentNode.style.top = f + "px";
				K.parentNode.style.display = M ? "block" : "none"
			}
		}
	};
	this.addRemoveLinkListeners = function(b, a) {
		if (a) {
			this.addRemoveEvtListener(b, a, "click", this.clickLink, false);
			this.addRemoveEvtListener(b, a, "mouseover", this.mouseoverLink, false);
			this.addRemoveEvtListener(b, a, "mouseout", this.mouseoutLink, false)
		}
	};
	this.clickLink = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetLinkDiv();
			return false
		}
	}(this);
	this.mouseoverLink = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getMenuItemComp(c);
			if (b) {
				b[0].className = "CanvasXpressListItemActive";
				b[1].className = "CanvasXpressListItemAActive"
			}
			return false
		}
	}(this);
	this.mouseoutLink = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getMenuItemComp(c);
			if (b) {
				b[0].className = "CanvasXpressListItem";
				b[1].className = "CanvasXpressListItemA"
			}
			return false
		}
	}(this);
	this.resetLinkDiv = function() {
		var a = this.$(this.target + "-cX-Link-Content");
		if (a && a.childNodes) {
			while (a.childNodes.length > 0) {
				this.addRemoveLinkListeners("removeEvtListener", a.childNodes[0]);
				a.removeChild(a.childNodes[0])
			}
			a.parentNode.style.display = "none"
		}
	};
	this.resetLinks = function() {
		this.resetLinkDiv()
	};
	this.initializeLinks = function() {
		if (!this.disableEvents) {
			this.addLinkDiv()
		}
	};
	this.initializeLinks()
};
CanvasXpress.prototype.initTooltip = function() {
	this.addTooltipDiv = function(m, l, k, a) {
		this.resetInfoSpan();
		var b = 0;
		var f = this.target + "-cX-TooltipDiv" + b;
		var p = this.$(this.target + "-cX-Info");
		if (p && p.style.display != "none") {
			l = parseInt(p.style.left);
			k = parseInt(p.style.top)
		}
		var g = this.$(f);
		while (g) {
			b++;
			f = this.target + "-cX-TooltipDiv" + b;
			g = this.$(f)
		}
		var h = this.$cX("div", {
			id: f,
			className: "CanvasXpressTooltip draggable"
		}, {
			left: l + "px",
			top: k + "px",
			zIndex: 29010
		});
		var j = this.$cX("img", {
			id: f + "Close",
			className: "CanvasXpressTooltip",
			src: CanvasXpress.images.cancel1,
			alt: "Close",
			title: "Close"
		});
		if (!a) {
			a = {}
		}
		a.clear = "both";
		var o = this.$cX("div", {
			id: f + "HTML",
			innerHTML: m || ""
		}, a);
		h.appendChild(j);
		h.appendChild(o);
		document.body.appendChild(h);
		return h
	};
	this.addRemoveTooltipDivsListeners = function(a, b) {
		this.addRemoveEvtListener(a, b, "mousedown", this.registerMousemove, false);
		this.addRemoveEvtListener(a, b, "touchstart", this.registerMousemove, false);
		this.addRemoveEvtListener(a, b.firstChild, "click", this.closeTooltipDiv, false)
	};
	this.closeTooltipDiv = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = c.target || c.srcElement;
			if (b) {
				var f = b.parentNode;
				a.addRemoveTooltipDivsListeners("removeEvtListener", f);
				f.parentNode.removeChild(f)
			}
			return false
		}
	}(this);
	this.showTooltipDiv = function(c, i, b, a, h, g) {
		var f;
		if (h && g) {
			f = this.addTooltipDiv(i, h, g, a);
			this.addRemoveTooltipDivsListeners("addEvtListener", f)
		} else {
			var k = this.$(this.target + "-cX-Info");
			var j = b ? this.regularCoordinates(c, b) : this.adjustedCoordinates(c, k);
			if (j) {
				h = j.x;
				g = c ? j.y : j.y + 25;
				f = this.addTooltipDiv(i, h, g, a);
				this.addRemoveTooltipDivsListeners("addEvtListener", f)
			}
		}
	};
	this.resetTooltipDivs = function() {
		var c = 0;
		var a = this.target + "-cX-TooltipDiv" + c;
		var b = this.$(a);
		while (b) {
			this.addRemoveTooltipDivsListeners("removeEvtListener", b);
			b.parentNode.removeChild(b);
			c++;
			a = this.target + "-cX-TooltipDiv" + c;
			b = this.$(a)
		}
	};
	this.addInfoSpan = function() {
		if (this.$(this.target + "-cX-Info")) {
			this.resetInfoSpan();
			return
		}
		var a = this.$cX("span", {
			id: this.target + "-cX-Info",
			className: "CanvasXpressTooltip"
		}, {
			display: "none",
			zIndex: 29010
		});
		document.body.appendChild(a)
	};
	this.resetInfoSpan = function(d, c) {
		var b = this.$(this.target + "-cX-Info");
		if (b && !this.noInfoSpanReset) {
			var a = new Date().getTime() - this.infoStartTime;
			if (a > this.infoTimeIn || c) {
				b.style.left = "0px";
				b.style.top = "0px";
				b.style.display = "none";
				b.innerHTML = ""
			}
		}
	};
	this.flashInfoSpan = function(j, i, n, b) {
		var f = this;
		if (b) {
			this.noInfoSpanReset = true
		}
		var o = new Date().getTime() - this.infoStartTime;
		var q = this.$(this.target + "-cX-Info");
		var g = this.$(this.target);
		var a = g.getClientRects();
		if (q) {
			q.innerHTML = n;
			q.style.display = "block";
			var m = parseInt(q.clientWidth);
			var e = parseInt(q.clientHeight);
			var d = document.body.scrollLeft + a[0].left;
			var o = document.body.scrollTop + a[0].top;
			q.style.left = (d + (j || 0)) + "px";
			q.style.top = (o + (i || 0)) + "px";
			if (b) {
				this.noInfoSpanReset = true;
				var k = function() {
					this.update = function() {
						var c = new Date().getTime();
						if (c - f.infoStartTime > b) {
							f.noInfoSpanReset = false;
							f.resetInfoSpan();
							clearInterval(h)
						}
					};
					var h = setInterval(this.update, b)
				};
				k.call()
			}
		}
	};
	this.showInfoSpan = function(d, k, a) {
		if (this.draggingOn || this.remoteUpdating || this.noInfoSpanReset) {
			return
		}
		var m = new Date().getTime() - this.infoStartTime;
		var n = this.$(this.target + "-cX-Info");
		if (n && k && k != "" && m > this.infoTimeIn) {
			var l = a ? this.regularCoordinates(d, a) : this.adjustedCoordinates(d, n);
			if (l) {
				var g = l.x;
				var f = d ? l.y : l.y + 25;
				if (this.meta.system.isIE) {
					g += document.body.scrollLeft;
					f += document.body.scrollTop
				}
				if (!isNaN(k)) {
					k = k.toString()
				}
				if (k.match(/\w/)) {
					n.innerHTML = k;
					n.style.left = (g + 10) + "px";
					n.style.top = (f - 20) + "px";
					n.style.display = "inline";
					n.style.zIndex = parseInt(n.style.zIndex);
					var j = parseInt(n.clientWidth);
					var b = parseInt(n.clientHeight);
					if (j < window.innerWidth && j > (window.innerWidth + window.pageXOffset) - g && (j + 20) < (g - window.pageXOffset)) {
						n.style.left = (g - (j + 20)) + "px";
						n.style.left = (g - (parseInt(n.clientWidth) + 20)) + "px"
					}
					if (b < window.innerHeight && b > (window.innerHeight + window.pageYOffset) - f && (b - 15) < (f - window.pageYOffset)) {
						n.style.top = (f - (b - 15)) + "px";
						n.style.top = (f - (parseInt(n.clientHeight) - 15)) + "px"
					}
					this.infoStartTime = new Date().getTime();
					var c = this;
					var i = function() {
						this.update = function() {
							var h = new Date().getTime();
							if (h - c.infoStartTime > c.infoTimeOut) {
								c.resetInfoSpan();
								clearInterval(e)
							}
						};
						var e = setInterval(this.update, 100)
					};
					i.call()
				}
			}
		}
	};
	this.initializeTooltip = function() {
		this.setPixelImage();
		if (!this.disableEvents) {
			this.addInfoSpan()
		}
	};
	this.initializeTooltip()
};
CanvasXpress.prototype.initToolbar = function() {
	this.addToolbarDiv = function() {
		if (this.$(this.target + "-cX-Toolbar")) {
			return
		}
		var a = this.beaconImage;
		var o = this.meta.canvas.ctx.canvas.height < 350 && !this.meta.system.isTouchScreen;
		var k = this.meta.canvas.ctx.canvas.height >= 500 ? "24px" : "18px";
		var f = this.$cX("div", {
			id: this.target + "-cX-Toolbar"
		}, {
			position: "absolute",
			overflow: "hidden",
			width: this.width + "px",
			height: "0px",
			left: "7px",
			top: "12px",
			zIndex: 9000
		});
		var r = this.$cX("div", {
			id: this.target + "-cX-Toolbar-Custom"
		}, {
			cssFloat: "left"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-ToolbarSave",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.cameraToolbar,
			alt: "Save as png",
			title: "Save as png"
		}, {
			width: k,
			height: k
		});
		var j = this.$cX("img", {
			id: this.target + "-cX-ToolbarLayout",
			className: "CanvasXpressToolbarImage",
			src: this.appLayout ? CanvasXpress.images.applicationToolbar : CanvasXpress.images.application1Toolbar,
			alt: this.appLayout ? "Basic layout" : "Application layout",
			title: this.appLayout ? "Basic layout" : "Application layout"
		}, {
			width: k,
			height: k,
			display: this.disableDataFilters || this.disableDataTable || this.disableConfigurator || o ? "none" : "block"
		});
		var h = this.$cX("img", {
			id: this.target + "-cX-ToolbarDataExplorer",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.databaseSearchToolbar,
			alt: "Explore data",
			title: "Explore data"
		}, {
			width: k,
			height: k,
			display: "block"
		});
		var l = this.$cX("img", {
			id: this.target + "-cX-ToolbarInformation",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.infoToolbar,
			alt: "Data Details",
			title: "Data Details"
		}, {
			width: k,
			height: k,
			display: this.info ? "block" : "none"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-ToolbarMaxMin",
			className: "CanvasXpressToolbarImage",
			src: this.maximized ? CanvasXpress.images.minimizeToolbar : CanvasXpress.images.maximizeToolbar,
			alt: this.maximized ? "Minimize" : "Maximize",
			title: this.maximized ? "Minimize" : "Maximize"
		}, {
			marginRight: "13px",
			width: k,
			height: k
		});
		var n = this.$cX("div", {
			id: this.target + "-cX-ToolbarHelpDescription",
			className: "CanvasXpressToolbarHelp draggable"
		}, {
			cursor: "move",
			display: "none",
			padding: "10px",
			position: "absolute"
		});
		var g = this.$cX("img", {
			id: this.target + "-cX-ToolbarHelpClose",
			className: "CanvasXpressToolbarHelp",
			src: CanvasXpress.images.cancel1,
			alt: "Close",
			title: "Close"
		});
		n.appendChild(document.createTextNode("Help"));
		n.appendChild(g);
		n.appendChild(this.$cX("br"));
		this.addHelp(n);
		f.appendChild(r);
		f.appendChild(a);
		f.appendChild(d);
		f.appendChild(l);
		f.appendChild(h);
		f.appendChild(j);
		f.appendChild(b);
		f.appendChild(n);
		var n = this.$("north-wrapper-" + this.target);
		if (n) {
			n.appendChild(f);
			this.addRemoveToolbarListeners("addEvtListener")
		}
	};
	this.addRemoveToolbarListeners = function(c) {
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarSave"), "click", this.print, false);
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarLayout"), "click", this.clickLayout, false);
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarDataExplorer"), "click", this.clickDataExplorer, false);
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarInformation"), "click", this.clickDataDetails, false);
		this.addRemoveEvtListener(c, this.$(this.target + "-cX-ToolbarMaxMin"), "click", this.clickGraphMaxMin, false);
		var a = this.$(this.target + "-cX-Toolbar-Custom");
		if (c == "removeEvtListener" && a) {
			for (var b = 0; b < a.childNodes.length; b++) {
				this.addRemoveEvtListener(c, a.childNodes[b], "click", this.addCustomToolbarMenu, false);
				this.addRemoveEvtListener(c, a.childNodes[b], "contextmenu", this.unpinFromToolbar, false)
			}
		}
	};
	this.clickHelp = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.$(a.target + "-cX-Toolbar");
			var d = a.$(a.target + "-cX-ToolbarHelpDescription");
			if (c && d) {
				c.style.overflow = "visible";
				d.style.display = "block";
				d.style.left = ((f.layerX || f.x) - 400) + "px";
				d.style.top = (f.layerY || f.y) + "px"
			}
			return false
		}
	}(this);
	this.clickShowCode = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.showCodeDiv();
			return false
		}
	}(this);
	this.closeHelp = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.$(a.target + "-cX-Toolbar");
			var d = a.$(a.target + "-cX-ToolbarHelpDescription");
			if (c && d) {
				d.style.display = "none";
				setTimeout(function() {
					c.style.overflow = "hidden"
				}, 300)
			}
			return false
		}
	}(this);
	this.clickLayoutNoAnimation = function(c) {
		if (this.appLayout && !c) {
			var b = this.showFadeResizeMoveAnimation;
			this.showFadeResizeMoveAnimation = false;
			this.hideTable();
			this.hideDataFilter();
			var a = this.$(this.target + "-cX-ToolbarLayout");
			a.src = CanvasXpress.images.applicationToolbar;
			a.alt = "Application layout";
			a.title = "Application layout";
			this.appLayout = false;
			this.activeAccordion = false;
			this.showFadeResizeMoveAnimation = b;
			return false
		}
	};
	this.clickLayoutShowDataFilter = function() {
		this.showDataFilter();
		if (!this.dataFilterLastState || (this.dataFilterLastState && this.dataFilterLastState != "docked")) {
			this.moveDataFilter();
			if (!this.activeAccordion) {
				var a = this;
				setTimeout(function() {
					if (a.graphType == "Genome") {
						a.activateAccordion(false, a.$(a.target + "-cX-DataFilterGenomeHeader"))
					} else {
						if (a.graphType == "Network") {
							a.activateAccordion(false, a.$(a.target + "-cX-DataFilterNodeHeader"))
						} else {
							a.activateAccordion(false, a.$(a.target + "-cX-DataFilterVariableHeader"))
						}
					}
				}, this.showFadeResizeMoveAnimation ? 500 : 0)
			}
		}
	};
	this.clickLayoutShowDataTable = function() {
		this.updateDataTable();
		if (!this.dataTableLastState || (this.dataTableLastState && this.dataTableLastState != "docked")) {
			this.moveDataTableDiv("dock")
		}
		var a = this;
		setTimeout(function() {
			var b = a.$("middle-container-" + a.target);
			a.dataTableTarget = a.$(a.target + "-cX-DataTable");
			a.updateDataTableResizerDiv(false, parseInt(b.style.width) - (a.appLayoutDataTable ? 20 : 2), parseInt(a.dataTableTarget.style.height));
			a.endDataTableResizerDiv();
			a.hideToolbar()
		}, this.showFadeResizeMoveAnimation ? 500 : 0)
	};
	this.backgroundMask = function(a) {
		var b = this.$("container-" + this.target);
		if (b) {
			if (a) {
				b.style.position = "fixed";
				b.style.left = 0;
				b.style.top = 0;
				b.style.width = a[0];
				b.style.height = a[1];
				b.style.overflow = "hidden";
				b.style.zIndex = 1000000;
				b.style.backgroundColor = "white"
			} else {
				b.style.position = "relative";
				b.style.left = "";
				b.style.top = "";
				b.style.width = "";
				b.style.height = "";
				b.style.overflow = "";
				b.style.zIndex = "";
				b.style.backgroundColor = ""
			}
		}
	};
	this.clickLayout = function(a) {
		return function(i, c, j) {
			if (!i) {
				i = window.event
			}
			if (a.appLayoutDataTable) {
				a.clickDataTable(i);
				setTimeout(function() {
					a.clickDataFilters(i)
				}, 1000)
			} else {
				if (a.appLayoutDataFilter) {
					a.clickDataFilters(i);
					setTimeout(function() {
						a.clickDataTable(i)
					}, 1000)
				} else {
					var f = a.showFadeResizeMoveAnimation ? 500 : 0;
					if (!c) {
						if (i) {
							c = i.target || i.srcElement
						} else {
							c = a.$(a.target + "-cX-ToolbarLayout")
						}
					}
					a.appLayout = a.appLayout ? false : true;
					c.src = a.appLayout ? CanvasXpress.images.applicationToolbar : CanvasXpress.images.application1Toolbar;
					c.alt = a.appLayout ? "Basic layout" : "Application layout";
					c.title = a.appLayout ? "Basic layout" : "Application layout";
					if (a.resizeHeightOnLayout) {
						a.setDataTableDimensions()
					}
					var b = a.isLayoutConfigurator ? a.configuratorWidth + a.dataFilterWidth - 14 : a.dataFilterWidth - 14;
					var d = a.dataTableLastHeight ? a.dataTableRowsHeight + 9 : a.dataTableRowsHeight + 53;
					if (a.appLayout) {
						if (a.resizeWidthOnLayout && a.width - b >= b * 1.3) {
							if (a.resizeHeightOnLayout && a.height - d >= d * 1) {
								a.setDimensions(a.width - b, a.height - d + 24, true);
								a.resizeWidthOnLayoutActive = true;
								a.resizeHeightOnLayoutActive = true
							} else {
								a.setDimensions(a.width - b, a.height + 18.5, true);
								a.resizeWidthOnLayoutActive = true
							}
							a.resizeViewport()
						} else {
							if (a.resizeHeightOnLayout && a.height - d >= d * 1) {
								a.setDimensions(a.width - 12, a.height - d + 24, true);
								a.resizeHeightOnLayoutActive = true;
								a.resizeViewport()
							}
						}
						var g = a.isLayoutConfigurator ? 500 : 1;
						if (a.isLayoutConfigurator) {
							a.addConfigurator();
							a.selectConfig(false, true);
							if (!a.configuratorLastState || (a.configuratorLastState && a.configuratorLastState != "docked")) {
								a.clickDockUndockConfigurator()
							}
						}
						a.dataFilterHeight = a.meta.canvas.ctx.canvas.height - (a.graphType == "Genome" ? 60 : 81);
						setTimeout(function() {
							a.clickLayoutShowDataFilter();
							setTimeout(function() {
								a.clickLayoutShowDataTable()
							}, f)
						}, g)
					} else {
						if (a.isLayoutConfigurator) {
							a.closeConfigurator()
						}
						setTimeout(function() {
							if (a.activeAccordion) {
								a.activateAccordion(false, a.activeAccordion.previousSibling)
							}
							a.hideDataFilter();
							setTimeout(function() {
								a.hideTable();
								a.hideToolbar();
								setTimeout(function() {
									if (a.resizeWidthOnLayoutActive) {
										if (a.resizeHeightOnLayoutActive) {
											a.setDimensions(a.width + b + 36, a.height + d + 12, true)
										} else {
											a.setDimensions(a.width + b + 36, a.height + 18.5, true)
										}
									} else {
										if (a.resizeHeightOnLayoutActive) {
											a.setDimensions(a.width + 48, a.height + d + 12, true)
										}
									}
									a.resizeWidthOnLayoutActive = false;
									a.resizeHeightOnLayoutActive = false;
									setTimeout(function() {
										a.updateRemoteNavigationWindow()
									}, f * 0.2)
								}, f)
							}, f)
						}, f)
					}
				}
			}
			return false
		}
	}(this);
	this.clickDataTable = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.removeMenus();
			if (a.maximized) {
				if (a.appLayout) {
					a.clickLayout(d, a.$(a.target + "-cX-ToolbarLayout"));
					setTimeout(function() {
						a.clickDataTable(d)
					}, 2000)
				} else {
					if (a.appLayoutDataFilter) {
						a.clickDataFilters(d);
						setTimeout(function() {
							a.clickLayout(d, a.$(a.target + "-cX-ToolbarLayout"))
						}, 1500)
					} else {
						a.setDataTableDimensions();
						var b = -12;
						var c = a.dataTableLastHeight ? a.dataTableRowsHeight + 9 : a.dataTableRowsHeight + 53;
						a.appLayoutDataTable = a.appLayoutDataTable ? false : true;
						if (a.appLayoutDataTable) {
							a.setDimensions(a.width - b, a.height - c + 24, true);
							a.resizeHeightOnLayoutActive = true;
							a.clickLayoutShowDataTable()
						} else {
							a.hideTable();
							setTimeout(function() {
								a.setDimensions(a.width + b + 36, a.height + c + 12, true, 250);
								a.resizeHeightOnLayoutActive = false
							}, 250)
						}
					}
				}
			} else {
				a.updateDataTable()
			}
			return false
		}
	}(this);
	this.clickDataExplorer = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.removeMenus();
			a.addDataExplorer(b);
			return false
		}
	}(this);
	this.clickDataFilters = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.removeMenus();
			if (a.maximized) {
				if (a.appLayout) {
					a.clickLayout(d, a.$(a.target + "-cX-ToolbarLayout"));
					setTimeout(function() {
						a.clickDataFilters(d)
					}, 2000)
				} else {
					if (a.appLayoutDataTable) {
						a.clickDataTable(d);
						setTimeout(function() {
							a.clickLayout(d, a.$(a.target + "-cX-ToolbarLayout"))
						}, 1500)
					} else {
						var b = a.isLayoutConfigurator ? a.configuratorWidth + a.dataFilterWidth - 9 : a.dataFilterWidth - 9;
						var c = a.graphType == "Genome" ? 60 : 81;
						a.appLayoutDataFilter = a.appLayoutDataFilter ? false : true;
						if (a.appLayoutDataFilter) {
							a.setDimensions(a.width - b, a.height + 18.5, true);
							a.resizeWidthOnLayoutActive = true;
							a.dataFilterHeight = a.meta.canvas.ctx.canvas.height - c;
							a.clickLayoutShowDataFilter()
						} else {
							if (a.activeAccordion) {
								a.activateAccordion(false, a.activeAccordion.previousSibling)
							}
							a.hideDataFilter();
							setTimeout(function() {
								a.resizeViewportMiddle(a.width + b + 36, a.height + 18.5);
								a.setDimensions(a.width + b + 36, a.height + 18.5, true, 250);
								a.resizeWidthOnLayoutActive = false
							}, 250)
						}
					}
				}
			} else {
				a.showDataFilter()
			}
			return false
		}
	}(this);
	this.clickDataDetails = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = document.body.scrollLeft;
			var f = document.body.scrollTop;
			var c = {
				maxWidth: "500px",
				maxHeight: "500px",
				whiteSpace: "normal",
				overflow: "auto",
				textAlign: "left"
			};
			a.showTooltipDiv(d, a.info, false, c, d.clientX + b - a.width, d.clientY + f);
			return false
		}
	}(this);
	this.clickRepResearch = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			var b = document.body.scrollLeft;
			var h = document.body.scrollTop;
			var c = a.prettyJSON(CanvasXpress.stack[a.target]);
			var f = '<pre class="CanvasXpressCode">\n' + c + "</pre>\n";
			var d = {
				maxWidth: "500px",
				maxHeight: "500px",
				whiteSpace: "normal",
				overflow: "auto",
				textAlign: "left"
			};
			a.showTooltipDiv(g, f, false, d, g.clientX + b - (a.width / 2), g.clientY + h);
			return false
		}
	}(this);
	this.clickGraphMaxMin = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = 1;
			if (a.appLayout) {
				a.clickLayout(c, a.$(a.target + "-cX-ToolbarLayout"));
				b = 2000
			} else {
				if (a.appLayoutDataTable) {
					a.clickDataTable(c);
					b = 1000
				} else {
					if (a.appLayoutDataFilter) {
						a.clickDataFilters(c);
						b = 1000
					}
				}
			}
			setTimeout(function() {
				var h = a.$(a.target + "-cX-ToolbarMaxMin");
				var d = screen.width;
				var f = screen.height;
				var g = window.innerWidth;
				var e = window.innerHeight;
				if (h) {
					if (a.maximized) {
						a.backgroundMask();
						h.alt = "Maximize";
						h.title = "Maximize";
						h.src = CanvasXpress.images.maximizeToolbar;
						a.setDimensions(a.maximized[0], a.maximized[1]);
						a.maximized = false;
						a.dataFilterHeight = a.meta.canvas.ctx.canvas.height - (a.graphType == "Genome" ? 60 : 81)
					} else {
						a.maximized = [a.width + 18, a.height + 18];
						a.backgroundMask([d, f]);
						h.alt = "Minimize";
						h.title = "Minimize";
						h.src = CanvasXpress.images.minimizeToolbar;
						a.setDimensions(g + 3, e + 19);
						a.dataFilterHeight = a.meta.canvas.ctx.canvas.height - (a.graphType == "Genome" ? 60 : 81)
					}
				}
			}, b);
			return false
		}
	}(this);
	this.addHelp = function(l) {
		var i = this.$cX("div", false, {
			width: "400px"
		});
		i.appendChild(this.$cX("br"));
		var C = this.$cX("img", {
			src: CanvasXpress.images.help1
		});
		i.appendChild(C);
		i.appendChild(document.createTextNode(" Show this help"));
		i.appendChild(this.$cX("br"));
		var v = this.$cX("img", {
			src: CanvasXpress.images.camera
		});
		i.appendChild(v);
		i.appendChild(document.createTextNode(" Print"));
		i.appendChild(this.$cX("br"));
		var g = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Save the image as a 'png' file."
		});
		i.appendChild(g);
		var s = this.$cX("img", {
			src: CanvasXpress.images.disk
		});
		i.appendChild(s);
		i.appendChild(document.createTextNode(" Save"));
		i.appendChild(this.$cX("br"));
		var G = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Save save the data as a tab delimited file."
		});
		i.appendChild(G);
		var D = this.$cX("img", {
			src: CanvasXpress.images.funnel
		});
		i.appendChild(D);
		i.appendChild(document.createTextNode(" Filters"));
		i.appendChild(this.$cX("br"));
		var H = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Widget used to filter the data and metadata. Metadata will be automatically assigned as text, numeric or date."
		});
		i.appendChild(H);
		var D = this.$cX("img", {
			src: CanvasXpress.images.table
		});
		i.appendChild(D);
		i.appendChild(document.createTextNode(" Show data"));
		i.appendChild(this.$cX("br"));
		var b = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Show the data used for this visualization in an HTML table."
		});
		i.appendChild(b);
		var o = this.$cX("img", {
			src: CanvasXpress.images.transpose
		});
		i.appendChild(o);
		i.appendChild(document.createTextNode(" Transpose data table"));
		i.appendChild(this.$cX("br"));
		var C = this.$cX("img", {
			src: CanvasXpress.images.cog
		});
		i.appendChild(C);
		i.appendChild(document.createTextNode(" Show the configurator"));
		i.appendChild(this.$cX("br"));
		var f = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "This widget allows you to customize this graph. You may enter the name of the property you wish to customize in the text box (which filters as you type) or browse through a number of categories.<br>You will find a short description for the property you select along with its category and links to other relevant properties.<br>You will also see the current value for the seleced property along with a link to an additional widget to help you specifying the new value."
		});
		i.appendChild(f);
		var F = this.$cX("img", {
			src: CanvasXpress.images.configureShow
		});
		i.appendChild(F);
		i.appendChild(document.createTextNode(" Application mode (Filter and Table)"));
		i.appendChild(this.$cX("br"));
		var e = this.$cX("p", {
			className: "CanvasXpressToolbarHelp",
			innerHTML: "Show both the data table and the data filters."
		});
		i.appendChild(e);
		var A = this.$cX("img", {
			src: CanvasXpress.images.pin
		});
		i.appendChild(A);
		i.appendChild(document.createTextNode(" Dock widget to the side"));
		i.appendChild(this.$cX("br"));
		var m = this.$cX("img", {
			src: CanvasXpress.images.unpin
		});
		i.appendChild(m);
		i.appendChild(document.createTextNode(" Undock widget from the side"));
		i.appendChild(this.$cX("br"));
		var y = this.$cX("img", {
			src: CanvasXpress.images.purpleCode
		});
		i.appendChild(y);
		i.appendChild(document.createTextNode(" Show visualization code"));
		i.appendChild(this.$cX("br"));
		var B = this.$cX("img", {
			src: CanvasXpress.images.menuDropdown
		});
		i.appendChild(B);
		i.appendChild(document.createTextNode(" Show configuration menus"));
		i.appendChild(this.$cX("br"));
		var r = this.$cX("img", {
			src: CanvasXpress.images.fullScreen
		});
		i.appendChild(r);
		i.appendChild(document.createTextNode(" Maximize window. Click again to restore."));
		i.appendChild(this.$cX("br"));
		var E = this.$cX("img", {
			src: CanvasXpress.images.cancel1
		});
		i.appendChild(E);
		i.appendChild(document.createTextNode(" Close widget"));
		i.appendChild(this.$cX("br"));
		i.appendChild(this.$cX("br"));
		var j = this.$cX("a", {
			href: "http://canvasxpress.org",
			target: "_blank",
			innerHTML: "canvasXpress"
		});
		i.appendChild(document.createTextNode("Additional documentation at "));
		i.appendChild(j);
		i.appendChild(this.$cX("br"));
		l.appendChild(i)
	};
	this.showToolbar = function(d) {
		if (!this.disableToolbar) {
			var a = this.$(this.target + "-cX-Toolbar");
			var c = this.$("west-container-" + this.target);
			if (a && parseInt(a.style.height) == 0 && c) {
				this.resizeMove(a, 0, 12, this.width, 34, 250);
				if (d) {
					var b = this;
					setTimeout(function() {
						b.hideToolbar(d)
					}, d)
				}
			}
		}
	};
	this.hideToolbar = function(d) {
		var a = this.$(this.target + "-cX-Toolbar");
		var c = this.$("west-container-" + this.target);
		if (a && parseInt(a.style.height) == 34 && c) {
			this.resizeMove(a, 0, 12, this.width, 0, 250)
		} else {
			if (d && a && parseInt(a.style.height) > 0) {
				var b = this;
				setTimeout(function() {
					b.hideToolbar(d)
				}, d)
			}
		}
	};
	this.isToolbar = function(c) {
		if (!c) {
			c = window.event
		}
		var b = this.adjustedCoordinates(c);
		if (b) {
			var a = b.x;
			var d = b.y;
			if (d > 0 && d < 32 && a > 0 && a < this.width) {
				this.showToolbar()
			} else {
				if (d > 32 && d < this.height && a > 0 && a < this.width) {
					this.hideToolbar()
				}
			}
		}
	};
	this.addTouchToolbarDiv = function() {
		if (this.$(this.target + "-cX-TouchToolbar")) {
			return
		}
		var n = this.meta.canvas.ctx.canvas.height >= 500 ? 32 : 22;
		var j = this.meta.canvas.ctx.canvas.height >= 500 ? 16 : 11;
		var f = this.$cX("div", {
			id: this.target + "-cX-TouchToolbar"
		}, {
			position: "absolute",
			width: (n + j + 12) + "px",
			height: ((n * 6) + 12) + "px",
			left: 0 + "px",
			top: ((this.height - (n * 6)) / 2) + "px",
			display: "flex",
			zIndex: 9000
		});
		var g = this.$cX("div", {
			id: this.target + "-cX-TouchToolbarLeft"
		}, {
			width: 0,
			height: ((n * 6) + 12) + "px",
			overflow: "hidden"
		});
		var b = this.$cX("div", {
			id: this.target + "-cX-TouchToolbarRight"
		}, {
			width: (j - 1) + "px",
			height: "128px"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarMouse",
			className: "CanvasXpressToolbarImage",
			key: "mouse",
			src: CanvasXpress.images.hoverToolbar,
			swp: CanvasXpress.images.mouseLeftToolbar,
			title: "Toggle hover / drag"
		}, {
			width: n + "px",
			height: n + "px"
		});
		var o = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarAlt",
			className: "CanvasXpressToolbarImage",
			key: "alt",
			src: CanvasXpress.images.altZeroToolbar,
			swp: CanvasXpress.images.altToolbar,
			title: "Toggle Alt on / off"
		}, {
			width: n + "px",
			height: n + "px"
		});
		var q = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarShift",
			className: "CanvasXpressToolbarImage",
			key: "shift",
			src: CanvasXpress.images.shiftZeroToolbar,
			swp: CanvasXpress.images.shiftToolbar,
			title: "Toggle Shift on / off"
		}, {
			width: n + "px",
			height: n + "px"
		});
		var l = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarCtrl",
			className: "CanvasXpressToolbarImage",
			key: "ctrl",
			src: CanvasXpress.images.ctrlZeroToolbar,
			swp: CanvasXpress.images.ctrlToolbar,
			title: "Toggle Ctrl on / off"
		}, {
			width: n + "px",
			height: n + "px"
		});
		var p = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarWheel",
			className: "CanvasXpressToolbarImage",
			key: "wheel",
			src: CanvasXpress.images.mouseToolbar,
			swp: CanvasXpress.images.mouseWheelToolbar,
			title: "Toggle Ctrl on / off"
		}, {
			width: n + "px",
			height: n + "px"
		});
		var k = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarEsc",
			className: "CanvasXpressToolbarImage",
			key: "esc",
			src: CanvasXpress.images.escToolbar,
			swp: CanvasXpress.images.escToolbar,
			title: "Click to ESC"
		}, {
			width: n + "px",
			height: n + "px"
		});
		var i = this.$cX("img", {
			id: this.target + "-cX-TouchToolbarMobileHandle",
			className: "CanvasXpressToolbarImage",
			src: CanvasXpress.images.mobileHandle,
			title: "Interaction"
		}, {
			width: (j - 4) + "px",
			height: n + "px",
			position: "relative",
			top: ((n * 2.5) + 6) + "px"
		});
		g.appendChild(d);
		g.appendChild(o);
		g.appendChild(q);
		g.appendChild(l);
		g.appendChild(p);
		g.appendChild(k);
		b.appendChild(i);
		f.appendChild(g);
		f.appendChild(b);
		var p = this.$("west-wrapper-" + this.target);
		if (p) {
			p.appendChild(f);
			this.addRemoveTouchToolbarListeners("addEvtListener")
		}
	};
	this.addRemoveTouchToolbarListeners = function(a) {
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarMobileHandle"), "click", this.clickMobileHandle, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarMouse"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarAlt"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarShift"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarCtrl"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarWheel"), "click", this.clickMobileKey, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-TouchToolbarEsc"), "click", this.clickMobileKey, false)
	};
	this.teaseMobileControls = function(a) {
		var b = this;
		if (!a) {
			a = 1000
		}
		if (!this.disableTouchToolbar && this.meta.system.isTouchScreen) {
			b.clickMobileHandle();
			setTimeout(function() {
				b.clickMobileHandle()
			}, a)
		}
	};
	this.clickMobileHandle = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.$(a.target + "-cX-TouchToolbarLeft");
			var d = a.meta.canvas.ctx.canvas.height >= 500 ? 38 : 28;
			if (c) {
				var b = parseInt(c.clientWidth);
				if (b > 0) {
					a.resizeMove(c, 0, 0, 0, (d * 6) + 12, 250)
				} else {
					a.resizeMove(c, 0, 0, d, (d * 6) + 12, 250)
				}
			}
			return false
		}
	}(this);
	this.clickMobileKey = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			var b = this.key;
			a[b + "KeyMobile"] = a[b + "KeyMobile"] ? false : true;
			var d = this.src;
			this.src = this.swp;
			this.swp = d;
			if (b == "esc") {
				a.resetMobileKeys();
				a.masterReset(g)
			} else {
				var f = ["alt", "shift", "ctrl"];
				var h = a.$(a.target + "-cX-TouchToolbarMouse");
				for (var c = 0; c < f.length; c++) {
					if (a[f[c] + "KeyMobile"]) {
						if (!a.mouseKeyMobile) {
							d = h.src;
							h.src = h.swp;
							h.swp = d;
							a.mouseKeyMobile = true
						}
						break
					}
				}
			}
			return false
		}
	}(this);
	this.resetMobileKeys = function() {
		var d = ["Mouse", "Alt", "Shift", "Ctrl", "Wheel", "Esc"];
		for (var b = 0; b < d.length; b++) {
			var e = this.$(this.target + "-cX-TouchToolbar" + d[b]);
			var a = d[b].toLowerCase();
			if (e && this[a + "KeyMobile"]) {
				var c = e.src;
				e.src = e.swp;
				e.swp = c;
				this[a + "KeyMobile"] = false
			}
		}
	};
	this.initializeToolbar = function() {
		this.setPixelImage();
		if (!this.disableEvents) {
			if (!this.disableToolbar) {
				this.addToolbarDiv()
			}
			if (!this.disableTouchToolbar && this.meta.system.isTouchScreen) {
				this.addTouchToolbarDiv()
			}
		}
	};
	this.initializeToolbar()
};
CanvasXpress.prototype.initConfigurator = function() {
	this.addConfigurator = function(a) {
		return function(af, D, N, M) {
			var w = false;
			if (!af) {
				af = window.event
			}
			if (a.isVML || a.disableConfigurator) {
				return
			}
			var ah = a.$(a.target + "-cX-Configurator");
			if (ah) {
				w = true;
				if (a.activeTarget) {
					a.activeTarget.style.zIndex = 10000
				}
				a.activeTarget = ah;
				a.activeTarget.style.zIndex = 10001
			}
			var F = "Search property or function";
			a.configuringOn = true;
			if (D) {
				if (a.isArray(D)) {
					D = D[0]
				}
				if (a.graphType == "Network") {
					a.configuringNetwork = D;
					if (a.data.nodes.length > D) {
						F = "Configure " + (a.data.nodes[D].label || a.data.nodes[D].name || a.data.nodes[D].id)
					} else {
						var A = a.data.edges[D - a.data.nodes.length];
						var I = a.data.nodes[a.data.nodeIndices[A.id1]];
						var H = a.data.nodes[a.data.nodeIndices[A.id2]];
						F = "Configure " + (I.label || I.name || I.id) + " - " + (H.label || I.name || H.id)
					}
				} else {
					if (a.graphType == "Genome") {
						a.configuringGenome = D;
						F = "Configure track " + D
					}
				}
			}
			var B = N != null && M != null ? {
				x: N,
				y: M
			} : a.adjustedCoordinates(af);
			if (B) {
				N = a.applicationLook || a.configuratorLastState == "docked" ? 0 : B.x;
				M = a.applicationLook || a.configuratorLastState == "docked" ? 0 : B.y;
				if (w) {
					ah.style.left = N + "px";
					ah.style.top = M + "px";
					return
				} else {
					ah = a.$cX("div", {
						id: a.target + "-cX-Configurator",
						className: a.applicationLook ? "CanvasXpressConfigurator fixed" : "CanvasXpressConfigurator draggable"
					}, {
						cursor: "move",
						left: N + "px",
						top: M + "px",
						padding: "10px",
						position: "absolute",
						zIndex: 10001
					})
				}
				var ab = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorKeyText"
				}, {
					display: "block",
					marginBottom: "5px",
					width: a.configuratorWidth + "px"
				});
				var ac = a.$cX("span", {
					id: a.target + "-cX-ConfiguratorKeyTextSpan",
					className: "CanvasXpressConfigurator",
					innerHTML: F
				});
				var J = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorKeyMenu",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.menuDropdown,
					alt: "Open menus",
					title: "Open menus"
				});
				var ad = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorKeySearch",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.find,
					alt: "Browse properties by category",
					title: "Browse properties by category"
				});
				var C = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorKeyDock",
					className: "CanvasXpressConfigurator",
					src: a.applicationLook ? CanvasXpress.images.unpin : CanvasXpress.images.pin,
					alt: a.applicationLook ? "Undock" : "Dock",
					title: a.applicationLook ? "Undock" : "Dock",
					state: a.applicationLook ? "docked" : "free"
				});
				var Z = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorKeyClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var aa = a.$cX("input", {
					id: a.target + "-cX-ConfiguratorKey",
					className: "CanvasXpressConfigurator",
					type: "text"
				}, {
					display: "block",
					width: a.configuratorWidth + "px"
				});
				var Y = a.$cX("select", {
					id: a.target + "-cX-ConfiguratorCategories",
					className: "CanvasXpressConfigurator",
					size: 5
				}, {
					display: "none",
					width: a.configuratorWidth + "px"
				});
				var S = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorSugestionsText",
					innerHTML: "Select property"
				}, {
					display: "none",
					margin: "5px 0px 5px 0px",
					width: a.configuratorWidth + "px"
				});
				var R = a.$cX("select", {
					id: a.target + "-cX-ConfiguratorSugestions",
					className: "CanvasXpressConfigurator",
					size: a.mobileApp ? 5 : 10
				}, {
					display: "none",
					width: a.configuratorWidth + "px"
				});
				var ag = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorSugestionsDescription"
				}, {
					display: "none",
					margin: "5px 0px 5px 0px",
					width: a.configuratorWidth + "px",
					minHeight: "56px",
					overflow: "auto"
				});
				var P = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorValueText",
					innerHTML: "Current value"
				}, {
					display: "none",
					margin: "5px 0px 5px 0px",
					width: a.configuratorWidth + "px"
				});
				var aj = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorSeeAlso"
				}, {
					display: "none",
					width: a.configuratorWidth + "px",
					minHeight: "20px",
					overflow: "auto"
				});
				var O = a.$cX("input", {
					id: a.target + "-cX-ConfiguratorValue",
					className: "CanvasXpressConfigurator",
					type: "text"
				}, {
					display: "none",
					width: a.configuratorWidth + "px"
				});
				var E = a.$cX("input", {
					id: a.target + "-cX-ConfiguratorApply",
					value: "Apply",
					type: "button"
				}, {
					display: "none",
					cssFloat: "left",
					borderRadius: "5px",
					top: "4px",
					position: "relative",
					width: (a.configuratorWidth / 2) + "px"
				});
				var ai = a.$cX("input", {
					id: a.target + "-cX-ConfiguratorButton",
					value: "Draw",
					type: "button"
				}, {
					display: "none",
					cssFloat: "left",
					borderRadius: "5px",
					top: "4px",
					position: "relative",
					width: (a.configuratorWidth / 2) + "px"
				});
				var T = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorOptionsClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var L = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorOptions",
					className: "CanvasXpressConfigurator draggable"
				}, {
					cursor: "move",
					display: "none",
					padding: "10px",
					position: "absolute"
				});
				var V = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorCurrent",
					className: "CanvasXpressConfiguratorColor"
				}, {
					width: "181px",
					height: "16px",
					cssFloat: "left",
					cursor: "default"
				});
				var U = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorColorClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var X = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColor",
					className: "CanvasXpressConfigurator draggable"
				}, {
					width: "204px",
					cursor: "move",
					display: "none",
					padding: "10px",
					position: "absolute"
				});
				var G = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorFilter",
					className: "CanvasXpressConfiguratorFilter draggable",
					innerHTML: 'Build filter ("+" to set "-" to remove)'
				}, {
					cursor: "move",
					display: "none",
					padding: "10px",
					position: "absolute"
				});
				var K = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorFilterClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var Q = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorExample",
					className: "CanvasXpressConfiguratorExample draggable"
				}, {
					width: (a.configuratorExamplesSize + 35) + "px",
					maxHeight: (a.configuratorExamplesSize) + "px",
					cursor: "move",
					display: "none",
					padding: "10px",
					position: "absolute",
					overflow: "hidden",
					paddingBottom: "35px"
				});
				var ae = a.$cX("span", {
					id: a.target + "-cX-ConfiguratorExampleSpan",
					className: "CanvasXpressConfiguratorExample",
					innerHTML: ""
				});
				var t = a.$cX("img", {
					id: a.target + "-cX-ConfiguratorExampleClose",
					className: "CanvasXpressConfigurator",
					src: CanvasXpress.images.cancel1,
					alt: "Close",
					title: "Close"
				});
				var h = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorExampleContent",
					className: "CanvasXpressConfiguratorExampleContent"
				}, {
					maxWidth: (a.configuratorExamplesSize + 35) + "px",
					maxHeight: (a.configuratorExamplesSize) + "px",
					overflow: "auto"
				});
				ab.appendChild(ac);
				ab.appendChild(Z);
				ab.appendChild(C);
				ab.appendChild(ad);
				ab.appendChild(J);
				L.appendChild(document.createTextNode("Select option ..."));
				L.appendChild(T);
				L.appendChild(a.$cX("br"));
				X.appendChild(V);
				X.appendChild(U);
				X.appendChild(a.$cX("br"));
				G.appendChild(K);
				G.appendChild(a.$cX("br"));
				Q.appendChild(ae);
				Q.appendChild(t);
				Q.appendChild(a.$cX("br"));
				Q.appendChild(h);
				ah.appendChild(ab);
				ah.appendChild(aa);
				ah.appendChild(Y);
				ah.appendChild(S);
				ah.appendChild(R);
				ah.appendChild(ag);
				ah.appendChild(aj);
				ah.appendChild(P);
				ah.appendChild(O);
				ah.appendChild(E);
				ah.appendChild(ai);
				ah.appendChild(L);
				ah.appendChild(X);
				ah.appendChild(G);
				ah.appendChild(Q);
				var W = a.$("west-wrapper-" + a.target);
				if (W) {
					W.appendChild(ah);
					if (a.activeTarget) {
						a.activeTarget.style.zIndex = 10000
					}
					a.activeTarget = ah;
					a.addRemoveConfiguratorListeners("addEvtListener");
					if (a.configuringNetwork || a.configuringGenome) {
						a.selectConfig(false, true)
					}
					setTimeout(function() {
						aa.focus()
					}, 300)
				}
			}
		}
	}(this);
	this.addConfiguratorCloseMenus = function(a) {
		return function(d, c, b, f) {
			a.removeMenus();
			a.addConfigurator(d, c, b, f)
		}
	}(this);
	this.addRemoveConfiguratorListeners = function(h) {
		var B = this.$(this.target + "-cX-Configurator");
		var w = this.$(this.target + "-cX-ConfiguratorCategories");
		var j = this.$(this.target + "-cX-ConfiguratorSugestions");
		var d = this.$(this.target + "-cX-ConfiguratorApply");
		var C = this.$(this.target + "-cX-ConfiguratorButton");
		var x = this.$(this.target + "-cX-ConfiguratorKeyClose");
		var D = this.$(this.target + "-cX-ConfiguratorKeyDock");
		var A = this.$(this.target + "-cX-ConfiguratorKeySearch");
		var a = this.$(this.target + "-cX-ConfiguratorKeyMenu");
		var e = this.$(this.target + "-cX-ConfiguratorOptions");
		var k = this.$(this.target + "-cX-ConfiguratorOptionsClose");
		var v = this.$(this.target + "-cX-ConfiguratorColor");
		var u = this.$(this.target + "-cX-ConfiguratorColorClose");
		var g = this.$(this.target + "-cX-ConfiguratorFilter");
		var r = this.$(this.target + "-cX-ConfiguratorFilterClose");
		var y = this.$(this.target + "-cX-ConfiguratorExample");
		var o = this.$(this.target + "-cX-ConfiguratorExampleClose");
		if (B && w && j && C && d && x && D && A && a && e && k && v && u && g && r && y && o) {
			this[h](B, "mousedown", this.registerMousemove, false);
			this[h](w, "change", this.changeCategory, false);
			this[h](w, "click", this.changeCategory, false);
			this[h](j, "change", this.clickSuggestions, false);
			this[h](j, "click", this.clickSuggestions, false);
			this[h](d, "click", this.clickApplyConfigurator, false);
			this[h](C, "click", this.clickConfigurator, false);
			this[h](a, "click", this.clickMenuDropDown, false);
			this[h](A, "click", this.clickSearch, false);
			this[h](D, "click", this.clickDockUndockConfigurator, false);
			this[h](x, "click", this.closeConfigurator, false);
			this[h](e, "mousedown", this.registerMousemove, false);
			this[h](k, "click", this.closePropertyOptions, false);
			this[h](v, "mousedown", this.registerMousemove, false);
			this[h](u, "click", this.closePropertyColor, false);
			this[h](g, "mousedown", this.registerMousemove, false);
			this[h](r, "click", this.closePropertyFilter, false);
			this[h](y, "mousedown", this.registerMousemove, false);
			this[h](o, "click", this.closePropertyExample, false)
		}
	};
	this.getConfigurableProperties = function() {
		if (this.configuringNetwork) {
			if (this.data.nodes.length > this.configuringNetwork) {
				return this.getNodeConfigurableProperties(this.configuringNetwork)
			} else {
				return this.getEdgeConfigurableProperties(this.configuringNetwork - this.data.nodes.length)
			}
		} else {
			if (this.configuringGenome) {
				if (!isNaN(this.configuringGenome) || this.configuringGenome.match(/:/)) {
					return this.featureConfigurableProperties
				} else {
					if (this.configuringGenome.match(/track/)) {
						return this.trackConfigurableProperties
					} else {
						this.configuringGenome = false
					}
				}
			}
		}
		var d = [];
		for (var c in CanvasXpress.doc.P) {
			if (!CanvasXpress.doc.P[c].Z) {
				var a = CanvasXpress.doc.P[c].M;
				var b = CanvasXpress.doc.P[c].U;
				if (CanvasXpress.doc.M[a].U) {
					if (CanvasXpress.doc.M[a].U.hasOwnProperty(this.graphType)) {
						d.push(c)
					}
				} else {
					if (b) {
						if (b.hasOwnProperty(this.graphType)) {
							d.push(c)
						}
					} else {
						d.push(c)
					}
				}
			}
		}
		return d
	};
	this.getConfigurableObjectDoc = function(a) {
		if (this.configuringNetwork) {
			if (this.data.nodes.length > this.configuringNetwork) {
				return CanvasXpress.doc.N[a] ? CanvasXpress.doc.N[a] : false
			} else {
				return CanvasXpress.doc.E[a] ? CanvasXpress.doc.E[a] : false
			}
		} else {
			if (this.configuringGenome) {
				if (!isNaN(this.configuringGenome) || this.configuringGenome.match(/:/)) {
					return CanvasXpress.doc.F[a] ? CanvasXpress.doc.F[a] : false
				} else {
					if (this.configuringGenome.match(/track/)) {
						return CanvasXpress.doc.G[a] ? CanvasXpress.doc.G[a] : false
					} else {
						this.configuringGenome = false;
						return CanvasXpress.doc.P[a] ? CanvasXpress.doc.P[a] : false
					}
				}
			} else {
				return CanvasXpress.doc.P[a] ? CanvasXpress.doc.P[a] : false
			}
		}
	};
	this.selectConfig = function(D, F) {
		var z = this.$(this.target + "-cX-ConfiguratorKey");
		var q = this.$(this.target + "-cX-ConfiguratorSugestionsText");
		var n = this.$(this.target + "-cX-ConfiguratorSugestions");
		var E = this.$(this.target + "-cX-ConfiguratorSugestionsDescription");
		var l = this.$(this.target + "-cX-ConfiguratorValueText");
		var H = this.$(this.target + "-cX-ConfiguratorSeeAlso");
		var j = this.$(this.target + "-cX-ConfiguratorValue");
		var f = this.$(this.target + "-cX-ConfiguratorApply");
		var G = this.$(this.target + "-cX-ConfiguratorButton");
		var B = this.$(this.target + "-cX-ConfiguratorValueHREF");
		var m = document.activeElement;
		var y = this.getConfigurableProperties();
		var w = [];
		if (this.getKeyCode(D) == 13) {
			this.resetOptionColorFiltersExamples();
			if (this.editingDescriptionOn) {
				this.submitEditPropertyDescription()
			} else {
				if (n && j && j.value) {
					var g = false;
					for (var A = 0; A < y.length; A++) {
						if (n.value == y[A]) {
							g = true;
							break
						}
					}
					if (g) {
						this.clickConfigurator(D, n, j)
					} else {
						this.resetConfigurator()
					}
				}
			}
		} else {
			if (m.id.match(/canvasXpressConfiguratorFilterValue/)) {
				return
			} else {
				if (z && m.id == z.id || F) {
					this.resetOptionColorFiltersExamples();
					this.resetEditPropertyDescription();
					for (var A = 0; A < y.length; A++) {
						if (y[A].toLowerCase().indexOf(z.value.toLowerCase()) >= 0) {
							w.push(y[A])
						}
					}
					if (w.length > 0 && q && n && E && l && H && j && G && f) {
						this.resetSugestions();
						if (!this.configuringNetwork && !this.configuringGenome) {
							w.sort(function(d, c) {
								return CanvasXpress.doc.P[d].M > CanvasXpress.doc.P[c].M ? 1 : CanvasXpress.doc.P[c].M > CanvasXpress.doc.P[d].M ? -1 : d > c ? 1 : c > d ? -1 : 0
							});
							for (var A = 0; A < w.length; A++) {
								var y = this.$cX("option", {
									text: CanvasXpress.doc.P[w[A]].M ? CanvasXpress.doc.P[w[A]].M + " : " + w[A] : "NA : " + w[A],
									value: w[A]
								});
								try {
									n.add(y, null)
								} catch (C) {
									n.add(y)
								}
							}
						} else {
							w.sort();
							for (var A = 0; A < w.length; A++) {
								var y = this.$cX("option", {
									text: w[A],
									value: w[A]
								});
								try {
									n.add(y, null)
								} catch (C) {
									n.add(y)
								}
							}
						}
						n.options[0].selected = true;
						this.setConfiguratorPropertyValue(n, E, l, H, j);
						q.innerHTML = "Select property (" + w.length + ")";
						q.style.display = "block";
						n.style.display = "block";
						E.style.display = "block";
						l.style.display = "block";
						H.style.display = "block";
						j.style.display = "block";
						G.style.display = "block";
						f.style.display = "block"
					} else {
						z.value = z.value.slice(0, z.value.length - 1)
					}
				} else {
					if (j && m.id == j.id) {
						this.resetOptionColorFiltersExamples();
						this.resetEditPropertyDescription();
						if (B && B.innerHTML == "color") {
							B.style.color = j.value ? this.rgbToHex(this.validateColor(j.value.replace(/[\'\"]/g, ""))) : this.foreground
						}
					} else {
						if (this.remoteService) {
							this.resetOptionColorFiltersExamples();
							this.selectDataSet(D)
						}
					}
				}
			}
		}
		return false
	};
	this.clickSearch = function(a) {
		return function(G) {
			if (!G) {
				G = window.event
			}
			a.configuringNetwork = false;
			a.configuringGenome = false;
			a.resetEditOptionColorFiltersExamples();
			var E = a.$(a.target + "-cX-ConfiguratorKeyTextSpan");
			var C = a.$(a.target + "-cX-ConfiguratorKey");
			var A = a.$(a.target + "-cX-ConfiguratorCategories");
			var w = a.$(a.target + "-cX-ConfiguratorSugestionsText");
			var t = a.$(a.target + "-cX-ConfiguratorSugestions");
			var H = a.$(a.target + "-cX-ConfiguratorSugestionsDescription");
			var q = a.$(a.target + "-cX-ConfiguratorValueText");
			var J = a.$(a.target + "-cX-ConfiguratorSeeAlso");
			var p = a.$(a.target + "-cX-ConfiguratorValue");
			var I = a.$(a.target + "-cX-ConfiguratorButton");
			var c = a.$(a.target + "-cX-ConfiguratorApply");
			var f = a.$(a.target + "-cX-ConfiguratorOptions");
			var y = a.$(a.target + "-cX-ConfiguratorColor");
			var h = a.$(a.target + "-cX-ConfiguratorFilter");
			var B = a.getKeys(CanvasXpress.doc.M).sort();
			var j = [];
			if (C && C.style.display == "none") {
				if (E) {
					E.innerText = "Search property or function"
				}
				if (A) {
					A.style.display = "none"
				}
				C.value = "";
				C.style.display = "block"
			} else {
				if (E) {
					for (var D = 0; D < B.length; D++) {
						if (CanvasXpress.doc.M[B[D]].U) {
							if (CanvasXpress.doc.M[B[D]].U.hasOwnProperty(a.graphType)) {
								j.push(B[D])
							}
						} else {
							j.push(B[D])
						}
						E.innerText = "Select category (" + j.length + ")"
					}
				}
				if (C) {
					C.style.display = "none"
				}
				if (A) {
					a.resetCategories();
					for (var D = 0; D < j.length; D++) {
						var x = a.$cX("option", {
							text: j[D],
							value: j[D]
						});
						try {
							A.add(x, null)
						} catch (F) {
							A.add(x)
						}
					}
					A.style.display = "block"
				}
			}
			if (w && t && H && q && J && p && I && c && f && y && h) {
				w.style.display = "none";
				t.style.display = "none";
				H.style.display = "none";
				q.style.display = "none";
				J.style.display = "none";
				p.style.display = "none";
				I.style.display = "none";
				c.style.display = "none";
				f.style.display = "none";
				y.style.dysplay = "none";
				h.style.dysplay = "none"
			}
			return false
		}
	}(this);
	this.clickMenuDropDown = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.closeConfigurator(b);
			a.addMenu(b, false, false, false, 8, 8);
			return false
		}
	}(this);
	this.clickDockUndockConfigurator = function(a) {
		return function(m, f) {
			if (!m) {
				m = window.event
			}
			var p = a.$(a.target + "-cX-Configurator");
			var n = a.$(a.target + "-cX-ConfiguratorKeyDock");
			var q = a.$(a.target + "-cX-ConfiguratorButton");
			var t = a.$(a.target + "-cX-ConfiguratorApply");
			var s = a.$("middle-container-" + a.target);
			var g = a.$("west-container-" + a.target);
			var l = a.$("east-container-" + a.target);
			var k = this.showFadeResizeMoveAnimation ? 500 : 0;
			if (p && n && s && g && l) {
				if (n.state == "free" && !f) {
					var o = (parseInt(p.style.padding) * 2) + 2;
					var j = p.clientHeight - o;
					a.configuringOn = "docked";
					a.resizeViewportWest();
					p.className = "CanvasXpressConfigurator fixed";
					p.style.cursor = "default";
					n.src = CanvasXpress.images.unpin;
					n.alt = "Undock";
					n.title = "Undock";
					n.state = "docked";
					a.configuratorLastState = "docked";
					s.style.width = p.clientWidth + a.meta.canvas.ctx.canvas.width + l.clientWidth + 2;
					a.resizeMove(g, 0, 0, p.clientWidth, a.meta.canvas.ctx.canvas.height, k, null);
					a.resizeMove(p, 0, 0, a.configuratorWidth, a.meta.canvas.ctx.canvas.height - o, k, null);
					q.style.left = ((a.configuratorWidth / 2) + 10) + "px";
					t.style.left = "10px";
					q.style.position = "absolute";
					t.style.position = "absolute";
					setTimeout(function() {
						a.resizeViewportWest();
						q.style.top = (a.meta.canvas.ctx.canvas.height - (o + 10)) + "px";
						t.style.top = (a.meta.canvas.ctx.canvas.height - (o + 10)) + "px";
						q.style.position = "absolute";
						t.style.position = "absolute"
					}, k)
				} else {
					a.configuringOn = "free";
					p.className = "CanvasXpressConfigurator draggable";
					p.style.cursor = "move";
					q.style.left = "0px";
					t.style.left = "0px";
					q.style.top = "4px";
					t.style.top = "4px";
					q.style.position = "relative";
					t.style.position = "relative";
					n.src = CanvasXpress.images.pin;
					n.alt = "Dock";
					n.title = "Dock";
					n.state = "free";
					a.configuratorLastState = "free";
					a.resizeMove(g, 0, 0, 0, a.meta.canvas.ctx.canvas.height, k, function() {
						s.style.width = a.meta.canvas.ctx.canvas.width + l.clientWidth
					});
					a.resizeViewportWest();
					setTimeout(function() {
						p.style.height = ""
					}, k)
				}
			}
			return false
		}
	}(this);
	this.closeConfigurator = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetViewportOverflow("west");
			a.clickDockUndockConfigurator(b, true);
			a.resetConfigurator();
			return false
		}
	}(this);
	this.changeCategory = function(a) {
		return function(G, D, I) {
			if (!G) {
				G = window.event
			}
			a.resetEditOptionColorFiltersExamples();
			var C = a.$(a.target + "-cX-ConfiguratorCategories");
			var w = a.$(a.target + "-cX-ConfiguratorSugestionsText");
			var t = a.$(a.target + "-cX-ConfiguratorSugestions");
			var H = a.$(a.target + "-cX-ConfiguratorSugestionsDescription");
			var q = a.$(a.target + "-cX-ConfiguratorValueText");
			var K = a.$(a.target + "-cX-ConfiguratorSeeAlso");
			var l = a.$(a.target + "-cX-ConfiguratorValue");
			var f = a.$(a.target + "-cX-ConfiguratorApply");
			var J = a.$(a.target + "-cX-ConfiguratorButton");
			var g = a.$(a.target + "-cX-ConfiguratorOptions");
			var B = a.$(a.target + "-cX-ConfiguratorColor");
			var h = a.$(a.target + "-cX-ConfiguratorFilter");
			var k = CanvasXpress.doc.M;
			if (I) {
				C.value = I
			}
			if (C && C.value && w && t && H && q && K && l && J && g && B && h) {
				var y = k[C.value].P.sort();
				a.resetSugestions();
				for (var E = 0; E < y.length; E++) {
					if (I && y[E] == I) {
						D = E
					}
					var A = a.$cX("option", {
						text: y[E],
						value: y[E]
					});
					try {
						t.add(A, null)
					} catch (F) {
						t.add(A)
					}
				}
				t.options[D || 0].selected = true;
				w.innerHTML = "Select property (" + y.length + ")";
				a.setConfiguratorPropertyValue(t, H, q, K, l);
				w.style.display = "block";
				t.style.display = "block";
				H.style.display = "block";
				q.style.display = "block";
				K.style.display = "block";
				l.style.display = "block";
				f.style.display = "block";
				J.style.display = "block";
				g.style.display = "none";
				B.style.display = "none";
				h.style.display = "none"
			}
			return false
		}
	}(this);
	this.hideCategories = function() {
		var a = this.$(this.target + "-cX-ConfiguratorCategories");
		var b = this.$(this.target + "-cX-ConfiguratorKeyTextSpan");
		var c = this.$(this.target + "-cX-ConfiguratorKeySearch");
		var e = this.$(this.target + "-cX-ConfiguratorKeyDock");
		if (a && b && c && e) {
			a.style.display = "none";
			b.innerHTML = "";
			c.style.display = "none";
			e.style.display = "none"
		}
	};
	this.resetCategories = function() {
		var a = this.$(this.target + "-cX-ConfiguratorCategories");
		if (a) {
			if (a.hasChildNodes()) {
				while (a.childNodes.length >= 1) {
					a.removeChild(a.firstChild)
				}
			}
			a.style.display = "none"
		}
	};
	this.clickSuggestions = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetEditOptionColorFiltersExamples();
			a.setConfiguratorPropertyValue();
			return false
		}
	}(this);
	this.setConfiguratorPropertyValue = function(l, e, j, g, h) {
		if (!l) {
			l = this.$(this.target + "-cX-ConfiguratorSugestions")
		}
		if (!e) {
			e = this.$(this.target + "-cX-ConfiguratorSugestionsDescription")
		}
		if (!j) {
			j = this.$(this.target + "-cX-ConfiguratorValueText")
		}
		if (!g) {
			g = this.$(this.target + "-cX-ConfiguratorSeeAlso")
		}
		if (!h) {
			h = this.$(this.target + "-cX-ConfiguratorValue")
		}
		var k;
		var f = this.$(this.target + "-cX-ConfiguratorOptions");
		var c = this.getConfigurableObjectDoc(l.value);
		h.value = "";
		h.style.readonly = false;
		if (this.configuringNetwork) {
			if (typeof(this[l.value]) == "function") {
				h.style.disabled = "disabled";
				h.style.readonly = false
			} else {
				if (this.configuringNetwork < this.data.nodes.length) {
					k = this.data.nodes[this.configuringNetwork][l.value]
				} else {
					k = this.data.edges[this.configuringNetwork - this.data.nodes.length][l.value]
				}
			}
		} else {
			if (this.configuringGenome) {
				var b = this.subtracksInfo;
				if (!isNaN(this.configuringGenome)) {
					k = this.data.tracks[b[this.configuringGenome].track].data[b[this.configuringGenome].index][l.value]
				} else {
					if (this.configuringGenome.match(/:/)) {
						k = parseInt(this.configuringGenome.split(":")[1]);
						k = this.data.tracks[b[k].track].data[b[k].index][l.value]
					} else {
						k = parseInt(this.configuringGenome.replace("track-", ""));
						k = this.data.tracks[b[k].track][l.value]
					}
				}
			} else {
				if (typeof(this[l.value]) == "function") {
					j.innerHTML = "Current&nbsp;value&nbsp;[&nbsp;<i>function</i>&nbsp;]&nbsp;" + this[l.value].length + "&nbsp;parameter(s)";
					if (this[l.value].length == 0) {
						h.style.disabled = "disabled";
						h.style.readonly = false
					}
				} else {
					k = this[l.value]
				}
			}
		}
		h.value = k ? JSON.stringify(k) : "";
		this.addPropertyDescription(e, c, l.value);
		this.addPropertySeeAlsoLinks(g, c);
		this.addPropertyOptions(j, f, c, l.value, k);
		if (this.showConfiguratorExamplesOnSelect) {
			this.resetPropertyExample();
			this.clickExamplePropertyDescription(false, l.value)
		}
	};
	this.resetSugestions = function() {
		var a = this.$(this.target + "-cX-ConfiguratorSugestions");
		if (a) {
			if (a.hasChildNodes()) {
				while (a.childNodes.length >= 1) {
					a.removeChild(a.firstChild)
				}
			}
			a.style.display = "none"
		}
	};
	this.addPropertyDescription = function(r, g, f) {
		var t = g && g.C ? g.C : "";
		var j = g && g.M ? g.M : "";
		var v = g && g.H ? true : false;
		this.resetPropertyDescription(r);
		var n = this.$cX("img", {
			id: this.target + "-cX-ConfiguratorSugestionsDescriptionEdit",
			src: CanvasXpress.images.pencil,
			alt: "Edit description",
			title: "Edit description"
		}, {
			cursor: "default",
			margin: "2px",
			width: "10px",
			height: "10px"
		});
		var a = this.$cX("i", {
			innerHTML: f
		});
		var w = this.$cX("span", {
			id: this.target + "-cX-ConfiguratorSugestionsDescriptionEditSpan",
			className: "CanvasXpressConfigurator",
			prop: f,
			innerHTML: " : " + t
		});
		var k = this.$cX("i", {
			innerHTML: j
		});
		var l = this.$cX("a", {
			id: this.target + "-cX-ConfiguratorSugestionsDescriptionExample",
			href: "javascript:void(0)",
			alt: "Show examples",
			title: "Show examples"
		});
		var u = this.$cX("span", false, {
			className: "CanvasXpressConfigurator"
		});
		l.appendChild(a);
		u.appendChild(document.createTextNode("Description [ "));
		u.appendChild(k);
		u.appendChild(document.createTextNode(" ]"));
		r.appendChild(u);
		r.appendChild(this.$cX("br"));
		r.appendChild(v ? l : a);
		r.appendChild(w);
		r.appendChild(n);
		this.addEvtListener(l, "click", this.clickExamplePropertyDescription, false);
		this.addEvtListener(n, "click", this.clickEditPropertyDescription, false)
	};
	this.resetPropertyDescription = function(f, b, a) {
		if (!f) {
			f = this.$(this.target + "-cX-ConfiguratorSugestionsDescription")
		}
		if (!b) {
			b = this.$(this.target + "-cX-ConfiguratorSugestionsDescriptionEdit")
		}
		if (f && b) {
			this.removeEvtListener(b, "click", this.clickEditPropertyDescription, false);
			if (!a) {
				a = this.$(this.target + "-cX-ConfiguratorSugestionsDescriptionExample")
			}
			if (a) {
				this.removeEvtListener(a, "click", this.clickExamplePropertyDescription, false)
			}
			while (f.childNodes.length > 0) {
				var g = f.childNodes[0];
				f.removeChild(g)
			}
		}
	};
	this.getExamplesDocObject = function(l, z) {
		var c = [];
		if (l) {
			var n = this.getConfigurableObjectDoc(l);
			var e = n.U ? this.getKeys(n.U) : CanvasXpress.doc.M[n.M]["U"] ? this.getKeys(CanvasXpress.doc.M[n.M]["U"]) : ["Bar"];
			for (var t = 0; t < n.H.length; t++) {
				if (n.H[t].match(/\*/)) {
					var a = [];
					var r = n.H[t] == "{*}" ? {} : JSON.parse(String(n.H[t].replace("*,", "")));
					var h = r.data ? this.getDataSet(r.data) : false;
					var y = r.skipExample ? this.getObjectArray(r.skipExample) : {};
					var b = r.functions ? r.functions : false;
					var g = r.conditional ? r.conditional : false;
					if (h) {
						delete(r.data)
					}
					if (y) {
						delete(r.skipExample)
					}
					if (b) {
						delete(r.functions)
					}
					if (g) {
						delete(r.conditional)
					}
					if (n.T == "option") {
						a = n.O
					} else {
						if (n.T == "boolean") {
							a = [true, false]
						} else {
							if (n.T == "color") {
								a = ["rgb(255,125,51)", "rgb(51,255,125)", "rgb(125,51,255)"];
								a.unshift(n.D)
							} else {
								if (n.T == "float") {
									a = n.D == "null" ? [null, 0.5] : [parseFloat(n.D), Math.max(parseFloat(n.D) * 1.5, 1)]
								} else {
									if (n.T == "integer") {
										a = n.D == 0 ? [0, 1] : [parseInt(n.D), parseInt((parseInt(n.D) * 1.5) + 0.5)]
									}
								}
							}
						}
					}
					for (var s = 0; s < a.length; s++) {
						if (y.hasOwnProperty(a[s])) {
							continue
						}
						var m = (z ? l : this.target) + "-cX-ConfiguratorExample-" + l + "-" + String(a[s]).replace(/\s/m, "-") + "-" + t;
						var v = this.cloneObject(r);
						v[l] = a[s];
						if (v[l] == "false") {
							v[l] = false
						} else {
							if (v[l] == "true") {
								v[l] = true
							} else {
								if (v[l] == "null") {
									v[l] = null
								}
							}
						}
						if (!v.graphType) {
							v.graphType = e[0]
						}
						if (g) {
							for (var k in g) {
								v[k] = g[k][s % g[k].length]
							}
						}
						if (b && s == 0) {
							c.push([m, h, v, b])
						} else {
							c.push([m, h, v])
						}
					}
				} else {
					var s = JSON.parse(String(n.H[t]));
					var x = s.data ? this.getDataSet(s.data) : false;
					var w = s.functions ? s.functions : false;
					if (x) {
						delete(s.data)
					}
					if (w) {
						delete(s.functions)
					}
					var m = (z ? l : this.target) + "-cX-ConfiguratorExample-" + l + "-" + t;
					if (!s.graphType) {
						s.graphType = e[0]
					}
					if (w) {
						c.push([m, x, s, w])
					} else {
						c.push([m, x, s])
					}
				}
			}
		}
		return c
	};
	this.clickExamplePropertyDescription = function(a) {
		return function(u, n, y) {
			a.resetPropertyExample();
			var t = y ? a.$(n + "-cX-API-Example") : a.$(a.target + "-cX-ConfiguratorExample");
			var d = y ? a.$(n + "-cX-API-ExampleSpan") : a.$(a.target + "-cX-ConfiguratorExampleSpan");
			var m = y ? a.$(n + "-cX-API-ExampleContent") : a.$(a.target + "-cX-ConfiguratorExampleContent");
			if (t && d && m) {
				t.style.display = "block";
				if (!n) {
					n = this.firstChild.innerHTML
				}
				var f = a.getExamplesDocObject(n);
				d.innerHTML = n;
				for (var r = 0; r < f.length; r++) {
					var o = f[r][0];
					var l = f[r][1];
					var s = f[r][2];
					var g = f[r][3];
					var w = a.$cX("canvas", {
						id: o,
						width: y ? 500 : a.configuratorExamplesSize,
						height: y ? 500 : a.configuratorExamplesSize
					});
					m.appendChild(w);
					var h = new CanvasXpress(o, l, s);
					if (g) {
						for (var q = 0; q < g.length; q++) {
							if (g[q].match(/:/)) {
								var b = g[q].split(":");
								h[b.shift()].apply(h, b)
							} else {
								h[g[q]]()
							}
						}
					}
				}
				if (!y) {
					if (a.alignConfiguratorExamples || a.configuratorLastState == "docked") {
						var k = a.$(a.target + "-cX-Configurator");
						t.style.left = k.offsetWidth + "px";
						t.style.top = "-1px";
						t.style.height = (k.clientHeight - 45) + "px";
						m.style.maxHeight = (k.clientHeight - 45) + "px";
						a.removeClass(t, "draggable")
					} else {
						var x = a.adjustedCoordinates(u, t);
						t.style.left = x.x + "px";
						t.style.top = x.y + "px";
						delete(t.style.height);
						m.style.Maxheight = "500px";
						a.addClass(t, "draggable")
					}
				}
			}
		}
	}(this);
	this.clickEditPropertyDescription = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			a.resetPropertyColor();
			a.resetPropertyFilter();
			a.resetPropertyExample();
			var f = a.$(a.target + "-cX-Configurator");
			var g = a.$(a.target + "-cX-ConfiguratorSugestions");
			var u = a.$(a.target + "-cX-ConfiguratorSugestionsDescriptionEditSpan");
			var m = a.$(a.target + "-cX-ConfiguratorOptions");
			if (f && g && u && m) {
				m.style.display = "none";
				var t = a.adjustedCoordinates(h, g);
				if (t) {
					a.editingDescriptionOn = true;
					var r = t.x;
					var o = t.y;
					var j = a.$cX("div", {
						id: a.target + "-cX-ConfiguratorEditForm",
						className: "CanvasXpressConfigurator draggable"
					}, {
						cursor: "move",
						left: r + "px",
						top: o + "px",
						padding: "10px",
						position: "absolute",
						width: (a.configuratorWidth * 0.8) + "px"
					});
					var l = a.$cX("img", {
						id: a.target + "-cX-ConfiguratorEditFormClose",
						className: "CanvasXpressConfigurator",
						src: CanvasXpress.images.cancel1,
						alt: "Close",
						title: "Close"
					});
					var q = a.$cX("textarea", {
						id: a.target + "-cX-ConfiguratorEditFormValue",
						className: "CanvasXpressConfigurator",
						value: u.prop + u.innerHTML,
						rows: 10
					}, {
						width: "100%",
						maxWidth: (a.configuratorWidth * 0.8) + "px"
					});
					var n = a.$cX("input", {
						id: a.target + "-cX-ConfiguratorEditFormButton",
						value: "Submit",
						type: "button"
					}, {
						width: "100%",
						borderRadius: "5px",
						maxWidth: (a.configuratorWidth * 0.8) + "px"
					});
					j.appendChild(document.createTextNode("Editing " + g.value));
					j.appendChild(l);
					j.appendChild(a.$cX("br"));
					j.appendChild(q);
					j.appendChild(n);
					a.addEvtListener(l, "click", a.closeEditPropertyDescription, false);
					a.addEvtListener(n, "click", a.submitEditPropertyDescription, false);
					f.appendChild(j)
				}
			}
		}
	}(this);
	this.submitEditPropertyDescription = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.$(a.target + "-cX-ConfiguratorSugestions");
			var b = a.$(a.target + "-cX-ConfiguratorEditFormValue");
			var d = a.$(a.target + "-cX-ConfiguratorSugestionsDescriptionEditSpan");
			if (c && b && d) {
				b.value = b.value.replace(/\n/g, "");
				CanvasXpress.doc.P[c.value].C = b.value;
				d.innerHTML = b.value;
				alert("New description for:\n - " + c.value + " -\nwas submitted and may apppear\nin new versions of CanvasXpress\nThank you for your contribution")
			}
			a.resetEditPropertyDescription()
		}
	}(this);
	this.closeEditPropertyDescription = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetEditPropertyDescription()
		}
	}(this);
	this.resetEditPropertyDescription = function() {
		var e = this.$(this.target + "-cX-ConfiguratorEditForm");
		var f = this.$(this.target + "-cX-ConfiguratorEditFormClose");
		var a = this.$(this.target + "-cX-ConfiguratorEditFormButton");
		if (e && f && a) {
			this.addEvtListener(f, "click", this.closeEditPropertyDescription, false);
			this.addEvtListener(a, "click", this.submitEditPropertyDescription, false);
			e.parentNode.removeChild(e)
		}
		this.editingDescriptionOn = false
	};
	this.addPropertySeeAlsoLinks = function(e, g) {
		this.resetPropertySeeAlsoLinks(e);
		var d = this.$cX("span", false, {
			className: "CanvasXpressConfigurator"
		});
		d.appendChild(document.createTextNode("See Also: "));
		e.appendChild(d);
		if (g && g.S) {
			for (var f = 0; f < g.S.length; f++) {
				var h = this.$cX("a", {
					href: "javascript:void(0)",
					innerHTML: g.S[f]
				});
				this.addEvtListener(h, "click", this.clickPropertySeeAlsoLinks, false);
				e.appendChild(h);
				if (f < g.S.length - 1) {
					e.appendChild(document.createTextNode(", "))
				}
			}
		}
	};
	this.clickPropertySeeAlsoLinks = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			var f = a.$(a.target + "-cX-ConfiguratorKey");
			var b = a.$(a.target + "-cX-ConfiguratorCategories");
			var g = a.$(a.target + "-cX-ConfiguratorSugestions");
			var c = h.target || h.srcElement;
			if (b && b.style.display == "block") {
				var l = CanvasXpress.doc.P[c.innerHTML];
				var j = CanvasXpress.doc.M[l.M].P.sort();
				b.value = l.M;
				for (i = 0; i < j.length; i++) {
					if (j[i] == c.innerHTML) {
						a.changeCategory(h, i);
						return false
					}
				}
				a.changeCategory(h)
			} else {
				if (f) {
					f.value = c.innerHTML;
					a.selectConfig(h, true)
				}
			}
			return false
		}
	}(this);
	this.resetPropertySeeAlsoLinks = function(b) {
		if (!b) {
			b = this.$(this.target + "-cX-ConfiguratorSeeAlso")
		}
		if (b && b.childNodes) {
			while (b.childNodes.length > 0) {
				var d = b.childNodes[0];
				if (d.nodeName.toLowerCase() == "a") {
					this.removeEvtListener(d, "click", this.clickPropertySeeAlsoLinks, false)
				}
				b.removeChild(d)
			}
		}
	};
	this.addPropertyOptions = function(w, p, f, g, s) {
		this.resetPropertyOptions(w, p);
		var q = this.$cX("span", false, {
			className: "CanvasXpressConfigurator"
		});
		var l = this.$cX("i");
		q.appendChild(document.createTextNode("Current value"));
		if (f && f.T && (f.T == "option" || f.T == "array" || f.T == "boolean")) {
			var x = this.$cX("div", {
				id: this.target + "-cX-ConfiguratorOptionsContainer",
				className: "CanvasXpressConfiguratorOptions"
			});
			var r = this.$cX("a", {
				href: "javascript:void(0)",
				innerHTML: f.T,
				alt: "Modify property",
				title: "Modify property"
			});
			this.addEvtListener(r, "click", this.clickPropertyOptions, false);
			q.appendChild(document.createTextNode(" ["));
			l.appendChild(r);
			q.appendChild(document.createTextNode(" "));
			q.appendChild(l);
			q.appendChild(document.createTextNode(" ]"));
			if (f.T == "array") {
				var n = f.X ? this[f.X]() : f.O ? f.O : [];
				var m = this.getObjectArray(s);
				if (n.length > 0) {
					for (var h = 0; h < n.length; h++) {
						var g = this.$cX("input", {
							type: "checkbox",
							value: n[h],
							checked: m.hasOwnProperty(n[h]) ? true : false
						}, {
							marginLeft: "0px"
						});
						this.addEvtListener(g, "change", this.updatePropertyValue, false);
						x.appendChild(document.createTextNode((h + 1) + ". "));
						x.appendChild(g);
						x.appendChild(document.createTextNode(n[h]));
						x.appendChild(this.$cX("br"))
					}
				} else {
					x.appendChild(this.$cX("br"));
					x.appendChild(document.createTextNode("This array is user defined"));
					x.appendChild(this.$cX("br"))
				}
			} else {
				var n = f.T == "boolean" ? ["true", "false"] : f.X ? this[f.X]() : f.O ? f.O : [];
				if (f.X && f.O) {
					n = n.concat(f.O)
				}
				for (var h = 0; h < n.length; h++) {
					var g = this.$cX("a", {
						href: "javascript:void(0)",
						innerHTML: n[h],
						alt: "Modify property",
						title: "Modify property"
					}, {
						padding: "2px"
					});
					this.addEvtListener(g, "click", this.updatePropertyValue, false);
					x.appendChild(document.createTextNode((h + 1) + ". "));
					x.appendChild(g);
					x.appendChild(this.$cX("br"))
				}
			}
			p.appendChild(x)
		} else {
			if (f && f.T) {
				q.appendChild(document.createTextNode(" ["));
				if (f.T == "color") {
					var n;
					if (this.configuringNetwork) {
						if (this.configuringNetwork < this.data.nodes.length) {
							n = this.data.nodes[this.configuringNetwork][g]
						} else {
							n = this.data.edges[this.configuringNetwork - this.data.nodes.length][g]
						}
					} else {
						if (this.configuringGenome) {
							var e = this.subtracksInfo;
							if (!isNaN(this.configuringGenome)) {
								n = this.data.tracks[e[this.configuringGenome].track].data[e[this.configuringGenome].index]
							} else {
								if (this.configuringGenome.match(/:/)) {
									n = parseInt(this.configuringGenome.split(":")[1]);
									n = this.data.tracks[e[n].track].data[e[n].index]
								} else {
									n = parseInt(this.configuringGenome.replace("track-", ""));
									n = this.data.tracks[e[n].track]
								}
							}
						} else {
							n = this[g]
						}
					}
					var r = this.$cX("a", {
						id: this.target + "-cX-ConfiguratorValueHREF",
						href: "javascript:void(0)",
						innerHTML: f.T,
						alt: "Modify color",
						title: "Modify color"
					}, {
						color: n ? this.rgbToHex(this.validateColor(n)) : this.foreground
					});
					this.addEvtListener(r, "click", this.addPropertyColor, false);
					l.appendChild(r)
				} else {
					if (f && f.T == "filter") {
						var r = this.$cX("a", {
							id: this.target + "-cX-ConfiguratorValueFilter",
							href: "javascript:void(0)",
							innerHTML: f.T,
							name: g
						});
						r.opts = f.X ? this[f.X]() : f.O ? f.O : [];
						r.opts.unshift("");
						this.addEvtListener(r, "click", this.addPropertyFilter, false);
						l.appendChild(r)
					} else {
						l.appendChild(document.createTextNode(f.T))
					}
				}
				q.appendChild(document.createTextNode(" "));
				q.appendChild(l);
				q.appendChild(document.createTextNode(" ]"))
			}
		}
		w.appendChild(q)
	};
	this.clickPropertyOptions = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.resetEditPropertyDescription();
			var c = a.$(a.target + "-cX-ConfiguratorOptions");
			if (c) {
				c.style.display = "block";
				c.style.left = b.layerX + "px";
				c.style.top = b.layerY + "px"
			}
			return false
		}
	}(this);
	this.closePropertyOptions = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.handleHideDiv(a.target + "-cX-ConfiguratorOptions")
		}
	}(this);
	this.resetPropertyOptions = function(a, e, b) {
		if (!a) {
			a = this.$(this.target + "-cX-ConfiguratorValueText")
		}
		if (!e) {
			e = this.$(this.target + "-cX-ConfiguratorOptions")
		}
		if (a && a.childNodes && !b) {
			while (a.childNodes.length > 0) {
				var f = a.childNodes[0];
				if (f.nodeName.toLowerCase() == "a") {
					this.removeEvtListener(f, "click", this.clickPropertyOptions, false)
				}
				a.removeChild(f)
			}
		}
		if (e) {
			var d = this.$(this.target + "-cX-ConfiguratorOptionsContainer");
			if (d) {
				while (d.childNodes.length > 0) {
					var f = d.childNodes[0];
					if (f.nodeName.toLowerCase() == "a") {
						this.removeEvtListener(f, "click", this.updatePropertyValue, false)
					} else {
						if (f.nodeName.toLowerCase() == "input" && f.type == "checkbox") {
							this.removeEvtListener(f, "change", this.updatePropertyValue, false)
						}
					}
					d.removeChild(f)
				}
				e.removeChild(d)
			}
			e.style.display = "none"
		}
	};
	this.addPropertyFilter = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.resetEditPropertyDescription();
			var b = d.target || d.srcElement;
			var c = a.$(a.target + "-cX-ConfiguratorFilter");
			a.addAllPropertyFilters(b.name, b.opts);
			c.style.display = "block";
			c.opts = b.opts;
			c.style.left = d.layerX + "px";
			c.style.top = d.layerY + "px"
		}
	}(this);
	this.addAllPropertyFilters = function(c, d) {
		var b = this.$(this.target + "-cX-ConfiguratorFilter");
		for (var a = 0; a < this[c].length; a++) {
			this.insertPropertyFilterRow(b, a, c, d)
		}
		this.insertPropertyFilterRow(b, this[c].length, c, d)
	};
	this.insertPropertyFilterRow = function(F, B, r, y) {
		if (!F) {
			F = this.$(this.target + "-cX-ConfiguratorFilter")
		}
		if (F) {
			var e = this.configuratorWidth * 0.25;
			var G = this.$cX("div", {
				id: this.target + "-cX-ConfiguratorFilterContainer" + B
			}, {
				width: (this.configuratorWidth * 1.05) + "px"
			});
			var q = this.$cX("select", {
				id: this.target + "-cX-ConfiguratorFilterSelect" + B,
				className: "CanvasXpressConfiguratorFilter",
				param: r,
				idx: B
			}, {
				marginRight: "2px",
				marginLeft: "1px",
				width: e + "px"
			});
			if (!y) {
				y = F.opts
			}
			y.sort();
			for (var A = 0; A < y.length; A++) {
				var d = this.$cX("option", {
					text: y[A],
					value: y[A]
				});
				try {
					q.add(d, null)
				} catch (E) {
					q.add(d)
				}
				if (this[r][B] && y[A] == this[r][B]) {
					d.selected = true
				}
			}
			this.addEvtListener(q, "change", this.unsetPropertyFilterRow, false);
			var t = this.$cX("select", {
				id: this.target + "-cX-ConfiguratorFilterOp" + B,
				className: "CanvasXpressConfiguratorFilter",
				param: r,
				idx: B
			}, {
				marginRight: "2px",
				width: e + "px"
			});
			var x = this.getOperators();
			for (var A = 0; A < x.length; A++) {
				var d = this.$cX("option", {
					text: x[A],
					value: x[A]
				});
				try {
					t.add(d, null)
				} catch (E) {
					t.add(d)
				}
				if (this[r + "Op"][B] && x[A] == this[r + "Op"][B]) {
					d.selected = true
				}
			}
			this.addEvtListener(t, "change", this.unsetPropertyFilterRow, false);
			var I = this.$cX("img", {
				src: CanvasXpress.images.caseSensitive
			}, {
				width: "10px"
			});
			var H = this.$cX("input", {
				id: this.target + "-cX-ConfiguratorFilterCase" + B,
				type: "checkbox",
				param: r,
				idx: B,
				alt: "Check for case sensitive",
				title: "Check for case sensitive"
			}, {
				width: "10px"
			});
			if (this[r + "Case"][B]) {
				H.checked = true
			}
			this.addEvtListener(H, "change", this.unsetPropertyFilterRow, false);
			var n = this.$cX("input", {
				id: this.target + "-cX-ConfiguratorFilterValue" + B,
				param: r,
				idx: B,
				type: "text"
			}, {
				width: e + "px"
			});
			if (this[r + "Value"][B]) {
				n.value = this[r + "Value"][B]
			}
			this.addEvtListener(n, "change", this.unsetPropertyFilterRow, false);
			var u = this.$cX("img", {
				id: this.target + "-cX-ConfiguratorFilterMinus" + B,
				src: CanvasXpress.images.minus,
				alt: "Remove Filter",
				title: "Remove Filter",
				param: r,
				idx: B
			}, {
				padding: "9px 2px 2px 2px",
				cssFloat: "left",
				cursor: "default",
				width: "10px"
			});
			this.addEvtListener(u, "click", this.removePropertyFilterRow, false);
			var e = this.$cX("img", {
				id: this.target + "-cX-ConfiguratorFilterPlus" + B,
				src: CanvasXpress.images.add1,
				alt: "Set Filter",
				title: "Set Filter",
				param: r,
				idx: B
			}, {
				padding: "7px 2px 2px 2px",
				cssFloat: "right",
				cursor: "default",
				width: "10px"
			});
			this.addEvtListener(e, "click", this.addPropertyFilterRow, false);
			var D = this.$cX("img", {
				id: this.target + "-cX-ConfiguratorFilterCheck" + B,
				src: CanvasXpress.images.accept,
				alt: "Filter added",
				title: "Filter added"
			}, {
				padding: "7px 2px 2px 2px",
				cssFloat: "right",
				cursor: "default",
				width: "10px",
				display: this[r][B] ? "block" : "none"
			});
			var C = this.$cX("div", {
				id: this.target + "-cX-ConfiguratorFilterCheckEmpty" + B
			}, {
				cssFloat: "right",
				cursor: "default",
				width: "10px",
				display: this[r][B] ? "none" : "block"
			});
			G.appendChild(u);
			G.appendChild(q);
			G.appendChild(t);
			G.appendChild(I);
			G.appendChild(H);
			G.appendChild(n);
			G.appendChild(C);
			G.appendChild(D);
			G.appendChild(e);
			F.appendChild(G)
		}
	};
	this.addPropertyFilterRow = function(a) {
		return function(q) {
			if (!q) {
				q = window.event
			}
			var b = q.target || q.srcElement;
			var d = b.parentNode;
			var r = b.param;
			var l = b.idx;
			var t = a.$(a.target + "-cX-ConfiguratorValue");
			var n = a.$(a.target + "-cX-ConfiguratorFilterCheck" + l);
			var m = a.$(a.target + "-cX-ConfiguratorFilterCheckEmpty" + l);
			if (d && r && l != null && t && n && m) {
				var j = d.childNodes[1].value;
				var f = d.childNodes[2].value;
				var s = d.childNodes[4].checked;
				var u = d.childNodes[5].value;
				if (j != "" && ((f != "" && u != "") || f.match("null"))) {
					if (a[r].length > 0 && a[r][l] != null) {
						a[r][l] = j;
						a[r + "Op"][l] = f;
						a[r + "Value"][l] = u;
						a[r + "Case"][l] = s
					} else {
						a[r].push(j);
						a[r + "Op"].push(f);
						a[r + "Value"].push(u);
						a[r + "Case"].push(s);
						a.insertPropertyFilterRow(false, l + 1, r)
					}
					t.value = '["' + a[r].join('", "') + '"]';
					n.style.display = "block";
					m.style.display = "none"
				}
			}
		}
	}(this);
	this.removePropertyFilterRow = function(a) {
		return function(k) {
			if (!k) {
				k = window.event
			}
			var d = k.target || k.srcElement;
			var j = d.parentNode;
			var h = j.parentNode;
			var l = d.param;
			var f = d.idx;
			var b = a.$(a.target + "-cX-ConfiguratorValue");
			if (j && l && f != null && b) {
				a.resetFilters(l, f);
				a.resetPropertyFilter(true);
				a.addAllPropertyFilters(l, h.opts);
				b.value = a[l].length > 0 ? '["' + a[l].join('", "') + '"]' : "[]"
			}
		}
	}(this);
	this.unsetPropertyFilterRow = function(a) {
		return function(m) {
			if (!m) {
				m = window.event
			}
			var p = [];
			var b = m.target || m.srcElement;
			var n = b.param;
			var f = b.idx;
			if (n && f != null) {
				if (a[n].length > 0 && a[n][f]) {
					a[n][f] = false;
					a[n + "Op"][f] = false;
					a[n + "Value"][f] = false;
					a[n + "Case"][f] = false;
					for (var d = 0; d < a[n].length; d++) {
						if (d != f) {
							p.push(a[n][d])
						}
					}
					var l = a.$(a.target + "-cX-ConfiguratorFilterCheck" + f);
					var k = a.$(a.target + "-cX-ConfiguratorFilterCheckEmpty" + f);
					var o = a.$(a.target + "-cX-ConfiguratorValue");
					if (l && k && o) {
						l.style.display = "none";
						k.style.display = "block";
						o.value = p.length > 0 ? '["' + p.join('", "') + '"]' : "[]"
					}
				}
			}
		}
	}(this);
	this.closePropertyFilter = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.handleHideDiv(a.target + "-cX-ConfiguratorFilter");
			a.resetPropertyFilter()
		}
	}(this);
	this.closePropertyExample = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.handleHideDiv(a.target + "-cX-ConfiguratorExample");
			a.resetPropertyExample()
		}
	}(this);
	this.resetPropertyFilter = function(a) {
		var b = this.$(this.target + "-cX-ConfiguratorFilter");
		if (b) {
			if (b && b.childNodes) {
				while (b.childNodes.length > 3) {
					var c = b.childNodes[3];
					this.removeEvtListener(c.childNodes[0], "click", this.removePropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[1], "change", this.unsetPropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[2], "change", this.unsetPropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[4], "change", this.unsetPropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[5], "change", this.unsetPropertyFilterRow, false);
					this.removeEvtListener(c.childNodes[8], "click", this.addPropertyFilterRow, false);
					b.removeChild(b.childNodes[3])
				}
			}
			if (!a) {
				b.style.display = "none"
			}
		}
	};
	this.resetPropertyExample = function(a) {
		var b = this.$(this.target + "-cX-ConfiguratorExample");
		if (b) {
			var c = b.getElementsByTagName("canvas");
			while (c.length > 0) {
				this.destroy(c[0].id)
			}
			if (!a) {
				b.style.display = "none"
			}
		}
	};
	this.addPropertyColor = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			a.resetEditPropertyDescription();
			var d = a.$(a.target + "-cX-ConfiguratorColor");
			var t = a.$(a.target + "-cX-ConfiguratorValue");
			if (d && t) {
				var g = t.value ? a.rgbToHex(a.validateColor(t.value.replace(/[\'\"]/g, ""))) : a.foreground;
				a.colorRGBfromString(g);
				var r = Math.round(a.colorHSV[0] / 6 * 180);
				var q = Math.round((1 - a.colorHSV[1]) * 100);
				var m = Math.round((1 - a.colorHSV[2]) * 100);
				var l = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorContainer"
				}, {
					width: "210px",
					height: "101px",
					marginTop: "7px"
				});
				var b = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorPalette",
					className: "CanvasXpressConfiguratorColorMain"
				}, {
					position: "relative",
					left: "0px",
					top: "0px",
					width: "181px",
					height: "101px"
				});
				var o = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorPaletteCurrent",
					className: "CanvasXpressConfiguratorColorExtra"
				}, {
					position: "relative",
					left: (r - 7) + "px",
					top: (q - 7) + "px",
					width: "195px",
					height: "115px"
				});
				b.appendChild(o);
				var w = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorSaturation",
					className: "CanvasXpressConfiguratorColor"
				}, {
					position: "relative",
					left: "188px",
					width: "15px",
					height: "100px",
					border: "1px solid rgb(51,122,183)",
					cursor: "crosshair"
				});
				for (var f = 0; f < 100; f += 4) {
					var u = a.$cX("div", false, {
						height: "4px",
						position: "relative",
						left: "0px",
						cursor: "crosshair"
					});
					w.appendChild(u)
				}
				var k = a.$cX("div", {
					id: a.target + "-cX-ConfiguratorColorSaturationCurrent",
					className: "CanvasXpressConfiguratorColorExtra"
				}, {
					position: "relative",
					left: "0px",
					top: (m - 108) + "px",
					width: "29px",
					height: "115px"
				});
				w.appendChild(k);
				l.appendChild(b);
				l.appendChild(w);
				d.appendChild(l);
				a.colorizeCurrentColorDiv();
				a.colorizeSaturationColorDiv();
				a.addEvtListener(b, "mousedown", a.registerPalette, false);
				a.addEvtListener(w, "mousedown", a.registerSaturation, false);
				d.style.display = "block";
				d.style.left = j.layerX + "px";
				d.style.top = j.layerY + "px"
			}
			return false
		}
	}(this);
	this.registerPalette = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.changingColorOn = "palette";
			if (a.colorHSV[2] == 0) {
				a.colorFromHsv(null, null, 1);
				a.colorizeCurrentColorDiv();
				var c = a.$(a.target + "-cX-ConfiguratorColorSaturationCurrent");
				if (c) {
					c.style.top = "-108px"
				}
			}
			a.updateColorValue(b);
			a.colorizeSaturationColorDiv();
			return false
		}
	}(this);
	this.registerSaturation = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.changingColorOn = "saturation";
			a.updateColorValue(b);
			return false
		}
	}(this);
	this.updateColorValue = function(g) {
		if (this.changingColorOn) {
			if (this.changingColorOn == "palette") {
				var f = this.$(this.target + "-cX-ConfiguratorColorPalette");
				var b = this.$(this.target + "-cX-ConfiguratorColorPaletteCurrent");
				if (f && b) {
					var d = this.adjustedCoordinates(g, f);
					if (d) {
						var a = Math.min(Math.max(0, d.x), 181);
						var j = Math.min(Math.max(0, d.y), 101);
						b.style.left = (a - 7) + "px";
						b.style.top = (j - 7) + "px";
						this.colorFromHsv(a * 6 / 180, 1 - j / 100, null);
						this.colorizeCurrentColorDiv();
						this.colorizeSaturationColorDiv()
					}
				}
			} else {
				var c = this.$(this.target + "-cX-ConfiguratorColorSaturation");
				var h = this.$(this.target + "-cX-ConfiguratorColorSaturationCurrent");
				if (c && h) {
					var d = this.adjustedCoordinates(g, c);
					if (d) {
						var j = Math.min(Math.max(0, d.y), 101);
						h.style.top = (j - 108) + "px";
						this.colorFromHsv(null, null, 1 - j / 100);
						this.colorizeCurrentColorDiv()
					}
				}
			}
		}
	};
	this.colorizeCurrentColorDiv = function() {
		var f = this.$(this.target + "-cX-ConfiguratorColorCurrent");
		var a = this.$(this.target + "-cX-ConfiguratorValue");
		var d = this.$(this.target + "-cX-ConfiguratorValueHREF");
		if (f && a && d) {
			var e = this.colorRGBToString();
			var b = this.hexToRgb("#" + e);
			f.style.backgroundColor = "#" + e;
			f.innerHTML = "&nbsp;&nbsp;" + b;
			f.style.color = this.complementaryColor(b, true);
			a.value = '"' + b + '"';
			d.style.color = "#" + e
		}
	};
	this.colorizeSaturationColorDiv = function() {
		var b = function(m, k, c, j, h) {
			return "rgb(" + (m * (1 - j / h) * 100) + "%," + (k * (1 - j / h) * 100) + "%," + (c * (1 - j / h) * 100) + "%)"
		};
		var e = this.$(this.target + "-cX-ConfiguratorColorSaturation");
		if (e && this.colorHSV) {
			var f = e.childNodes;
			var a = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], 1);
			if (a) {
				for (var d = 0; d < f.length - 1; d++) {
					f[d].style.backgroundColor = b(a[0], a[1], a[2], d, f.length - 1)
				}
			}
		}
	};
	this.endColorChange = function(a) {
		this.changingColorOn = false
	};
	this.closePropertyColor = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.handleHideDiv(a.target + "-cX-ConfiguratorColor");
			a.resetPropertyColor()
		}
	}(this);
	this.resetPropertyColor = function() {
		var c = this.$(this.target + "-cX-ConfiguratorColor");
		var b = this.$(this.target + "-cX-ConfiguratorColorPalette");
		var a = this.$(this.target + "-cX-ConfiguratorColorSaturation");
		if (c && b && a) {
			if (c && c.childNodes) {
				while (c.childNodes.length > 3) {
					c.removeChild(c.childNodes[3])
				}
				this.removeEvtListener(b, "mousedown", this.registerPalette, false);
				this.removeEvtListener(a, "mousedown", this.registerSaturation, false)
			}
			c.style.display = "none"
		}
	};
	this.updatePropertyValue = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			a.resetEditPropertyDescription();
			var f = a.$(a.target + "-cX-ConfiguratorValue");
			var j = a.$(a.target + "-cX-ConfiguratorOptions");
			var d = h.target || h.srcElement;
			if (d.nodeName.toLowerCase() == "input") {
				var b = [];
				for (var g = 0; g < d.parentNode.childNodes.length; g++) {
					var k = d.parentNode.childNodes[g];
					if (k.checked) {
						b.push(k.value)
					}
				}
				f.value = b.length > 0 ? '["' + b.join('", "') + '"]' : "[]"
			} else {
				if (f && j) {
					if (d.innerHTML == "true") {
						f.value = d.innerHTML
					} else {
						if (d.innerHTML == "false") {
							f.value = d.innerHTML
						} else {
							if (d.innerHTML == "null") {
								f.value = d.innerHTML
							} else {
								f.value = '"' + d.innerHTML + '"'
							}
						}
					}
					j.style.display = "none"
				}
			}
			return false
		}
	}(this);
	this.clickApplyConfigurator = function(a) {
		return function(b) {
			return a.clickConfigurator(b, false, false, true)
		}
	}(this);
	this.clickConfigurator = function(a) {
		return function(g, d, c, b) {
			if (!g) {
				g = window.event
			}
			if (!d) {
				d = a.$(a.target + "-cX-ConfiguratorSugestions")
			}
			if (!c) {
				c = a.$(a.target + "-cX-ConfiguratorValue")
			}
			if (d && c) {
				var f = a.getConfigurableObjectDoc(d.value);
				if (c.value) {
					var h = JSON.parse(c.value);
					if (f.T == "color" && !a.validateColor(h)) {
						alert('"' + h + '" is NOT a valid color');
						return false
					}
				}
			}
			a.updateClickConfigurator(d.value, c.value, b);
			return false
		}
	}(this);
	this.updateClickConfigurator = function(g, d, b) {
		this.functionCaller = "updateClickConfigurator";
		if (this.configuringNetwork) {
			if (this.configuringNetwork < this.data.nodes.length) {
				if (typeof(this[g]) == "function") {
					this[g](this.data.nodes[this.configuringNetwork])
				} else {
					this.data.nodes[this.configuringNetwork][g] = JSON.parse(d)
				}
			} else {
				if (typeof(this[g]) == "function") {
					this[g](this.data.edges[this.configuringNetwork - this.data.nodes.length])
				} else {
					this.data.edges[this.configuringNetwork - this.data.nodes.length][g] = JSON.parse(d)
				}
			}
		} else {
			if (this.configuringGenome) {
				var e = this.subtracksInfo;
				if (!isNaN(this.configuringGenome)) {
					this.data.tracks[e[this.configuringGenome].track].data[e[this.configuringGenome].index][g] = JSON.parse(d)
				} else {
					if (this.configuringGenome.match(/:/)) {
						var j = parseInt(this.configuringGenome.split(":")[1]);
						this.data.tracks[e[j].track].data[e[j].index][g] = JSON.parse(d)
					} else {
						var j = parseInt(this.configuringGenome.replace("track-", ""));
						this.data.tracks[j][g] = JSON.parse(d)
					}
				}
			} else {
				if (typeof(this[g]) == "function") {
					if (this[g].length > 0 && d) {
						var c = JSON.parse(d);
						this[g](c)
					} else {
						this[g]()
					}
					this.resetConfigurator();
					return false
				} else {
					this[g] = JSON.parse(d);
					this.meta.config.user[g] = this[g]
				}
			}
		}
		if (!b) {
			this.resetConfigurator()
		}
		var h = g.match(/filter(.+)By/);
		if (h) {
			this.reset();
			this.filterData()
		}
		this.resetPropertyExample();
		this.draw()
	};
	this.handleHideDiv = function(a) {
		var b = this.$(a);
		if (b) {
			b.style.display = "none"
		}
		return false
	};
	this.resetOptionColorFiltersExamples = function() {
		this.resetPropertyOptions(false, false, true);
		this.resetPropertyColor();
		this.resetPropertyFilter();
		this.resetPropertyExample()
	};
	this.resetEditOptionColorFiltersExamples = function() {
		this.resetEditPropertyDescription();
		this.resetPropertyOptions(false, false, true);
		this.resetPropertyFilter();
		this.resetPropertyExample()
	};
	this.resetConfigurator = function() {
		if (this.configuringOn && this.configuringOn != "docked") {
			this.resetEditOptionColorFiltersExamples();
			this.resetPropertyDescription();
			this.resetPropertySeeAlsoLinks();
			this.editingDescriptionOn = false;
			this.configuratorLastState = false;
			this.configuringOn = false;
			this.configuringNetwork = false;
			this.configuringGenome = false;
			this.addRemoveConfiguratorListeners("removeEvtListener");
			this.removeTarget(this.target + "-cX-Configurator")
		}
	}
};
CanvasXpress.prototype.initAcknowlegments = function() {
	this.addAcknowledgmentDiv = function() {
		if (this.$(this.target + "canvasXpressAcknowledgmentDiv")) {
			this.setAcknowledgmentVisibility();
			return
		}
		var f = document.createElement("div");
		f.id = this.target + "canvasXpressAcknowledgmentDiv";
		f.style.display = this.acknowledgment ? "block" : "none";
		f.style.width = this.width + "px";
		f.style.cssFloat = "left";
		f.style.position = "relative";
		f.style.zIndex = 9999;
		f.style.display = this.acknowledgment ? "block" : "none";
		f.style.top = this.citation ? (((this.citationFontSize * this.citationScaleFontFactor) + 36) * -1) + "px" : "-31px";
		f.style.right = "3px";
		var c = document.createElement("img");
		c.src = CanvasXpress.images.cx;
		c.style.margin = "2px";
		c.alt = "Graphs powered by canvasXpress";
		c.title = "Graphs powered by canvasXpress";
		c.style.cssFloat = "right";
		var b = document.createElement("a");
		b.href = "http://canvasxpress.org";
		b.target = "_blank";
		b.style.cssFloat = "right";
		b.appendChild(c);
		f.appendChild(b);
		var e = this.$("south-wrapper-" + this.target);
		if (e) {
			e.appendChild(f)
		}
	};
	this.resizeAcknowledgmentDiv = function() {
		var b = this.$(this.target + "canvasXpressAcknowledgmentDiv");
		if (b) {
			b.style.width = this.width + "px"
		}
	};
	this.setAcknowledgmentVisibility = function() {
		var b = this.$(this.target + "canvasXpressAcknowledgmentDiv");
		if (b) {
			b.style.display = this.acknowledgment ? "block" : "none";
			b.style.top = this.citation ? (((this.citationFontSize * this.citationScaleFontFactor) + 36) * -1) + "px" : "-31px";
			b.style.right = "3px"
		}
	};
	this.addAcknowledgmentDiv()
};
CanvasXpress.prototype.initCodeInfo = function() {
	this.addInfoCodeDiv = function() {
		if (this.$(this.target + "-cX-Code")) {
			return
		}
		var h = this.$cX("div", {
			id: this.target + "-cX-Code",
			className: "CanvasXpressCode draggable"
		}, {
			left: "50px",
			top: "-200px",
			display: "none"
		});
		var j = this.$cX("img", {
			id: this.target + "-cX-CodeCloseImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.cancel1,
			alt: "Close Code",
			title: "Close Code"
		});
		var f = this.$cX("img", {
			id: this.target + "-cX-CodePrettyImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.blueCode,
			alt: "Pretty Code",
			title: "Pretty Code"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-CodeCompactImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.greenCode,
			alt: "Compact Code",
			title: "Compact Code"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-CodeTabImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.yellowCode,
			alt: "Tab Code",
			title: "Tab Code"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-CodeParamsImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.redCode,
			alt: "Params Code",
			title: "Params Code"
		});
		var k = this.$cX("img", {
			id: this.target + "-cX-CodeSelectImage",
			className: "CanvasXpressCode",
			src: CanvasXpress.images.selectAll,
			alt: "Select Code",
			title: "Select Code"
		});
		var g = this.$cX("div", {
			id: this.target + "-cX-CodeContainer",
			className: "CanvasXpressCodeContainer"
		});
		var a = this.$("north-wrapper-" + this.target);
		var l = this.$("south-wrapper-" + this.target);
		if (a) {
			a.appendChild(g)
		}
		if (l) {
			h.appendChild(j);
			h.appendChild(f);
			h.appendChild(e);
			h.appendChild(d);
			h.appendChild(b);
			h.appendChild(k);
			h.appendChild(g);
			l.appendChild(h);
			this.addRemoveCodeListeners("addEvtListener")
		}
	};
	this.addRemoveCodeListeners = function(a) {
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-Code"), "mousedown", this.registerMousemove, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeCloseImage"), "click", this.clickCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodePrettyImage"), "click", this.clickChangeCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeCompactImage"), "click", this.clickChangeCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeTabImage"), "click", this.clickChangeCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeParamsImage"), "click", this.clickChangeCode, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-CodeSelectImage"), "click", this.clickSelectCode, false)
	};
	this.clickCode = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.hideCodeDiv();
			return false
		}
	}(this);
	this.clickChangeCode = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			switch (b.id) {
				case a.target + "-cX-CodePrettyImage":
					a.codeType = "pretty";
					break;
				case a.target + "-cX-CodeCompactImage":
					a.codeType = "compact";
					break;
				case a.target + "-cX-CodeTabImage":
					a.codeType = "tab";
					break;
				case a.target + "-cX-CodeParamsImage":
					a.codeType = "params";
					break;
				default:
					break
			}
			a.updateCodeDiv();
			return false
		}
	}(this);
	this.clickSelectCode = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b;
			var c = a.$(a.target + "-cX-CodeContent");
			if (c) {
				if (document.selection) {
					b = document.body.createTextRange();
					b.moveToElementText(c);
					b.select()
				} else {
					if (window.getSelection) {
						b = document.createRange();
						b.selectNode(c);
						window.getSelection().addRange(b)
					}
				}
			}
			return false
		}
	}(this);
	this.clearCodeDiv = function() {
		var b = this.$(this.target + "-cX-Code");
		var a = this.$(this.target + "-cX-CodeContent");
		if (b && a) {
			a.parentNode.removeChild(a);
			b.style.display = "none"
		}
	};
	this.updateCodeDiv = function(i) {
		var j = this.$(this.target + "-cX-Code");
		var d = this.$(this.target + "-cX-CodeContainer");
		var g = this.cloneObject(this.data);
		var e = this.codeType == "pretty" ? this.prettyJSON(g) : this.codeType == "params" ? "{\n  ...\n}" : JSON.stringify(g);
		var f = this.codeType == "pretty" || this.codeType == "params" ? this.prettyJSON(this.getConfig()) : JSON.stringify(this.getConfig());
		if (j && d) {
			this.clearCodeDiv();
			var a = this.codeType == "tab" || this.codeType == "compact" ? "span" : "pre";
			var b = this.codeType == "tab" ? "canvasID\t" + e + "\t" + f + "\n" : 'new CanvasXpress("canvasID", ' + e + ", " + f + ")\n";
			d.appendChild(this.$cX(a, {
				id: this.target + "-cX-CodeContent",
				className: "CanvasXpressCodeContent",
				innerHTML: b
			}));
			j.style.display = "block";
			if (i) {
				j.style.zIndex = i
			}
		}
	};
	this.updateInfoDiv = function(a) {
		var b = this.$(this.target + "-cX-Info");
		if (b && a) {
			b.innerHTML = a
		}
	};
	this.showDiv = function(a) {
		var b = this.$(this.target + "-cX-" + a);
		if (b) {
			b.style.display = "block"
		}
	};
	this.hideDiv = function(a) {
		var b = this.$(this.target + "-cX-" + a);
		if (b) {
			b.style.display = "none"
		}
	};
	this.showCodeDiv = function() {
		this.updateCodeDiv();
		this.removeMenus();
		this.showDiv("Code")
	};
	this.hideCodeDiv = function() {
		this.hideDiv("Code")
	};
	this.showInfoDiv = function() {
		this.removeMenus();
		this.showDiv("Info")
	};
	this.hideInfoDiv = function() {
		this.hideDiv("Info")
	};
	this.initializeCodeInfo = function() {
		this.addInfoCodeDiv()
	};
	this.initializeCodeInfo()
};
CanvasXpress.prototype.initBin = function() {
	this.addBinConfigurator = function(M, B) {
		this.removeMenus();
		var z = this.target + "-" + M + "-cX-Bin";
		var f = this.range(this.data.y.data[M]);
		var E = (f[1] - f[0]) / B;
		var w = this.getAxisDecimals(f[0]) + 1;
		this.binConfigurations[z] = {};
		this.binConfigurations[z]["apply"] = false;
		this.binConfigurations[z]["n"] = B;
		this.binConfigurations[z]["vi"] = M;
		this.binConfigurations[z]["min"] = f[0];
		this.binConfigurations[z]["max"] = f[1];
		this.binConfigurations[z]["dec"] = w;
		this.binConfigurations[z]["name"] = "Custom-" + this.data.y.vars[M] + "-Bin";
		this.binConfigurations[z]["bins"] = [];
		for (var H = 0; H < B; H++) {
			this.binConfigurations[z]["bins"][H] = {
				name: "Bin-" + (H + 1),
				value: Number(f[0] + ((H + 1) * E))
			}
		}
		var I = this.$cX("div", {
			id: z,
			className: "CanvasXpressBin draggable"
		}, {
			left: "20px",
			top: "-200px",
			display: "block"
		});
		var g = this.$cX("img", {
			id: z + "CloseImage",
			className: "CanvasXpressBin",
			src: CanvasXpress.images.cancel1,
			alt: "Close Bin Configurator",
			title: "Close Bin Configurator"
		});
		var J = this.$cX("div", {
			id: z + "Container",
			className: "CanvasXpressBinContainer"
		});
		var C = this.$cX("input", {
			id: z + "Name",
			className: "CanvasXpressBin",
			type: "text",
			value: "Custom-" + this.data.y.vars[M] + "-Bin"
		}, {
			width: "100%"
		});
		var A = this.$cX("div", {
			id: z + "NameSegmentContainer",
			className: "CanvasXpressBinNameContainer"
		});
		var y = this.$cX("table", {
			id: z + "NameSegment",
			className: "CanvasXpressBinTable"
		}, {
			width: "100%"
		});
		var v = this.$cX("tbody");
		var G = this.$cX("th");
		var F = this.$cX("th", {
			innerHTML: "Name"
		});
		var D = this.$cX("th", {
			innerHTML: "Max"
		});
		var o = this.$cX("tr");
		o.appendChild(G);
		o.appendChild(F);
		o.appendChild(D);
		v.appendChild(o);
		for (var H = 0; H < B; H++) {
			var G = this.$cX("td", {
				innerHTML: H + 1
			}, {
				width: (this.configuratorWidth * 0.1) + "px"
			});
			var F = this.$cX("td");
			var D = this.$cX("td");
			var e = this.$cX("input", {
				id: z + "Name" + H,
				className: "CanvasXpressBin",
				type: "text",
				value: "Bin-" + (H + 1)
			}, {
				width: (this.configuratorWidth * 0.65) + "px"
			});
			var h = this.$cX("input", {
				id: z + "Value" + H,
				className: "CanvasXpressBin",
				type: "text",
				value: this.formatNumber(f[0] + ((H + 1) * E), w)
			}, {
				width: (this.configuratorWidth * 0.25) + "px"
			});
			var o = this.$cX("tr");
			D.appendChild(h);
			F.appendChild(e);
			o.appendChild(G);
			o.appendChild(F);
			o.appendChild(D);
			v.appendChild(o)
		}
		y.appendChild(v);
		A.appendChild(y);
		var L = this.$cX("input", {
			id: z + "Apply",
			value: "Apply",
			type: "button"
		}, {
			cssFloat: "left",
			borderRadius: "5px",
			top: "4px",
			position: "relative",
			width: "50%"
		});
		var K = this.$cX("input", {
			id: z + "Button",
			value: "Done",
			type: "button"
		}, {
			cssFloat: "left",
			borderRadius: "5px",
			top: "4px",
			position: "relative",
			width: "50%"
		});
		var u = this.$("south-wrapper-" + this.target);
		if (u) {
			J.appendChild(this.$cX("span", {
				className: "CanvasXpressBin",
				innerHTML: "Edit Name"
			}));
			J.appendChild(this.$cX("br"));
			J.appendChild(C);
			J.appendChild(this.$cX("br"));
			J.appendChild(this.$cX("br"));
			J.appendChild(this.$cX("span", {
				className: "CanvasXpressBin",
				innerHTML: "Edit Bin Name and Range"
			}));
			J.appendChild(this.$cX("br"));
			J.appendChild(A);
			J.appendChild(L);
			J.appendChild(K);
			J.appendChild(this.$cX("br"));
			I.appendChild(g);
			I.appendChild(J);
			u.appendChild(I);
			this.addRemoveBinListeners("addEvtListener", z)
		}
	};
	this.addRemoveBinListeners = function(b, d) {
		var c = d ? [d] : this.getKeys(this.binConfigurations);
		for (var a = 0; a < c.length; a++) {
			this.addRemoveEvtListener(b, this.$(c[a]), "mousedown", this.registerMousemove, false);
			this.addRemoveEvtListener(b, this.$(c[a] + "CloseImage"), "click", this.closeBinConfigurator, false);
			this.addRemoveEvtListener(b, this.$(c[a] + "Apply"), "click", this.applyBinConfigurator, false);
			this.addRemoveEvtListener(b, this.$(c[a] + "Button"), "click", this.doneBinConfigurator, false);
			if (b == "removeEvtListener" && this.binConfigurations[c[a]] && !this.binConfigurations[c[a]]["apply"]) {
				delete(this.binConfigurations[c[a]])
			}
		}
	};
	this.closeBinConfigurator = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			var f = b.id.replace("CloseImage", "");
			var d = a.$(f);
			if (d) {
				a.addRemoveBinListeners("removeEvtListener", f);
				d.parentNode.removeChild(d)
			}
			return false
		}
	}(this);
	this.validateBinning = function(a) {
		var e = false;
		var h = this.$(a + "Name0").value;
		var m = this.$(a + "Value0").value;
		for (var k = 1; k < this.binConfigurations[a]["n"]; k++) {
			var p = this.$(a + "Name" + k).value;
			var b = this.$(a + "Value" + k).value;
			if (h == "" || h == null) {
				e = "Value for Bin " + k + " CANNOT be null";
				break
			} else {
				if (p == "" || p == null) {
					e = "Value for Bin " + (k + 1) + " CANNOT be null";
					break
				} else {
					if (m == "" || m == null) {
						e = "Value for " + h + " (" + m + ") CANNOT be null";
						break
					} else {
						if (b == "" || b == null) {
							e = "Value for " + p + " (" + b + ") CANNOT be null";
							break
						} else {
							if (isNaN(m)) {
								e = "Value for " + h + " (" + m + ") is NOT a number";
								break
							} else {
								if (isNaN(b)) {
									e = "Value for " + p + " (" + b + ") is NOT a number";
									break
								} else {
									if (m > b) {
										e = "Value for " + h + " (" + m + ")CANNOT be greater that value for " + p + " (" + b + ")";
										break
									}
									h = p;
									m = b
								}
							}
						}
					}
				}
			}
		}
		if (e) {
			alert(e);
			return false
		} else {
			for (var k = 0; k < this.binConfigurations[a]["n"]; k++) {
				var c = this.$(a + "Name" + k).value;
				var o = this.$(a + "Value" + k).value;
				this.binConfigurations[a]["bins"][k] = {
					name: c,
					value: o
				}
			}
			var d = this.binConfigurations[a]["name"];
			var g = this.binConfigurations[a]["vi"];
			this.data.x[d] = [];
			for (var k = 0; k < this.data.y.data[g].length; k++) {
				var o = this.data.y.data[g][k];
				if (!isNaN(o) && o != "" && o != null) {
					for (var f = 0; f < this.binConfigurations[a]["n"]; f++) {
						if (o <= this.binConfigurations[a]["bins"][f].value) {
							this.data.x[d][k] = this.binConfigurations[a]["bins"][f].name;
							break
						}
					}
				} else {
					this.data.x[d][k] = ""
				}
			}
			if (this.isGroupedData) {
				this.ungroupSamples(true)
			}
			this.updateData(this.data);
			this.groupSamples([d]);
			this.sortSamplesByCategory([d]);
			this.binConfigurations[a]["apply"] = true;
			return true
		}
	};
	this.applyBinConfigurator = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			var d = b.id.replace("Apply", "");
			a.validateBinning(d)
		}
	}(this);
	this.doneBinConfigurator = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = a.getTargetEvent(d);
			var g = b.id.replace("Button", "");
			var c = a.validateBinning(g);
			var f = a.$(g);
			if (f && c) {
				a.addRemoveBinListeners("removeEvtListener", g);
				f.parentNode.removeChild(f)
			}
			return false
		}
	}(this)
};
CanvasXpress.prototype.initDataExplorer = function() {
	this.addDataExplorer = function(f) {
		var a = this.target + "-cX-DataExplorer";
		var j = this.$(a);
		if (j) {
			return
		}
		var g = this.$cX("div", {
			id: this.target + "-cX-DataExplorer",
			className: "CanvasXpressBin draggable"
		}, {
			left: "20px",
			top: "-" + (this.height - 20) + "px",
			display: "block"
		});
		var m = this.$cX("img", {
			id: this.target + "-cX-DataExplorerCloseImage",
			className: "CanvasXpressBin",
			src: CanvasXpress.images.cancel1,
			alt: "Close Data Explorer",
			title: "Close Data Explorer"
		}, {
			height: "18px"
		});
		var h = this.$cX("div", {
			id: this.target + "-cX-DataExplorerContainer",
			className: "CanvasXpressBinContainer"
		});
		var k = this.$("south-wrapper-" + this.target);
		if (k) {
			g.appendChild(m);
			var o = this.loadDataExplorerTopPanel();
			h.appendChild(o);
			var i = this.$cX("img", {
				id: this.target + "-cX-DataExplorerMinimizeImage1",
				className: "CanvasXpressBin",
				src: CanvasXpress.images.collapseFolder,
				srt: CanvasXpress.images.expandFolder,
				alt: "Collapse Variables and Sample Metadata",
				title: "Collapse Variables and Sample Metadata"
			}, {
				height: "18px"
			});
			h.appendChild(i);
			var n = this.loadDataExplorerMiddlePanel();
			h.appendChild(n);
			h.appendChild(this.$cX("br"));
			h.appendChild(this.$cX("hr", {
				className: "CanvasXpressDataExplorer"
			}, {
				width: "201px"
			}));
			var b = this.$cX("img", {
				id: this.target + "-cX-DataExplorerMinimizeImage2",
				className: "CanvasXpressBin",
				src: CanvasXpress.images.collapseFolder,
				srt: CanvasXpress.images.expandFolder,
				alt: "Collapse Samples and Variable Metadata",
				title: "Collapse Samples and Variable Metadata"
			}, {
				height: "18px"
			});
			h.appendChild(b);
			var l = this.loadDataExplorerBottomPanel();
			h.appendChild(l);
			g.appendChild(h);
			k.appendChild(g);
			this.addRemoveDataExplorerListeners("addEvtListener")
		}
	};
	this.loadDataExplorerTopPanel = function() {
		var g = this.loadFormatDataExplorerDiv();
		var c = this.loadLayoutDataExplorerDiv();
		var a = this.loadMetadataDataExplorerDiv();
		var h = this.loadPropertiesDataExplorerDiv();
		var f = this.loadOrientationDataExplorerDiv();
		var b = this.loadGraphTypesDataExplorerDiv();
		var e = this.loadAxesDataExplorerDiv();
		var d = this.$cX("div", {
			className: "CanvasXpressDataExplorerPanel"
		});
		d.appendChild(g);
		d.appendChild(c);
		d.appendChild(a);
		d.appendChild(this.$cX("br"));
		d.appendChild(h);
		d.appendChild(f);
		d.appendChild(this.$cX("br"));
		d.appendChild(b);
		d.appendChild(e);
		d.appendChild(this.$cX("br"));
		d.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "201px"
		}));
		return d
	};
	this.loadDataExplorerMiddlePanel = function() {
		var b = this.loadVariablesDataExplorerDiv();
		var a = this.loadAnnotationsDataExplorerDiv();
		var c = this.$cX("div", {
			className: "CanvasXpressDataExplorerPanel"
		});
		c.appendChild(this.$cX("br"));
		c.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Variables / Data Series"
		}));
		c.appendChild(this.$cX("img", {
			id: this.target + "-cX-DataExplorerSortVariables",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sortAsciiAsc,
			asr: CanvasXpress.images.sortAsciiDesc,
			params: ["sortDataExplorer"],
			alt: "Sort Variables",
			title: "Sort Variables"
		}, {
			border: "none",
			padding: 0
		}));
		c.appendChild(this.$cX("br"));
		c.appendChild(b);
		c.appendChild(this.$cX("br"));
		c.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Sample Metadata"
		}));
		c.appendChild(this.$cX("img", {
			id: this.target + "-cX-DataExplorerSortAnnotations",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sortAsciiAsc,
			asr: CanvasXpress.images.sortAsciiDesc,
			params: ["sortDataExplorer"],
			alt: "Sort Sample Metadata",
			title: "Sort Sample Metadata"
		}, {
			border: "none",
			padding: 0
		}));
		c.appendChild(this.$cX("br"));
		c.appendChild(a);
		return c
	};
	this.loadDataExplorerBottomPanel = function() {
		var a = this.loadSamplesDataExplorerDiv();
		var c = this.loadDescriptionsDataExplorerDiv();
		var b = this.$cX("div", {
			className: "CanvasXpressDataExplorerPanel"
		});
		b.appendChild(this.$cX("br"));
		b.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Samples"
		}));
		b.appendChild(this.$cX("img", {
			id: this.target + "-cX-DataExplorerSortSamples",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sortAsciiAsc,
			asr: CanvasXpress.images.sortAsciiDesc,
			params: ["sortDataExplorer"],
			alt: "Sort Samples",
			title: "Sort Samples"
		}, {
			border: "none",
			padding: 0
		}));
		b.appendChild(this.$cX("br"));
		b.appendChild(a);
		b.appendChild(this.$cX("br"));
		b.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Variable Metadata"
		}));
		b.appendChild(this.$cX("img", {
			id: this.target + "-cX-DataExplorerSortDescriptions",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sortAsciiAsc,
			asr: CanvasXpress.images.sortAsciiDesc,
			params: ["sortDataExplorer"],
			alt: "Sort Variable Metadata",
			title: "Sort Variable Metadata"
		}, {
			border: "none",
			padding: 0
		}));
		b.appendChild(this.$cX("br"));
		b.appendChild(c);
		return b
	};
	this.loadFormatDataExplorerDiv = function() {
		var b = this.$cX("div", {
			id: this.target + "-cX-DataExplorerFormat",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "47px",
			height: "43px",
			textAlign: "center",
			cssFloat: "left"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerTranspose",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.transposeData,
			params: ["transpose"],
			alt: "Transpose data",
			title: "Transpose data"
		});
		b.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Format",
			title: "Click in icons to reformat data",
			alt: "Click in icons to reformat data"
		}, {
			width: "47px",
			cursor: "pointer"
		}));
		b.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "53px"
		}));
		b.appendChild(a);
		return b
	};
	this.loadLayoutDataExplorerDiv = function() {
		var c = this.$cX("div", {
			id: this.target + "-cX-DataExplorerLayout",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "60px",
			height: "43px",
			textAlign: "center",
			cssFloat: "left"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerGroupSamples",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.groupSamples,
			params: ["groupSamples"],
			alt: "Group Samples",
			title: "Group Samples"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerSegregate",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.segregate,
			params: ["segregate"],
			alt: "Segregate Data",
			title: "Segregate Data"
		});
		c.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Layout",
			title: "Drag sample metadata to change layout",
			alt: "Drag sample metadata to change layout"
		}, {
			width: "60px",
			cursor: "pointer"
		}));
		c.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "66px"
		}));
		c.appendChild(a);
		c.appendChild(b);
		return c
	};
	this.loadMetadataDataExplorerDiv = function() {
		var a = this.$cX("div", {
			id: this.target + "-cX-DataExplorerMetadata",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "45px",
			height: "43px",
			textAlign: "center",
			cssFloat: "left"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerDOE",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.doe,
			params: ["createDOE"],
			alt: "Explore Meta Data",
			title: "Explore Meta Data"
		});
		a.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "DOE",
			title: "Click in icon to explore meta data",
			alt: "Click in icon to explore meta data"
		}, {
			width: "45px",
			cursor: "pointer"
		}));
		a.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "51px"
		}));
		a.appendChild(b);
		return a
	};
	this.loadPropertiesDataExplorerDiv = function() {
		var g = this.$cX("div", {
			id: this.target + "-cX-DataExplorerProperties",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "90px",
			height: "74px",
			textAlign: "center",
			cssFloat: "left"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-DataExplorerColor",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.colors,
			params: ["colorBy"],
			alt: "Color Data",
			title: "Color Data"
		});
		var f = this.$cX("img", {
			id: this.target + "-cX-DataExplorerShape",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.shapes,
			params: ["shapeBy"],
			alt: "Shape Data",
			title: "Shape Data"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerSize",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.sizes,
			params: ["sizeBy"],
			alt: "Size Data",
			title: "Size Data"
		});
		var c = this.$cX("img", {
			id: this.target + "-cX-DataExplorerPattern",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.patterns,
			params: ["patternBy"],
			alt: "Pattern Data",
			title: "Pattern Data"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerConnect",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.connects,
			params: ["connectBy"],
			alt: "Connect Data",
			title: "Connect Data"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-DataExplorerTreemapBy",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.treemap,
			params: ["treemapBy"],
			alt: "Treemap Data",
			title: "Treemap Data"
		});
		g.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Properties",
			title: "Drag metadata to change propeties",
			alt: "Drag metadata to change properties"
		}, {
			width: "90px",
			cursor: "pointer"
		}));
		g.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "96px"
		}));
		g.appendChild(d);
		g.appendChild(f);
		g.appendChild(b);
		g.appendChild(c);
		g.appendChild(a);
		g.appendChild(e);
		return g
	};
	this.loadOrientationDataExplorerDiv = function() {
		var c = this.$cX("div", {
			id: this.target + "-cX-DataExplorerOrientation",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "77px",
			height: "43px",
			textAlign: "center",
			cssFloat: "left"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerVertical",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.graphOrientationVertical,
			params: ["changeAttribute", ["graphOrientation", "vertical"]],
			alt: "Vertical Graph",
			title: "Vertical Graph"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-DataExplorerHorizontal",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.graphOrientationHorizontal,
			params: ["changeAttribute", ["graphOrientation", "horizontal"]],
			alt: "Horizontal Graph",
			title: "Horizontal Graph"
		});
		var b = this.loadFileUploadDataExplorerDiv();
		c.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Orientation",
			title: "Click icon to change graph orientation",
			alt: "Click icon to change graph orientation"
		}, {
			width: "77px",
			cursor: "pointer"
		}));
		c.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "83px"
		}));
		c.appendChild(a);
		c.appendChild(d);
		c.appendChild(b);
		return c
	};
	this.loadFileUploadDataExplorerDiv = function() {
		var e = this.$cX("div", {
			id: this.target + "-cX-DataExplorerFileUploadDiv"
		});
		var a = this.$cX("label", {
			htmlFor: this.target + "-cX-DataExplorerFileUpload"
		});
		var b = this.$cX("span", {
			innerHTML: "Upload",
			className: "CanvasXpressDataExplorer",
			title: "Click to upload a new file",
			alt: "Click to upload a new file",
			params: ["fileUpload"]
		});
		var c = this.$cX("input", {
			id: this.target + "-cX-DataExplorerFileUpload",
			type: "file"
		}, {
			display: "none"
		});
		a.appendChild(b);
		e.appendChild(a);
		e.appendChild(c);
		return e
	};
	this.loadGraphTypesDataExplorerDiv = function() {
		var j = this.$cX("div", {
			id: this.target + "-cX-DataExplorerGraphs",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "120px",
			height: "134px",
			textAlign: "center",
			cssFloat: "left",
			marginBottom: "15px"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerArea",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.area,
			params: ["changeAttribute", ["graphType", "Area"]],
			alt: "Area",
			title: "Area"
		});
		var k = this.$cX("img", {
			id: this.target + "-cX-DataExplorerBar",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.bar,
			params: ["changeAttribute", ["graphType", "Bar"]],
			alt: "Bar",
			title: "Bar"
		});
		var l = this.$cX("img", {
			id: this.target + "-cX-DataExplorerBoxplot",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.boxplot,
			params: ["changeAttribute", ["graphType", "Boxplot"]],
			alt: "Boxplot",
			title: "Boxplot"
		});
		var p = this.$cX("img", {
			id: this.target + "-cX-DataExplorerCorrelation",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.correlation,
			params: ["changeAttribute", ["graphType", "Correlation"]],
			alt: "Correlation",
			title: "Correlation"
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerCircular",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.circular,
			params: ["changeAttribute", ["graphType", "Circular"]],
			alt: "Circular",
			title: "Circular"
		});
		var i = this.$cX("img", {
			id: this.target + "-cX-DataExplorerHeatmap",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.heatmap,
			params: ["changeAttribute", ["graphType", "Heatmap"]],
			alt: "Heatmap",
			title: "Heatmap"
		});
		var h = this.$cX("img", {
			id: this.target + "-cX-DataExplorerDotplot",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.dotplot,
			params: ["changeAttribute", ["graphType", "Dotplot"]],
			alt: "Dotplot",
			title: "Dotplot"
		});
		var o = this.$cX("img", {
			id: this.target + "-cX-DataExplorerLine",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.line,
			params: ["changeAttribute", ["graphType", "Line"]],
			alt: "Line",
			title: "Line"
		});
		var g = this.$cX("img", {
			id: this.target + "-cX-DataExplorerPie",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.pie,
			params: ["changeAttribute", ["graphType", "Pie"]],
			alt: "Pie Chart",
			title: "Pie Chart"
		});
		var f = this.$cX("img", {
			id: this.target + "-cX-DataExplorerScatter2D",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.scatter2d,
			params: ["changeAttribute", ["graphType", "Scatter2D"]],
			alt: "Scatter 2D",
			title: "Scatter 2D"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-DataExplorerScatterBubble2D",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.scatterBubble2d,
			params: ["changeAttribute", ["graphType", "ScatterBubble2D"]],
			alt: "Scatter Bubble 2D",
			title: "Scatter Bubble 2D"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-DataExplorerScatter3D",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.scatter3d,
			params: ["changeAttribute", ["graphType", "Scatter3D"]],
			alt: "Scatter 3D",
			title: "Scatter 3D"
		});
		var q = this.$cX("img", {
			id: this.target + "-cX-DataExplorerStacked",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.stacked,
			params: ["changeAttribute", ["graphType", "Stacked"]],
			alt: "Stacked",
			title: "Stacked"
		});
		var m = this.$cX("img", {
			id: this.target + "-cX-DataExplorerStackedPercent",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.stackedPercent,
			params: ["changeAttribute", ["graphType", "StackedPercent"]],
			alt: "Stacked Percent",
			title: "Stacked Percent"
		});
		var c = this.$cX("img", {
			id: this.target + "-cX-DataExplorerTagCloud",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.tagCloud,
			params: ["changeAttribute", ["graphType", "TagCloud"]],
			alt: "Tag Cloud",
			title: "Tag Cloud"
		});
		var n = this.$cX("img", {
			id: this.target + "-cX-DataExplorerTreemap",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.treemap,
			params: ["changeAttribute", ["graphType", "Treemap"]],
			alt: "Treemap",
			title: "Treemap"
		});
		j.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Graph Types",
			title: "Click in icons to change graph type",
			alt: "Click in icons to change graph type"
		}, {
			width: "120px",
			cursor: "pointer"
		}));
		j.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "126px"
		}));
		j.appendChild(b);
		j.appendChild(k);
		j.appendChild(l);
		j.appendChild(a);
		j.appendChild(p);
		j.appendChild(i);
		j.appendChild(h);
		j.appendChild(o);
		j.appendChild(g);
		j.appendChild(f);
		j.appendChild(d);
		j.appendChild(e);
		j.appendChild(q);
		j.appendChild(m);
		j.appendChild(c);
		j.appendChild(n);
		return j
	};
	this.loadAxesDataExplorerDiv = function() {
		var f = this.$cX("div", {
			id: this.target + "-cX-DataExplorerAxes",
			className: "CanvasXpressDataExplorer"
		}, {
			width: "46px",
			height: "134px",
			textAlign: "center",
			cssFloat: "left",
			marginBottom: "15px"
		});
		var b = this.$cX("img", {
			id: this.target + "-cX-DataExplorerXAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.xAxis,
			params: ["addToAxis", ["xAxis"]],
			alt: "X-Axis",
			title: "X-Axis"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-DataExplorerLinLogXAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.linLogV,
			params: ["linLog", ["xAxis"]],
			alt: "X-Axis Lin / Log",
			title: "X-Axis Lin / Log"
		}, {
			width: "10px",
			height: "24px",
			border: "none",
			padding: 0
		});
		var h = this.$cX("img", {
			id: this.target + "-cX-DataExplorerYAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.yAxis,
			params: ["addToAxis", ["yAxis"]],
			alt: "Y-Axis",
			title: "Y-Axis"
		});
		var d = this.$cX("img", {
			id: this.target + "-cX-DataExplorerLinLogYAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.linLogV,
			params: ["linLog", ["yAxis"]],
			alt: "Y-Axis Lin / Log",
			title: "Y-Axis Lin / Log"
		}, {
			width: "10px",
			height: "24px",
			border: "none",
			padding: 0
		});
		var g = this.$cX("img", {
			id: this.target + "-cX-DataExplorerZAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.zAxis,
			params: ["addToAxis", ["zAxis"]],
			alt: "Z-Axis",
			title: "Z-Axis"
		});
		var c = this.$cX("img", {
			id: this.target + "-cX-DataExplorerLinLogZAxis",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.linLogV,
			params: ["linLog", ["zAxis"]],
			alt: "Z-Axis Lin / Log",
			title: "Z-Axis Lin / Log"
		}, {
			width: "10px",
			height: "24px",
			border: "none",
			padding: 0
		});
		var a = this.$cX("img", {
			id: this.target + "-cX-DataExplorerMotion",
			className: "CanvasXpressDataExplorer",
			src: CanvasXpress.images.motion,
			params: ["motion"],
			alt: "Motion",
			title: "Motion"
		});
		f.appendChild(this.$cX("span", {
			className: "CanvasXpressBin",
			innerHTML: "Axes",
			title: "Drag Samples to assign to Axis",
			alt: "Drag Samples to assign to Axis"
		}, {
			width: "46px",
			cursor: "pointer"
		}));
		f.appendChild(this.$cX("hr", {
			className: "CanvasXpressDataExplorer"
		}, {
			width: "52px"
		}));
		f.appendChild(b);
		f.appendChild(e);
		f.appendChild(h);
		f.appendChild(d);
		f.appendChild(g);
		f.appendChild(c);
		f.appendChild(a);
		return f
	};
	this.loadVariablesDataExplorerDiv = function(a) {
		if (!a) {
			a = this.$cX("div", {
				id: this.target + "-cX-DataExplorerVariables",
				className: "CanvasXpressDataExplorer",
				type: "vars"
			}, {
				width: "180px",
				height: "52px",
				overflowY: "auto"
			})
		}
		for (var b = 0; b < this.data.y.vars.length; b++) {
			var c = this.$cX("span", {
				id: this.target + "-cX-DataExplorerVariables-" + this.data.y.vars[b],
				innerHTML: this.data.y.vars[b],
				className: "CanvasXpressDataExplorerNumeric",
				type: "vars",
				numeric: true,
				params: ["switchVarToAnnotation"],
				draggable: true
			});
			a.appendChild(c)
		}
		return a
	};
	this.loadSamplesDataExplorerDiv = function(b) {
		if (!b) {
			b = this.$cX("div", {
				id: this.target + "-cX-DataExplorerSamples",
				className: "CanvasXpressDataExplorer",
				type: "smps"
			}, {
				width: "180px",
				height: "52px",
				overflowY: "auto"
			})
		}
		for (var a = 0; a < this.data.y.smps.length; a++) {
			var c = this.$cX("span", {
				id: this.target + "-cX-DataExplorerSamples-" + this.data.y.smps[a],
				innerHTML: this.data.y.smps[a],
				className: "CanvasXpressDataExplorerNumeric",
				type: "smps",
				numeric: true,
				params: ["switchSmpToAnnotation"],
				draggable: true
			});
			b.appendChild(c)
		}
		return b
	};
	this.loadAnnotationsDataExplorerDiv = function(a) {
		var b = this.meta.data.x;
		if (!a) {
			a = this.$cX("div", {
				id: this.target + "-cX-DataExplorerAnnotations",
				className: "CanvasXpressDataExplorer",
				type: "x"
			}, {
				width: "180px",
				height: "52px",
				overflowY: "auto"
			})
		}
		if (this.data.x) {
			for (var c in this.data.x) {
				var d = this.$cX("span", {
					id: this.target + "-cX-DataExplorerAnnotations-" + c,
					innerHTML: c,
					className: b[c].type == "String" ? "CanvasXpressDataExplorerString" : "CanvasXpressDataExplorerNumeric",
					type: "x",
					numeric: b[c].type == "String" ? false : true,
					params: ["switchAnnotationToVar"],
					draggable: true
				});
				a.appendChild(d)
			}
		}
		return a
	};
	this.loadDescriptionsDataExplorerDiv = function(d) {
		var a = this.meta.data.z;
		if (!d) {
			d = this.$cX("div", {
				id: this.target + "-cX-DataExplorerDescriptions",
				className: "CanvasXpressDataExplorer",
				type: "z"
			}, {
				width: "180px",
				height: "52px",
				overflowY: "auto"
			})
		}
		if (this.data.z) {
			for (var b in this.data.z) {
				var c = this.$cX("span", {
					id: this.target + "-cX-DataExplorerDescriptions-" + b,
					innerHTML: b,
					className: a[b].type == "String" ? "CanvasXpressDataExplorerString" : "CanvasXpressDataExplorerNumeric",
					type: "z",
					numeric: a[b].type == "String" ? false : true,
					params: ["switchAnnotationToSmp"],
					draggable: true
				});
				d.appendChild(c)
			}
		}
		return d
	};
	this.addRemoveDataExplorerListeners = function(q) {
		var e;
		var F = this.$(this.target + "-cX-DataExplorerFormat");
		var w = this.$(this.target + "-cX-DataExplorerMetadata");
		var G = this.$(this.target + "-cX-DataExplorerOrientation");
		var E = this.$(this.target + "-cX-DataExplorerGraphs");
		var H = this.$(this.target + "-cX-DataExplorerAxes");
		var A = this.$(this.target + "-cX-DataExplorerLayout");
		var u = this.$(this.target + "-cX-DataExplorerProperties");
		var o = this.$(this.target + "-cX-DataExplorerVariables");
		var B = this.$(this.target + "-cX-DataExplorerSortVariables");
		var r = this.$(this.target + "-cX-DataExplorerSamples");
		var y = this.$(this.target + "-cX-DataExplorerSortSamples");
		var n = this.$(this.target + "-cX-DataExplorerAnnotations");
		var k = this.$(this.target + "-cX-DataExplorerSortAnnotations");
		var h = this.$(this.target + "-cX-DataExplorerDescriptions");
		var c = this.$(this.target + "-cX-DataExplorerSortDescriptions");
		this.addRemoveEvtListener(q, this.$(this.target + "-cX-DataExplorerMinimizeImage1"), "click", this.collapseExpandDataExplorerPanel, false);
		this.addRemoveEvtListener(q, this.$(this.target + "-cX-DataExplorerMinimizeImage2"), "click", this.collapseExpandDataExplorerPanel, false);
		this.addRemoveEvtListener(q, this.$(this.target + "-cX-DataExplorer"), "mousedown", this.registerMousemove, false);
		this.addRemoveEvtListener(q, this.$(this.target + "-cX-DataExplorerCloseImage"), "click", this.closeDataExplorer, false);
		e = [F, w, G, E];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				this.addRemoveEvtListener(q, e[D], "click", this.dataExplorerClick, false);
				if (e[D].childNodes.length == 5 && e[D].childNodes[4].id == this.target + "-cX-DataExplorerFileUploadDiv") {
					this[q](e[D].childNodes[4].childNodes[1], "change", this.loadFile, false)
				}
			}
		}
		e = [H, A, u, o, r, n, h];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				this.addRemoveEvtListener(q, e[D], "drop", this.dropDataExplorer, false);
				this.addRemoveEvtListener(q, e[D], "dragover", this.dragOverDataExplorer, false);
				this.addRemoveEvtListener(q, e[D], "dragenter", this.dragEnterDataExplorer, false);
				this.addRemoveEvtListener(q, e[D], "dragleave", this.dragLeaveDataExplorer, false);
				for (var C = 0; C < e[D].childNodes.length; C++) {
					var b = e[D].childNodes[C];
					if (b.tagName == "SPAN") {
						this.addRemoveEvtListener(q, b, "dragstart", this.dragStartDataExplorer, false);
						this.addRemoveEvtListener(q, b, "dragend", this.dragEndDataExplorer, false)
					}
				}
			}
		}
		e = [A, u];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				this.addRemoveEvtListener(q, e[D], "click", this.dataExplorerClickReset, false)
			}
		}
		e = [B, y, k, c];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				this.addRemoveEvtListener(q, e[D], "click", this.dataExplorerClickSort, false)
			}
		}
		e = [H];
		for (var D = 0; D < e.length; D++) {
			if (e[D]) {
				for (var C = 0; C < e[D].childNodes.length; C++) {
					var b = e[D].childNodes[C];
					if (b.tagName == "IMG") {
						if (b.id.match(/LinLog/)) {
							this.addRemoveEvtListener(q, b, "click", this.dataExplorerClickLinLog, false)
						} else {
							this.addRemoveEvtListener(q, b, "click", this.dataExplorerClickReset, false)
						}
					}
				}
			}
		}
	};
	this.collapseExpandDataExplorerPanel = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var b = a.getTargetEvent(f);
			var d = b.nextElementSibling;
			var c = b.title;
			if (c.match("Collapse")) {
				b.title = c.replace("Collapse", "Expand");
				d.style.display = "none"
			} else {
				b.title = c.replace("Expand", "Collapse");
				d.style.display = "block"
			}
			b.alt = b.title;
			var g = b.src;
			b.src = b.srt;
			b.srt = g;
			return false
		}
	}(this);
	this.dragStartDataExplorer = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			b.style.opacity = "0.3";
			c.dataTransfer.setData("text", c.target.id);
			return false
		}
	}(this);
	this.dragEnterDataExplorer = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (b.tagName == "SPAN" && b.parentNode.lastChild && b.parentNode.lastChild.tagName != "IMG") {
				b.parentNode.className = "CanvasXpressDataExplorerActive"
			} else {
				if (b.tagName == "SPAN" && b.parentNode.lastChild && b.parentNode.lastChild.tagName == "IMG") {
					b.parentNode.className = "CanvasXpressDataExplorer"
				} else {
					if ((b.tagName == "DIV" && b.lastChild && b.lastChild.tagName != "IMG") || b.tagName == "IMG") {
						b.className = "CanvasXpressDataExplorerActive"
					}
				}
			}
			return false
		}
	}(this);
	this.dragOverDataExplorer = function(a) {
		return function(c) {
			a.cancelEvent(c);
			var b = a.getTargetEvent(c);
			if (b.tagName == "SPAN" && b.parentNode.lastChild && b.parentNode.lastChild.tagName != "IMG") {
				b.parentNode.className = "CanvasXpressDataExplorerActive"
			} else {
				if (b.tagName == "DIV" && b.lastChild && b.lastChild.tagName != "IMG") {
					b.className = "CanvasXpressDataExplorerActive"
				}
			}
			return false
		}
	}(this);
	this.dragLeaveDataExplorer = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (b.tagName == "DIV" || b.tagName == "IMG") {
				b.className = "CanvasXpressDataExplorer"
			}
			return false
		}
	}(this);
	this.dragEndDataExplorer = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			var c = a.getTargetEvent(g);
			c.style.opacity = "1.0";
			var d = c.parentNode;
			if (d.tagName == "SPAN") {
				d = d.parentNode
			}
			d.className = "CanvasXpressDataExplorer";
			var f = d.type;
			var b = c.type;
			if (f == b) {
				return false
			}
			return false
		}
	}(this);
	this.dropDataExplorer = function(a) {
		return function(r) {
			a.cancelEvent(r);
			var p, l, c, m;
			var s = r.dataTransfer.getData("text");
			var g = a.$(s);
			if (g) {
				var v = g.innerHTML;
				var u = g.type;
				var h = g.numeric;
				var t = g.params[0];
				if (r.target.tagName == "IMG") {
					r.target.className = "CanvasXpressDataExplorer";
					p = a.getTargetEvent(r);
					m = p.title.split(" : ")[0];
					l = p.params[0];
					switch (l) {
						case "groupSamples":
							if (u == "x") {
								var f = a.groupingFactors;
								if (a.isInArray(v, f)) {
									var b = [];
									for (var o = 0; o < f.length; o++) {
										if (f[o] != v) {
											b.push(f[o])
										}
									}
									f = b
								} else {
									f.push(v)
								}
								if (f.length > 0) {
									a.groupSamples(f);
									p.title = m + " : " + a.groupingFactors.join(", ");
									p.alt = p.title
								} else {
									a.ungroupSamples();
									p.title = m;
									p.alt = p.title
								}
							} else {
								alert("Ooops! Only Sample factors")
							}
							return false;
						case "segregate":
							if (u == "x") {
								var q = a.segregateSamplesBy;
								if (a.isInArray(v, q)) {
									var b = [];
									for (var o = 0; o < q.length; o++) {
										if (q[o] != v) {
											b.push(q[o])
										}
									}
									if (b.length > 0) {
										a.segregateSamplesBy = b;
										a.segregate("Samples", b)
									} else {
										a.segregateSamplesBy = [];
										a.desegregate("Samples")
									}
								} else {
									if (a.segregateSamplesBy.length + a.segregateVariablesBy.length < 2) {
										q.push(v);
										a.segregate("Samples", q)
									} else {
										alert("Ooops! Only 2 segregation factors")
									}
								}
							} else {
								if (u == "z") {
									var q = a.segregateVariablesBy;
									if (a.isInArray(v, q)) {
										var b = [];
										for (var o = 0; o < q.length; o++) {
											if (q[o] != v) {
												b.push(q[o])
											}
										}
										if (b.length > 0) {
											a.segregateVariablesBy = b;
											a.segregate("Variables", b)
										} else {
											a.segregateVariablesBy = [];
											a.desegregate("Variables")
										}
									} else {
										if (a.segregateSamplesBy.length + a.segregateVariablesBy.length < 2) {
											q.push(v);
											a.segregate("Variables", q)
										} else {
											alert("Ooops! Only 2 segregation factors")
										}
									}
								} else {
									alert("Ooops! Only Sample or Variable factors");
									return false
								}
							}
							var b = a.segregateVariablesBy;
							b = b.concat(a.segregateSamplesBy);
							p.title = b.length > 0 ? m + " : " + b.join(", ") : m;
							p.alt = p.title;
							return false;
						case "addToAxis":
							var n = p.params[1][0];
							if (u == "smps") {
								if (r.shiftKey) {
									a.changeSampleInAxis(v, n)
								} else {
									a.changeSampleInAxis(v, n, true)
								}
								p.title = m + " : " + a[n].join(", ");
								p.alt = p.title
							} else {
								alert("Ooops! Only samples allowed")
							}
							return false;
						case "motion":
							if (u == "smps") {
								c = p.type;
								g.type = c;
								a[t](v);
								g.params[0] = "switchAnnotationToSmp";
								var j = a.$(a.target + "-cX-DataExplorerDescriptions");
								if (j) {
									j.appendChild(g)
								}
							} else {
								if (u == "vars") {
									g.type = c;
									a[t](v);
									g.params[0] = "switchAnnotationToVar";
									var k = a.$(a.target + "-cX-DataExplorerAnnotations");
									if (k) {
										k.appendChild(g)
									}
								}
							}
							a.changeAttribute("motionBy", v);
							p.title = m + " : " + v;
							p.alt = p.title;
							return false;
						case "linLog":
							return false;
						default:
							a.changeAttribute(l, v);
							p.title = m + " : " + v;
							p.alt = p.title;
							return false
					}
				} else {
					if (r.target.tagName == "SPAN" && r.target.parentNode.lastChild && r.target.parentNode.lastChild.tagName != "IMG") {
						p = r.target.parentNode
					} else {
						if (r.target.tagName == "DIV") {
							p = r.target
						}
					}
					c = p.type;
					if (u == c) {
						return false
					} else {
						if (u == "smps" && c == "z") {
							g.type = c;
							a[t](v);
							g.params[0] = "switchAnnotationToSmp"
						} else {
							if (u == "z" && c == "smps") {
								if (!h) {
									alert("Ooops! Only numeric data");
									return false
								}
								g.type = c;
								a[t](v);
								g.params[0] = "switchSmpToAnnotation"
							} else {
								if (u == "vars" && c == "x") {
									g.type = c;
									a[t](v);
									g.params[0] = "switchAnnotationToVar"
								} else {
									if (u == "x" && c == "vars") {
										if (!h) {
											alert("Ooops! Only numeric data");
											return false
										}
										g.type = c;
										a[t](v);
										g.params[0] = "switchVarToAnnotation"
									} else {
										alert("Ooops! Only changes between data and ortogonal numeric metadata");
										return false
									}
								}
							}
						}
					}
					p.appendChild(g)
				}
			}
			return false
		}
	}(this);
	this.dataExplorerClick = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var c = a.getTargetEvent(d);
			var b = c.params;
			if (c.tagName.match(/input/i)) {
				return true
			} else {
				if (b[1]) {
					a[b[0]].apply(a, b[1])
				} else {
					if (b[0] == "createDOE" && a.isDOE) {
						a.removeDOE()
					} else {
						if (b[0] == "fileUpload") {
							return false
						} else {
							a[b[0]]()
						}
					}
				}
			}
			return false
		}
	}(this);
	this.dataExplorerClickSort = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var b = a.getTargetEvent(f);
			var j = b.id.replace("-cX-DataExplorerSort", "-cX-DataExplorer");
			var d = a.$(j);
			if (d) {
				var h = d.childNodes.length - 1;
				for (var c = h; c > 0; c--) {
					d.insertBefore(d.lastChild, d.childNodes[h - c])
				}
				var g = b.src;
				b.src = b.asr;
				b.asr = g
			}
			return false
		}
	}(this);
	this.dataExplorerClickLinLog = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var c = a.getTargetEvent(f);
			var b = c.params;
			if (c && b) {
				var d = b[1][0] + "Transform";
				if (a[d]) {
					a.changeAttribute(d, false)
				} else {
					a.changeAttribute(d, a.transformBase == 2 ? "log2" : "log10")
				}
			}
			return false
		}
	}(this);
	this.dataExplorerClickReset = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			var c = a.getTargetEvent(j);
			var f = c.title.split(" : ")[0];
			var b = c.params;
			c.title = f;
			c.alt = f;
			switch (b[0]) {
				case "groupSamples":
					if (a.groupingFactors.length > 0) {
						a.ungroupSamples()
					}
					return false;
				case "segregate":
					for (var g = 0; g < a.segregateSamplesBy.length; g++) {
						a.showSampleSegregation(a.segregateSamplesBy[g])
					}
					for (var g = 0; g < a.segregateVariablesBy.length; g++) {
						a.showVariableSegregation(a.segregateVariablesBy[g])
					}
					return false;
				case "addToAxis":
					var h = c.params[1][0];
					var d = a[h];
					a.changeSampleInAxis(d[0], h, true);
					c.title = f + " : " + a[h].join(", ");
					c.alt = c.title;
					return false;
				case "motion":
					a.changeAttribute("motionBy", false);
					return false;
				default:
					if (a[b[0]]) {
						a.changeAttribute(b[0], false)
					}
					return false
			}
		}
	}(this);
	this.closeDataExplorer = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			var f = b.id.replace("CloseImage", "");
			var d = a.$(f);
			if (d) {
				a.addRemoveDataExplorerListeners("removeEvtListener");
				d.parentNode.removeChild(d)
			}
			return false
		}
	}(this);
	this.resetDataExplorer = function() {
		var j = this.$(this.target + "-cX-DataExplorerContainer");
		var b = this.$(this.target + "-cX-DataExplorerVariables");
		var g = this.$(this.target + "-cX-DataExplorerSamples");
		var a = this.$(this.target + "-cX-DataExplorerAnnotations");
		var h = this.$(this.target + "-cX-DataExplorerDescriptions");
		this.addRemoveDataExplorerListeners("removeEvtListener");
		var e = [b, g, a, h];
		for (var d = 0; d < e.length; d++) {
			var f = e[d];
			while (f.childNodes.length > 0) {
				f.removeChild(f.childNodes[0])
			}
		}
		this.loadVariablesDataExplorerDiv(b);
		this.loadSamplesDataExplorerDiv(g);
		this.loadAnnotationsDataExplorerDiv(a);
		this.loadDescriptionsDataExplorerDiv(h);
		this.addRemoveDataExplorerListeners("addEvtListener")
	}
};
CanvasXpress.prototype.initDataFilter = function() {
	this.addDataFilterDiv = function() {
		if (this.$(this.target + "-cX-DataFilter")) {
			return
		}
		var j = this.dataFilterLastX != null ? parseInt(this.dataFilterLastX) : -this.meta.canvas.ctx.canvas.width * 0.5;
		var h = this.dataFilterLastY != null ? parseInt(this.dataFilterLastY) : this.meta.canvas.ctx.canvas.height * 0.5;
		var u = this.graphType == "Genome" ? 60 : 81;
		this.dataFilterHeight = this.meta.canvas.ctx.canvas.height - u;
		this.activeAccordion = null;
		var B = this.$cX("div", {
			id: this.target + "-cX-DataFilter",
			className: this.applicationLook ? "CanvasXpressDataFilter fixed" : "CanvasXpressDataFilter draggable-container"
		}, {
			top: h + "px",
			left: j + "px",
			display: "none",
			zIndex: 10000,
			marginLeft: "3px"
		});
		var o = this.$cX("div", {
			id: this.target + "-cX-DataFilterToolbar",
			className: this.applicationLook ? "CanvasXpressDataFilterToolbar fixed" : "CanvasXpressDataFilterToolbar draggable"
		}, {
			width: this.dataFilterWidth + "px"
		});
		var b = this.$cX("span", {
			innerHTML: "Filters",
			className: "CanvasXpressDataFilterToolbarText"
		});
		var s = this.$cX("img", {
			id: this.target + "-cX-DataFilterKeyFlash",
			className: "CanvasXpressDataFilterToolbarImage",
			src: this.filterFlashingOn ? CanvasXpress.images.lightbulb : CanvasXpress.images.lightbulbOff,
			alt: this.filterFlashingOn ? "Turn off Flashing" : "Turn on Flashing",
			title: this.filterFlashingOn ? "Turn off Flashing" : "Turn on Flashing"
		}, {
			display: this.graphType == "Network" ? "block" : "none"
		});
		if (this.meta.system.isIE) {
			s.style.marginTop = "-10px"
		}
		var g = this.$cX("img", {
			id: this.target + "-cX-DataFilterKeyReset",
			className: "CanvasXpressDataFilterToolbarImage",
			src: CanvasXpress.images.funnelCross,
			alt: "Reset filters",
			title: "Reset filters"
		});
		if (this.meta.system.isIE) {
			g.style.marginTop = "-10px"
		}
		var v = this.$cX("img", {
			id: this.target + "-cX-DataFilterKeyDock",
			className: "CanvasXpressDataFilterToolbarImage",
			src: this.applicationLook ? CanvasXpress.images.unpin : CanvasXpress.images.pin,
			alt: this.applicationLook ? "Undock" : "Dock",
			title: this.applicationLook ? "Undock" : "Dock",
			state: this.applicationLook ? "docked" : "free"
		});
		if (this.meta.system.isIE) {
			v.style.marginTop = "-10px"
		}
		var x = this.$cX("img", {
			id: this.target + "-cX-DataFilterKeyClose",
			className: "CanvasXpressDataFilterToolbarImage",
			src: CanvasXpress.images.cancel1,
			alt: "Close",
			title: "Close"
		});
		if (this.meta.system.isIE) {
			x.style.marginTop = "-10px"
		}
		var C = this.$cX("div", {
			id: this.target + "-cX-DataFilterContainer",
			className: "CanvasXpressDataFilterContainer"
		}, {
			width: this.dataFilterWidth + "px"
		});
		var m = this.$cX("div", {
			id: this.target + "-cX-DataFilterVariableHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType.match(/Genome|Network/) ? "none" : "block"
		});
		var r = this.$cX("div", {
			id: this.target + "-cX-DataFilterVariableContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var e = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variables",
			className: "CanvasXpressDataFilterText"
		});
		var k = this.$cX("div", {
			id: this.target + "-cX-DataFilterSampleHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType.match(/Genome|Network/) ? "none" : "block"
		});
		var q = this.$cX("div", {
			id: this.target + "-cX-DataFilterSampleContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var c = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Samples",
			className: "CanvasXpressDataFilterText"
		});
		var y = this.$cX("div", {
			id: this.target + "-cX-DataFilterNodeHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType == "Network" ? "block" : "none"
		});
		var A = this.$cX("div", {
			id: this.target + "-cX-DataFilterNodeContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var n = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nodes",
			className: "CanvasXpressDataFilterText"
		});
		var t = this.$cX("div", {
			id: this.target + "-cX-DataFilterEdgeHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType == "Network" ? "block" : "none"
		});
		var z = this.$cX("div", {
			id: this.target + "-cX-DataFilterEdgeContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var i = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Edges",
			className: "CanvasXpressDataFilterText"
		});
		var f = this.$cX("div", {
			id: this.target + "-cX-DataFilterGenomeHeader",
			className: "CanvasXpressDataFilterHead"
		}, {
			width: this.dataFilterWidth + "px",
			display: this.graphType == "Genome" ? "block" : "none"
		});
		var l = this.$cX("div", {
			id: this.target + "-cX-DataFilterGenomeContent",
			className: "CanvasXpressDataFilterContent"
		}, {
			width: this.dataFilterWidth + "px",
			height: "0px",
			display: "none"
		});
		var a = this.$cX("span", {
			innerHTML: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Features",
			className: "CanvasXpressDataFilterText"
		});
		o.appendChild(b);
		o.appendChild(x);
		o.appendChild(v);
		o.appendChild(g);
		o.appendChild(s);
		m.appendChild(e);
		k.appendChild(c);
		y.appendChild(n);
		t.appendChild(i);
		f.appendChild(a);
		C.appendChild(m);
		C.appendChild(r);
		C.appendChild(k);
		C.appendChild(q);
		C.appendChild(y);
		C.appendChild(A);
		C.appendChild(t);
		C.appendChild(z);
		C.appendChild(f);
		C.appendChild(l);
		B.appendChild(o);
		B.appendChild(C);
		var p = this.$("east-wrapper-" + this.target);
		if (p) {
			p.appendChild(B);
			this.addRemoveDataFilterListeners("addEvtListener")
		}
	};
	this.addRemoveDataFilterListeners = function(k) {
		var e = this.$(this.target + "-cX-DataFilterToolbar");
		var a = this.$(this.target + "-cX-DataFilterKeyFlash");
		var g = this.$(this.target + "-cX-DataFilterKeyReset");
		var b = this.$(this.target + "-cX-DataFilterKeyDock");
		var c = this.$(this.target + "-cX-DataFilterKeyClose");
		var h = this.$(this.target + "-cX-DataFilterVariableHeader");
		var i = this.$(this.target + "-cX-DataFilterSampleHeader");
		var d = this.$(this.target + "-cX-DataFilterNodeHeader");
		var f = this.$(this.target + "-cX-DataFilterEdgeHeader");
		var j = this.$(this.target + "-cX-DataFilterGenomeHeader");
		if (e && a && g && b && c && h && i && d && f && j) {
			this[k](e, "mousedown", this.registerMousemove, false);
			this[k](a, "click", this.flashDataFilter, false);
			this[k](g, "click", this.resetDataFilter, false);
			this[k](b, "click", this.dockUndockDataFilter, false);
			this[k](c, "click", this.hideDataFilter, false);
			this[k](h, "click", this.activateAccordion, false);
			this[k](i, "click", this.activateAccordion, false);
			this[k](d, "click", this.activateAccordion, false);
			this[k](f, "click", this.activateAccordion, false);
			this[k](j, "click", this.activateAccordion, false)
		}
	};
	this.flashDataFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (a.filterFlashingOn) {
				a.filterFlashingOn = false;
				b.src = CanvasXpress.images.lightbulbOff;
				b.alt = "Turn on Flashing";
				b.title = "Turn on Flashing"
			} else {
				a.filterFlashingOn = true;
				b.src = CanvasXpress.images.lightbulb;
				b.alt = "Turn off Flashing";
				b.title = "Turn off Flashing"
			}
			return false
		}
	}(this);
	this.activateAccordion = function(a) {
		return function(f, b) {
			if (!f) {
				f = window.event
			}
			var d = a;
			if (!b) {
				b = a.getTargetEvent(f)
			}
			if (b) {
				if (b.tagName.toLowerCase() == "span") {
					b = b.parentNode
				}
				b.className = "CanvasXpressDataFilterHeadActive";
				b.firstChild.className = "CanvasXpressDataFilterTextActive";
				var c = b.nextSibling;
				if (c) {
					setTimeout(function() {
						if (d.activeAccordion && c.id == d.activeAccordion.id) {
							c = false
						}
						d.transitionAccordion(new Date().getTime(), 250, c, d.activeAccordion);
						if (d.activeAccordion) {
							var e = d.activeAccordion.previousSibling;
							e.className = "CanvasXpressDataFilterHead";
							e.firstChild.className = "CanvasXpressDataFilterText"
						}
						d.activeAccordion = c
					}, 33)
				}
			}
			return false
		}
	}(this);
	this.resizeDataFilterForScroller = function(s) {
		var p = this.$(this.target + "-cX-DataFilterVariableContentSearchItems");
		var q = this.$(this.target + "-cX-DataFilterSampleContentSearchItems");
		var l = this.$(this.target + "-cX-DataFilterNodeContentSearchItems");
		var n = this.$(this.target + "-cX-DataFilterEdgeContentSearchItems");
		var b = this.$(this.target + "-cX-DataFilterGenomeContentSearchItems");
		this.dataFilterScroller = s ? true : false;
		var k = [p, q, l, n, b];
		var e = s ? -18 : 18;
		var f = this.meta.system.isIE ? 44 : 42;
		var d = s ? (this.dataFilterWidth - (f + 18)) / (this.dataFilterWidth - f) : (this.dataFilterWidth - f) / (this.dataFilterWidth - (f + 18));
		if (s && this.dataFilterScrollerResized) {
			return
		}
		for (var h = 0; h < k.length; h++) {
			if (k[h]) {
				for (var g = 0; g < k[h].childNodes.length; g++) {
					var m = k[h].childNodes[g];
					if (m.type == "numeric") {
						m.childNodes[0].style.width = (parseInt(m.childNodes[0].style.width) + e) + "px";
						m.childNodes[1].style.width = (parseInt(m.childNodes[1].style.width) + e) + "px";
						m.childNodes[2].style.width = (parseInt(m.childNodes[2].style.width) + e) + "px";
						var a = m.childNodes[2].childNodes[1];
						var o = parseInt(a.style.width) * d;
						a.units /= d;
						a.style.width = o + "px"
					}
				}
			}
		}
		this.dataFilterScrollerResized = s ? true : false
	};
	this.moveDataFilter = function(l) {
		var k, m;
		var o = this.$(this.target + "-cX-DataFilter");
		var i = this.$(this.target + "-cX-DataFilterToolbar");
		var e = this.$(this.target + "-cX-DataFilterKeyDock");
		var d = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
		var f = this.$("north-container-" + this.target);
		var a = this.$("south-container-" + this.target);
		var j = this.$("west-container-" + this.target);
		var s = this.$("middle-container-" + this.target);
		var c = this.$("east-container-" + this.target);
		var n = this.$("east-wrapper-" + this.target);
		var b = 64;
		var q = 0;
		var p = this.showFadeResizeMoveAnimation ? 500 : 0;
		var g = this;
		if (o && i && e && f && a && j && s && c && n) {
			var r = (i.clientWidth - this.dataFilterWidth) + 2;
			m = parseInt(f.clientHeight) + this.meta.canvas.ctx.canvas.height + parseInt(a.clientHeight);
			if (e.state == "free" && !l) {
				i.className = "CanvasXpressDataFilterToolbar fixed";
				e.src = CanvasXpress.images.unpin;
				e.alt = "Undock";
				e.title = "Undock";
				e.setAttribute("state", "docked");
				this.dataFilterLastState = "docked";
				this.dataFilterLastX = o.style.left;
				this.dataFilterLastY = o.style.top;
				var k = parseInt(j.style.width) + this.meta.canvas.ctx.canvas.width + i.clientWidth + 2;
				if (d) {
					this.resizeMove(d, 0, 0, Math.max(k, parseInt(a.clientWidth)) + q, m + b)
				}
				this.resizeMove(s, 0, 0, k, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(c, 0, 0, this.dataFilterWidth + r, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(n, 0, 0, this.dataFilterWidth + r, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(o, 0, 0, this.dataFilterWidth, this.meta.canvas.ctx.canvas.height)
			} else {
				i.className = "CanvasXpressDataFilterToolbar draggable";
				e.src = CanvasXpress.images.pin;
				e.alt = "Dock";
				e.title = "Dock";
				e.setAttribute("state", "free");
				this.dataFilterLastState = "free";
				if (l) {
					delete(this.dataFilterLastState);
					this.dataFilterLastX = null;
					this.dataFilterLastY = null;
					this.fade(o, 500, function() {
						g.resetFade(o);
						o.style.display = "none";
						o.style.width = g.dataFilterWidth + "px";
						o.style.height = g.meta.canvas.ctx.canvas.height + "px"
					})
				}
				k = parseInt(j.style.width) + this.meta.canvas.ctx.canvas.width;
				if (d) {
					this.resizeMove(d, 0, 0, Math.max(k, parseInt(a.clientWidth)) + q, m + b)
				}
				this.resizeMove(s, 0, 0, k, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(c, 0, 0, 0, this.meta.canvas.ctx.canvas.height);
				this.resizeMove(n, 0, 0, 0, this.meta.canvas.ctx.canvas.height);
				if (!l) {
					this.resizeMove(o, 0, 0, 0, this.meta.canvas.ctx.canvas.height)
				}
			}
		}
	};
	this.updateDataFilter = function(a) {
		this.functionCaller = "updateDataFilter";
		var m = this;
		var c = this.isDOE;
		var g, j;
		var b = function(u, p, w, i, s) {
			var q = {
				min: ">=",
				max: "<=",
				like: "like",
				exact: "exact"
			};
			if (q[w]) {
				m[u].push(s != null ? i + ":::" + s : i);
				m[u + "Op"].push(q[w]);
				m[u + "Case"].push(false);
				m[u + "Value"].push(m.toDoFilter[p][i][w])
			}
		};
		if (this.filteringStringOn || this.filteringNumericOn || a) {
			this.resetFilters();
			var n = false;
			if (c) {
				this.removeDOE(true)
			}
			for (var k in this.toDoFilter) {
				for (var e in this.toDoFilter[k]) {
					for (var l in this.toDoFilter[k][e]) {
						var d = this.toDoFilter[k][e]["ref"];
						if (l != "ref") {
							if (k == "sample") {
								b("filterSmpBy", k, l, e, d)
							} else {
								if (k == "variable") {
									b("filterVarBy", k, l, e, d)
								} else {
									if (k == "node") {
										b("filterNodeBy", k, l, e, d)
									} else {
										if (k == "edge") {
											b("filterEdgeBy", k, l, e, d)
										} else {
											if (k == "feature") {
												b("filterFeatureBy", k, l, e, d)
											}
										}
									}
								}
							}
						}
					}
				}
			}
			this.reset(true);
			this.filterData(true);
			if (this.layoutComb) {
				g = this.varIndices;
				j = this.smpIndices
			}
			if (c) {
				this.createDOE(true)
			}
			if (this.data.d && this.data.d.reg) {
				this.updateCorrelation()
			}
			if (this.validateAxesOnFilterData()) {
				if (this.graphType == "Network" && this.filterFlashingOn) {
					var f = [];
					for (var h = 0; h < this.data.nodes.length; h++) {
						if (!this.data.nodes[h].hide) {
							f.push(this.data.nodes[h].id)
						}
					}
					this.flashNode(f, false, 5)
				} else {
					if (this.isGroupedData && this.smpIndices.length > 0) {
						this.groupSamples(this.groupingFactors, false, false, true, true)
					}
					this.draw();
					if (this.layoutComb) {
						this.varIndices = g;
						this.smpIndices = j
					}
				}
			} else {
				if (!this.scatterPlotMatrix) {
					this.reset(true)
				}
				this.draw()
			}
		}
	};
	this.refreshDataFilters = function(e, C, n, A, b) {
		if (e && C) {
			var y;
			switch (C) {
				case "variable":
					y = this.getSampleVariableData("vars");
					break;
				case "sample":
					y = this.getSampleVariableData("smps");
					break
			}
			if (y) {
				if (!this.lastRefreshedFilter) {
					this.lastRefreshedFilter = []
				}
				var m = this.lastRefreshedFilter.length > 0 ? this.lastRefreshedFilter[this.lastRefreshedFilter.length - 1] : "";
				var x = false;
				while (m == n) {
					this.lastRefreshedFilter.pop();
					m = this.lastRefreshedFilter[this.lastRefreshedFilter.length - 1];
					x = true
				}
				for (var u = 0; u < e.childNodes.length; u++) {
					var z = e.childNodes[u];
					var D = this.$(z.id.replace("DataFilterContainer", "DataFilterScroll"));
					var h = this.$(z.id.replace("DataFilterContainer", "DataFilterOptions"));
					if (D && h) {
						if (D.uvalue != n && !A) {
							var B = this.sortObject(y[D.uvalue]["o"]);
							D.fvalues = ["(All) " + B.length + " values"];
							for (var q = 0; q < B.length; q++) {
								D.fvalues.push(B[q])
							}
							D.fvalues.push("")
						} else {
							if (A && x && (m == D.uvalue || this.lastRefreshedFilter.length == 0)) {
								D.fvalues = D.values
							}
						}
						while (h.childNodes.length > 0) {
							h.removeChild(h.childNodes[0])
						}
						if ((D.uvalue == n && !A) || (A && m == D.uvalue)) {
							this.loadStringFilter(D.fvalues, D.uvalue, h, y[D.uvalue]["o"])
						} else {
							this.loadStringFilter(D.fvalues, D.uvalue, h)
						}
					}
				}
				if (!A) {
					this.lastRefreshedFilter.push(n)
				}
			}
		} else {
			if (b) {
				var x = this.$(this.target + "-cX-DataFilterContainer");
				if (x) {
					this.lastRefreshedFilter = [];
					for (var u = 0; u < x.childNodes.length; u++) {
						if (x.childNodes[u].id.match("Content")) {
							var z = x.childNodes[u];
							for (var q = 0; q < z.childNodes.length; q++) {
								if (z.childNodes[q].id.match("Items")) {
									var w = z.childNodes[q];
									for (var n = 0; n < w.childNodes.length; n++) {
										if (w.childNodes[n].id.match("Container")) {
											var y = w.childNodes[n];
											var D = this.$(y.id.replace("DataFilterContainer", "DataFilterScroll"));
											var h = this.$(y.id.replace("DataFilterContainer", "DataFilterOptions"));
											if (D && h) {
												D.fvalues = D.values;
												while (h.childNodes.length > 0) {
													h.removeChild(h.childNodes[0])
												}
												this.loadStringFilter(D.fvalues, D.uvalue, h)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.validateAxesOnFilterData = function() {
		if (!this.startingXAxisIndices) {
			this.startingXAxis = this.xAxis;
			this.startingXAxisIndices = this.graphType.match(/Scatter/i) ? this.xAxisIndices : this.xAxisVarIndices
		}
		if (!this.startingXAxis2Indices) {
			this.startingXAxis2 = this.xAxis2;
			this.startingXAxis2Indices = this.xAxis2VarIndices
		}
		if (!this.startingYAxisIndices) {
			this.startingYAxis = this.yAxis;
			this.startingYAxisIndices = this.yAxisIndices
		}
		if (!this.startingZAxisIndices) {
			this.startingZAxis = this.zAxis;
			this.startingZAxisIndices = this.zAxisIndices
		}
		if (this.graphType.match(/Scatter/i)) {
			var a = this.getObjectArray(this.smpIndices);
			this.xAxis = [];
			this.xAxisIndices = [];
			for (var b = 0; b < this.startingXAxisIndices.length; b++) {
				if (a.hasOwnProperty(this.startingXAxisIndices[b])) {
					this.xAxis.push(this.data.y.smps[this.startingXAxisIndices[b]]);
					this.xAxisIndices.push(this.startingXAxisIndices[b])
				}
			}
			if (this.xAxisIndices.length < 1) {
				this.xAxis = this.startingXAxis;
				this.xAxisIndices = this.startingXAxisIndices;
				if (this.debug) {
					alert("Cannot filter since there are no samples left in X-Axis")
				}
				return false
			}
			this.yAxis = [];
			this.yAxisIndices = [];
			for (var b = 0; b < this.startingYAxisIndices.length; b++) {
				if (a.hasOwnProperty(this.startingYAxisIndices[b])) {
					this.yAxis.push(this.data.y.smps[this.startingYAxisIndices[b]]);
					this.yAxisIndices.push(this.startingYAxisIndices[b])
				}
			}
			if (this.yAxisIndices.length < 1) {
				this.yAxis = this.startingYAxis;
				this.yAxisIndices = this.startingYAxisIndices;
				if (this.debug) {
					alert("Cannot filter since there are no samples left in Y-Axis")
				}
				return false
			}
			if (this.graphType == "Scatter3D" || this.graphType == "ScatterBubble2D") {
				this.zAxis = [];
				this.zAxisIndices = [];
				for (var b = 0; b < this.startingZAxisIndices.length; b++) {
					if (a.hasOwnProperty(this.startingZAxisIndices[b])) {
						this.zAxis.push(this.data.y.smps[this.startingZAxisIndices[b]]);
						this.zAxisIndices.push(this.startingZAxisIndices[b])
					}
				}
				if (this.zAxisIndices.length < 1) {
					this.zAxis = this.startingZAxis;
					this.zAxisIndices = this.startingZAxisIndices;
					if (this.debug) {
						alert("Cannot filter since there are no samples left in Z-Axis")
					}
					return false
				}
			}
		} else {
			if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
				var a = this.getObjectArray(this.varIndices);
				this.xAxis = [];
				this.xAxisIndices = [];
				for (var b = 0; b < this.startingXAxisIndices.length; b++) {
					if (a.hasOwnProperty(this.startingXAxisIndices[b])) {
						this.xAxis.push(this.data.y.vars[this.startingXAxisIndices[b]]);
						this.xAxisIndices.push(this.startingXAxisIndices[b])
					}
				}
				if (this.xAxisIndices.length < 1) {
					this.xAxis = this.startingXAxis;
					this.xAxisIndices = this.startingXAxisIndices;
					if (this.debug) {
						alert("Cannot filter since there are no variables left in X-Axis")
					}
					return false
				}
				this.xAxis2 = [];
				this.xAxis2Indices = [];
				for (var b = 0; b < this.startingXAxis2Indices.length; b++) {
					if (a.hasOwnProperty(this.startingXAxis2Indices[b])) {
						this.xAxis2.push(this.data.y.vars[this.startingXAxis2Indices[b]]);
						this.xAxis2Indices.push(this.startingXAxis2Indices[b])
					}
				}
				if (this.xAxis2Indices.length < 1) {
					this.xAxis2 = this.startingXAxis2;
					this.xAxisIndices2 = this.startingXAxis2Indices;
					if (this.debug) {
						alert("Cannot filter since there are no variables left in X-Axis2")
					}
					return false
				}
			}
		}
		return true
	};
	this.showDataFilter = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var f = a.$(a.target + "-cX-DataFilter");
			if (f) {
				if (f.style.left == "0px" && f.style.top == "0px") {
					var b = a.$("west-container-" + a.target);
					var c = a.$("middle-container-" + a.target);
					if (b && c) {
						c.style.width = (parseInt(b.clientWidth) + a.meta.canvas.ctx.canvas.width + a.dataFilterWidth) + "px"
					}
				}
				if (a.activeTarget) {
					a.activeTarget.style.zIndex = 10000
				}
				a.activeTarget = f;
				f.style.display = "block";
				a.loadDataFilter();
				f.style.zIndex = 10001
			}
			return false
		}
	}(this);
	this.removeGenericDataFilterListenersOrReset = function(y) {
		var x = [];
		var v = [];
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Area":
			case "AreaLine":
			case "Dotplot":
			case "DotLine":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Boxplot":
			case "Correlation":
			case "Pie":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Scatter3D":
			case "Candlestick":
			case "Circular":
				var k = this.$(this.target + "-cX-DataFilterSampleContent");
				var l = this.$(this.target + "-cX-DataFilterVariableContent");
				if (k && l) {
					x.push(k, l);
					v.push(this.getSampleVariableData("smps", true));
					v.push(this.getSampleVariableData("vars", true))
				}
				break;
			case "Venn":
				return;
			case "Network":
				var s = this.$(this.target + "-cX-DataFilterNodeContent");
				var o = this.$(this.target + "-cX-DataFilterEdgeContent");
				if (s && o) {
					x.push(s, o);
					v.push(this.getNodeData(true));
					v.push(this.getEdgeData(true))
				}
				break;
			case "Genome":
				var g = this.$(this.target + "-cX-DataFilterGenomeContent");
				if (g) {
					x.push(g);
					v.push(this.getFeatureData(true))
				}
				break
		}
		for (var t = 0; t < v.length; t++) {
			var f = x[t];
			var m = v[t];
			var A = this.getKeys(m);
			A.sort();
			for (var q = 0; q < A.length; q++) {
				var z = m[A[q]]["t"];
				var w = A[q].replace(/\W/g, "_");
				if (z == "string") {
					var a = this.$(this.target + ":" + w + ":cX-DataFilterInput");
					var p = this.$(this.target + ":" + w + ":cX-DataFilterScroll");
					if (p && a) {
						if (y) {
							a.value = "";
							this.resetSelectStringFilter(p)
						} else {
							this.addRemoveNumericDataFilterListeners("removeEvtListener", p)
						}
					}
				} else {
					var n = this.$(this.target + ":" + w + ":cX-DataFilterMin");
					var h = this.$(this.target + ":" + w + ":cX-DataFilterMinLabel");
					var e = this.$(this.target + ":" + w + ":cX-DataFilterRange");
					var r = this.$(this.target + ":" + w + ":cX-DataFilterMax");
					var u = this.$(this.target + ":" + w + ":cX-DataFilterMaxLabel");
					var b = this.meta.system.isIE ? 44 : 42;
					if (this.dataFilterScroller) {
						b += 18
					}
					if (n && h && e && r && u) {
						if (y) {
							n.style.left = "0px";
							h.value = this.bestFormatNumber(e.min, e.decis);
							e.style.left = "0px";
							e.style.width = (this.dataFilterWidth - b) + "px";
							r.style.left = "0px";
							u.value = this.bestFormatNumber(e.max, e.decis)
						} else {
							this.addRemoveNumericDataFilterListeners("removeEvtListener", n, r, h, u)
						}
					}
				}
			}
		}
	};
	this.loadDataFilter = function() {
		if (!this.toDoFilter) {
			this.toDoFilter = {}
		}
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Area":
			case "AreaLine":
			case "Dotplot":
			case "DotLine":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Boxplot":
			case "Correlation":
			case "Pie":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Scatter3D":
			case "Candlestick":
			case "Circular":
				return this.loadDataFilterSmpVar();
			case "Venn":
				return;
			case "Network":
				return this.loadDataFilterNetwork();
			case "Genome":
				return this.loadDataFilterGenome()
		}
	};
	this.loadDataFilterGeneric = function(b, q, h) {
		var n = this.graphType == "Genome" ? 95 : 116;
		var o = this.getKeys(h);
		o.sort();
		if (!q.loaded) {
			q.loaded = {}
		}
		var a = q.id + "Search";
		if (!this.$(a)) {
			var j = this.$cX("div", {
				id: a,
				className: "CanvasXpressDataFilterContainerHoverable"
			}, {
				width: "97%"
			});
			var p = this.$cX("input", {
				id: a + "Input",
				type: "text",
				placeholder: " Search filters"
			}, {
				cursor: "default",
				width: "97%",
				margin: "3px",
				border: "none"
			});
			var l = this.$cX("div", {
				id: a + "Items"
			}, {
				overflow: "auto"
			});
			j.appendChild(p);
			q.appendChild(j);
			q.appendChild(l)
		}
		var g = this.$(a + "Items");
		if (g) {
			g.style.height = this.meta.canvas.ctx.canvas.height - n
		}
		for (var f = 0; f < o.length; f++) {
			var k = h[o[f]]["t"];
			var e = h[o[f]]["r"];
			var m = this.getKeys(h[o[f]]["o"]);
			if (m.length > 0) {
				if (k == "string") {
					if (!q.loaded[o[f]]) {
						l.appendChild(this.createStringFilter(b, o[f], m, e));
						q.loaded[o[f]] = true
					}
				} else {
					if (!q.loaded[o[f]]) {
						if (m[0] == "min" && m[1] == "max") {
							m = [h[o[f]]["o"]["min"], h[o[f]]["o"]["max"]]
						}
						l.appendChild(this.createNumericFilter(b, o[f], m, e));
						q.loaded[o[f]] = true
					}
				}
			}
		}
	};
	this.loadDataFilterSmpVar = function() {
		var b = this.$(this.target + "-cX-DataFilterSampleContent");
		var a = this.$(this.target + "-cX-DataFilterVariableContent");
		if (b && a) {
			this.loadDataFilterGeneric("sample", b, this.getSampleVariableData("smps", true));
			this.loadDataFilterGeneric("variable", a, this.getSampleVariableData("vars", true))
		}
	};
	this.loadDataFilterNetwork = function() {
		var b = this.$(this.target + "-cX-DataFilterNodeContent");
		var a = this.$(this.target + "-cX-DataFilterEdgeContent");
		if (b && a) {
			this.loadDataFilterGeneric("node", b, this.getNodeData(true));
			this.loadDataFilterGeneric("edge", a, this.getEdgeData(true))
		}
	};
	this.loadDataFilterGenome = function() {
		var a = this.$(this.target + "-cX-DataFilterGenomeContent");
		if (a) {
			this.loadDataFilterGeneric("feature", a, this.getFeatureData(true))
		}
	};
	this.createNumericFilter = function(g, w, f, n) {
		var a = function(d) {
			var b = 1000000;
			return (((d * b) - (parseInt(d) * b)) / b).toString().replace(/\./, "").length - 1
		};
		var c = this.meta.system.isIE ? 44 : 42;
		var p = [];
		for (var x = 0; x < f.length; x++) {
			if (f[x] != null && f[x] != "") {
				p.push(f[x])
			}
		}
		f = p;
		f.sort(function(e, d) {
			return e - d
		});
		var B = w.replace(/\W/g, "_");
		var D = this.$cX("div", {
			id: this.target + ":" + B + ":cX-DataFilterContainer",
			className: "CanvasXpressDataFilterContainerHoverable",
			type: "numeric"
		});
		var u = this.$cX("div", {
			id: this.target + ":" + B + ":cX-DataFilterScale",
			className: f[0] <= 0 ? "CanvasXpressDataFilterContainerScaleNone" : "CanvasXpressDataFilterContainerScaleLinearLog",
			innerHTML: w,
			draggable: true
		}, {
			width: (this.dataFilterWidth - 12) + "px",
			margin: "5px"
		});
		var m = this.$cX("div", false, {
			width: (this.dataFilterWidth - 12) + "px",
			height: "14px",
			margin: "2px"
		});
		var z = parseFloat(f[0]) < 0 ? false : parseFloat(f[0]) == 0 ? 0 : Math.log(parseFloat(f[0]));
		var C = parseFloat(f[f.length - 1]) < 0 ? false : parseFloat(f[f.length - 1]) == 0 ? 0 : Math.log(parseFloat(f[f.length - 1]));
		var F = z != null && C != null ? (C - z) / (this.dataFilterWidth - c) : false;
		var j = this.$cX("div", {
			id: this.target + ":" + B + ":cX-DataFilterRange",
			className: "CanvasXpressDataFilterContainerRange",
			min: parseFloat(f[0]),
			max: parseFloat(f[f.length - 1]),
			range: f[f.length - 1] - f[0],
			units: (f[f.length - 1] - f[0]) / (this.dataFilterWidth - c),
			decis: a(f[f.length - 1] - f[0]),
			lmin: z,
			lmax: C,
			lunits: F,
			scale: F ? "linear" : false,
			filter: g,
			ref: n,
			uvalue: w
		}, {
			width: (this.dataFilterWidth - c) + "px"
		});
		var y = this.$cX("input", {
			id: this.target + ":" + B + ":cX-DataFilterMinLabel",
			className: "CanvasXpressDataFilterContainerMinValue",
			type: "text",
			value: this.bestFormatNumber(f[0], j.decis)
		});
		var h = this.$cX("input", {
			id: this.target + ":" + B + ":cX-DataFilterMaxLabel",
			className: "CanvasXpressDataFilterContainerMaxValue",
			type: "text",
			value: this.bestFormatNumber(f[f.length - 1], j.decis)
		});
		var E = this.$cX("div", {
			className: "CanvasXpressDataFilterContainerNumeric"
		}, {
			width: (this.dataFilterWidth - 14) + "px"
		});
		var A = this.$cX("div", {
			id: this.target + ":" + B + ":cX-DataFilterMin",
			className: "CanvasXpressDataFilterContainerMin"
		}, {
			left: "0px"
		});
		var o = this.$cX("div", {
			id: this.target + ":" + B + ":cX-DataFilterMax",
			className: "CanvasXpressDataFilterContainerMax"
		}, {
			left: "0px"
		});
		m.appendChild(y);
		m.appendChild(h);
		E.appendChild(A);
		E.appendChild(j);
		E.appendChild(o);
		D.appendChild(u);
		D.appendChild(m);
		D.appendChild(E);
		this.addRemoveNumericDataFilterListeners("addEvtListener", A, o, y, h, u);
		return D
	};
	this.addRemoveNumericDataFilterListeners = function(e, d, a, f, c, b) {
		if (e && d && a) {
			this[e](d, "mousedown", this.mousedownNumericFilter, false);
			this[e](a, "mousedown", this.mousedownNumericFilter, false);
			this[e](f, "change", this.changeNumericFilter, false);
			this[e](c, "change", this.changeNumericFilter, false);
			this[e](b, "click", this.clickNumericFilter, false);
			this[e](b, "dragstart", this.dragStartDataFilter, false);
			this[e](b, "dragend", this.dragEndDataFilter, false)
		}
	};
	this.dragStartDataFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			c.acs = a.adjustedCoordinates(c);
			var b = a.getTargetEvent(c);
			if (b) {
				c.dataTransfer.setDragImage(b.parentNode, -5, -5);
				b.parentNode.style.opacity = "0.3";
				c.dataTransfer.setData("text/html", b.parentNode.innerHTML);
				a.xMouseDown = c.screenX;
				a.yMouseDown = c.screenY
			}
			return false
		}
	}(this);
	this.dragEndDataFilter = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			g.ace = a.adjustedCoordinates(g);
			var c = a.getTargetEvent(g);
			var f = c.parentNode.innerHTML;
			if (c) {
				c.parentNode.style.opacity = "1.0";
				var d = g.screenX - a.xMouseDown;
				var b = g.screenY - a.yMouseDown
			}
			return false
		}
	}(this);
	this.changeNumericFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (b) {
				a.filteringNumericOn = b;
				a.updateNumericFilter(c)
			}
			return false
		}
	}(this);
	this.mousedownNumericFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (b) {
				a.filteringNumericOn = b;
				a.xMouseDown = c.clientX;
				a.yMouseDown = c.clientY
			}
			return false
		}
	}(this);
	this.clickNumericFilter = function(a) {
		return function(h) {
			if (!h) {
				h = window.event
			}
			var d = a.getTargetEvent(h);
			if (d) {
				var c = a.$(d.id.replace("cX-DataFilterScale", "cX-DataFilterRange"));
				var g = a.adjustedCoordinates(h, d);
				if (c && g && c.scale) {
					var f = a.isIE ? 44 : 42;
					var b = a.dataFilterScroller ? parseInt(a.dataFilterWidth * 0.98) - 18 : parseInt(a.dataFilterWidth * 0.98);
					if (g.x > b - 13) {
						d.className = "CanvasXpressDataFilterContainerScaleLogLinear";
						c.scale = "log"
					} else {
						if (g.x > b - 26) {
							d.className = "CanvasXpressDataFilterContainerScaleLinearLog";
							c.scale = "linear"
						}
					}
				}
			}
			return false
		}
	}(this);
	this.updateNumericFilter = function(t) {
		if (this.filteringNumericOn) {
			this.cancelEvent(t);
			var r = this.filteringNumericOn;
			var v, o, p, h, i, u, b;
			if (r.id.match(/cX-DataFilterMin(Label)?/)) {
				b = RegExp.$1;
				v = true;
				o = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterMin");
				p = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterMax");
				h = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterRange");
				i = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterMinLabel");
				u = r.id.replace("cX-DataFilterMin" + b, "cX-DataFilterMaxLabel")
			} else {
				if (r.id.match(/cX-DataFilterMax(Label)?/)) {
					b = RegExp.$1;
					v = false;
					p = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterMax");
					o = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterMin");
					h = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterRange");
					i = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterMinLabel");
					u = r.id.replace("cX-DataFilterMax" + b, "cX-DataFilterMaxLabel")
				}
			}
			o = this.$(o);
			p = this.$(p);
			h = this.$(h);
			i = this.$(i);
			u = this.$(u);
			if (o && p && h && i && u) {
				var k, s;
				var c = this.meta.system.isIE ? 44 : 42;
				var l = this.dataFilterWidth - c;
				if (this.dataFilterScroller) {
					l -= 18
				}
				if (b) {
					var z = r.value - 0,
						m, g = i.value - 0,
						d = u.value - 0;
					var q = false;
					if (r === u && z < g) {
						z = g;
						q = true
					}
					if (r === i && z > d) {
						z = d;
						q = true
					}
					if (z < h.min) {
						z = h.min;
						q = true
					}
					if (z > h.max) {
						z = h.max;
						q = true
					}
					if (q) {
						r.value = this.bestFormatNumber(z, h.decis)
					}
					if (h.scale == "log") {
						s = z ? (Math.log(z) - h.lmin) / h.lunits : 0
					} else {
						s = (z - h.min) / h.units
					}
					s = Math.ceil(s);
					if (v) {
						s = Math.ceil(s);
						h.style.width = (parseInt(h.style.width) - s + parseInt(o.style.left)) + "px";
						o.style.left = s + "px";
						h.style.left = s + "px";
						p.style.left = s + "px"
					} else {
						h.style.width = Math.max(0, Math.floor(s) - parseInt(o.style.left)) + "px"
					}
				} else {
					k = t.clientX - this.xMouseDown;
					s = parseInt(o.style.left) + k;
					var a = v ? parseInt(h.style.width) - k : parseInt(h.style.width) + k;
					var n = this.absoluteCoordinates(o);
					var j = this.absoluteCoordinates(p);
					if (v) {
						if (s > 0 && a > 0) {
							this.xMouseDown = t.clientX;
							s = Math.max(0, Math.min(l, s));
							a = Math.max(0, Math.min(l, a))
						} else {
							if (s > 0) {
								s -= k;
								a = (j.x - n.x) - 29
							} else {
								a += s;
								s = 0
							}
						}
						o.style.left = s + "px";
						h.style.left = s + "px";
						h.style.width = a + "px";
						p.style.left = s + "px";
						var x;
						if (h.scale == "log") {
							x = s != 0 ? Math.exp((h.lunits * s) + h.lmin) : 0
						} else {
							x = (h.units * s) + h.min
						}
						x = Math.min(Math.max(x, h.min), parseFloat(u.value));
						i.value = this.bestFormatNumber(x, h.decis)
					} else {
						if (s + a <= l && a >= 0) {
							this.xMouseDown = t.clientX;
							s = Math.max(0, Math.min(l, s));
							a = Math.max(0, Math.min(l - s, a))
						} else {
							if (s + a > l) {
								s -= k;
								a = l - s
							}
						}
						h.style.width = Math.max(0, a) + "px";
						var y;
						if (h.scale == "log") {
							y = a != l ? Math.exp((h.lunits * (s + a)) + h.lmin) : h.max
						} else {
							y = (h.units * (s + a)) + h.min
						}
						y = Math.max(Math.min(y, h.max), parseFloat(i.value));
						u.value = this.bestFormatNumber(y, h.decis)
					}
				}
				var w = h.uvalue;
				var f = h.filter;
				if (!this.toDoFilter[f]) {
					this.toDoFilter[f] = {}
				}
				if (!this.toDoFilter[f][w]) {
					this.toDoFilter[f][w] = {}
				}
				if (b) {
					if (v) {
						this.toDoFilter[f][w]["min"] = z
					} else {
						this.toDoFilter[f][w]["max"] = z
					}
				} else {
					if (x != null) {
						this.toDoFilter[f][w]["min"] = x
					}
					if (y != null) {
						this.toDoFilter[f][w]["max"] = y
					}
				}
				if (h.ref != null) {
					this.toDoFilter[f][w]["ref"] = h.ref
				}
				this.updateDataFilter();
				this.refreshDataFilters(r.parentNode.parentNode.parentNode, f, w);
				if (b) {
					this.endNumericFilter(t)
				}
			}
		}
		return false
	};
	this.endNumericFilter = function(a) {
		if (this.filteringNumericOn) {
			this.filteringNumericOn = false
		}
	};
	this.createStringFilter = function(r, g, p, a) {
		p.sort();
		p.unshift("(All) " + p.length + " values");
		p.push("");
		var j = g.replace(/\W/g, "_");
		var n = this.$cX("div", {
			id: this.target + ":" + j + ":cX-DataFilterContainer",
			className: "CanvasXpressDataFilterContainerHoverable",
			type: "string"
		});
		var f = this.$cX("div", {
			innerHTML: g,
			draggable: true
		}, {
			width: "98%",
			margin: "5px"
		});
		var h = this.$cX("input", {
			id: this.target + ":" + j + ":cX-DataFilterInput",
			type: "text",
			placeholder: " Search values"
		}, {
			cursor: "default",
			width: "97%",
			marginLeft: "3px"
		});
		var c = this.$cX("div", {
			id: this.target + ":" + j + ":cX-DataFilterMask",
			className: p.length - 2 > this.maxItemMenuCheckbox ? "CanvasXpressDataFilterContainerMask" : "CanvasXpressDataFilterContainerMaskNoOverflow"
		}, {
			width: "96%",
			height: p.length - 2 > this.maxItemMenuCheckbox ? "80px" : (((p.length - 1) * 19) + 4) + "px"
		});
		var u = this.$cX("div", {
			id: this.target + ":" + j + ":cX-DataFilterScroll",
			type: (p.length - 2) > this.maxItemMenuCheckbox ? "long" : "short",
			filter: r,
			uvalue: g,
			values: p,
			fvalues: p,
			selected: {
				0: true
			},
			ref: a,
			skey: j,
			last: 0
		}, {
			width: "96%",
			height: p.length - 2 > this.maxItemMenuCheckbox ? ((p.length + 1) * 16) + "px" : (((p.length - 1) * 19) + 4) + "px"
		});
		var b = this.$cX("div", {
			id: this.target + ":" + j + ":cX-DataFilterOptions"
		}, {
			width: p.length - 2 > this.maxItemMenuCheckbox ? "110%" : "100%",
			margin: "2px",
			position: "relative"
		});
		this.loadStringFilter(p, j, b);
		u.appendChild(b);
		c.appendChild(u);
		n.appendChild(f);
		if (p.length - 2 > this.maxItemMenuCheckbox) {
			n.appendChild(h)
		}
		n.appendChild(c);
		this.addRemoveStringDataFilterListeners("addEvtListener", c);
		return n
	};
	this.loadStringFilter = function(p, g, e, q) {
		if (p && g && e) {
			if (p.length - 2 > this.maxItemMenuCheckbox) {
				for (var h = 0; h < Math.min(5, p.length); h++) {
					var b = p[h].length > 30 ? p[h].substr(0, 30) + " ..." : p[h];
					var m = (!q && h == 0) || (q && q.hasOwnProperty(p[h])) ? "CanvasXpressDataFilterContainerItemSelected" : "CanvasXpressDataFilterContainerItem";
					var n = this.$cX("div", {
						id: this.target + ":" + g + ":cX-DataFilterItem-" + h,
						className: m,
						innerHTML: b,
						alt: p[h],
						title: p[h],
						index: h
					});
					e.appendChild(n)
				}
			} else {
				for (var h = 0; h < p.length - 1; h++) {
					var b = p[h].length > 30 ? p[h].substr(0, 30) + " ..." : p[h];
					var j = this.$cX("div", {
						id: this.target + ":" + g + ":cX-DataFilterDivItem-" + h,
						alt: p[h],
						title: p[h],
						value: b,
						index: h
					});
					var n = this.$cX("input", {
						id: this.target + ":" + g + ":cX-DataFilterItem-" + h,
						className: "CanvasXpressCheckbox",
						type: "checkbox",
						checked: q && !q.hasOwnProperty(p[h]) ? false : true,
						value: b,
						index: h,
						name: ""
					});
					var f = this.$cX("label", {
						"for": this.target + ":" + g + ":cX-DataFilterItem-" + h,
						className: "CanvasXpressCheckboxLabel",
						innerHTML: p[h]
					});
					j.appendChild(n);
					j.appendChild(f);
					e.appendChild(j)
				}
			}
		}
	};
	this.addRemoveStringDataFilterListeners = function(c, b) {
		if (c && b) {
			var a = b.parentNode.firstElementChild;
			if (b.firstChild.type == "long") {
				this[c](b, "scroll", this.scrollStringFilter, false)
			}
			this[c](b, "mousedown", this.registerStringFilter, false);
			this[c](b, "mouseup", this.endStringFilter, false);
			this[c](a, "dragstart", this.dragStartDataFilter, false);
			this[c](a, "dragend", this.dragEndDataFilter, false)
		}
	};
	this.scrollStringFilter = function(a) {
		return function(j, c, n) {
			if (!j) {
				j = window.event
			}
			if (!c) {
				c = a.getTargetEvent(j)
			}
			var p = c.firstChild;
			var f = p.firstChild;
			var g = p.skey;
			var m = Math.max(0, Math.min(Math.floor(c.scrollTop / 16), p.fvalues.length - 5));
			f.style.top = c.scrollTop + "px";
			for (var h = 0; h < Math.min(5, p.fvalues.length); h++) {
				var l = a.$(a.target + ":" + g + ":cX-DataFilterItem-" + h);
				if (l) {
					var c = p.fvalues[m + h].length > 30 ? p.fvalues[m + h].substr(0, 30) + " ..." : p.fvalues[m + h];
					l.className = p.selected[m + h] ? "CanvasXpressDataFilterContainerItemSelected" : "CanvasXpressDataFilterContainerItem";
					l.innerHTML = c;
					l.alt = p.fvalues[m + h];
					l.title = p.fvalues[m + h];
					l.index = m + h
				}
			}
			if (a.filteringStringOn && !n) {
				a.updateSelectStringFilter(false, a.$(a.target + ":" + g + ":cX-DataFilterItem-4"), true)
			}
			return false
		}
	}(this);
	this.registerStringFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.getTargetEvent(c);
			if (!b.id) {
				b = b.parentNode
			}
			if (!b.id.match(/cX-DataFilterMask/)) {
				if (!b.id.match(/cX-DataFilterDivItem/)) {
					if (b.parentNode.id.match(/cX-DataFilterDivItem/)) {
						a.updateSelectStringFilter(false, b, false, true);
						a.filteringStringOn = b.parentNode
					} else {
						a.$(b.parentNode.id.replace("cX-DataFilterOptions", "cX-DataFilterInput")).value = "";
						a.updateSelectStringFilter(false, b, c.shiftKey, c.ctrlKey);
						a.filteringStringOn = b
					}
				} else {
					a.updateSelectStringFilter(false, b.firstChild, false, true);
					a.filteringStringOn = b
				}
			}
			return false
		}
	}(this);
	this.endStringFilter = function(a) {
		return function(k, d, g) {
			if (!k) {
				k = window.event
			}
			if (!d && a.filteringStringOn && a.filteringStringOn.parentNode) {
				d = a.filteringStringOn.parentNode.parentNode
			}
			if (!d) {
				return
			}
			var t = d.selected;
			var j = d.filter;
			var p = d.uvalue;
			var b = d.ref;
			var n = d.fvalues;
			var c = g ? "like" : "exact";
			var m;
			if (!t[0]) {
				if (!a.toDoFilter[j]) {
					a.toDoFilter[j] = {}
				}
				if (!a.toDoFilter[j][p]) {
					a.toDoFilter[j][p] = {}
				}
				a.toDoFilter[j][p][c] = [];
				for (var h in t) {
					a.toDoFilter[j][p][c].push(n[h])
				}
				if (b != null) {
					a.toDoFilter[j][p]["ref"] = b
				}
			} else {
				if (a.toDoFilter[j] && a.toDoFilter[j][p]) {
					delete(a.toDoFilter[j][p])
				}
			}
			a.filteringStringOn = true;
			a.updateDataFilter();
			a.refreshDataFilters(d.parentNode.parentNode.parentNode, j, p, t[0]);
			a.scrollStringFilter(false, d.parentNode, true);
			a.filteringStringOn = false;
			return false
		}
	}(this);
	this.updateStringFilter = function(b) {
		var a = this.getTargetEvent(b);
		var c = this.filteringStringOn && this.filteringStringOn.id ? this.filteringStringOn.id.replace(/-\d$/, "") : "";
		if (a.id.match(c) && !b.ctrlKey) {
			this.updateSelectStringFilter(false, a, true)
		}
	};
	this.updateSelectStringFilter = function(j, E, B, c) {
		if (j) {
			var D = this.$(j);
			var t = this.$(j.replace("cX-DataFilterInput", "cX-DataFilterScroll"));
			if (D.value) {
				var u = 0;
				var r = t.firstChild;
				var F = r.childNodes[0].index;
				var C = null;
				var k = 0;
				t.selected = {};
				for (var y = 1; y < t.fvalues.length - 1; y++) {
					if (t.fvalues[y].toLowerCase().match(D.value.toLowerCase())) {
						if (!C) {
							C = y;
							k = y * 16
						}
						t.selected[y] = true;
						u++
					}
				}
				if (u + 2 == t.fvalues.length) {
					t.selected = {
						0: true
					};
					C = 0
				}
				if (C != null) {
					t.parentNode.scrollTop = k;
					this.scrollStringFilter(false, t.parentNode)
				}
				this.endStringFilter(false, t, true)
			} else {
				this.resetSelectStringFilter(t);
				this.endStringFilter(false, t)
			}
		} else {
			if (E) {
				var d = E.index;
				var r = E.parentNode;
				var m = false;
				if (!r.id) {
					return false
				}
				while (!r.id.match(/cX-DataFilterOptions/)) {
					r = r.parentNode;
					m = true;
					if (!r.id) {
						return false
					}
				}
				var k = r.parentNode;
				var w = k.last;
				var A = k.selected;
				var g = k.fvalues;
				var F = r.childNodes[0].index;
				var u = 0;
				var a = c && k.selected[d];
				k.selected = {};
				if (!a) {
					k.selected[d] = true
				}
				if (B) {
					if (d > w) {
						for (var y = w; y <= d; y++) {
							k.selected[y] = true;
							if (y) {
								u++
							}
						}
					} else {
						for (var y = d; y <= w; y++) {
							k.selected[y] = true;
							if (y) {
								u++
							}
						}
					}
				} else {
					if (c) {
						if (!a) {
							k.last = d
						}
						if (m && d == 0) {
							for (var y = 0; y < g.length - 1; y++) {
								k.selected[y] = true
							}
						} else {
							for (var y in A) {
								if (y == d && a) {
									continue
								}
								k.selected[y] = true;
								if (y) {
									u++
								}
							}
						}
					} else {
						k.last = d
					}
				}
				if (u > 0) {
					delete(k.selected[0])
				}
				if (!m) {
					delete(k.selected[g.length - 1]);
					for (var y = 0; y < r.childNodes.length; y++) {
						r.childNodes[y].className = k.selected[y + F] ? "CanvasXpressDataFilterContainerItemSelected" : "CanvasXpressDataFilterContainerItem"
					}
				}
			}
		}
	};
	this.resetSelectStringFilter = function(a) {
		if (a) {
			a.selected = {
				0: true
			};
			var b = a.parentNode;
			b.scrollTop = 0;
			this.scrollStringFilter(false, b)
		}
	};
	this.updateSearchFilters = function(e) {
		var g = this.$(e).parentNode.parentNode;
		if (g) {
			var h = g.childNodes;
			var b = new RegExp(h[0].firstChild.value, "i");
			for (var d = 0; d < h[1].childNodes.length; d++) {
				var a = h[1].childNodes[d].id.split(":");
				if (a[1].match(b)) {
					h[1].childNodes[d].style.display = "block"
				} else {
					h[1].childNodes[d].style.display = "none"
				}
			}
		}
	};
	this.hideDataFilterNoAnimation = function() {
		var a = this.showFadeResizeMoveAnimation;
		this.showFadeResizeMoveAnimation = false;
		this.hideDataFilter();
		this.showFadeResizeMoveAnimation = a;
		return false
	};
	this.hideDataFilter = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.moveDataFilter(true);
			return false
		}
	}(this);
	this.dockUndockDataFilter = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = a.$(a.target + "-cX-DataFilter");
			if (b) {
				a.moveDataFilter()
			}
			return false
		}
	}(this);
	this.resizeDataFilter = function() {
		var a = this.graphType == "Genome" ? 60 : 81;
		this.dataFilterHeight = this.meta.canvas.ctx.canvas.height - a;
		if (this.activeAccordion) {
			this.activeAccordion.style.height = this.dataFilterHeight + "px"
		}
	};
	this.resetDataFilter = function(a) {
		return function(d, g, b) {
			a.functionCaller = "resetDataFilter";
			a.resetFilters();
			a.refreshDataFilters(false, false, false, false, true);
			a.toDoFilter = {};
			a.reset();
			if (b) {
				var c = a.$(a.target + "-cX-DataFilter");
				if (c) {
					a.removeGenericDataFilterListenersOrReset();
					c.parentNode.removeChild(c);
					a.addDataFilterDiv()
				}
			} else {
				a.removeGenericDataFilterListenersOrReset(true)
			}
			if (a.isOncoprint) {
				a.sortIndices("onc", "desc")
			}
			if (!g) {
				if (a.isGroupedData) {
					a.groupSamples(a.groupingFactors)
				} else {
					a.draw()
				}
			}
			return false
		}
	}(this);
	this.rebuildDataFilter = function() {
		this.resetDataFilter(false, true, true)
	};
	this.initializeDataFilterEvents = function() {
		this.addDataFilterDiv()
	};
	this.initializeDataFilterEvents()
};
CanvasXpress.prototype.initDataTable = function() {
	this.addDataTableDiv = function(E, F) {
		if (this.$(this.target + "-cX-DataTable")) {
			return
		}
		var p = this;
		var O = function(n, d, b) {
			var o = p.$cX(d == 0 || b == 0 ? "th" : "td", {
				id: p.target + "-cX-DataTableCell." + d + "." + b,
				className: d == 0 || b == 0 ? "CanvasXpressTableCellHead" : "CanvasXpressTableCell"
			}, {
				width: p.colWidth + "px",
				height: p.rowHeight + "px"
			});
			n.appendChild(o)
		};
		if (!F) {
			this.setDataTableDimensions(E)
		}
		var C = 20;
		var f = 44;
		var m = this.dataTableLastX != null ? parseInt(this.dataTableLastX) : this.meta.canvas.ctx.canvas.width * 0.1;
		var k = this.dataTableLastY != null ? parseInt(this.dataTableLastY) : -this.meta.canvas.ctx.canvas.height * 0.9;
		var q = this.dataTableLastWidth || this.dataTableColsWidth + C;
		var G = this.dataTableLastHeight || this.dataTableRowsHeight + f;
		var v = ((this.colWidth + 8) * 3) + 6;
		var M = ((this.rowHeight + 4) * 3) + 8;
		var L = this.$cX("div", {
			id: this.target + "-cX-DataTable",
			className: "CanvasXpressDataTable draggable-container"
		}, {
			top: k + "px",
			left: m + "px",
			width: q + "px",
			height: G + "px",
			minWidth: (v + C) + "px",
			minHeight: (M + f + 20) + "px",
			display: "none",
			marginTop: "3px"
		});
		var l = this.$cX("div", {
			id: this.target + "-cX-DataTableToolbar",
			className: "CanvasXpressDataTableToolbar draggable"
		}, {
			width: q + "px",
			minWidth: (v + C) + "px"
		});
		var h = this.$cX("img", {
			id: this.target + "-cX-DataTableSaveImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: CanvasXpress.images.disk,
			alt: "Save data",
			title: "Save data"
		});
		var c = this.$cX("img", {
			id: this.target + "-cX-DataTableTransposeImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: CanvasXpress.images.transpose,
			alt: "Transpose data",
			title: "Transpose data"
		});
		var g = this.$cX("img", {
			id: this.target + "-cX-DataTableNetworkImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: this.networkShowDataTable == "nodes" ? CanvasXpress.images.edges : CanvasXpress.images.nodes,
			alt: this.networkShowDataTable == "nodes" ? "Show edge data" : "Show node data",
			title: this.networkShowDataTable == "nodes" ? "Show edge data" : "Show node data"
		}, {
			display: this.graphType == "Network" ? "block" : "none"
		});
		var x = this.$cX("img", {
			id: this.target + "-cX-DataTableDockImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: this.dataTableLastState && this.dataTableLastState == "docked" ? CanvasXpress.images.unpin : CanvasXpress.images.pin,
			alt: this.dataTableLastState && this.dataTableLastState == "docked" ? "Undock" : "Dock",
			title: this.dataTableLastState && this.dataTableLastState == "docked" ? "Undock" : "Dock"
		});
		var D = this.$cX("img", {
			id: this.target + "-cX-DataTableCloseImage",
			className: "CanvasXpressDataTableToolbarImage",
			src: CanvasXpress.images.cancel1,
			alt: "Close table",
			title: "Close table"
		});
		var H = this.$cX("div", {
			id: this.target + "-cX-DataTableContainer",
			className: "CanvasXpressDataTableContainer"
		}, {
			width: q + "px",
			height: (G - 20) + "px",
			minWidth: (v + C) + "px",
			minHeight: (M + f) + "px"
		});
		var a = this.$cX("div", {
			id: this.target + "-cX-DataTableTableMask",
			className: "CanvasXpressDataTableMask"
		}, {
			width: (q - C) + "px",
			height: (G - f) + "px",
			minWidth: v + "px",
			minHeight: (M + 20) + "px"
		});
		var A = this.$cX("table", {
			id: this.target + "-cX-DataTableTable",
			className: "CanvasXpressDataTable"
		});
		var N = this.$cX("tbody");
		for (var J = 0; J < this.maxRows; J++) {
			var B = this.$cX("tr");
			for (var I = 0; I < this.maxCols; I++) {
				O(B, J, I)
			}
			N.appendChild(B)
		}
		var z = this.$cX("div", {
			id: this.target + "-cX-DataTableVer",
			className: "CanvasXpressDataTableVertical"
		}, {
			height: (G - f) + "px",
			minHeight: (M + 20) + "px"
		});
		var e = this.$cX("img", {
			id: this.target + "-cX-DataTableVerImage",
			src: CanvasXpress.images.canvasXpress,
			width: 1,
			height: this.dataTableTotalHeight
		});
		z.appendChild(e);
		var K = this.$cX("div", {
			id: this.target + "-cX-DataTableHor",
			className: "CanvasXpressDataTableHorizontal"
		}, {
			width: (q - C) + "px",
			minWidth: v + "px"
		});
		var y = this.$cX("img", {
			id: this.target + "-cX-DataTableHorImage",
			src: CanvasXpress.images.canvasXpress,
			width: this.dataTableTotalWidth,
			height: 1
		});
		K.appendChild(y);
		var s = this.$cX("div", {
			id: this.target + "-cX-DataTableResizer",
			className: "CanvasXpressDataTableResizer resizable"
		});
		l.appendChild(D);
		l.appendChild(x);
		l.appendChild(c);
		l.appendChild(h);
		l.appendChild(g);
		A.appendChild(N);
		a.appendChild(A);
		H.appendChild(a);
		H.appendChild(z);
		H.appendChild(K);
		H.appendChild(s);
		L.appendChild(l);
		L.appendChild(H);
		var u = this.$("south-wrapper-" + this.target);
		if (u) {
			u.appendChild(L);
			this.addRemoveDataTableListeners("addEvtListener")
		}
	};
	this.addRemoveDataTableListeners = function(a, f) {
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableHor"), "scroll", this.scrollTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableVer"), "scroll", this.scrollTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableToolbar"), "mousedown", this.registerMousemove, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableSaveImage"), "click", this.saveTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableNetworkImage"), "click", this.networkUpdateTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableTransposeImage"), "click", this.transposeDataTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableDockImage"), "click", this.dockUndockTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCloseImage"), "click", this.hideTable, false);
		this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableResizer"), "mousedown", this.mousedownDataTableResizer, false);
		var e = f ? f[0] : this.maxRows;
		var g = f ? f[1] : this.maxCols;
		for (var d = 0; d < g; d++) {
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "click", this.clickDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mousemove", this.mousemoveDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mousedown", this.mousedownDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mouseover", this.mouseoverDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell.0." + d), "mouseout", this.mouseoutDataTableHeader, false)
		}
		for (var d = 0; d < e; d++) {
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + ".0"), "mouseover", this.mouseoverDataTableHeader, false);
			this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + ".0"), "mouseout", this.mouseoutDataTableHeader, false)
		}
		for (var d = 1; d < e; d++) {
			for (var b = 1; b < g; b++) {
				this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + "." + b), "mouseover", this.mouseoverDataTableCell, false);
				this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + "." + b), "mouseout", this.mouseoutDataTableCell, false);
				this.addRemoveEvtListener(a, this.$(this.target + "-cX-DataTableCell." + d + "." + b), "click", this.clickDataTableCell, false)
			}
		}
	};
	this.scrollTable = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			a.removeMenus();
			var j = a.$(a.target + "-cX-DataTable");
			var b = a.$(a.target + "-cX-DataTableVer");
			var f = a.$(a.target + "-cX-DataTableHor");
			if (j && b && f && !a.resizingDataTableOn) {
				var i = Math.ceil(f.scrollLeft / (f.scrollWidth / a.totalCols));
				var c = Math.ceil(b.scrollTop / (b.scrollHeight / a.totalRows));
				a.dataTableLastScrollLeft = f.scrollLeft;
				a.dataTableLastScrollTop = b.scrollTop;
				a.dataTableLastScrollWidth = f.scrollWidth;
				a.dataTableLastScrollHeight = b.scrollHeight;
				if (i != a.startCol || c != a.startRow) {
					a.startCol = i;
					a.startRow = c;
					a.updateDataTable(false, false, false, true)
				}
			}
			return false
		}
	}(this);
	this.saveTable = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			a.removeMenus();
			var b = a.maxCols;
			var f = a.maxRows;
			var c = a.startCol;
			var i = a.startRow;
			a.maxCols = a.totalCols;
			a.maxRows = a.totalRows;
			a.startCol = 0;
			a.startRow = 0;
			var h = a.updateDataTable(false, false, true);
			a.exportToExcel(h);
			a.maxCols = b;
			a.maxRows = f;
			a.startCol = c;
			a.startRow = i;
			return false
		}
	}(this);
	this.dockUndockTable = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.removeMenus();
			var c = a.dataTableLastState && a.dataTableLastState == "docked" ? "undock" : "dock";
			var b = a.getTargetEvent(d);
			if (c == "dock") {
				b.src = CanvasXpress.images.unpin;
				b.alt = "Undock";
				b.title = "Undock"
			} else {
				b.src = CanvasXpress.images.pin;
				b.alt = "Dock";
				b.title = "Dock"
			}
			a.moveDataTableDiv(c);
			return false
		}
	}(this);
	this.transposeDataTable = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.removeMenus();
			a.startRow = 0;
			a.startCol = 0;
			a.dataTableTransposed = a.dataTableTransposed ? false : true;
			a.sortDataTableHead = false;
			a.updateDataTable(false, true, false, false, true);
			a.resizeDataTable();
			return false
		}
	}(this);
	this.minimizeTable = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.moveDataTableDiv("min");
			return false
		}
	}(this);
	this.maximizeTable = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.moveDataTableDiv("max");
			return false
		}
	}(this);
	this.hideTableNoAnimation = function() {
		var a = this.showFadeResizeMoveAnimation;
		this.showFadeResizeMoveAnimation = false;
		this.hideTable();
		this.showFadeResizeMoveAnimation = a;
		return false
	};
	this.hideTable = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.removeMenus();
			var c = a.$(a.target + "-cX-DataTable");
			if (c) {
				a.showDataTable = false;
				a.moveDataTableDiv("hide");
				setTimeout(function() {
					a.hideUnhideDataTable(true);
					a.resetFade(c);
					a.resetDataTable(true)
				}, 500)
			}
			return false
		}
	}(this);
	this.networkUpdateTable = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			a.removeMenus();
			var b = a.getTargetEvent(c);
			a.networkShowDataTable = a.networkShowDataTable == "nodes" ? "edges" : "nodes";
			a.updateDataTable(false, true, false, true);
			return false
		}
	}(this);
	this.mousedownDataTableResizer = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			a.removeMenus();
			var b = d.target || d.srcElement;
			if (a.hasClass(b, "resizable")) {
				var f = a.$(a.target + "-cX-DataTable");
				if (f) {
					a.dataTableTarget = f;
					a.xMouseDown = d.clientX;
					a.yMouseDown = d.clientY;
					a.dataTableWidth = parseInt(a.dataTableTarget.style.width);
					a.dataTableHeight = parseInt(a.dataTableTarget.style.height);
					a.resizingDataTableOn = true
				}
			}
			return false
		}
	}(this);
	this.mousemoveDataTableHeader = function(a) {
		return function(j) {
			if (!j) {
				j = window.event
			}
			var c = a.resizingDataTableColumnOn ? a.dataTableColumnTarget : a.getTargetEvent(j);
			var n = a.adjustedCoordinates(j, c);
			var l = a.$(a.target + "-cX-DataTableHorImage");
			if (n && l) {
				if (a.resizingDataTableColumnOn) {
					var b = a.dataTableColumnTarget.id.split(".");
					var g = parseInt(b[2]);
					var k = n.x - a.xMouseDown;
					var m = Math.max(a.colWidth, (a.dataTableColumnWidth[a.startCol + g] || a.colWidth) + k);
					a.dataTableColumnTarget.firstChild.style.width = m + "px";
					l.width += k;
					for (var h = a.startRow; h < a.startRow + a.totalRows; h++) {
						var d = a.$(a.target + "-cX-DataTableCell." + h + "." + g);
						if (d) {
							d.style.width = m + "px";
							d.firstChild.style.width = m + "px"
						}
					}
					a.dataTableColumnWidth[a.startCol + g] = m;
					a.xMouseDown = n.x;
					a.yMouseDown = n.y;
					document.body.style.cursor = "col-resize"
				} else {
					var f = (c.offsetLeft + c.clientWidth) - n.x;
					if (f < 5 && c.nodeName.toLowerCase() == "th") {
						c.style.cursor = "col-resize"
					} else {
						c.style.cursor = a.isResizeDataTable(c, n) ? "col-resize" : "default"
					}
				}
			}
			return false
		}
	}(this);
	this.mousedownDataTableHeader = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = a.getTargetEvent(d);
			b = b.nodeName.toLowerCase() == "th" || !a.isIE ? b : b.parentNode;
			var c = a.adjustedCoordinates(d, b);
			if (c) {
				if (a.isResizeDataTable(b, c)) {
					a.dataTableColumnTarget = b;
					a.xMouseDown = c.x;
					a.yMouseDown = c.y;
					a.resizingDataTableColumnOn = true;
					document.body.style.cursor = "col-resize"
				}
			}
			return false
		}
	}(this);
	this.isResizeDataTable = function(a, b) {
		return (a.offsetLeft + a.offsetWidth) - b.x < (this.meta.system.isIE ? 10 : 5) && (a.nodeName.toLowerCase() == "th" || (this.meta.system.isIE && a.parentNode && a.parentNode.nodeName.toLowerCase() == "th"))
	};
	this.getColumnsDataTableHeaderMenu = function() {
		var a = this.maxCols;
		var g = this.maxRows;
		var e = this.startCol;
		var j = this.startRow;
		var b = this.dataTableColumnHide;
		this.maxCols = this.totalCols;
		this.maxRows = 0;
		this.startCol = 0;
		this.startRow = 0;
		this.dataTableColumnHide = {};
		var h = this.updateDataTable(false, false, true);
		this.maxCols = a;
		this.maxRows = g;
		this.startCol = e;
		this.startRow = j;
		this.dataTableColumnHide = b;
		var k = [];
		for (var f = 1; f < h[0].length; f++) {
			k.push([h[0][f], this.dataTableColumnHide[h[0][f]] ? "unchecked" : "checked", "hideUnhideDataTableColumn", [h[0][f]]])
		}
		return k
	};
	this.clickDataTableHeader = function(a) {
		return function(l, f) {
			if (!l) {
				l = window.event
			}
			if (a.noSorting) {
				return
			}
			if (!f) {
				a.cancelEvent(l);
				f = a.getTargetEvent(l)
			}
			var b = a.target + "-cX-DataTableCell.0.0";
			if (f.tagName.match(/th/i)) {
				f = f.firstChild
			}
			if (f.tagName.match(/^a$/i)) {
				if (a.skipHeaderMouseout && a.skipHeaderMouseout.id == this.id) {
					a.removeMenus();
					return false
				}
				var o = a.maxCols;
				var w = a.maxRows;
				var j = a.startCol;
				var q = a.startRow;
				var u = a.dataTableColumnHide;
				a.maxCols = a.totalCols;
				a.maxRows = 0;
				a.startCol = 0;
				a.startRow = 0;
				a.dataTableColumnHide = {};
				var n = a.updateDataTable(false, false, true);
				a.maxCols = o;
				a.maxRows = w;
				a.startCol = j;
				a.startRow = q;
				a.dataTableColumnHide = u;
				var p = [];
				for (var k = 1; k < n[0].length; k++) {
					p.push([n[0][k], a.dataTableColumnHide[n[0][k]] ? "unchecked" : "checked", "hideUnhideDataTableColumn", [n[0][k]]])
				}
				var h = [];
				h.push(["Sort Ascending", "sortAsciiAsc", "sortDataTableByColumn", ["asc", f.parentNode]]);
				h.push(["Sort Descending", "sortAsciiDesc", "sortDataTableByColumn", ["desc", f.parentNode]]);
				h.push(["-"]);
				h.push(["Columns", "table", false, false, false, "getColumnsDataTableHeaderMenu", []]);
				var g = a.absoluteCoordinates(f);
				var r = a.absoluteCoordinates(a.$(a.target + "-cX-DataTable"));
				var t = a.absoluteCoordinates(a.$(a.target));
				a.addMenu(l, false, false, h, (g.x - r.x) + (r.x - t.x), g.y - (t.y - 28), this);
				a.skipHeaderMouseout = this
			} else {
				if (f.className == "CanvasXpressTableCellSortDesc") {
					f.className = "CanvasXpressTableCellSortAsc"
				} else {
					f.className = "CanvasXpressTableCellSortDesc"
				}
				if (a.sortDataTableHead) {
					if (a.sortDataTableHead.id != f.id) {
						var v = a.$(a.sortDataTableHead.id);
						if (v) {
							if (f.parentNode.id == b) {
								a.sortDataTableHead.id = a.target + "-cX-DataTableCellContent.0.0"
							}
							v.className = "CanvasXpressTableCell"
						}
					}
				}
				a.removeMenus();
				a.sortDataTableHead = f;
				a.sortDataTable()
			}
			return false
		}
	}(this);
	this.mouseoverDataTableHeader = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			this.className = "CanvasXpressTableCellHeadActive";
			this.firstChild.firstChild.className = "CanvasXpressTableCellHeadActive";
			return false
		}
	}(this);
	this.mouseoutDataTableHeader = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.skipHeaderMouseout && a.skipHeaderMouseout.id == this.id) {
				return false
			} else {
				this.className = "CanvasXpressTableCellHead";
				this.firstChild.firstChild.className = "CanvasXpressTableCellHead"
			}
			return false
		}
	}(this);
	this.mouseoverDataTableCell = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			this.className = "CanvasXpressTableCellActive";
			return false
		}
	}(this);
	this.mouseoutDataTableCell = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			this.className = "CanvasXpressTableCell";
			return false
		}
	}(this);
	this.clickDataTableCell = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.removeMenus();
			return false
		}
	}(this);
	this.hideUnhideDataTableColumn = function(a) {
		if (this.dataTableColumnHide[a]) {
			delete(this.dataTableColumnHide[a])
		} else {
			this.dataTableColumnHide[a] = true
		}
		this.updateDataTable(false, false, false, true)
	};
	this.sortDataTableByColumn = function(b, a) {
		if (b == "asc") {
			a.className = "CanvasXpressTableCellSortDesc"
		} else {
			a.className = "CanvasXpressTableCellSortAsc"
		}
		this.sortDataTableHead = a;
		this.clickDataTableHeader(false, a)
	};
	this.setDataTableDimensions = function(d, k) {
		var b = 0;
		var p = 0;
		var e = 0;
		var l = false;
		var j = function() {
			for (var a = 0; a < d.w.grps.length; a++) {
				e += d.w.grps[a].length
			}
			return e
		};
		if (!d) {
			d = this.data
		}
		if (!this.dataTableColumnHide) {
			this.dataTableColumnHide = {}
		}
		var s = 0;
		if (d.x) {
			for (var h in d.x) {
				if (!this.dataTableColumnHide[h]) {
					s++
				}
			}
		}
		var m = 0;
		if (d.z) {
			for (var h in d.z) {
				if (!this.dataTableColumnHide[h]) {
					m++
				}
			}
		}
		var w = this.getDataTableDimensions();
		if (w[0] != this.maxRows || w[1] != this.maxCols) {
			this.initialMaxRows = this.maxRows;
			this.initialMaxCols = this.maxCols
		}
		if (this.graphType == "Network") {
			var q = this.getAllNetworkAttributes(d);
			b = this.dataTableTransposed ? 1 + d[this.networkShowDataTable].length : 1 + q[1];
			p = this.dataTableTransposed ? 1 + q[1] : 1 + d[this.networkShowDataTable].length
		} else {
			if (this.graphType == "Genome") {
				b = 1;
				p = 1
			} else {
				if (this.graphType == "Venn") {
					var u = this.getVennCompartments(d);
					b = this.dataTableTransposed ? 1 + u[1] : 2;
					p = this.dataTableTransposed ? 2 : 1 + u[1]
				} else {
					if (this.graphType == "Correlation") {
						b = this.correlationAxis == "samples" ? 1 + d.y.smps.length : 1 + d.y.vars.length;
						p = b
					} else {
						if (this.graphType == "Candlestick") {
							if (d.y) {
								b = this.dataTableTransposed ? 1 + (d.y.smps.length * d.y.vars.length) : 6;
								p = this.dataTableTransposed ? 6 : 1 + (d.y.smps.length * d.y.vars.length)
							} else {
								if (d.market) {
									b = this.dataTableTransposed ? 1 + (d.market.smps.length * d.market.vars.length) : 6;
									p = this.dataTableTransposed ? 6 : 1 + (d.market.smps.length * d.market.vars.length)
								}
							}
						} else {
							if (d.y && d.y.vars && d.y.smps) {
								b = this.dataTableTransposed ? 1 + m + d.y.smps.length : 1 + s + d.y.vars.length;
								p = this.dataTableTransposed ? 1 + s + d.y.vars.length : 1 + m + d.y.smps.length
							} else {
								if (d.w && d.w.vars && d.w.grps) {
									e = j();
									b = this.dataTableTransposed ? 1 + m + e : 1 + s + d.w.vars.length;
									p = this.dataTableTransposed ? 1 + s + d.w.vars.length : 1 + m + e
								}
							}
						}
					}
				}
			}
		}
		if (this.maxRows > b) {
			this.initialMaxRows = this.maxRows;
			this.maxRows = b
		}
		if (this.maxCols > p) {
			this.initialMaxCols = this.maxCols;
			this.maxCols = p
		}
		if (this.totalRows == null || this.totalCols == null) {
			this.totalRows = b;
			this.totalCols = p
		} else {
			if (k || b != this.totalRows || p != this.totalCols || w[0] != this.maxRows || w[1] != this.maxCols || w[2] != this.rowHeight || w[3] != this.colWidth) {
				this.totalRows = b;
				this.totalCols = p;
				l = true
			} else {
				this.totalRows = b;
				this.totalCols = p;
				if (this.showDataTable) {
					this.hideUnhideDataTable()
				}
			}
		}
		this.dataTableTotalHeight = 10;
		for (var h = 0; h < this.totalRows; h++) {
			this.dataTableTotalHeight += this.setDataTableRowHeight(h)
		}
		this.dataTableTotalHeight += this.totalRows * 4;
		this.dataTableTotalWidth = 10;
		for (var h = 0; h < this.totalCols; h++) {
			this.dataTableTotalWidth += this.setDataTableColumnWidth(h)
		}
		this.dataTableTotalWidth += this.totalCols * 8;
		this.dataTableRowsHeight = 10;
		for (var h = this.startRow; h < this.startRow + this.maxRows; h++) {
			this.dataTableRowsHeight += this.setDataTableRowHeight(h)
		}
		this.dataTableRowsHeight += this.maxRows * 4;
		this.dataTableColsWidth = 10;
		for (var h = this.startCol; h < this.startCol + this.maxCols; h++) {
			this.dataTableColsWidth += this.setDataTableColumnWidth(h)
		}
		this.dataTableColsWidth += this.maxCols * 8;
		if (l) {
			this.resetDataTable(true, w)
		}
	};
	this.setDataTableColumnWidth = function(b, a) {
		if (!this.dataTableColumnWidth[b]) {
			this.dataTableColumnWidth[b] = this.colWidth
		} else {
			if (a) {
				this.dataTableColumnWidth[b] = Math.max(a, this.colWidth)
			}
		}
		return this.dataTableColumnWidth[b]
	};
	this.setDataTableRowHeight = function(a, b) {
		if (!this.dataTableRowHeight[a]) {
			this.dataTableRowHeight[a] = this.rowHeight
		} else {
			if (b) {
				this.dataTableRowHeight[a] = Math.max(b, this.rowHeight)
			}
		}
		return this.dataTableRowHeight[a]
	};
	this.getAllNetworkAttributes = function(c) {
		var b = this.getNetworkData(this.networkShowDataTable, true);
		var d = this.getKeys(b).length;
		return [b, d]
	};
	this.getVennCompartments = function(c) {
		var b = {};
		var d = 0;
		if (c.venn && c.venn.data) {
			for (var a in c.venn.data) {
				b[a] = 1;
				d++
			}
		}
		return [b, d]
	};
	this.getDataTableDimensions = function() {
		var f = 0;
		var i = 0;
		var e = 0;
		var b = 0;
		var d = this.$(this.target + "-cX-DataTableTable");
		var g = this.$(this.target + "-cX-DataTableCell.0.0");
		if (d) {
			var a = d.childNodes[0].rows;
			if (a) {
				f = a.length;
				i = a[0].cells.length;
				e = g && g.firstChild && g.firstChild.style ? parseInt(g.firstChild.style.height) : 0;
				b = g && g.firstChild && g.firstChild.style ? parseInt(g.firstChild.style.width) : 0
			}
		}
		return [f, i, e, b]
	};
	this.resetDataTable = function(b, a) {
		this.addRemoveDataTableListeners("removeEvtListener", a);
		this.removeTarget(this.target + "-cX-DataTable");
		this.addDataTableDiv(false, b)
	};
	this.rebuildDataTable = function(b, a) {
		this.resetDataTable()
	};
	this.hideUnhideDataTable = function(a) {
		if (this.initialMaxRows) {
			this.maxRows = this.initialMaxRows
		}
		if (this.initialMaxCols) {
			this.maxCols = this.initialMaxCols
		}
		var b = this.$(this.target + "-cX-DataTable");
		if (b) {
			if (a == true) {
				b.style.display = "none"
			} else {
				b.style.display = "block"
			}
		}
	};
	this.resizeDataTable = function() {
		var g = this.$(this.target + "-cX-DataTableContainer");
		var d = this.$(this.target + "-cX-DataTableVer");
		var f = this.$(this.target + "-cX-DataTableHor");
		if (g && d && f) {
			var b = 0;
			this.maxCols = 0;
			for (var e = this.startCol; e < this.totalCols; e++) {
				b += this.dataTableColumnWidth[e] + 8;
				if (parseInt(g.style.width) < b) {
					this.maxCols++;
					break
				} else {
					this.maxCols++
				}
			}
			if (b < parseInt(g.style.width) && this.startCol > 0) {
				for (var e = this.startCol; e >= 0; e--) {
					if (b + this.dataTableColumnWidth[e] + 8 < parseInt(g.style.width)) {
						b += this.dataTableColumnWidth[e] + 8;
						this.maxCols++;
						this.startCol--
					} else {
						break
					}
				}
			}
			if (parseInt(g.style.width) > this.dataTableTotalWidth) {
				this.maxCols = (this.totalCols - this.startCol)
			}
			this.maxCols = Math.max(3, Math.min(this.maxCols, (this.totalCols - this.startCol)));
			var a = 0;
			this.maxRows = 0;
			for (var e = this.startRow; e < this.totalRows; e++) {
				a += this.dataTableRowHeight[e] + 4;
				if (parseInt(g.style.height) < a) {
					this.maxRows++;
					break
				} else {
					this.maxRows++
				}
			}
			if (a < parseInt(g.style.height) && this.startRow > 0) {
				for (var e = this.startRow; e >= 0; e--) {
					if (a + this.dataTableRowHeight[e] + 4 < parseInt(g.style.height)) {
						a += this.dataTableRowHeight[e] + 4;
						this.maxRows++;
						this.startRow--
					} else {
						break
					}
				}
			}
			if (parseInt(g.style.height) > this.dataTableTotalHeight) {
				this.totalRows = (this.totalRows - this.startRow)
			}
			this.maxRows = Math.max(3, Math.min(this.maxRows, (this.totalRows - this.startRow)));
			this.updateDataTable(false, true, false, true);
			d = this.$(this.target + "-cX-DataTableVer");
			f = this.$(this.target + "-cX-DataTableHor");
			if (d && f) {
				if (!this.meta.system.isIE) {
					d.scrollHeight = this.dataTableLastScrollHeight
				}
				d.scrollTop = this.dataTableLastScrollTop ? this.dataTableLastScrollTop : d.scrollTop;
				if (!this.meta.system.isIE) {
					f.scrollWidth = this.dataTableLastScrollWidth
				}
				f.scrollLeft = this.dataTableLastScrollLeft ? this.dataTableLastScrollLeft : f.scrollLeft
			}
			if (this.dataTableLastState == "docked") {
				this.resizeViewportSouth(true)
			}
		}
	};
	this.sortDataTable = function() {
		this.sortDir = this.sortDataTableHead.className == "CanvasXpressTableCellSortDesc" ? "descending" : "ascending";
		var a = this.sortDataTableHead.innerText ? this.sortDataTableHead.innerText : this.sortDataTableHead.textContent;
		if (this.graphType == "Network") {
			if (this.dataTableTransposed) {
				if (this.sortDataTableHead.type == "cxb") {
					this.sortDataTableHead.className = "CanvasXpressTableCell";
					this.sortDataTableHead = false;
					return
				} else {
					this.sortNetworkIndices(a)
				}
			} else {
				this.sortDataTableHead.className = "CanvasXpressTableCell";
				this.sortDataTableHead = false;
				return
			}
		} else {
			if (this.graphType == "Genome") {
				this.sortDataTableHead.className = "CanvasXpressTableCell";
				this.sortDataTableHead = false;
				return
			} else {
				if (this.graphType == "Venn") {
					this.sortDataTableHead.className = "CanvasXpressTableCell";
					this.sortDataTableHead = false;
					return
				} else {
					if (this.graphType == "Correlation") {
						if (this.correlationAxis == "samples") {
							if (this.sortDataTableHead.type == "cxb") {
								this.sortSamples()
							} else {
								this.sortSamples(false, false, a, "cor", true);
								this.sortDataTableHead.className = "CanvasXpressTableCell";
								this.sortDataTableHead = false
							}
						} else {
							if (this.sortDataTableHead.type == "cxb") {
								this.sortVariables()
							} else {
								this.sortVariables(false, false, a, "cor", true);
								this.sortDataTableHead.className = "CanvasXpressTableCell";
								this.sortDataTableHead = false
							}
						}
					} else {
						if (this.graphType == "Candlestick") {
							this.sortDataTableHead.className = "CanvasXpressTableCell";
							this.sortDataTableHead = false;
							return
						} else {
							if (this.data.y.vars && this.data.y.smps) {
								if (this.dataTableTransposed) {
									if (this.sortDataTableHead.type == "cxx") {
										this.sortSamplesByCategory([a])
									} else {
										if (this.sortDataTableHead.type == "cxv") {
											this.sortSamplesByVariable(a)
										} else {
											if (this.sortDataTableHead.type == "cxb") {
												this.sortSamples()
											}
										}
									}
								} else {
									if (this.sortDataTableHead.type == "cxz") {
										this.sortVariablesByCategory([a])
									} else {
										if (this.sortDataTableHead.type == "cxs") {
											this.sortVariablesBySample(a)
										} else {
											if (this.sortDataTableHead.type == "cxb") {
												this.sortVariables()
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		this.updateDataTable(false, true, false, false, true)
	};
	this.getDataClassAsArray = function(A, b, M, E, B, e) {
		var m = 0;
		var h = 0;
		var z = 0;
		var t = 0;
		var J = [];
		var K = [];
		var x = [];
		var w = [];
		var f = function(r, s, d, N) {
			if (s.hasOwnProperty(r)) {
				return s[r] != null ? s[r] : ""
			} else {
				if (d[0][r] && d[0][r].hasOwnProperty("r")) {
					var v = d[0][r]["r"];
					for (var l = 0; l < N[v].length; l++) {
						var k = N[v][l];
						if (s.hasOwnProperty(k)) {
							s = s[k]
						} else {
							return ""
						}
					}
					if (s.hasOwnProperty(r)) {
						return s[r] != null ? s[r] : ""
					}
				}
				return ""
			}
		};
		if (b == null) {
			b = 0
		}
		if (M == null) {
			M = 999
		}
		if (E == null) {
			E = 0
		}
		if (B == null) {
			B = 999
		}
		if (this.graphType == "Network") {
			var L = this.getAllNetworkAttributes(A);
			x.push("");
			w.push("cxb");
			if (this.dataTableTransposed) {
				for (var G in L[0]) {
					if (h < M && t >= b && !this.dataTableColumnHide[G]) {
						x.push(G);
						w.push("cxx");
						h++
					}
					t++
				}
				J.push(x);
				K.push(w);
				for (var G = 0; G < A[this.networkShowDataTable].length; G++) {
					if (m < B && z >= E) {
						h = 0;
						t = 0;
						x = [G + 1];
						w = ["cxz"];
						for (var F in L[0]) {
							if (h < M && t >= b && !this.dataTableColumnHide[F]) {
								var q = f(F, A[this.networkShowDataTable][G], L, this[this.networkShowDataTable + "Properties"]);
								x.push(q);
								w.push("cxy");
								h++
							}
							t++
						}
						J.push(x);
						K.push(w);
						m++
					}
					z++
				}
			} else {
				for (var G = 0; G < A[this.networkShowDataTable].length; G++) {
					if (h < M && t >= b && !this.dataTableColumnHide[G + 1]) {
						x.push(G + 1);
						w.push("cxz");
						h++
					}
					t++
				}
				J.push(x);
				K.push(w);
				for (var G in L[0]) {
					if (m < B && z >= E) {
						h = 0;
						t = 0;
						x = [G];
						w = ["cxx"];
						for (var F = 0; F < A[this.networkShowDataTable].length; F++) {
							if (h < M && t >= b && !this.dataTableColumnHide[G + 1]) {
								var q = f(G, A[this.networkShowDataTable][F], L, this[this.networkShowDataTable + "Properties"]);
								x.push(q);
								w.push("cxy");
								h++
							}
							t++
						}
						J.push(x);
						K.push(w);
						m++
					}
					z++
				}
			}
		} else {
			if (this.graphType == "Genome") {
				J = [
					["Not implemented"]
				];
				K = [
					["cxb"]
				]
			} else {
				if (this.graphType == "Venn") {
					var q = this.getVennCompartments(A);
					x.push("");
					w.push("cxb");
					if (this.dataTableTransposed) {
						x.push("No");
						w.push("cxz");
						J.push(x);
						K.push(w);
						for (var G in q[0]) {
							if (m < B && z >= E) {
								h = 0;
								t = 0;
								x = [G];
								w = ["cxx"];
								if (h < M && t >= b) {
									x.push(A.venn.data[G]);
									w.push("cxy");
									h++
								}
								t++;
								J.push(x);
								K.push(w);
								m++
							}
							z++
						}
					} else {
						for (var G in q[0]) {
							if (h < M && t >= b) {
								x.push(G);
								w.push("cxx");
								h++
							}
							t++
						}
						J.push(x);
						K.push(w);
						if (m < B && z >= E) {
							h = 0;
							t = 0;
							x = ["No"];
							w = ["cxz"];
							for (var G in q[0]) {
								if (h < M && t >= b) {
									x.push(A.venn.data[G]);
									w.push("cxy");
									h++
								}
								t++
							}
							J.push(x);
							K.push(w)
						}
					}
				} else {
					if (this.graphType == "Correlation") {
						var p = this.correlationAxis == "samples" ? A.y.smps : A.y.vars;
						var g = this.correlationAxis == "samples" ? this.smpIndices : this.varIndices;
						var n = this.correlationAxis == "samples" ? "cxs" : "cxv";
						x.push("");
						w.push("cxb");
						for (var G = 0; G < p.length; G++) {
							if (h < M && t >= b && !this.dataTableColumnHide[e ? p[g[G]] : p[G]]) {
								x.push(e ? p[g[G]] : p[G]);
								w.push(n);
								h++
							}
							t++
						}
						J.push(x);
						K.push(w);
						for (var G = 0; G < p.length; G++) {
							if (m < B && z >= E) {
								h = 0;
								t = 0;
								x = [e ? p[g[G]] : p[G]];
								w = [n];
								for (var F = 0; F < p.length; F++) {
									if (h < M && t >= b && !this.dataTableColumnHide[e ? p[g[F]] : p[F]]) {
										if (A.y.cor) {
											x.push(e ? A.y.cor[g[G]][g[F]] : A.y.cor[G][F])
										} else {
											x.push(G == F ? 1 : A.y.data)
										}
										w.push("cxy");
										h++
									}
									t++
								}
								J.push(x);
								K.push(w);
								m++
							}
							z++
						}
					} else {
						if (this.graphType == "Candlestick") {
							var L = ["open", "low", "high", "close", "volume"];
							x.push("");
							w.push("cxb");
							if (this.dataTableTransposed) {
								for (var G = 0; G < A.y.vars.length; G++) {
									for (var F = 0; F < L.length; F++) {
										var C = A.y.vars.length > 1 ? A.y.vars[G] + ":" + L[F] : L[F];
										if (h < M && t >= b && !this.dataTableColumnHide[C]) {
											x.push(C);
											w.push("cxv");
											h++
										}
										t++
									}
								}
								J.push(x);
								K.push(w);
								for (var G = 0; G < A.y.smps.length; G++) {
									if (m < B && z >= E) {
										h = 0;
										t = 0;
										x = [A.y.smps[G]];
										w = ["cxs"];
										for (var F = 0; F < A.y.vars.length; F++) {
											for (var D = 0; D < L.length; D++) {
												var C = A.y.vars.length > 1 ? A.y.vars[F] + ":" + L[D] : L[D];
												if (h < M && t >= b && !this.dataTableColumnHide[C]) {
													x.push(A.y[L[D]][F][G] != null ? A.y[L[D]][F][G] : A.y[L[D]][G]);
													w.push("cxy");
													h++
												}
												t++
											}
										}
										J.push(x);
										K.push(w);
										m++
									}
									z++
								}
							} else {
								for (var G = 0; G < A.y.smps.length; G++) {
									if (h < M && t >= b && !this.dataTableColumnHide[A.y.smps[G]]) {
										x.push(A.y.smps[G]);
										w.push("cxs");
										h++
									}
									t++
								}
								J.push(x);
								K.push(w);
								for (var G = 0; G < A.y.vars.length; G++) {
									for (var F = 0; F < L.length; F++) {
										if (m < B && z >= E) {
											h = 0;
											t = 0;
											var C = A.y.vars.length > 1 ? A.y.vars[G] + ":" + L[F] : L[F];
											x = [C];
											w = ["cxv"];
											for (var D = 0; D < A.y.smps.length; D++) {
												if (h < M && t >= b && !this.dataTableColumnHide[A.y.smps[D]]) {
													x.push(A.y[L[F]][G][D] != null ? A.y[L[F]][G][D] : A.y[L[F]][D]);
													w.push("cxy");
													h++
												}
												t++
											}
											J.push(x);
											K.push(w);
											m++
										}
										z++
									}
								}
							}
						} else {
							if (A.y.vars && A.y.smps) {
								var I = e ? this.varIndices.length : A.y.vars.length;
								var H = e ? this.smpIndices.length : A.y.smps.length;
								var y = A.x ? this.sortObject(A.x) : false;
								var u = A.z ? this.sortObject(A.z) : false;
								x.push("");
								w.push("cxb");
								if (this.dataTableTransposed) {
									if (A.x) {
										for (var G = 0; G < y.length; G++) {
											if (h < M && t >= b && !this.dataTableColumnHide[y[G]]) {
												x.push(y[G]);
												w.push("cxx");
												h++
											}
											t++
										}
									}
									for (var G = 0; G < I; G++) {
										if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.vars[this.varIndices[G]] : A.y.vars[G]]) {
											x.push(e ? A.y.vars[this.varIndices[G]] : A.y.vars[G]);
											w.push("cxv");
											h++
										}
										t++
									}
									J.push(x);
									K.push(w);
									if (A.z) {
										for (var G = 0; G < u.length; G++) {
											if (m < B && z >= E) {
												h = 0;
												t = 0;
												x = [u[G]];
												w = ["cxz"];
												if (A.x) {
													for (var F = 0; F < y.length; F++) {
														if (h < M && t >= b && !this.dataTableColumnHide[y[F]]) {
															x.push("");
															w.push("cxb");
															h++
														}
														t++
													}
												}
												for (var F = 0; F < I; F++) {
													if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.vars[this.varIndices[F]] : A.y.vars[F]]) {
														x.push(e ? A.z[u[G]][this.varIndices[F]] : A.z[u[G]][F]);
														w.push("cxz");
														h++
													}
													t++
												}
												J.push(x);
												K.push(w);
												m++
											}
											z++
										}
									}
									for (var G = 0; G < H; G++) {
										if (m < B && z >= E) {
											h = 0;
											t = 0;
											x = [e ? A.y.smps[this.smpIndices[G]] : A.y.smps[G]];
											w = ["cxs"];
											if (A.x) {
												for (var F = 0; F < y.length; F++) {
													if (h < M && t >= b && !this.dataTableColumnHide[y[F]]) {
														x.push(e ? A.x[y[F]][this.smpIndices[G]] : A.x[y[F]][G]);
														w.push("cxx");
														h++
													}
													t++
												}
											}
											for (var F = 0; F < I; F++) {
												if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.vars[this.varIndices[F]] : A.y.vars[F]]) {
													if (e) {
														x.push(A.y.data[this.varIndices[F]][this.smpIndices[G]] != null ? A.y.data[this.varIndices[F]][this.smpIndices[G]] : A.y.data[this.smpIndices[G]])
													} else {
														x.push(A.y.data[F][G] != null ? A.y.data[F][G] : A.y.data[G])
													}
													w.push("cxy");
													h++
												}
												t++
											}
											J.push(x);
											K.push(w);
											m++
										}
										z++
									}
								} else {
									if (A.z) {
										for (var G = 0; G < u.length; G++) {
											if (h < M && t >= b && !this.dataTableColumnHide[u[G]]) {
												x.push(u[G]);
												w.push("cxz");
												h++
											}
											t++
										}
									}
									for (var G = 0; G < H; G++) {
										if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.smps[this.smpIndices[G]] : A.y.smps[G]]) {
											x.push(e ? A.y.smps[this.smpIndices[G]] : A.y.smps[G]);
											w.push("cxs");
											h++
										}
										t++
									}
									J.push(x);
									K.push(w);
									if (A.x) {
										for (var G = 0; G < y.length; G++) {
											if (m < B && z >= E) {
												h = 0;
												t = 0;
												x = [y[G]];
												w = ["cxx"];
												if (A.z) {
													for (var F = 0; F < u.length; F++) {
														if (h < M && t >= b && !this.dataTableColumnHide[u[F]]) {
															x.push("");
															w.push("cxb");
															h++
														}
														t++
													}
												}
												for (var F = 0; F < H; F++) {
													if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.smps[this.smpIndices[F]] : A.y.smps[F]]) {
														x.push(e ? A.x[y[G]][this.smpIndices[F]] : A.x[y[G]][F]);
														w.push("cxx");
														h++
													}
													t++
												}
												J.push(x);
												K.push(w);
												m++
											}
											z++
										}
									}
									for (var G = 0; G < I; G++) {
										if (m < B && z >= E) {
											h = 0;
											t = 0;
											x = [e ? A.y.vars[this.varIndices[G]] : A.y.vars[G]];
											w = ["cxv"];
											if (A.z) {
												for (var F = 0; F < u.length; F++) {
													if (h < M && t >= b && !this.dataTableColumnHide[u[F]]) {
														x.push(e ? A.z[u[F]][this.varIndices[G]] : A.z[u[F]][G]);
														w.push("cxz");
														h++
													}
													t++
												}
											}
											for (var F = 0; F < H; F++) {
												if (h < M && t >= b && !this.dataTableColumnHide[e ? A.y.smps[this.smpIndices[F]] : A.y.smps[F]]) {
													if (e) {
														x.push(A.y.data[this.varIndices[G]][this.smpIndices[F]] != null ? A.y.data[this.varIndices[G]][this.smpIndices[F]] : A.y.data[this.smpIndices[F]])
													} else {
														x.push(A.y.data[G][F] != null ? A.y.data[G][F] : A.y.data[F])
													}
													w.push("cxy");
													h++
												}
												t++
											}
											J.push(x);
											K.push(w);
											m++
										}
										z++
									}
								}
							}
						}
					}
				}
			}
		}
		return [J, K]
	};
	this.updateDataTable = function(g, c, d, h, b) {
		if (this.dataTableLastState && this.dataTableLastState == "docked" && h) {
			this.dataTableLastX = 0;
			this.dataTableLastY = 0
		}
		if (!this.dataTableLastState) {
			this.dataTableLastState = "visible"
		}
		if (!g) {
			g = this.data
		} else {
			g = this.getUngroupedDataObject(g)
		}
		if (!d) {
			this.setDataTableDimensions(g, c)
		}
		var a = this.getDataClassAsArray(g, this.startCol, this.maxCols, this.startRow, this.maxRows, true);
		if (d) {
			return a[0]
		} else {
			this.loadDataTableValues(a[0], a[1], h, b)
		}
	};
	this.loadDataTableValues = function(B, C, u, p) {
		var m = this.$(this.target + "-cX-DataTable");
		if (m) {
			var l = this.startRow;
			for (var x = 0; x < B.length; x++) {
				var y = this.startCol;
				for (var v = 0; v < B[x].length + this.startCol; v++) {
					var r = this.target + "-cX-DataTableCell." + x + "." + v;
					var D = this.target + "-cX-DataTableCellContent." + l + "." + y;
					var g = this.target + "-cX-DataTableCellContentA." + l + "." + y;
					var A = this.$(r);
					if (A) {
						if (A.hasChildNodes()) {
							while (A.childNodes.length >= 1) {
								A.removeChild(A.firstChild)
							}
						}
						var F = B[x][v] != null ? B[x][v] : "";
						var b = C[x][v] != null ? C[x][v] : "";
						if (!isNaN(F) && b == "cxy") {
							F = this.bestFormatNumber(F)
						}
						var f = this.$cX("div", {
							id: D,
							className: "CanvasXpressTableCell ",
							title: F,
							alt: F,
							type: b
						});
						if (x == 0) {
							var E = this.$cX("a", {
								id: g,
								className: "CanvasXpressTableCellHead ",
								href: "#"
							});
							f.appendChild(E)
						}
						f.appendChild(document.createTextNode(F));
						if (x != 0) {
							f.style.height = this.setDataTableRowHeight(l) + "px";
							A.style.height = this.setDataTableRowHeight(l) + "px"
						} else {
							f.style.height = this.setDataTableRowHeight(0) + "px";
							A.style.height = this.setDataTableRowHeight(0) + "px"
						}
						if (v != 0) {
							f.style.width = this.setDataTableColumnWidth(y) + "px";
							A.style.width = this.setDataTableColumnWidth(y) + "px"
						} else {
							f.style.width = this.setDataTableColumnWidth(0) + "px";
							A.style.width = this.setDataTableColumnWidth(0) + "px"
						}
						A.appendChild(f);
						y++
					}
				}
				l++
			}
			if (this.sortDataTableHead) {
				var o = this.$(this.sortDataTableHead.id);
				var h = this.$(this.target + "-cX-DataTableCell.0.0").firstChild;
				var k = this.target + "-cX-DataTableCellContent.0.0";
				if (o) {
					o.className = this.sortDataTableHead.className
				}
				if (h) {
					h.className = this.sortDataTableHead.id == k ? this.sortDataTableHead.className : "CanvasXpressTableCell"
				}
			}
			this.activeTarget = m;
			m.style.display = "block"
		}
	};
	this.moveDataTableDiv = function(e) {
		var n = this.$(this.target + "-cX-DataTable");
		if (n) {
			var p, r, j;
			var a = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
			var g = this.$("north-container-" + this.target);
			var c = this.$("west-container-" + this.target);
			var m = this.$("east-container-" + this.target);
			var o = this.$("south-container-" + this.target);
			var q = this.$("south-wrapper-" + this.target);
			var b = 64;
			var f = 0;
			var i = this.showFadeResizeMoveAnimation ? 500 : 0;
			var k = this;
			if (c && m && o && q) {
				if (e && e == "dock") {
					this.dataTableLastState = "docked";
					this.dataTableLastHeight = n.clientHeight;
					this.dataTableLastX = n.offsetLeft;
					this.dataTableLastY = n.offsetTop;
					r = Math.max(n.clientWidth, parseInt(c.style.width) + parseInt(m.style.width) + this.meta.canvas.ctx.canvas.width) + 2;
					j = parseInt(g.style.height) + this.meta.canvas.ctx.canvas.height + n.clientHeight + 2;
					if (a) {
						this.resizeMove(a, 0, 0, r + f, j + b)
					}
					this.resizeMove(o, 0, 0, r, n.clientHeight + 2);
					this.resizeMove(q, 0, 0, r, n.clientHeight + 2);
					this.resizeMove(n, 0, 0, n.clientWidth, n.clientHeight)
				} else {
					if (e && e == "hide") {
						delete(this.dataTableLastState);
						delete(this.dataTableLastX);
						delete(this.dataTableLastY);
						r = parseInt(c.style.width) + parseInt(m.style.width) + this.meta.canvas.ctx.canvas.width;
						j = parseInt(g.style.height) + this.meta.canvas.ctx.canvas.height;
						if (a) {
							this.resizeMove(a, 0, 0, r + f, j + b)
						}
						this.fade(n);
						this.resizeMove(q, 0, 0, r, 0);
						this.resizeMove(o, 0, 0, r, 0)
					} else {
						if (e && (e == "max" || e == "release" || e == "undock")) {
							this.dataTableLastState = "free";
							r = parseInt(c.style.width) + parseInt(m.style.width) + this.meta.canvas.ctx.canvas.width;
							j = parseInt(g.style.height) + this.meta.canvas.ctx.canvas.height;
							if (a) {
								this.resizeMove(a, 0, 0, r + r, j + b)
							}
							if (e == "max" || e == "undock") {
								this.resizeMove(n, parseInt(this.dataTableLastX), parseInt(this.dataTableLastY), n.clientWidth, parseInt(this.dataTableLastHeight) || (this.dataTableRowsHeight + 42))
							}
							this.resizeMove(q, 0, 0, r, 0);
							this.resizeMove(o, 0, 0, r, 0)
						} else {
							this.dataTableLastX = n.offsetLeft;
							this.dataTableLastY = n.offsetTop;
							return
						}
					}
				}
			}
		}
	};
	this.updateDataTableResizerDiv = function(g, l, k) {
		if (!g) {
			g = window.event
		}
		if (g && (l == null || k == null)) {
			l = Math.abs(this.dataTableWidth) - (this.xMouseDown - g.clientX);
			k = Math.abs(this.dataTableHeight) - (this.yMouseDown - g.clientY)
		}
		if (this.dataTableTarget && this.dataTableTarget.style) {
			var i = this.$(this.target + "-cX-DataTable");
			var j = this.$(this.target + "-cX-DataTableContainer");
			var a = this.$(this.target + "-cX-DataTableTableMask");
			var n = this.$(this.target + "-cX-DataTableVer");
			var b = this.$(this.target + "-cX-DataTableHor");
			var o = this.$(this.target + "-cX-DataTableToolbar");
			var f = 20;
			var p = 44;
			if (i && j && a && n && b && o) {
				this.dataTableTarget.style.width = this.meta.system.isIE ? Math.max(0, l) + "px" : l + "px";
				j.style.width = this.meta.system.isIE ? Math.max(0, l) + "px" : l + "px";
				a.style.width = this.meta.system.isIE ? Math.max(0, (l - f)) + "px" : (l - f) + "px";
				b.style.width = this.meta.system.isIE ? Math.max(0, (l - f)) + "px" : (l - f) + "px";
				o.style.width = this.meta.system.isIE ? Math.max(0, l) + "px" : l + "px";
				this.dataTableTarget.style.height = this.meta.system.isIE ? Math.max(0, k) + "px" : k + "px";
				j.style.height = this.meta.system.isIE ? Math.max(0, (k - 20)) + "px" : (k - 20) + "px";
				a.style.height = this.meta.system.isIE ? Math.max(0, (k - p)) + "px" : (k - p) + "px";
				n.style.height = this.meta.system.isIE ? Math.max(0, (k - p)) + "px" : (k - p) + "px";
				this.dataTableLastWidth = l;
				this.dataTableLastHeight = k
			}
		}
	};
	this.endDataTableResizerDiv = function(a) {
		if (this.dataTableTarget != null) {
			this.resizeDataTable();
			this.xMouseDown = null;
			this.yMouseDown = null;
			this.dataTableWidth = null;
			this.dataTableHeight = null;
			this.dataTableTarget = false;
			this.resizingDataTableOn = false
		}
	};
	this.endDataTableColumnResize = function(a) {
		that = this;
		this.xMouseDown = null;
		this.yMouseDown = null;
		this.resizingDataTableColumnOn = false;
		this.dataTableColumnTarget = false;
		document.body.style.cursor = "default";
		this.noSorting = true;
		setTimeout(function() {
			that.noSorting = false
		}, 200)
	};
	this.initializeDataTableEvents = function() {
		this.addDataTableDiv()
	};
	this.initializeDataTableEvents()
};
CanvasXpress.prototype.initCanvasResizerEvents = function() {
	this.addCanvasResizerDiv = function(a) {
		if (a) {
			if (document.getElementById("canvasXpressCanvasResize")) {
				return
			}
		} else {
			if (document.getElementById(this.target + "canvasXpressCanvasResize")) {
				return
			}
		}
		var b = document.createElement("div");
		b.id = a ? "canvasXpressCanvasResize" : this.target + "canvasXpressCanvasResize";
		b.className = "CanvasXpressCanvasResizer";
		b.style.left = "0px";
		b.style.top = "0px";
		b.style.width = "0.5px";
		b.style.height = "0.5px";
		if (a) {
			b.style.opacity = 0.5;
			b.style.filter = "alpha(opacity = 50)";
			b.style.backgroundColor = this.resizerBackgroundColor
		}
		b.style.position = "absolute";
		b.style.display = "none";
		b.style.zIndex = 100001;
		if (a) {
			document.body.appendChild(b);
			return b
		} else {
			this.meta.canvas.ctx.canvas.parentNode.appendChild(b)
		}
	};
	this.isCanvasResize = function(c) {
		if (this.resizable) {
			if (!c) {
				c = window.event
			}
			var b = this.adjustedCoordinates(c);
			if (b) {
				var a = b.x;
				var d = b.y;
				if (a > this.width - 18 && d > this.height - 18) {
					this.resizeCanvasCursorShow = "se-resize";
					return true
				} else {
					if (a > this.width - 18 && d > 20) {
						this.resizeCanvasCursorShow = "e-resize";
						return true
					} else {
						if (d > this.height - 18) {
							this.resizeCanvasCursorShow = "s-resize";
							return true
						} else {
							this.resizeCanvasCursorShow = false;
							return false
						}
					}
				}
			}
		}
	};
	this.updateCanvasResizerCursor = function(d) {
		if (this.resizable) {
			if (!d) {
				d = window.event
			}
			var b = document.getElementById(this.target);
			if (b) {
				var c = this.adjustedCoordinates(d);
				if (c) {
					var a = c.x;
					var f = c.y;
					if (a > this.width - 18 && f > this.height - 18) {
						b.style.cursor = "se-resize";
						this.resizeCanvasCursorShow = "se-resize"
					} else {
						if (a > this.width - 18 && f > 20) {
							b.style.cursor = "e-resize";
							this.resizeCanvasCursorShow = "e-resize"
						} else {
							if (f > this.height - 18) {
								b.style.cursor = "s-resize";
								this.resizeCanvasCursorShow = "s-resize"
							} else {
								if (!this.movingOn) {
									b.style.cursor = "default";
									this.resizeCanvasCursorShow = false
								}
							}
						}
					}
				}
			}
		}
	};
	this.updateCanvasResizer = function(f) {
		if (this.resizingCanvasOn && this.resizeCanvasCursorShow) {
			document.body.style.cursor = this.resizeCanvasCursorShow;
			var c = document.getElementById(this.target + "canvasXpressCanvasResize");
			var a = document.getElementById("canvasXpressCanvasResize");
			var b = this.adjustedCoordinates(f);
			var d = this.relativeCoordinates(this.meta.canvas.ctx.canvas);
			if (c && b && d) {
				if (this.resizeCanvasCursorShow == "se-resize") {
					w = b.x;
					h = b.y
				} else {
					if (this.resizeCanvasCursorShow == "e-resize") {
						w = b.x;
						h = this.height
					} else {
						if (this.resizeCanvasCursorShow == "s-resize") {
							w = this.width;
							h = b.y
						}
					}
				}
				if (!a) {
					a = this.addCanvasResizerDiv(true)
				}
				this.preventSelection();
				dx = b.x - this.meta.canvas.ctx.canvas.width;
				dy = b.y - this.meta.canvas.ctx.canvas.height;
				c.style.width = w + "px";
				c.style.height = h + "px";
				c.style.display = "block";
				a.style.left = d.x + "px";
				a.style.top = d.y + "px";
				a.style.width = w + "px";
				a.style.height = h + "px";
				a.style.display = "block";
				CanvasXpress.resizing = true
			}
		}
	};
	this.showMask = function() {
		var a = document.getElementById(this.target + "canvasXpressCanvasResize");
		if (a) {
			a.className = "CanvasXpressCanvasResizer" + this.loadingImage;
			a.style.width = this.meta.canvas.ctx.canvas.width + "px";
			a.style.height = this.meta.canvas.ctx.canvas.height + "px";
			a.style.display = "block"
		}
	};
	this.hideMask = function() {
		var b = this.hexToString("686578546f537472696e67");
		var a = this;
		var c = document.getElementById(this.target + "canvasXpressCanvasResize");
		if (c) {
			c.style.width = "0.5px";
			c.style.height = "0.5px";
			c.style.display = "none"
		}
		setTimeout(function() {
			var d = a.beaconImage.width;
			if (d == 256) {
				a[a[b]("76616c696463")] = 2
			} else {
				if (d == 250) {
					a[a[b]("76616c696463")] = 1
				} else {
					a[a[b]("76616c696463")] = 0
				}
			}
			a.drawCx()
		}, 1000)
	};
	this.endCanvasResizer = function(g) {
		this.functionCaller = "endCanvasResizer";
		if (this.resizingCanvasOn) {
			var d = document.getElementById(this.target);
			var a = document.getElementById(this.target + "canvasXpressCanvasResize");
			var n = document.getElementById("canvasXpressCanvasResize");
			var k = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowBuffer");
			var c = this.$("west-container-" + this.target);
			var m = this.$("middle-container-" + this.target);
			var f = this.$("east-container-" + this.target);
			if (d && a && n) {
				this.clickLayoutNoAnimation();
				var l = parseInt(a.style.width);
				var j = parseInt(a.style.height);
				m.style.width = (parseInt(c.style.width) + parseInt(a.style.width) + parseInt(f.style.width)) + "px";
				m.style.height = a.style.height;
				this.resetAxesResizer();
				this.draw(l, j);
				this.resizeAcknowledgmentDiv();
				a.style.width = "0.5px";
				a.style.height = "0.5px";
				a.style.display = "none";
				d.style.cursor = "default";
				this.updateRemoteNavigationWindow();
				document.body.removeChild(n);
				this.resizeCanvasCursorShow = false;
				this.resizingCanvasOn = false;
				CanvasXpress.resizing = false
			}
		}
	};
	this.initializeCanvasResizerEvents = function() {
		if (!this.disableEvents) {
			this.addCanvasResizerDiv();
			this.showMask()
		}
	};
	this.initializeCanvasResizerEvents()
};
CanvasXpress.prototype.initAxisResizerEvents = function() {
	this.addAxesResizeDiv = function() {
		if (document.getElementById(this.target + "canvasXpressAxesResize")) {
			return
		}
		var c = ["Previous", "Next", "Current", "Middle", "Min", "Max", "Close"];
		var b = 9001;
		var e = document.createElement("div");
		e.id = this.target + "canvasXpressAxesResize";
		if (this.resizerTransparency) {
			e.style.opacity = 0.85;
			e.style.filter = "alpha(opacity = 85)"
		}
		e.style.position = "absolute";
		e.style.display = "none";
		e.style.zIndex = b;
		for (var a = 0; a < c.length; a++) {
			b++;
			var f = document.createElement("div");
			f.id = this.target + "canvasXpressAxesResize" + c[a];
			if (this.resizerTransparency) {
				f.style.opacity = 0.85;
				f.style.filter = "alpha(opacity = 85)"
			}
			f.style.position = "absolute";
			f.style.zIndex = b;
			e.appendChild(f)
		}
		this.meta.canvas.ctx.canvas.parentNode.appendChild(e)
	};
	this.clickAxesResizeClose = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.stopEvent(b);
			a.resetAxesResizer(b);
			a.resetFlags(b)
		}
	}(this);
	this.mousemoveActiveAxesResize = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.activateDeactivateAxesResizer(b)
		}
	}(this);
	this.mousedownAxesResize = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.cancelEvent(b);
			a.registerAxesResizer(b);
			return false
		}
	}(this);
	this.mousemoveAxesResize = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			a.cancelEvent(b);
			a.updateAxesResizer(b);
			return false
		}
	}(this);
	this.addRemoveAxesResizerListeners = function(p) {
		var a = document.getElementById(this.target + "canvasXpressAxesResize");
		var d = document.getElementById(this.target + "canvasXpressAxesResizeMin");
		var k = document.getElementById(this.target + "canvasXpressAxesResizeMax");
		var e = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
		var i = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
		var g = document.getElementById(this.target + "canvasXpressAxesResizeClose");
		var b = [a, d, k, e, i];
		if (a) {
			this[p](a, "mousemove", this.mousemoveActiveAxesResize, false);
			this[p](a, "mouseout", this.mousemoveActiveAxesResize, false)
		}
		if (g) {
			this[p](g, "click", this.clickAxesResizeClose, false)
		}
		for (var f = 0; f < b.length; f++) {
			if (b[f]) {
				this[p](b[f], "mousedown", this.mousedownAxesResize, false)
			}
		}
	};
	this.showAxesResizer = function(f, e, c, q, o, m, b, g, t, u, n, j, i) {
		if (!this.axesResizerShow) {
			var a = document.getElementById(this.target + "canvasXpressAxesResize");
			var k = document.getElementById(this.target + "canvasXpressAxesResizeClose");
			if (a && k) {
				this.updateResizerEventData(null, null, f, e, c, q, o, m, b, g, t, u, n, j, i);
				this.refreshAxesResizer();
				a.style.display = "block";
				if (this.resizerType && this.layoutValid) {
					k.style.display = "none"
				}
				this.addRemoveAxesResizerListeners("addEvtListener");
				if (this.layoutValid) {
					this.layoutValidR = j;
					this.layoutValidC = i;
					this.layoutValidN = n
				}
				this.axesResizerShow = true
			}
		}
	};
	this.refreshAxesResizer = function() {
		if (this.resizerEventData) {
			var b = document.getElementById(this.target + "canvasXpressAxesResize");
			var e = document.getElementById(this.target + "canvasXpressAxesResizeMin");
			var o = document.getElementById(this.target + "canvasXpressAxesResizeMax");
			var f = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
			var i = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
			var g = document.getElementById(this.target + "canvasXpressAxesResizeClose");
			var k = document.getElementById(this.target + "canvasXpressAxesResizePrevious");
			var j = document.getElementById(this.target + "canvasXpressAxesResizeNext");
			if (b && e && o && i && g && k && j) {
				var s = this.resizerEventData.areas.org[1] - this.resizerEventData.areas.org[0];
				var p = this.resizerEventData.areas.org[3] - this.resizerEventData.areas.org[2];
				var d = 14;
				var a = 9;
				var q = parseInt(a / 2);
				if (this.resizerEventData.pos == "h") {
					l = this.resizerEventData.l.match(/^t/) ? "Top" : "Bottom";
					b.key = "CanvasXpressCanvasResizerScrollerEmptyHor" + l;
					b.className = b.key;
					b.style.left = (this.resizerEventData.areas.org[0] - q) + "px";
					b.style.top = this.resizerEventData.areas.org[2] + "px";
					b.style.width = ((s + a) - 1) + "px";
					b.style.height = d + "px";
					b.style.backgroundRepeat = "repeat-x";
					k.key = "CanvasXpressCanvasResizerPrev" + l;
					k.className = k.key;
					k.style.left = "0px";
					k.style.top = "0px";
					k.style.width = a + "px";
					k.style.height = d + "px";
					e.key = "CanvasXpressCanvasResizerHandleLeft" + l;
					e.className = e.key;
					e.style.left = this.resizerEventData.areas.min[0] + "px";
					e.style.top = "0px";
					e.style.width = a + "px";
					e.style.height = d + "px";
					e.style.cursor = "e-resize";
					i.key = "CanvasXpressCanvasResizerScrollerBodyHor" + l;
					i.className = i.key;
					i.style.left = this.resizerEventData.areas.cur[0] + "px";
					i.style.top = "0px";
					i.style.width = this.resizerEventData.areas.cur[1] + "px";
					i.style.height = d + "px";
					i.style.cursor = "move";
					i.style.backgroundRepeat = "repeat-x";
					o.key = "CanvasXpressCanvasResizerHandleRight" + l;
					o.className = o.key;
					o.style.left = this.resizerEventData.areas.max[0] + "px";
					o.style.top = "0px";
					o.style.width = a + "px";
					o.style.height = d + "px";
					o.style.cursor = "e-resize";
					o.style.backgroundRepeat = "no-repeat";
					f.key = "CanvasXpressCanvasResizerScrollerHandleHor" + l;
					f.className = f.key;
					f.style.left = (this.resizerEventData.areas.min[0] + ((this.resizerEventData.areas.cur[1] - 1) / 2)) + "px";
					f.style.top = "0px";
					f.style.width = "8px";
					f.style.height = d + "px";
					f.style.cursor = "move";
					j.key = "CanvasXpressCanvasResizerNext" + l;
					j.className = j.key;
					j.style.left = (s - 1) + "px";
					j.style.top = "0px";
					j.style.width = a + "px";
					j.style.height = d + "px";
					g.key = "CanvasXpressCanvasResizerClose";
					g.className = g.key;
					g.style.left = (s + a) + "px";
					g.style.top = "0px";
					g.style.width = a + "px";
					g.style.height = d + "px"
				} else {
					l = this.resizerEventData.l.match(/^l/) ? "Left" : "Right";
					b.key = "CanvasXpressCanvasResizerScrollerEmptyVer" + l;
					b.className = b.key;
					b.style.left = this.resizerEventData.areas.org[0] + "px";
					b.style.top = (this.resizerEventData.areas.org[2] - q) + "px";
					b.style.width = d + "px";
					b.style.height = (p + a) + "px";
					b.style.backgroundRepeat = "repeat-y";
					k.key = "CanvasXpressCanvasResizerPrev" + l;
					k.className = k.key;
					k.style.left = "0px";
					k.style.top = p + "px";
					k.style.width = d + "px";
					k.style.height = a + "px";
					e.key = "CanvasXpressCanvasResizerHandleBottom" + l;
					e.className = e.key;
					e.style.left = "0px";
					e.style.top = this.resizerEventData.areas.min[2] + "px";
					e.style.width = d + "px";
					e.style.height = a + "px";
					e.style.cursor = "n-resize";
					e.style.backgroundRepeat = "no-repeat";
					i.key = "CanvasXpressCanvasResizerScrollerBodyVer" + l;
					i.className = i.key;
					i.style.left = "0px";
					i.style.top = this.resizerEventData.areas.cur[2] + "px";
					i.style.width = d + "px";
					i.style.height = this.resizerEventData.areas.cur[3] + "px";
					i.style.cursor = "move";
					i.style.backgroundRepeat = "repeat-y";
					o.key = "CanvasXpressCanvasResizerHandleTop" + l;
					o.className = o.key;
					o.style.left = "0px";
					o.style.top = this.resizerEventData.areas.max[2] + "px";
					o.style.width = d + "px";
					o.style.height = a + "px";
					o.style.cursor = "n-resize";
					o.style.backgroundRepeat = "no-repeat";
					f.key = "CanvasXpressCanvasResizerScrollerHandleVer" + l;
					f.className = f.key;
					f.style.left = "0px";
					f.style.top = (this.resizerEventData.areas.max[2] + (this.resizerEventData.areas.cur[3] / 2)) + "px";
					f.style.width = d + "px";
					f.style.height = d + "px";
					f.style.cursor = "move";
					f.style.backgroundRepeat = "no-repeat";
					j.key = "CanvasXpressCanvasResizerNext" + l;
					j.className = j.key;
					j.style.left = "0px";
					j.style.top = "0px";
					j.style.width = d + "px";
					j.style.height = a + "px";
					g.key = "CanvasXpressCanvasResizerClose";
					g.className = g.key;
					g.style.left = (d + 1) + "px";
					g.style.top = -a + "px";
					g.style.width = a + "px";
					g.style.height = d + "px"
				}
				this.drawAxesResizerMasks()
			}
		}
	};
	this.updateResizerEventData = function(h, F, z, o, n, a, V, S, I, M, G, H, x, r, q) {
		var i, E, D, k, j, y, w, f, c, O, N, C, B, m, U;
		z = z ? z : this.resizerEventData.axis;
		o = o ? o : this.resizerEventData.areas.org[0];
		n = n ? n : this.resizerEventData.areas.org[1];
		a = a ? a : this.resizerEventData.areas.org[2];
		V = V ? V : this.resizerEventData.areas.org[3];
		S = S ? S : this.resizerEventData.dim;
		I = I ? I : this.resizerEventData.pos;
		M = M ? M : this.resizerEventData.l;
		G = G ? G : this.resizerEventData.vals;
		H = H ? H : this.resizerEventData.set ? this.resizerEventData.set : "";
		x = x ? x : this.resizerEventData.c;
		r = r ? r : this.resizerEventData.i;
		q = q ? q : this.resizerEventData.j;
		var Q = G.graphType;
		var e = n - o;
		var b = V - a;
		if (Q == "Heatmap") {
			if (S == "y") {
				i = this.isGroupedData ? this.data.w.smps.length : this.data.y ? this.data.y.smps.length : 0
			} else {
				i = this.data.y ? this.data.y.vars.length : 0
			}
		} else {
			i = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y ? this.data.y.smps.length - 1 : 0
		}
		var T = this.resizerType == "samples" || Q == "Heatmap" ? 0 : G[z + "AbsMin"];
		var A = this.resizerType == "samples" || Q == "Heatmap" ? i : G[z + "AbsMax"];
		var t = I == "h" ? e : b;
		var P = t / (A - T);
		if (h == null || isNaN(h)) {
			if (this.resizerType == "samples") {
				h = this.isGroupedData ? this.grpIndices[0] : this.smpIndices[0]
			} else {
				if (Q == "Heatmap") {} else {
					h = Q.match(/Scatter/) ? G["setMin" + S.toUpperCase()] : (Q == "BarLine" || Q == "DotLine") && M.match(/b|r/) ? G.setMin2 : G.setMin
				}
				if (h == null || isNaN(h)) {
					h = T
				}
			}
		}
		h = Math.max(h, T);
		if (F == null || isNaN(F)) {
			if (this.resizerType == "samples") {
				F = this.isGroupedData ? this.grpIndices[this.grpIndices.length - 1] : this.smpIndices[this.smpIndices.length - 1]
			} else {
				if (Q == "Heatmap") {
					F = S == "x" ? G.varIndices.length : this.isGroupedData ? G.grpIndices.length : G.smpIndices.length;
					F += h
				} else {
					F = Q.match(/Scatter/) ? G["setMax" + S.toUpperCase()] : (Q == "BarLine" || Q == "DotLine") && M.match(/b|r/) ? G.setMax2 : G.setMax
				}
				if (F == null || isNaN(F)) {
					F = A
				}
			}
		}
		F = Math.min(F, A);
		var u = (h - T) * P;
		var R = (F - T) * P;
		var L = 14;
		var K = 9;
		var J = parseInt(K / 2);
		if (I == "h") {
			E = parseInt(u);
			D = K;
			k = 0;
			j = L;
			O = parseInt(u + J + 1);
			N = parseInt(R - (u + 1));
			C = 0;
			B = L;
			y = parseInt(R - 1);
			w = K;
			f = 0;
			c = L;
			m = n + (K - 1);
			U = V
		} else {
			E = 0;
			D = L;
			k = this.resizerType == "samples" || Q == "Heatmap" ? parseInt(R) : parseInt(b - (u + 1));
			j = K;
			O = 0;
			N = L;
			C = this.resizerType == "samples" || Q == "Heatmap" ? parseInt(u + J) : parseInt((b - R) + J);
			B = parseInt(R - u);
			y = 0;
			w = L;
			f = this.resizerType == "samples" || Q == "Heatmap" ? parseInt(u + 1) : parseInt(b - R);
			c = K;
			m = n;
			U = V + (K - 1)
		}
		this.resizerEventData = {
			g: Q,
			axis: z,
			dim: S,
			pos: I,
			l: M,
			vals: G,
			min: T,
			max: A,
			smin: h,
			smax: F,
			len: t,
			unit: P,
			width: L,
			set: H,
			c: x,
			i: r,
			j: q,
			areas: {
				org: [o, n, a, V],
				lim: [o, m, a, U],
				min: [E, D, k, j],
				max: [y, w, f, c],
				cur: [O, N, C, B]
			}
		}
	};
	this.updateAxesResizer = function(u) {
		if (this.axesResizingOn) {
			if (!u) {
				u = window.event
			}
			var p = this.resizerEventData.areas;
			var w = this.adjustedCoordinates(u);
			if (w) {
				var m, z, b, c, a;
				var f = this.xMouseDown - w.x;
				var d = this.yMouseDown - w.y;
				var i, h;
				var r = null;
				var t = null;
				var v = "";
				var D = 14;
				var C = 9 - 1;
				var A = parseInt(C / 2);
				if (this.resizerEventData.g == "Heatmap") {
					if (this.resizerEventData.dim == "y") {
						m = this.isGroupedData ? this.data.w.smps.length : this.data.y ? this.data.y.smps.length : 0;
						b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.isGroupedData ? this.data.w.smps.length : this.data.y.smps.length
					} else {
						m = this.data.y ? this.data.y.vars.length : 0;
						b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.data.y.vars.length
					}
					z = this.resizerEventData.lastMin != null ? this.resizerEventData.lastMin : this.resizerEventData.smin != null ? this.resizerEventData.smin : 0;
					a = this.resizerEventData.pos == "h" ? (p.org[1] - p.org[0]) / m : (p.org[3] - p.org[2]) / m
				} else {
					m = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y ? this.data.y.smps.length - 1 : 0;
					z = this.resizerEventData.lastMin != null ? this.resizerEventData.lastMin : this.resizerEventData.smin != null ? this.resizerEventData.smin : 0;
					b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y.smps.length - 1;
					a = this.resizerEventData.pos == "h" ? (p.org[1] - p.org[0]) / m : (p.org[3] - p.org[2]) / m
				}
				if (this.resizerEventData.active == "min") {
					i = f > p.min[0] ? this.xMouseDown - p.min[0] : f < (p.min[0] + p.min[1]) - p.max[0] ? this.xMouseDown - ((p.min[0] + p.min[1]) - p.max[0]) : w.x;
					h = d > p.min[2] - (p.max[2] + p.max[3]) ? this.yMouseDown - (p.min[2] - (p.max[2] + p.max[3])) : d < (p.lim[2] + p.min[2] + p.min[3]) - p.lim[3] ? (p.lim[3] - (p.lim[2] + p.min[2] + p.min[3])) + this.yMouseDown : w.y
				} else {
					if (this.resizerEventData.active == "max") {
						i = f > p.max[0] - (p.min[0] + p.min[1]) ? this.xMouseDown - (p.max[0] - (p.min[0] + p.min[1])) : f < (p.lim[0] + p.max[0] + p.max[1]) - p.lim[1] ? (p.lim[1] - (p.lim[0] + p.max[0] + p.max[1])) + this.xMouseDown : w.x;
						h = d > p.max[2] ? this.yMouseDown - p.max[2] : d < (p.lim[2] + p.max[2] + p.max[3]) - (p.lim[2] + p.min[2]) ? ((p.lim[2] + p.min[2]) - (p.lim[2] + p.max[2] + p.max[3])) + this.yMouseDown : w.y
					} else {
						if (this.resizerEventData.active == "cur") {
							i = f > p.min[0] ? this.xMouseDown - p.min[0] : f < (p.lim[0] + p.max[0] + p.max[1]) - p.lim[1] ? (p.lim[1] - (p.lim[0] + p.max[0] + p.max[1])) + this.xMouseDown : w.x;
							h = d > p.max[2] ? this.yMouseDown - p.max[2] : d < (p.lim[2] + p.min[2] + p.min[3]) - p.lim[3] ? (p.lim[3] - (p.lim[2] + p.min[2] + p.min[3])) + this.yMouseDown : w.y
						} else {
							return
						}
					}
				}
				var k = i - this.xMouseDown;
				var j = h - this.yMouseDown;
				if (this.resizerType == "samples" || this.resizerEventData.g == "Heatmap") {
					k -= k % a;
					j -= j % a
				}
				var q = k / this.resizerEventData.unit;
				var o = j / this.resizerEventData.unit;
				var s = document.getElementById(this.target + "canvasXpressAxesResizeMin");
				var n = document.getElementById(this.target + "canvasXpressAxesResizeMax");
				var B = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
				var g = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
				if (s && n && B && g) {
					if (this.resizerEventData.active == "min") {
						if (this.resizerEventData.pos == "h") {
							s.style.left = (p.min[0] + k) + "px";
							B.style.left = ((p.min[0] + k) + ((p.cur[1] - k) / 2)) + "px";
							g.style.left = (p.min[0] + k + A + 1) + "px";
							g.style.width = (p.cur[1] - k) + "px";
							z = parseInt((p.min[0] + C + k) / a);
							if (this.resizerType == "samples") {
								r = dateFormat(this.data.y.smps[z], this.timeFormat)
							} else {
								if (this.resizerEventData.g == "Heatmap") {
									r = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[z]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[z]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[z]]
								} else {
									r = this.formatNumber(this.resizerEventData.smin + q)
								}
							}
						} else {
							s.style.top = (p.min[2] + j) + "px";
							B.style.top = ((p.min[2] + j) - ((p.cur[3] + j) / 2)) + "px";
							g.style.height = ((p.cur[3] + j)) + "px";
							b = parseInt((p.min[2] + C + j) / a);
							if (this.resizerType == "samples") {
								r = dateFormat(this.data.y.smps[b], this.timeFormat)
							} else {
								if (this.resizerEventData.g == "Heatmap") {
									r = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
								} else {
									r = this.formatNumber(this.resizerEventData.smin - o)
								}
							}
						}
						this.showInfoSpan(u, r)
					} else {
						if (this.resizerEventData.active == "max") {
							if (this.resizerEventData.pos == "h") {
								n.style.left = (p.max[0] + k) + "px";
								B.style.left = ((p.min[0] + k) + ((p.cur[1] - k) / 2)) + "px";
								g.style.width = (p.cur[1] + k) + "px";
								b = parseInt((p.max[0] + C + k) / a);
								if (this.resizerType == "samples") {
									t = dateFormat(this.data.y.smps[b], this.timeFormat)
								} else {
									if (this.resizerEventData.g == "Heatmap") {
										t = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
									} else {
										t = this.formatNumber(this.resizerEventData.smax + q)
									}
								}
							} else {
								n.style.top = (p.max[2] + j) + "px";
								B.style.top = ((p.max[2] + j) + ((p.cur[3] - j) / 2)) + "px";
								g.style.top = (p.max[2] + j + A) + "px";
								g.style.height = (p.cur[3] - j) + "px";
								z = parseInt((p.max[2] + C + j) / a);
								if (this.resizerType == "samples") {
									t = dateFormat(this.data.y.smps[z], this.timeFormat)
								} else {
									if (this.resizerEventData.g == "Heatmap") {
										t = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[z]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[z]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[z]]
									} else {
										t = this.formatNumber(this.resizerEventData.smax - o)
									}
								}
							}
							this.showInfoSpan(u, t)
						} else {
							if (this.resizerEventData.active == "cur") {
								if (this.resizerEventData.pos == "h") {
									s.style.left = (p.min[0] + k) + "px";
									B.style.left = ((p.min[0] + k) + (p.cur[1] / 2)) + "px";
									n.style.left = (p.max[0] + k) + "px";
									g.style.left = (p.min[0] + k + A + 1) + "px";
									z = parseInt((p.min[0] + C + k) / a);
									b = parseInt((p.max[0] + C + k) / a);
									if (this.resizerType == "samples") {
										r = dateFormat(this.data.y.smps[z], this.timeFormat);
										t = dateFormat(this.data.y.smps[b], this.timeFormat)
									} else {
										if (this.resizerEventData.g == "Heatmap") {
											r = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[z]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[z]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[z]];
											t = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
										} else {
											r = this.formatNumber(this.resizerEventData.smin + q);
											t = this.formatNumber(this.resizerEventData.smax + q)
										}
									}
									this.showInfoSpan(u, r + "--" + t)
								} else {
									s.style.top = (p.min[2] + j) + "px";
									B.style.top = ((p.max[2] + j) + (p.cur[3] / 2)) + "px";
									n.style.top = (p.max[2] + j) + "px";
									g.style.top = (p.max[2] + j + A) + "px";
									b = parseInt((p.min[2] + C + j) / a);
									z = parseInt((p.max[2] + C + j) / a);
									if (this.resizerType == "samples") {
										r = dateFormat(this.data.y.smps[b], this.timeFormat);
										t = dateFormat(this.data.y.smps[z], this.timeFormat);
										this.showInfoSpan(u, t + "--" + r)
									} else {
										if (this.resizerEventData.g == "Heatmap") {
											r = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]];
											t = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[z]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[z]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[z]];
											this.showInfoSpan(u, t + "--" + r)
										} else {
											r = this.formatNumber(this.resizerEventData.smin - o);
											t = this.formatNumber(this.resizerEventData.smax - o);
											this.showInfoSpan(u, r + "--" + t)
										}
									}
								}
							}
						}
					}
					this.resizerEventData.lastMin = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? z : r;
					this.resizerEventData.lastMax = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? b : t;
					if (this.resizerDraw) {
						this.drawAxesResizerUpdate()
					}
				}
			}
		}
	};
	this.drawAxesResizerUpdate = function(d) {
		this.functionCaller = "drawAxesResizerUpdate";
		var b = this.resizerEventData.lastMin != null ? parseFloat(this.resizerEventData.lastMin) : parseFloat(this.resizerEventData.smin);
		var g = this.resizerEventData.lastMax != null ? parseFloat(this.resizerEventData.lastMax) : parseFloat(this.resizerEventData.smax);
		var j = this.resizerEventData.c || 0;
		if (this.resizerType == "samples") {
			var a = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y.smps.length - 1;
			var h = [];
			var f = [];
			for (var e = 0; e < b; e++) {
				f.push(true)
			}
			for (var e = b; e <= g; e++) {
				h.push(e);
				f.push(false)
			}
			for (var e = g + 1; e < a; e++) {
				f.push(true)
			}
			if (this.isGroupedData) {
				this.grpIndices = h;
				this.hiddenGrps = f
			} else {
				this.smpIndices = h;
				this.hiddenSmps = f
			}
		} else {
			if (this.resizerEventData.g == "Heatmap") {} else {
				if (this.resizerEventData.lastMin) {
					this["setMin" + this.resizerEventData.set] = b
				}
				if (this.resizerEventData.lastMax) {
					this["setMax" + this.resizerEventData.set] = g
				}
			}
		}
		if (d) {
			this.updateResizerEventData(b, g)
		}
		this.draw()
	};
	this.drawAxesResizerBackgroundData = function(d, o, b, n) {
		if (this.resizerType && this.resizerDataIndex > -1) {
			this.setAllSamplesVisible();
			var a, j, c, m;
			var k = this.graphType == "Candlestick" ? "close" : false;
			var g = [];
			var e = [];
			var p = [];
			for (var f = 0; f < this.smpIndices.length; f++) {
				g.push(this.getDataAtPos(this.resizerDataIndex, f, k))
			}
			var h = this.range(g);
			if (this.resizerPosition.match(/top|bottom/)) {
				a = b / (this.smpIndices.length - 1);
				j = n / ((h[1] - h[0]) * 1.2);
				c = (h[1] - h[0]) * 0.1 * j;
				m = o + n;
				e.push(d);
				p.push(m);
				for (var f = 0; f < g.length; f++) {
					e.push(d);
					p.push(m - (((g[f] - h[0]) * j) + c));
					d += a
				}
				d -= a;
				e.push(d);
				p.push(m)
			} else {
				a = n / (this.smpIndices.length - 1);
				j = b / ((h[1] - h[0]) * 1.2);
				c = (h[1] - h[0]) * 0.1 * j;
				e.push(d);
				p.push(o);
				for (var f = 0; f < g.length; f++) {
					e.push(d + ((g[f] - h[0]) * j) + c);
					p.push(o);
					o += a
				}
				o -= a;
				e.push(d);
				p.push(o)
			}
			this.drawShape("polygon", e, p, false, false, this.resizerBackgroundColorCurrent, this.resizerBackgroundColorOutlineCurrent, "closed")
		}
	};
	this.drawAxesResizerMasks = function() {
		if (this.resizerType) {
			var e, h, d, f;
			var c = this.resizerEventData.areas;
			var b = this.isGroupedData ? this.data.w.grps.length - 1 : this.data.y.smps.length - 1;
			var a = this.resizerEventData.pos == "h" ? (c.org[1] - c.org[0]) / b : (c.org[3] - c.org[2]) / b;
			var g = 9 - 1;
			if (this.resizerEventData.pos == "h") {
				if (this.resizerEventData.smin > 0) {
					e = c.org[0] - 1;
					h = c.org[2] - this.resizerWidth;
					d = a * this.resizerEventData.smin;
					f = this.resizerWidth;
					this.rectangle(e, h, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
					this.drawLine("line", e, h, e + d + 1, h, this.foreground);
					this.drawLine("line", e + d, h, e + d, h + f, this.foreground)
				}
				if (this.resizerEventData.smax < b) {
					e = c.org[0] + c.max[0] + 1;
					h = c.org[2] - this.resizerWidth;
					d = (a * (b - this.resizerEventData.smax)) + 1;
					f = this.resizerWidth;
					this.rectangle(e, h, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
					this.drawLine("line", e - 1, h, e + d + 2, h, this.foreground);
					this.drawLine("line", e - 1, h, e - 1, h + f, this.foreground)
				}
				e = c.org[0] + c.max[0];
				h = c.org[2] - 1;
				d = c.org[0] + a * this.resizerEventData.smin;
				this.drawLine("line", e, h, d, h, this.foreground)
			} else {
				if (this.resizerEventData.smin > 0) {
					e = c.org[0] + 14;
					h = c.org[2];
					d = this.resizerWidth;
					f = a * this.resizerEventData.smin;
					this.rectangle(e, h, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
					this.drawLine("line", e, h + f, e + d, h + f, this.foreground);
					this.drawLine("line", e + d, h, e + d, h + f, this.foreground)
				}
				if (this.resizerEventData.smax < b) {
					e = c.org[0] + 14;
					h = c.org[2] + c.min[2];
					d = this.resizerWidth;
					f = (b - this.resizerEventData.smax) * a;
					this.rectangle(e, h, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
					this.drawLine("line", e, h, e + d, h, this.foreground);
					this.drawLine("line", e + d, h, e + d, h + f, this.foreground)
				}
				e = c.org[0] + 14;
				h = c.org[2] + c.min[2];
				f = c.org[2] + (a * this.resizerEventData.smin);
				this.drawLine("line", e, h, e, f, this.foreground)
			}
		}
	};
	this.registerAxesResizer = function(d) {
		if (!d) {
			d = window.event
		}
		var h = this.adjustedCoordinates(d);
		if (h) {
			var g = h.x;
			var f = h.y;
			var c = this.resizerEventData.areas;
			var j = c.lim[1] - c.lim[0];
			var i = c.lim[3] - c.lim[2];
			var a = 5;
			var b = j > i ? "h" : "v";
			if (g >= c.min[0] + c.lim[0] && g <= c.min[0] + c.min[1] + c.lim[0] && f >= c.min[2] + c.lim[2] && f <= c.min[2] + c.min[3] + c.lim[2]) {
				this.resizerEventData.active = "min";
				this.axesResizingOn = true
			} else {
				if (g >= c.max[0] + c.lim[0] && g <= c.max[0] + c.max[1] + c.lim[0] && f >= c.max[2] + c.lim[2] && f <= c.max[2] + c.max[3] + c.lim[2]) {
					this.resizerEventData.active = "max";
					this.axesResizingOn = true
				} else {
					if (g >= c.cur[0] + c.lim[0] && g <= c.cur[0] + c.cur[1] + c.lim[0] && f >= c.cur[2] + c.lim[2] && f <= c.cur[2] + c.cur[3] + c.lim[2]) {
						this.resizerEventData.active = "cur";
						this.axesResizingOn = true
					} else {
						if (b == "h") {
							if (g >= c.lim[0] && g < c.min[0] + c.lim[0]) {
								this.resizerEventData.active = "prev";
								this.axesResizingOn = true
							} else {
								if (g > c.lim[0] + c.max[0] + c.max[1] && g <= c.lim[1] - a) {
									this.resizerEventData.active = "next";
									this.axesResizingOn = true
								}
							}
						} else {
							if (f >= c.lim[2] + c.min[2] + c.min[3] && f <= c.lim[2] + c.lim[3]) {
								this.resizerEventData.active = "prev";
								this.axesResizingOn = true
							} else {
								if (f >= c.lim[2] && f <= c.lim[2] + c.max[2]) {
									this.resizerEventData.active = "next";
									this.axesResizingOn = true
								}
							}
						}
					}
				}
			}
			this.xMouseDown = g;
			this.yMouseDown = f
		}
	};
	this.activateDeactivateAxesResizer = function(i) {
		if (!i) {
			i = window.event
		}
		var r = this.adjustedCoordinates(i);
		if (r) {
			var m;
			var q = r.x;
			var j = r.y;
			var g = this.resizerEventData.areas;
			var t = g.lim[1] - g.lim[0];
			var s = g.lim[3] - g.lim[2];
			var b = 5;
			var d = t > s ? "h" : "v";
			if (d == "h") {
				if (q >= g.lim[0] && q <= g.lim[0] + g.min[0]) {
					m = "prev"
				} else {
					if (q >= g.lim[0] + g.max[0] + g.max[1] && q <= g.lim[1] - b) {
						m = "next"
					}
				}
			} else {
				if (j >= g.lim[2] + g.min[2] + g.min[3] && j <= g.lim[2] + g.lim[3]) {
					m = "prev"
				} else {
					if (j >= g.lim[2] && j <= g.lim[2] + g.max[2]) {
						m = "next"
					}
				}
			}
			var c = document.getElementById(this.target + "canvasXpressAxesResizePrevious");
			var f = document.getElementById(this.target + "canvasXpressAxesResizeNext");
			if (c && f) {
				if (m == "prev") {
					var h = c.key;
					if (i.type.match(/mouseout|touchcancel/i)) {
						if (h.match(/Active/)) {
							c.key = h.replace("Active", "");
							c.className = c.key
						}
					} else {
						if (!h.match(/Active/)) {
							c.key += "Active";
							c.className = c.key
						}
					}
				} else {
					if (m == "next") {
						var h = f.key;
						if (i.type.match(/mouseout|touchcancel/i)) {
							if (h.match(/Active/)) {
								f.key = h.replace("Active", "");
								f.className = f.key
							}
						} else {
							if (!h.match(/Active/)) {
								f.key += "Active";
								f.className = f.key
							}
						}
					} else {
						var h = c.key;
						if (h.match(/Active/)) {
							c.key = h.replace("Active", "");
							c.className = c.key
						}
						h = f.key;
						if (h.match(/Active/)) {
							f.key = h.replace("Active", "");
							f.className = f.key
						}
					}
				}
			}
			return false
		}
	};
	this.moveAxesResizer = function(j) {
		var g = this.resizerEventData.smin;
		var k = this.resizerEventData.smax;
		var c = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? 1 : (k - g) / 10;
		if ((this.resizerType == "samples" || this.resizerEventData.g == "Heatmap") && this.resizerEventData.pos == "v") {
			if (this.resizerEventData.active == "prev") {
				if (g + c < this.resizerEventData.min) {
					c = g - this.resizerEventData.min;
					this.resizerEventData.lastMin = this.resizerEventData.min;
					this.resizerEventData.lastMax = k + c
				} else {
					this.resizerEventData.lastMin = g + c;
					this.resizerEventData.lastMax = k + c
				}
			} else {
				if (k - c > this.resizerEventData.max) {
					c = this.resizerEventData.max - k;
					this.resizerEventData.lastMin = g - c;
					this.resizerEventData.lastMax = this.resizerEventData.max
				} else {
					this.resizerEventData.lastMin = g - c;
					this.resizerEventData.lastMax = k - c
				}
			}
		} else {
			if (this.resizerEventData.active == "prev") {
				if (g - c < this.resizerEventData.min) {
					c = g - this.resizerEventData.min;
					this.resizerEventData.lastMin = this.resizerEventData.min;
					this.resizerEventData.lastMax = k - c
				} else {
					this.resizerEventData.lastMin = g - c;
					this.resizerEventData.lastMax = k - c
				}
			} else {
				if (k + c > this.resizerEventData.max) {
					c = this.resizerEventData.max - k;
					this.resizerEventData.lastMin = g + c;
					this.resizerEventData.lastMax = this.resizerEventData.max
				} else {
					this.resizerEventData.lastMin = g + c;
					this.resizerEventData.lastMax = k + c
				}
			}
		}
		var f = this.resizerEventData.areas;
		var d = document.getElementById(this.target + "canvasXpressAxesResizeMin");
		var n = document.getElementById(this.target + "canvasXpressAxesResizeMax");
		var m = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
		var i = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
		var b = 14;
		var a = 9 - 1;
		var o = parseInt(a / 2);
		var h = c * this.resizerEventData.unit;
		if ((this.resizerEventData.pos == "h" && this.resizerEventData.active == "prev") || (this.resizerEventData.pos == "v" && this.resizerEventData.active == "next")) {
			h *= -1
		}
		if (this.resizerEventData.pos == "h") {
			d.style.left = (f.min[0] + h + 1) + "px";
			m.style.left = ((f.min[0] + h) + (f.cur[1] / 2)) + "px";
			n.style.left = (f.max[0] + h) + "px";
			i.style.left = (f.min[0] + h + o + 1) + "px"
		} else {
			d.style.top = (f.min[2] + h + 1) + "px";
			m.style.top = ((f.max[2] + h) + (f.cur[3] / 2)) + "px";
			n.style.top = (f.max[2] + h) + "px";
			i.style.top = (f.max[2] + h + o + 1) + "px"
		}
	};
	this.getAxesVals = function(e) {
		var d = ["minData", "maxData", "xAxisMin", "xAxisMax", "xAxis2Min", "xAxis2Max", "yAxisMin", "yAxisMax", "zAxisMin", "zAxisMax", "xAxisUnit", "xAxis2Unit", "yAxisUnit", "zAxisUnit", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ", "xAxisAbsMin", "xAxisAbsMax", "xAxis2AbsMin", "xAxis2AbsMax", "yAxisAbsMin", "yAxisAbsMax", "zAxisAbsMin", "zAxisAbsMax", "graphType", "x", "y", "varIndices", "smpIndices", "grpIndices", "varIndicesStart", "smpIndicesStart"];
		var b = {};
		if (this.layoutComb) {
			for (var a = 0; a < d.length; a++) {
				b[d[a]] = this.layoutParams[e][d[a]]
			}
		} else {
			for (var a = 0; a < d.length; a++) {
				b[d[a]] = this[d[a]]
			}
		}
		return b
	};
	this.isAxis = function(k) {
		return false;
		if (!k) {
			k = window.event
		}
		if ((this.resizerType && this.layoutValid) || this.disableAxisResizer) {
			return false
		}
		var u = this.adjustedCoordinates(k);
		if (u) {
			var s = u.x;
			var p = u.y;
			var n = 0;
			var t = (this.margin * 1);
			var r = (this.margin * 2);
			var b = 18;
			for (var f = 0; f < this.layoutRows; f++) {
				for (var d = 0; d < this.layoutCols; d++) {
					var a = this.layoutComb ? n < this.data.l.weight.length : true;
					if (a) {
						var h = this.layoutComb ? this.layoutParams[n].graphType : this.graphType;
						if (h.match(/Network|Pie|Venn|Stacked|Area|Correlation|Circular/)) {
							return false
						}
						var m = this.getBoundsXY(n);
						if (h.match(/Scatter/)) {
							if (s >= m[0] && s <= m[1] && p >= m[3] && p <= m[3] + b) {
								var o = this.getAxesVals(n);
								this.showAxesResizer("xAxis", m[0], m[1], m[3] + t, m[3] + this.getAxisFont(o.x) + r, "x", "h", "b", o, "X", n, f, d);
								return true
							} else {
								if (s >= m[0] - b && s <= m[0] && p >= m[2] && p <= m[3]) {
									var o = this.getAxesVals(n);
									this.showAxesResizer("yAxis", m[0] - (this.getAxisFont(o.y) + r), m[0] - t, m[2], m[3], "y", "v", "l", o, "Y", n, f, d);
									return true
								}
							}
						} else {
							if (h.match(/Heatmap/)) {
								if (s >= m[0] - b && s <= m[0] && p >= m[2] && p <= m[3]) {
									var o = this.getAxesVals(n);
									this.showAxesResizer("xAxis", m[0] - (this.getAxisFont(o.y) + r), m[0] - t, m[2], m[3], "y", "v", "l", o, "", n, f, d);
									return true
								} else {
									if (s >= m[1] && s <= m[1] + b && p >= m[2] && p <= m[3]) {
										var o = this.getAxesVals(n);
										this.showAxesResizer("xAxis", m[1] + t, m[1] + this.getAxisFont(o.y) + r, m[2], m[3], "y", "v", "r", o, "", n, f, d);
										return true
									} else {
										if (s >= m[0] && s <= m[1] && p >= m[2] - b && p <= m[2]) {
											var o = this.getAxesVals(n);
											this.showAxesResizer("xAxis", m[0], m[1], m[2] - (this.getAxisFont(o.x) + r), m[2] - t, "x", "h", "t", o, "", n, f, d);
											return true
										} else {
											if (s >= m[0] && s <= m[1] && p >= m[3] && p <= m[3] + b) {
												var o = this.getAxesVals(n);
												this.showAxesResizer("xAxis", m[0], m[1], m[3] + t, m[3] + this.getAxisFont(o.x) + r, "x", "h", "b", o, "", n, f, d);
												return true
											}
										}
									}
								}
							} else {
								if (this.graphOrientation == "vertical") {
									if (s >= m[0] - b && s <= m[0] && p >= m[2] && p <= m[3]) {
										var o = this.getAxesVals(n);
										this.showAxesResizer("xAxis", m[0] - (this.getAxisFont(o.y) + r), m[0] - t, m[2], m[3], "y", "v", "l", o, "", n, f, d);
										return true
									} else {
										if (s >= m[1] && s <= m[1] + b && p >= m[2] && p <= m[3]) {
											var o = this.getAxesVals(n);
											if (h == "BarLine" || h == "DotLine") {
												this.showAxesResizer("xAxis2", m[1] + t, m[1] + this.getAxisFont(o.y) + r, m[2], m[3], "y", "v", "r", o, "2", n, f, d)
											} else {
												this.showAxesResizer("xAxis", m[1] + t, m[1] + this.getAxisFont(o.y) + r, m[2], m[3], "y", "v", "r", o, "", n, f, d)
											}
											return true
										}
									}
								} else {
									if (s >= m[0] && s <= m[1] && p >= m[2] - b && p <= m[2]) {
										var o = this.getAxesVals(n);
										this.showAxesResizer("xAxis", m[0], m[1], m[2] - (this.getAxisFont(o.x) + r), m[2] - t, "x", "h", "t", o, "", n, f, d);
										return true
									} else {
										if (s >= m[0] && s <= m[1] && p >= m[3] && p <= m[3] + b) {
											var o = this.getAxesVals(n);
											if (h == "BarLine" || h == "DotLine") {
												this.showAxesResizer("xAxis2", m[0], m[1], m[3] + t, m[3] + this.getAxisFont(o.x) + r, "x", "h", "b", o, "2", n, f, d)
											} else {
												this.showAxesResizer("xAxis", m[0], m[1], m[3] + t, m[3] + this.getAxisFont(o.x) + r, "x", "h", "b", o, "", n, f, d)
											}
											return true
										}
									}
								}
							}
						}
					}
					n++
				}
			}
		}
		return false
	};
	this.endAxesResizer = function(a) {
		if (this.axesResizingOn) {
			this.resetInfoSpan(a);
			if (this.resizerEventData.active == "prev" || this.resizerEventData.active == "next") {
				this.moveAxesResizer(a)
			}
			this.drawAxesResizerUpdate(true);
			this.axesResizingOn = false
		} else {
			if (this.resizerType) {
				this.updateResizerEventData();
				this.refreshAxesResizer()
			}
		}
	};
	this.resetAxesResizer = function(b) {
		if (this.axesResizerShow) {
			var a = document.getElementById(this.target + "canvasXpressAxesResize");
			if (a) {
				this.addRemoveAxesResizerListeners("removeEvtListener");
				a.style.display = "none";
				this.resizerEventData = {};
				this.resetInfoSpan(b);
				this.axesResizerShow = false
			}
		}
	};
	this.initializeAxisResizerEvents = function() {
		if (!this.disableEvents && !this.disableAxisResizer) {
			this.addAxesResizeDiv()
		}
	};
	this.initializeAxisResizerEvents()
};
CanvasXpress.prototype.initMotionEvents = function() {
	this.addMotionDiv = function() {
		var e = this.target + "-cX-Motion";
		if (this.$(e) || !this.motionBy) {
			return
		}
		this.setMotionObject();
		var h = this.width - this.motionControlHeight;
		var a = this.motionObject;
		var o = this.$cX("div", {
			id: e,
			className: "CanvasXpressMotion"
		}, {
			position: "absolute",
			left: 0,
			top: (this.height - 40) + "px",
			width: this.width + "px",
			height: "40px"
		});
		var g = this.$cX("img", {
			id: e + "Play",
			src: CanvasXpress.images.playButton,
			className: "CanvasXpressMotion"
		}, {
			width: "30px",
			height: "30px",
			cssFloat: "left"
		});
		var v = this.$cX("div", {
			id: e + "Scale",
			className: "CanvasXpressMotion"
		}, {
			width: h + "px",
			height: "14px",
			cssFloat: "left",
			margin: "2px"
		});
		var r = this.$cX("div", {
			id: e + "Container",
			className: "CanvasXpressDataFilterContainerNumeric"
		}, {
			width: h + "px",
			cssFloat: "left",
			clear: "none"
		});
		var q = this.$cX("div", {
			id: e + "Current",
			className: "CanvasXpressDataFilterContainerMax"
		});
		var n = this.$cX("div", {
			id: e + "Range",
			className: "CanvasXpressDataFilterContainerRange"
		}, {
			width: 0
		});
		if (a.type == "String") {
			for (var k = 0; k < a.levels.length; k++) {
				var m = this.measureText(a.levels[k].toString(), " 11px Arial");
				var u = this.$cX("div", {
					innerHTML: a.levels[k]
				}, {
					left: (30 + parseInt((k * a.unit) - (m / 2))) + "px",
					cssFloat: "left",
					position: "absolute"
				});
				v.appendChild(u)
			}
		} else {
			for (var k = 0; k < a.values.length; k++) {
				var m = this.measureText(a.values[k].toString(), " 11px Arial");
				var u = this.$cX("div", {
					innerHTML: a.values[k]
				}, {
					left: (30 + parseInt(((a.values[k] - a.min) * a.unit) - (m / 2))) + "px",
					cssFloat: "left",
					position: "absolute"
				});
				v.appendChild(u)
			}
		}
		r.appendChild(n);
		r.appendChild(q);
		o.appendChild(g);
		o.appendChild(v);
		o.appendChild(r);
		this.updateMotionIndices();
		var j = this.$("center-wrapper-" + this.target);
		if (j) {
			j.appendChild(o);
			this.addRemoveMotionListeners("addEvtListener")
		}
	};
	this.setMotionObject = function() {
		var b = {};
		var e = [];
		var c = {};
		var f = this.data.x && this.data.x[this.motionBy] ? this.meta.data.x[this.motionBy] : this.meta.data.z[this.motionBy];
		var a = this.width - (this.motionControlHeight + 14);
		if (f.type == "Numeric") {
			if (this.data.x && this.data.x[this.motionBy]) {
				for (var d = 0; d < this.data.x[this.motionBy].length; d++) {
					var g = this.data.x[this.motionBy][d];
					if (!c.hasOwnProperty(g)) {
						e.push(g);
						c[g] = true
					}
				}
				b.meta = "x"
			} else {
				for (var d = 0; d < this.data.z[this.motionBy].length; d++) {
					var g = this.data.z[this.motionBy][d];
					if (!c.hasOwnProperty(g)) {
						e.push(g);
						c[g] = true
					}
				}
				b.meta = "z"
			}
			if (e.length > 20) {
				b.type = "Numeric";
				b.values = [];
				b.min = f.rmin;
				b.max = f.rmax;
				b.unit = a / (f.vals[f.vals.length - 1] - f.rmin);
				b.current = f.rmin;
				for (var d = 0; d < f.vals.length; d++) {
					if (f.vals[d] >= f.rmin) {
						b.values.push(f.vals[d])
					}
				}
			} else {
				b.type = "String";
				b.levels = e.sort(function(i, h) {
					return i - h
				});
				b.unit = a / (e.length - 1);
				b.current = e[0]
			}
		} else {
			b.type = "String";
			b.levels = f.levels;
			b.unit = a / (f.levels.length - 1);
			b.current = f.levels[0]
		}
		b.varIndices = this.cloneObject(this.varIndices);
		b.smpIndices = this.cloneObject(this.smpIndices);
		b.grpIndices = this.cloneObject(this.grpIndices);
		b.varIndicesMotion = [];
		b.smpIndicesMotion = [];
		b.grpIndicesMotion = [];
		this.motionObject = b
	};
	this.updateMotionIndices = function(g, a) {
		if (this.motionBy && this.motionObject) {
			var c = [];
			var h = this.motionObject.meta == "x" ? this.motionObject.smpIndices : this.motionObject.varIndices;
			var k = this.motionObject.meta == "x" ? this.data.x[this.motionBy] : this.data.z[this.motionBy];
			if (this.motionObject.type == "String") {
				var b = g && g[0] != null ? g[0] : this.motionObject.levels[0];
				for (var e = 0; e < h.length; e++) {
					var j = h[e];
					if (k[j] == b) {
						c.push(j)
					}
				}
			} else {
				var d = g && g[0] != null ? g[0] : this.motionObject.min;
				var f = g && g[1] != null ? g[1] : this.motionObject.values[0];
				for (var e = 0; e < h.length; e++) {
					var j = h[e];
					if (k[j] > d && k[j] <= f) {
						c.push(j)
					}
				}
			}
			if (this.motionObject.meta == "x") {
				this.smpIndices = c
			} else {
				this.varIndices = c
			}
			if (g && g.length > 0 && !a) {
				this.motionObject.varIndicesMotion.push(this.cloneObject(this.varIndices));
				this.motionObject.smpIndicesMotion.push(this.cloneObject(this.smpIndices));
				this.motionObject.grpIndicesMotion.push(this.cloneObject(this.grpIndices))
			}
			if (this.motionObject.varIndicesMotion.length > 3) {
				this.motionObject.varIndicesMotion.shift()
			}
			if (this.motionObject.smpIndicesMotion.length > 3) {
				this.motionObject.smpIndicesMotion.shift()
			}
			if (this.motionObject.grpIndicesMotion.length > 3) {
				this.motionObject.grpIndicesMotion.shift()
			}
		}
	};
	this.addRemoveMotionListeners = function(a) {
		var b = this.$(this.target + "-cX-MotionPlay");
		var d = this.$(this.target + "-cX-MotionCurrent");
		if (a && b && d) {
			this[a](b, "click", this.clickMotion, false);
			this[a](d, "mousedown", this.mousedownMotion, false)
		}
	};
	this.mousedownMotion = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = a.getTargetEvent(d);
			if (b) {
				var c = a.$(a.target + "-cX-MotionRange");
				if (c) {
					a.motionOn = c.style.width + "px";
					a.xMouseDown = d.clientX;
					a.yMouseDown = d.clientY
				}
			}
			return false
		}
	}(this);
	this.updateMotion = function(h, k, g) {
		this.functionCaller = "updateMotion";
		var a = this.$(this.target + "-cX-MotionRange");
		if (a) {
			var j = this.width - (this.motionControlHeight + 14);
			var l = k != null ? Math.min(Math.max(0, k), j) : Math.min(Math.max(0, h.clientX + parseInt(this.motionOn) - this.xMouseDown), j);
			var d = l / this.motionObject.unit;
			a.style.width = l + "px";
			if (this.motionObject.type == "String") {
				var b = parseInt(d);
				if (this.motionObject.levels[b] != this.motionObject.current || g) {
					this.updateMotionIndices([this.motionObject.levels[b]], g);
					this.motionObject.current = this.motionObject.levels[b];
					this.draw()
				}
			} else {
				var b = d + this.motionObject.min;
				for (var c = 1; c < this.motionObject.values.length; c++) {
					if (this.motionObject.values[c] > b) {
						this.updateMotionIndices([this.motionObject.values[c - 1], b, g]);
						this.motionObject.current = b;
						this.draw();
						break
					}
				}
			}
		}
	};
	this.endMotion = function() {
		this.motionOn = false;
		return false
	};
	this.clickMotion = function(a) {
		return function(g) {
			if (!g) {
				g = window.event
			}
			var f = a.getTargetEvent(g);
			if (f) {
				a.motionOn = true;
				var d = a.width - (a.motionControlHeight + 14);
				var c = d / 100;
				var h = 0;
				var b = function() {
					if (h >= d) {
						var j = function() {
							var k = a.motionObject.varIndicesMotion.length;
							if (k < 1) {
								a.motionOn = false;
								clearInterval(e);
								return
							}
							a.motionObject.varIndicesMotion.shift();
							a.motionObject.smpIndicesMotion.shift();
							a.motionObject.grpIndicesMotion.shift();
							a.updateMotion(g, d, true)
						};
						clearInterval(i);
						var e = setInterval(j, 50)
					}
					h += c;
					a.updateMotion(g, h)
				};
				a.updateMotion(g, h);
				var i = setInterval(b, 50)
			}
		};
		return false
	}(this);
	this.removeMotionDiv = function() {
		var a = this.$(this.target + "-cX-Motion");
		if (a) {
			a.parentNode.removeChild(a);
			this.addRemoveMotionListeners("removeEvtListener")
		}
	};
	this.resetMotionDiv = function() {
		if (this.motionBy) {
			this.removeMotionDiv();
			this.addMotionDiv()
		}
	}
};
CanvasXpress.prototype.initDraggingEvents = function() {
	this.getActiveLayout = function(k) {
		if (k) {
			var h = {};
			if (k && k.type == "keydown") {
				h.x = (this.layoutComb ? this.layoutParams[0].width : this.width) / 2;
				h.y = (this.layoutComb ? this.layoutParams[0].height : this.height) / 2
			} else {
				h = this.adjustedCoordinates(k)
			}
			if (this.layoutValid) {
				var a = h.x;
				var g = h.y;
				var m = 0;
				for (var f = 0; f < this.layoutRows; f++) {
					for (var d = 0; d < this.layoutCols; d++) {
						if (m < this.data.l.weight.length) {
							var b = this.getBoundsXY(m);
							if (a >= b[0] && a <= b[1] && g >= b[2] && g <= b[3]) {
								this.layoutValidR = f;
								this.layoutValidC = d;
								this.layoutValidN = m;
								m = {
									idx: m,
									row: f,
									col: d,
									ac: h
								};
								return m
							}
							m++
						} else {
							return false
						}
					}
				}
			} else {
				return {
					idx: 0,
					row: 0,
					col: 0,
					ac: h
				}
			}
		}
		return false
	};
	this.setActiveLayout = function(a) {
		var b = this.getActiveLayout(a);
		if (b && b.row && b.col && b.idx) {
			this.layoutValidR = b.row;
			this.layoutValidC = b.col;
			this.layoutValidN = b.idx
		}
	};
	this.getActiveLayoutIndicesMetadata = function(f) {
		var g = this.getActiveLayout(f);
		if (g) {
			var q = this.layoutComb ? this.layoutParams[g.idx] : this;
			var a = this.cloneObject(q.varIndices);
			var h = this.isGroupedData ? this.cloneObject(q.grpIndices) : this.cloneObject(q.smpIndices);
			if (a && h) {
				this.setOriginalIndices(g.idx, a, h);
				var n = g.ac.x - (q.offsetX + this.marginLeft + q.left);
				var k = g.ac.y - (q.offsetY + this.marginTop + q.top);
				var m = Math.min(Math.max(n, 0), q.x) / q.x;
				var l = Math.ceil(a.length / 10) * 2;
				var d = Math.round(m * l);
				var p = l - d;
				var j = Math.min(Math.max(k, 0), q.y) / q.y;
				var i = Math.ceil(h.length / 10) * 2;
				var b = Math.round(j * i);
				var o = i - b;
				return {
					ac: g.ac,
					row: g.row,
					col: g.col,
					idx: g.idx,
					lcx: m,
					stx: d,
					edx: p,
					lcy: j,
					sty: b,
					edy: o,
					vin: a,
					sin: h
				}
			} else {
				var n = g.ac.x - (q.offsetX + this.marginLeft + q.left);
				var k = g.ac.y - (q.offsetY + this.marginTop + q.top);
				var m = Math.min(Math.max(n, 0), q.x) / q.x;
				var j = Math.min(Math.max(k, 0), q.y) / q.y;
				return {
					ac: g.ac,
					row: g.row,
					col: g.col,
					idx: g.idx,
					lcx: m,
					lcy: j
				}
			}
		}
		return false
	};
	this.setIndicesAfterWheelEvent = function(k, l) {
		this.functionCaller = "setIndicesAfterWheelEvent";
		var h, a, p, j, n, f, o;
		var c = false;
		var b = this.getActiveLayoutIndicesMetadata(k);
		if (b) {
			var q = this.layoutComb ? this.layoutParams[b.idx] : this;
			if (this.graphType == "Correlation") {
				h = this.correlationAxis == "variables" ? true : false;
				a = this.correlationAxis == "samples" ? true : false;
				p = b.stx;
				j = b.edx;
				n = b.stx;
				f = b.edx;
				o = false
			} else {
				if (this.graphType == "Heatmap") {
					h = !this.zoomVariablesDisable ? true : false;
					a = !this.zoomSamplesDisable ? true : false;
					p = b.stx;
					j = b.edx;
					n = b.sty;
					f = b.edy;
					o = false
				} else {
					if (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/)) {
						h = false;
						a = true;
						p = false;
						j = false;
						n = this.graphOrientation == "vertical" ? b.stx : b.sty;
						f = this.graphOrientation == "vertical" ? b.edx : b.edy;
						o = true
					}
				}
			}
			if (l > 0) {
				if (h && b.vin.length > 3) {
					if (q.varIndicesStart < 0) {
						q.varIndicesStart++
					}
					for (var g = 0; g < p; g++) {
						b.vin.shift();
						q.varIndicesStart++
					}
					for (var g = 0; g < j; g++) {
						b.vin.pop()
					}
					c = true
				}
				if (a && b.sin.length > 3) {
					if (q.smpIndicesStart < 0) {
						q.smpIndicesStart++
					}
					for (var g = 0; g < n; g++) {
						b.sin.shift();
						q.smpIndicesStart++
					}
					for (var g = 0; g < f; g++) {
						b.sin.pop()
					}
					c = true
				}
			} else {
				if (h) {
					for (var g = 0; g < p; g++) {
						if (q.varIndicesStart >= 0 && q.varIndicesStart + b.vin.length < q.startingVarIndices.length) {
							b.vin.push(q.startingVarIndices[q.varIndicesStart + b.vin.length]);
							c = true
						} else {
							if (q.varIndicesStart > 0) {
								q.varIndicesStart--;
								b.vin.unshift(q.startingVarIndices[q.varIndicesStart]);
								c = true
							}
						}
					}
					for (var g = 0; g < j; g++) {
						if (q.varIndicesStart > 0) {
							q.varIndicesStart--;
							b.vin.unshift(q.startingVarIndices[q.varIndicesStart]);
							c = true
						} else {
							if (q.varIndicesStart >= 0 && q.varIndicesStart + b.vin.length < q.startingVarIndices.length) {
								b.vin.push(q.startingVarIndices[q.varIndicesStart + b.vin.length]);
								c = true
							}
						}
					}
				}
				if (a) {
					for (var g = 0; g < n; g++) {
						if (q.smpIndicesStart >= 0 && q.smpIndicesStart + b.sin.length < q.startingSmpIndices.length) {
							b.sin.push(q.startingSmpIndices[q.smpIndicesStart + b.sin.length]);
							c = true
						} else {
							if (q.smpIndicesStart > 0) {
								q.smpIndicesStart--;
								b.sin.unshift(q.startingSmpIndices[q.smpIndicesStart]);
								c = true
							}
						}
					}
					for (var g = 0; g < f; g++) {
						if (q.smpIndicesStart > 0) {
							q.smpIndicesStart--;
							b.sin.unshift(q.startingSmpIndices[q.smpIndicesStart]);
							c = true
						} else {
							if (q.smpIndicesStart >= 0 && q.smpIndicesStart + b.sin.length < q.startingSmpIndices.length) {
								b.sin.push(q.startingSmpIndices[q.smpIndicesStart + b.sin.length]);
								c = true
							}
						}
					}
				}
			}
			if (h) {
				q.varIndices = b.vin
			}
			if (a) {
				if (o) {
					this.setSamplesVisible(b.sin, true)
				}
				if (q.isGroupedData) {
					q.grpIndices = b.sin
				} else {
					q.smpIndices = b.sin
				}
			}
			if (c) {
				k.ac = {
					x: b.ac.x,
					y: b.ac.y
				};
				this.draw()
			}
		}
	};
	this.setRangesAfterWheelEvent = function(h, i) {
		this.functionCaller = "setRangesAfterWheelEvent";
		var c = this.getActiveLayoutIndicesMetadata(h);
		if (c) {
			var l = this.layoutComb ? this.layoutParams[c.idx] : this;
			var j = c.ac.x > (this.marginLeft + l.offsetX + l.left) && c.ac.x < (this.marginLeft + l.offsetX + l.left + l.x);
			var f = c.ac.y > (this.marginTop + l.offsetY + l.top) && c.ac.y < (this.marginTop + l.offsetY + l.top + l.y);
			var b = l.xAxisRange * this.zoomStep * c.lcx;
			var a = l.yAxisRange * this.zoomStep * c.lcy;
			var k = l.xAxisRange * this.zoomStep * (1 - c.lcx);
			var g = l.yAxisRange * this.zoomStep * (1 - c.lcy);
			if (i > 0) {
				if (j) {
					this.setMinX = l.setMinX != null ? l.setMinX + b : l.xAxisMin + b;
					this.setMaxX = l.setMaxX != null ? l.setMaxX - k : l.xAxisMax - k
				}
				if (f && this.graphType != "Genome") {
					this.setMinY = l.setMinY != null ? l.setMinY + g : l.yAxisMin + g;
					this.setMaxY = l.setMaxY != null ? l.setMaxY - a : l.yAxisMax - a
				}
			} else {
				if (j) {
					this.setMinX = l.setMinX != null ? l.setMinX - b : l.xAxisMin - b;
					this.setMaxX = l.setMaxX != null ? l.setMaxX + k : l.xAxisMax + k
				}
				if (f && this.graphType != "Genome") {
					this.setMinY = l.setMinY != null ? l.setMinY - g : l.yAxisMin - g;
					this.setMaxY = l.setMaxY != null ? l.setMaxY + a : l.yAxisMax + a
				}
			}
			if (this.layoutComb) {
				l.setMinX = this.setMinX;
				l.setMaxX = this.setMaxX;
				l.setMinY = this.setMinY;
				l.setMaxY = this.setMaxY
			}
			h.ac = {
				x: c.ac.x,
				y: c.ac.y
			};
			this.draw()
		}
	};
	this.setIndicesAfterPannEvent = function(j, b) {
		this.functionCaller = "setIndicesAfterPannEvent";
		var a, p;
		var h = 0;
		var o = this.layoutComb ? this.layoutParams[this.layoutValidN || 0] : this;
		var c = this.cloneObject(o.varIndices);
		var n = o.isGroupedData ? this.cloneObject(o.grpIndices) : this.cloneObject(o.smpIndices);
		this.setOriginalIndices(this.layoutComb ? this.layoutValidN : 0, c, n);
		if (this.graphType == "Correlation") {
			h = 1;
			switch (b) {
				case 37:
					p = o.varIndicesStart > 0 ? 3 : o.smpIndicesStart > 0 ? 4 : 1;
					break;
				case 39:
					p = o.varIndicesStart > -1 ? 5 : o.smpIndicesStart > -1 ? 6 : 1;
					break
			}
		} else {
			if (this.graphType == "Heatmap") {
				h = 2
			} else {
				if (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/)) {
					h = 3
				}
			}
		}
		switch (b) {
			case 33:
				a = h == 1 ? 1 : h == 2 ? 4 : h == 3 ? 4 : 1;
				break;
			case 34:
				a = h == 1 ? 1 : h == 2 ? 6 : h == 3 ? 6 : 1;
				break;
			case 35:
				a = h == 1 ? 1 : h == 2 ? 1 : h == 3 ? 1 : 1;
				break;
			case 36:
				a = h == 1 ? 1 : h == 2 ? 2 : h == 3 ? 1 : 1;
				break;
			case 37:
				a = h == 1 ? p : h == 2 ? 3 : h == 3 ? 4 : 1;
				break;
			case 38:
				a = h == 1 ? 1 : h == 2 ? 4 : h == 3 ? 4 : 1;
				break;
			case 39:
				a = h == 1 ? p : h == 2 ? 5 : h == 3 ? 6 : 1;
				break;
			case 40:
				a = h == 1 ? 1 : h == 2 ? 6 : h == 3 ? 6 : 1;
				break
		}
		var l = false;
		if (a == 1) {
			return false
		} else {
			if (a == 2) {
				o.varIndicesStart = -1;
				o.smpIndicesStart = -1;
				o.varIndices = o.startingVarIndices;
				if (o.isGroupedData) {
					o.grpIndices = o.startingSmpIndices
				} else {
					o.smpIndices = o.startingSmpIndices
				}
				l = true
			} else {
				if (a == 3) {
					if (o.varIndicesStart > 0) {
						c.unshift(o.startingVarIndices[o.varIndicesStart - 1]);
						c.pop();
						o.varIndicesStart--;
						l = true
					}
				} else {
					if (a == 4) {
						for (var f = 0; f < (b == 33 ? 5 : 1); f++) {
							if (o.smpIndicesStart > 0) {
								n.unshift(o.startingSmpIndices[o.smpIndicesStart - 1]);
								n.pop();
								o.smpIndicesStart--;
								l = true
							}
						}
					} else {
						if (a == 5) {
							if (o.varIndicesStart > -1 && o.varIndicesStart + c.length < o.startingVarIndices.length) {
								c.push(o.startingVarIndices[o.varIndicesStart + c.length]);
								c.shift();
								o.varIndicesStart++;
								l = true
							}
						} else {
							if (a == 6) {
								for (var f = 0; f < (b == 34 ? 5 : 1); f++) {
									if (o.smpIndicesStart > -1 && o.smpIndicesStart + n.length < o.startingSmpIndices.length) {
										n.push(o.startingSmpIndices[o.smpIndicesStart + n.length]);
										n.shift();
										o.smpIndicesStart++;
										l = true
									}
								}
							}
						}
					}
				}
			}
		}
		o.varIndices = c;
		if (o.isGroupedData) {
			o.grpIndices = n
		} else {
			o.smpIndices = n
		}
		if (l) {
			this.draw()
		}
	};
	this.addDragDiv = function() {
		if (this.$(this.target + "-cX-Drag")) {
			return
		}
		var a = this.$cX("div", {
			id: this.target + "-cX-Drag",
			className: "CanvasXpressDrag"
		}, {
			width: "0px",
			height: "0px",
			zIndex: 9000
		});
		this.meta.canvas.ctx.canvas.parentNode.appendChild(a)
	};
	this.registerDragNetwork = function(n) {
		var d, l, g;
		var m = this.isEvent(n, true);
		var b = this.getTargetEvent(n);
		var h = n.shiftKey || this.shiftKeyMobile;
		var p = this.adjustBackNetworkObjectX(this.xMouseDown);
		var o = this.adjustBackNetworkObjectY(this.yMouseDown);
		var a = m[1];
		if (a && a.match(/-legend-/)) {
			if (a.match(/-legend-Nodes/)) {
				this.moveLegend = "Nodes";
				this.moveLegendX = this.data.legend.pos.nodes.x - p;
				this.moveLegendY = this.data.legend.pos.nodes.y - o
			} else {
				if (a.match(/-legend-Edges/)) {
					this.moveLegend = "Edges";
					this.moveLegendX = this.data.legend.pos.edges.x - p;
					this.moveLegendY = this.data.legend.pos.edges.y - o
				} else {
					if (a.match(/-legend-Decorations/)) {
						this.moveLegend = "Decorations";
						this.moveLegendX = this.data.legend.pos.decorations.x - p;
						this.moveLegendY = this.data.legend.pos.decorations.y - o
					} else {
						this.moveLegend = a.split(/-legend-/)[1];
						d = parseInt(this.moveLegend.replace("Text", ""));
						this.moveLegendX = this.data.legend.text[d].x - p;
						this.moveLegendY = this.data.legend.text[d].y - o
					}
				}
			}
		} else {
			if (a && a.match(/-lab$/)) {
				if (h) {
					l = true
				}
				d = m[0][0]
			} else {
				if (a && a.match(/-dec$/)) {
					if (h) {
						d = m[0][0].split("-")[0];
						g = true
					} else {
						this.resetDrag(n);
						this.resetFlags(n)
					}
				} else {
					if (a && a.match(/-elbow$/)) {
						b.style.cursor = "move";
						this.moveEdge = true;
						this.moveEdgeIndex = m[0][0] - this.data.nodes.length;
						this.moveEdgeElbow = m[0][1]
					} else {
						if (a && a.match(/-resize/)) {
							d = a.split("-")[0];
							this.resizeNode = a.split("-resize")[1]
						} else {
							d = m ? m[0][0] : "NaN"
						}
					}
				}
			}
			if (this.moveEdge) {
				var c = this.data.edges[this.moveEdgeIndex].elbows[this.moveEdgeElbow];
				this.moveEdgeX = c[0] - p;
				this.moveEdgeY = c[1] - o
			} else {
				if (!isNaN(d) && d < this.data.nodes.length) {
					b.style.cursor = "move";
					this.moveNode = true;
					this.moveNodeIndex = d;
					if (l) {
						this.moveNodeLab = true
					} else {
						if (g) {
							this.moveNodeDec = true
						}
					}
					var f = this.data.nodes[this.moveNodeIndex];
					this.moveNodeW = f.width ? f.width : f.size ? (this.nodeSize * f.size) : this.nodeSize;
					this.moveNodeH = f.height ? f.height : f.size ? (this.nodeSize * f.size) : this.nodeSize;
					if (this.moveNodeLab) {
						this.moveNodeX = f.labelX != null ? f.labelX - p : f.labelXi - p;
						this.moveNodeY = f.labelY != null ? f.labelY - o : f.labelYi - o
					} else {
						if (this.moveNodeDec) {
							this.moveNodeX = f.decorationsX != null ? f.decorationsX - p : f.decorationsXi - p;
							this.moveNodeY = f.decorationsY != null ? f.decorationsY - o : f.decorationsYi - o
						} else {
							if (this.is3DNetwork) {
								this.moveNodeX = f.x3d - p;
								this.moveNodeY = f.y3d - o
							} else {
								this.moveNodeX = f.x - p;
								this.moveNodeY = f.y - o
							}
						}
					}
				}
			}
		}
		if (this.networkStack.length < 1 || this.networkStack.length - 1 != this.networkStackIndex) {
			var k = this.cloneObject(this.networkStack);
			var q = this.networkStackIndex;
			this.clearNetworkStack();
			for (var j = 0; j < q; j++) {
				this.networkStack.push(this.cloneObject(k[j]))
			}
			this.addToNetworkStack();
			k = false
		}
	};
	this.registerDragGenome = function(b) {
		var a = this.isEvent(b, true);
		if (a && isNaN(a[0][0])) {
			this.moveGenome = a[0][0]
		} else {
			this.moveGenome = false
		}
	};
	this.registerDragScatter = function(d) {
		var b = this.isEvent(d, true);
		var c = b[1];
		var f = this.xMouseDown;
		var a = this.yMouseDown;
		if (c && c.match(/-legend-/)) {
			if (c.match(/-legend-sample/)) {
				ml = "legendSample";
				mx = this["legendSampleCurX"] - f;
				my = this["legendSampleCurY"] - a
			} else {
				if (c.match(/-legend-variable/)) {
					ml = "legendVariable";
					mx = this["legendVariableCurX"] - f;
					my = this["legendVariableCurY"] - a
				} else {
					if (c.match(/-legend-indicator-color/)) {
						ml = "legendColorIndicator";
						if (d.shiftKey || this.shiftKeyMobile) {
							this.resizeLegend = true
						} else {
							mx = this["legendColorIndicatorCurX"] - f;
							my = this["legendColorIndicatorCurY"] - a
						}
					} else {
						if (c.match(/-legend-color/)) {
							ml = "legendColor";
							mx = this["legendColorCurX"] - f;
							my = this["legendColorCurY"] - a
						} else {
							if (c.match(/-legend-size/)) {
								ml = "legendSize";
								mx = this["legendSizeCurX"] - f;
								my = this["legendSizeCurY"] - a
							} else {
								if (c.match(/-legend-shape/)) {
									ml = "legendShape";
									mx = this["legendShapeCurX"] - f;
									my = this["legendShapeCurY"] - a
								} else {
									if (c.match(/-legend-pattern/)) {
										ml = "legendPattern";
										mx = this["legendPatternCurX"] - f;
										my = this["legendPatternCurY"] - a
									} else {
										if (c.match(/-legend-oncoprint/)) {
											ml = "legendOncoprint";
											mx = this["legendOncoprintCurX"] - f;
											my = this["legendOncoprintCurY"] - a
										} else {
											if (c.match(/-legend-decoration/)) {
												ml = "legendDecoration";
												mx = this["legendDecorationCurX"] - f;
												my = this["legendDecorationCurY"] - a
											} else {
												ml = this.moveLegend;
												mx = this.moveLegendX;
												my = this.moveLegendY
											}
										}
									}
								}
							}
						}
					}
				}
			}
			this.moveLegend = ml;
			this.moveLegendX = mx;
			this.moveLegendY = my
		}
	};
	this.isLegend = function(a) {
		var b = this.isEvent(a, true);
		if (b[1] && b[1].match(/legend/)) {
			this.registerDragScatter(a)
		}
	};
	this.registerDrag = function(r) {
		if (!r) {
			r = window.event
		}
		if (this.isCanvasResize(r)) {
			this.resizingCanvasOn = true
		} else {
			if (this.isDOE) {
				return false
			} else {
				if (!r) {
					return false
				}
				if (!this.touches) {
					this.touches = []
				}
				var b = this.getTargetEvent(r);
				var h = r.shiftKey || this.shiftKeyMobile;
				var w = this.adjustedCoordinates(r);
				if (w) {
					CanvasXpress.current = b.id;
					var k = w.x;
					var x = w.y;
					var v = 0;
					for (var n = 0; n < this.layoutRows; n++) {
						for (var m = 0; m < this.layoutCols; m++) {
							var a = this.layoutComb ? v < this.data.l.weight.length : true;
							if (a) {
								var p = this.layoutComb ? this.layoutParams[v].graphType : this.graphType;
								var u = this.getBoundsXY(v);
								if (p.match(/Pie|Venn|Stacked|Area|Circular|Treemap|TagCloud/)) {
									if (this.meta.system.isTouchScreen) {
										if (k >= u[0] && k <= u[1] && x >= u[2] && x <= u[3] || this.moveGenome) {
											this.skipClick = false;
											this.draggingOn = true;
											this.xMouseDown = k;
											this.yMouseDown = x;
											this.touches.push([k, x, new Date().getTime()]);
											return false
										}
									} else {
										if (!p.match(/Network|Genome|Venn|Correlation|Scatter/)) {
											this.isLegend(r)
										} else {
											return false
										}
									}
								} else {
									if (p == "Genome") {
										this.registerDragGenome(r)
									}
								}
								if (k >= u[0] && k <= u[1] && x >= u[2] && x <= u[3] || this.moveGenome) {
									this.skipClick = false;
									this.draggingOn = true;
									this.xMouseDown = k;
									this.yMouseDown = x;
									this.touches.push([k, x, new Date().getTime()]);
									if (p == "Correlation") {
										return false
									}
									if (p.match(/Scatter/)) {
										this.registerDragScatter(r);
										if (this.moveLegend) {
											return false
										}
									}
									if (!p.match(/Network|Genome|Venn|Correlation|Scatter/)) {
										this.isLegend(r);
										if (this.moveLegend) {
											return false
										}
									}
									var s = this.$(this.target + "-cX-Drag");
									if (p == "Network") {
										this.registerDragNetwork(r)
									}
									if ((!p.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && !h) || (!p.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && h)) {
										s.style.left = u[0] + "px"
									} else {
										s.style.left = this.xMouseDown + "px"
									}
									if ((!p.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && !h) || (!p.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && h) || p == "Genome") {
										s.style.top = u[2] + "px"
									} else {
										s.style.top = this.yMouseDown + "px"
									}
									if (this.layoutValid) {
										this.layoutValidR = n;
										this.layoutValidC = m;
										this.layoutValidN = v
									}
									return false
								} else {
									if (k >= u[4] && k <= u[5] && x >= u[6] && x <= u[7]) {
										var f = this.isEvent(r);
										if (f) {
											this.skipClick = false;
											this.draggingOn = true;
											this.xMouseDown = k;
											this.yMouseDown = x;
											this.touches.push([k, x, new Date().getTime()]);
											if (p == "Correlation") {
												return false
											}
											if (p.match(/Scatter/)) {
												this.registerDragScatter(r);
												if (this.moveLegend) {
													return false
												}
											}
											if (!p.match(/Network|Genome|Venn|Correlation|Scatter/)) {
												this.isLegend(r);
												if (this.moveLegend) {
													return false
												}
											}
											var s = this.$(this.target + "-cX-Drag");
											if (f[0] == "varDendrogram" || f[0] == "smpDendrogram") {
												this.moveDendrogram = f[0];
												b.style.cursor = "move";
												if (f[0] == "varDendrogram" || (f[0] == "smpDendrogram" && this.graphOrientation == "vertical")) {
													s.style.left = u[4] + "px";
													s.style.width = (u[5] - u[4]) + "px";
													s.style.height = "3px"
												} else {
													s.style.width = "3px";
													s.style.top = u[6] + "px";
													s.style.height = (u[7] - u[6]) + "px"
												}
											} else {
												if (f[0].match("SmpOverlay")) {
													this.moveSmpOverlay = f[0];
													b.style.cursor = "move";
													if (p.match(/Heatmap/) || this.graphOrientation == "horizontal") {
														s.style.width = "3px";
														s.style.top = u[6] + "px";
														s.style.height = (u[7] - u[6]) + "px"
													} else {
														s.style.left = u[4] + "px";
														s.style.width = (u[5] - u[4]) + "px";
														s.style.height = "3px"
													}
												} else {
													if (f[0].match("Smp")) {
														this.moveSmp = f[0];
														b.style.cursor = "move";
														if (p.match(/Heatmap/) || this.graphOrientation == "horizontal") {
															s.style.left = u[4] + "px";
															s.style.width = (u[5] - u[4]) + "px";
															s.style.height = "3px"
														} else {
															s.style.width = "3px";
															s.style.top = u[6] + "px";
															s.style.height = (u[7] - u[6]) + "px"
														}
													} else {
														if (f[0].match("VarOverlay")) {
															this.moveVarOverlay = f[0];
															b.style.cursor = "move";
															s.style.left = u[4] + "px";
															s.style.width = (u[5] - u[4]) + "px";
															s.style.height = "3px"
														} else {
															if (f[0].match("Var")) {
																this.moveVar = f[0];
																b.style.cursor = "move";
																s.style.width = "3px";
																s.style.top = u[6] + "px";
																s.style.height = (u[7] - u[6]) + "px"
															}
														}
													}
												}
											}
											return false
										}
									}
								}
							}
							v++
						}
					}
					return false
				}
			}
		}
	};
	this.updateDragScatter3D = function(e, n, g, j, a) {
		this.functionCaller = "updateDragScatter3D";
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		var d = j;
		var i = a;
		var b = e;
		var h = n;
		var k = this.layoutComb ? this.layoutParams[g].x : this.x;
		var f = this.layoutComb ? this.layoutParams[g].y : this.y;
		var o = ((b - d) * this.rotationSensitivity) / k;
		var m = ((h - i) * this.rotationSensitivity) / f;
		this.xRotate -= o;
		this.yRotate += m;
		this.xMouseDown = e;
		this.yMouseDown = n;
		this.draw();
		this.skipClick = true
	};
	this.updateDragScatter = function(b, d) {
		this.functionCaller = "updateDragScatter";
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		if (this.resizeLegend) {
			var c = b - this.xMouseDown;
			var a = d - this.yMouseDown;
			this.heatmapIndicatorWidth += parseInt(c / 10);
			this.heatmapIndicatorHeight += parseInt(a / 10);
			this.heatmapIndicatorWidth = Math.max(10, this.heatmapIndicatorWidth);
			this.heatmapIndicatorHeight = Math.max(10, this.heatmapIndicatorHeight)
		} else {
			var e = this.moveLegend;
			var c = this[e + "CurX"] - b - this.moveLegendX;
			var a = this[e + "CurY"] - d - this.moveLegendY;
			this[e + "CurX"] -= c;
			this[e + "CurY"] -= a;
			this[e + "X"] = this[e + "CurX"];
			this[e + "Y"] = this[e + "CurY"]
		}
		this.draw();
		this.skipClick = true
	};
	this.updateDragNetwork = function(N, F, u) {
		this.functionCaller = "updateDragNetwork";
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		var E, r, p, C, G, q, L, J, z, H, m, i, g, P, f, O, d, B, v;
		var D = {};
		var A = this.data;
		var b = this.moveNodeX;
		var a = this.moveNodeY;
		var c = this.moveNodeW;
		var s = this.moveNodeH;
		var I = N.shiftKey || this.shiftKeyMobile;
		var j = N.ctrlKey || this.ctrlKeyMobile;
		this.movingOn = true;
		var o = this.adjustBackNetworkObjectX(F);
		var n = this.adjustBackNetworkObjectY(u);
		var K = this.getTargetEvent(N);
		F = this.adjustNetworkMouseDownX(F);
		u = this.adjustNetworkMouseDownY(u);
		K.style.cursor = I ? "se-resize" : "move";
		if (this.moveNode || this.moveEdge || this.moveLegend) {
			if (this.moveLegend) {
				J = A.legend;
				if (this.moveLegend.match("Text")) {
					C = parseInt(this.moveLegend.replace("Text", ""));
					r = J.text[C].x - o - this.moveLegendX;
					p = J.text[C].y - n - this.moveLegendY;
					J.text[C].x -= r;
					J.text[C].y -= p
				} else {
					C = this.moveLegend.toLowerCase();
					r = J.pos[C].x - o - this.moveLegendX;
					p = J.pos[C].y - n - this.moveLegendY;
					J.pos[C].x -= r;
					J.pos[C].y -= p
				}
			} else {
				if (A.edges[this.moveEdgeIndex]) {
					z = A.edges[this.moveEdgeIndex].elbows[this.moveEdgeElbow];
					r = z[0] - o - this.moveEdgeX;
					p = z[1] - n - this.moveEdgeY;
					this.modifyXYEdgeElbow(this.moveEdgeIndex, this.moveEdgeElbow, r, p)
				} else {
					if (A.nodes[this.moveNodeIndex]) {
						E = A.nodes[this.moveNodeIndex];
						if (this.moveNodeLab) {
							r = E.labelX != null ? E.labelX - o - b : E.labelXi - o - b;
							p = E.labelY != null ? E.labelY - n - a : E.labelYi - n - a;
							this.modifyXYNodeLab(E.id, r, p)
						} else {
							if (this.moveNodeDec) {
								r = E.decorationsX != null ? E.decorationsX - o - b : E.decorationsXi - o - b;
								p = E.decorationsY != null ? E.decorationsY - n - a : E.decorationsYi - n - a;
								this.modifyXYNodeDec(E.id, r, p)
							} else {
								r = this.is3DNetwork ? E.x3d - o - b : E.x - o - b;
								p = this.is3DNetwork ? E.y3d - n - a : E.y - n - a;
								if (I && !N.ctrlKey && !this.ctrlKeyMobile) {
									q = (c - r) + F;
									L = (s - p) + u;
									this.modifyNodeSize(E.id, Math.abs(q), Math.abs(L));
									for (var C in this.selectNode) {
										if (C != E.id) {
											this.modifyNodeSize(C, q, L)
										}
									}
								} else {
									if (this.resizeNode) {
										m = E.rotate != null ? E.rotate : 0;
										switch (this.resizeNode) {
											case "ROT":
												m = 180 - (Math.atan2(o - E.x, n - E.y) * 180 / Math.PI);
												q = c;
												L = s;
												r = 0;
												p = 0;
												break;
											case "TL":
												q = I ? (c - r) + F : c - F;
												L = I ? (s - p) + u : s - u;
												r += F / 2;
												p += u / 2;
												break;
											case "TR":
												q = I ? (c - r) + F : c + F;
												L = I ? (s - p) + u : s - u;
												r += F / 2;
												p += u / 2;
												break;
											case "BL":
												q = I ? (c - r) + F : c - F;
												L = I ? (s - p) + u : s + u;
												r += F / 2;
												p += u / 2;
												break;
											case "BR":
												q = I ? (c - r) + F : c + F;
												L = I ? (s - p) + u : s + u;
												r += F / 2;
												p += u / 2;
												break;
											case "TM":
												q = I ? (c - r) + F : c;
												L = I ? (s - p) + u : s - u;
												r = 0;
												p += u / 2;
												break;
											case "BM":
												q = I ? (c - r) + F : c;
												L = I ? (s - p) + u : s + u;
												r = 0;
												p += u / 2;
												break;
											case "ML":
												q = I ? (c - r) + F : c - F;
												L = I ? (s - p) + u : s;
												r += F / 2;
												p = 0;
												break;
											case "MR":
												q = I ? (c - r) + F : c + F;
												L = I ? (s - p) + u : s;
												r += F / 2;
												p = 0;
												break
										}
										P = this.getNodeWidth(E);
										f = this.getNodeHeight(E);
										O = Math.abs(q) / P;
										d = Math.abs(L) / f;
										B = (Math.abs(q) - P) / 2;
										v = (Math.abs(L) - f) / 2
									}
									H = this.findParentNodes(E.id);
									if (this.networkLayoutType != "radial" && ((this.moveParentsWithChildren && !I && !j) || (!this.moveParentsWithChildren && I && j)) && H) {
										E = A.nodes[A.nodeIndices[H[0]]]
									}
									this.modifyXYNode(E.id, r, p);
									if (E.community != null && this.networkConvexHulls[E.community]["nodes"] && j) {
										for (var G = 0; G < this.networkConvexHulls[E.community]["nodes"].length; G++) {
											if (this.networkConvexHulls[E.community]["nodes"][G] != this.moveNodeIndex) {
												var M = A.nodes[this.networkConvexHulls[E.community]["nodes"][G]];
												this.modifyXYNode(M.id, r, p)
											}
										}
									}
									if (m != null) {
										E.rotate = m
									}
									if (this.selectNode && (this.selectNode.hasOwnProperty(E.id) || j)) {
										if (j && !this.selectNode.hasOwnProperty(E.id)) {
											this.addRemoveToSelectedDataPoints([this.moveNodeIndex])
										}
										D[E.id] = true;
										H = this.findChildrenNodeIndices(E.id);
										if (H) {
											for (var G = 0; G < H.length; G++) {
												D[A.nodes[H[G]].id] = true
											}
										}
										for (var C in this.selectNode) {
											if (!D.hasOwnProperty(C)) {
												var M = A.nodes[A.nodeIndices[C]];
												H = this.findParentNodes(M.id);
												if (this.networkLayoutType != "radial" && ((this.moveParentsWithChildren && !I && !j) || (!this.moveParentsWithChildren && I && j)) && H) {
													M = A.nodes[A.nodeIndices[H[0]]]
												}
												if (this.resizeNode) {
													P = this.getNodeWidth(M);
													f = this.getNodeHeight(M);
													switch (this.resizeNode) {
														case "ROT":
															B = 0;
															v = 0;
															break;
														case "TL":
															break;
														case "TR":
															break;
														case "BL":
															break;
														case "BR":
															break;
														case "TM":
															break;
														case "BM":
															break;
														case "ML":
															break;
														case "MR":
															break
													}
													this.modifyXYNode(M.id, -B, -v)
												} else {
													this.modifyXYNode(M.id, r, p)
												}
												D[M.id] = true;
												H = this.findChildrenNodeIndices(M.id);
												if (m != null) {
													M.rotate = m
												}
												if (H) {
													for (var G = 0; G < H.length; G++) {
														D[A.nodes[H[G]].id] = true
													}
												}
											}
										}
									} else {
										this.resetSelectedNodes()
									}
									if (this.resizeNode) {
										this.modifyNodeSize(E.id, Math.abs(q), Math.abs(L));
										for (var C in this.selectNode) {
											if (C != E.id) {
												var M = A.nodes[A.nodeIndices[C]];
												this.modifyNodeSize(C, this.getNodeWidth(M) * O, this.getNodeHeight(M) * d)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		} else {
			this.panningX = F;
			this.panningY = u
		}
		this.skipClick = r != null || p != null ? true : false;
		this.draw(false, false, false, true);
		if (this.is3DNetwork && E) {
			this.moveNodeIndex = A.nodeIndices[E.id]
		}
	};
	this.updateDragGenome = function(a, b) {
		this.functionCaller = "updateDragGenome";
		if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
			return
		}
		if (this.moveGenome) {
			this.movingOn = true;
			var c = this.$(this.target + "-cX-Drag");
			c.style.left = "0px";
			c.style.width = this.width + "px";
			c.style.top = b + "px";
			c.style.height = "3px"
		} else {
			var c = (a - this.xMouseDown) / this.xAxisUnit;
			if (this.setMinX == null) {
				this.setMinX = this.xAxisMin
			}
			if (this.setMaxX == null) {
				this.setMaxX = this.xAxisMax
			}
			this.setMinX -= c;
			this.setMaxX -= c;
			this.draw();
			this.xMouseDown = a
		}
	};
	this.updateDrag = function(x) {
		if (this.draggingOn) {
			if (!x) {
				x = window.event
			}
			if (this.resetOn) {
				this.resetOn = false;
				this.stopEvent(x);
				return
			}
			var u = x.shiftKey || this.shiftKeyMobile;
			var f = x.ctrlKey || this.ctrlKeyMobile;
			var p = x.altKey || this.altKeyMobile;
			var A = this.adjustedCoordinates(x);
			if (A) {
				this.touchEvent = "drag";
				var r = A.x;
				var n = A.y;
				var v = this.layoutValidR;
				var s = this.layoutValidC;
				var z = this.layoutValidN || 0;
				var h = this.layoutComb ? this.layoutParams[z] : this;
				var w = h.graphType;
				if (this.meta.system.isTouchScreen && this.wheelKeyMobile) {
					if (n < this.yMouseDown || r > this.xMouseDown) {
						this.handleWheelEvent(x, 1, A)
					} else {
						this.handleWheelEvent(x, -1, A)
					}
					return false
				} else {
					if (w.match(/Pie|Venn|Stacked|Area|Circular|Treemap|TagCloud/)) {
						if (this.meta.system.isTouchScreen) {
							this.movingOn = true;
							this.resetOn = false
						}
						if (!w.match(/Network|Genome|Venn|Correlation|Scatter/) && this.moveLegend) {
							this.updateDragScatter(r, n);
							this.movingOn = true;
							this.resetOn = false
						} else {
							return false
						}
					}
				}
				if (w.match(/Scatter/) && this.moveLegend) {
					this.updateDragScatter(r, n)
				} else {
					if (!w.match(/Network|Genome|Venn|Correlation|Scatter/) && this.moveLegend) {
						this.updateDragScatter(r, n)
					} else {
						if ((w == "Scatter3D" && !u) || this.is3DPlot) {
							this.updateDragScatter3D(r, n, z, this.xMouseDown, this.yMouseDown)
						} else {
							if (w == "Network" && ((this.moveNode || this.moveLegend) || (!f && !u && !p))) {
								this.updateDragNetwork(x, r, n)
							} else {
								if (w == "Genome" && (this.moveGenome || (!u))) {
									this.updateDragGenome(r, n)
								} else {
									if (this.moveDendrogram) {
										var o = this.getBoundsXY(z);
										var y = this.$(this.target + "-cX-Drag");
										this.skipClick = true;
										if (r >= o[4] && r <= o[5] && n >= o[6] && n <= o[7]) {
											if (this.moveDendrogram == "varDendrogram" || (this.moveDendrogram == "smpDendrogram" && this.graphOrientation == "vertical")) {
												y.style.top = n + "px"
											} else {
												y.style.left = r + "px"
											}
										}
									} else {
										if (this.moveVarOverlay || this.moveSmpOverlay) {
											var o = this.getBoundsXY(z);
											var y = this.$(this.target + "-cX-Drag");
											this.skipClick = true;
											if (r >= o[4] && r <= o[5] && n >= o[6] && n <= o[7]) {
												if (this.moveSmpOverlay) {
													if (w.match(/Heatmap/) || this.graphOrientation == "horizontal") {
														y.style.left = r + "px"
													} else {
														y.style.top = n + "px"
													}
												} else {
													y.style.top = n + "px"
												}
											}
										} else {
											if (this.moveVar || this.moveSmp) {
												var o = this.getBoundsXY(z);
												var y = this.$(this.target + "-cX-Drag");
												this.skipClick = true;
												if (r >= o[4] && r <= o[5] && n >= o[6] && n <= o[7]) {
													if (this.moveSmp) {
														if (w.match(/Heatmap/) || this.graphOrientation == "horizontal") {
															y.style.top = n + "px"
														} else {
															y.style.left = r + "px"
														}
													} else {
														y.style.left = r + "px"
													}
												}
											} else {
												if (this.meta.system.isTouchScreen && this.touches && this.touches.length > 1) {
													return
												}
												var q;
												if (h.varIndicesStart > 0 || h.smpIndicesStart > 0) {
													q = true
												} else {
													if (h.varIndicesStart == 0 && h.startingVarIndices && h.startingVarIndices) {
														if (h.varIndicesStart + h.varIndices.length < h.startingVarIndices.length) {
															q = true
														} else {
															q = false
														}
													} else {
														if (h.smpIndicesStart == 0 && h.startingSmpIndices && h.startingSmpIndices) {
															if (h.smpIndicesStart + (h.isGroupedData ? h.grpIndices.length : h.smpIndices.length) < h.startingSmpIndices.length) {
																q = true
															} else {
																q = false
															}
														} else {
															q = false
														}
													}
												}
												if (w.match(/Heatmap|Bar|Line|Dotplot|Boxplot|Correlation/) && q) {
													this.panningOn = true;
													var m = Math.abs(this.xMouseDown - r);
													var k = Math.abs(this.yMouseDown - n);
													var y = false;
													if (m > k) {
														if (m > this.x / 20) {
															y = this.xMouseDown > r ? 39 : 37;
															this.xMouseDown = r;
															this.yMouseDown = n
														}
													} else {
														if (k > this.y / 20) {
															y = this.yMouseDown > n ? 40 : 38;
															this.xMouseDown = r;
															this.yMouseDown = n
														}
													}
													if (y) {
														this.handlePanning(x, y)
													}
													this.movingOn = true;
													this.resetOn = false;
													return false
												}
												if (w.match(/Correlation/)) {
													return false
												}
												var o = this.getBoundsXY(z);
												var a = w.match(/Scatter|Heatmap|Network|Genome|Circular/);
												var b = this.graphOrientation == "vertical";
												var y = this.$(this.target + "-cX-Drag");
												this.skipClick = true;
												if ((!a && b && !u) || (!a && !b && u)) {
													y.style.width = (o[1] - o[0]) + "px"
												} else {
													if (r > this.xMouseDown) {
														if (r > o[1]) {
															y.style.width = (o[1] - this.xMouseDown) + "px"
														} else {
															y.style.width = (r - this.xMouseDown) + "px"
														}
													} else {
														if (r < o[0]) {
															y.style.left = o[0] + "px";
															y.style.width = (this.xMouseDown - o[0]) + "px"
														} else {
															y.style.left = r + "px";
															y.style.width = (this.xMouseDown - r) + "px"
														}
													}
												}
												if ((!a && !b && !u) || (!a && b && u) || w == "Genome") {
													y.style.height = (o[3] - o[2]) + "px"
												} else {
													if (n > this.yMouseDown) {
														if (n > o[3]) {
															y.style.height = (o[3] - this.yMouseDown) + "px"
														} else {
															y.style.height = (n - this.yMouseDown) + "px"
														}
													} else {
														if (n < o[2]) {
															y.style.top = o[2] + "px";
															y.style.height = (this.yMouseDown - o[2]) + "px"
														} else {
															y.style.top = n + "px";
															y.style.height = (this.yMouseDown - n) + "px"
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			this.movingOn = true;
			this.resetOn = false
		}
	};
	this.endDrag = function(z) {
		this.functionCaller = "endDrag";
		if (this.draggingOn) {
			var b = this.layoutComb ? this.layoutParams[this.layoutValidN || 0].graphType : this.graphType;
			if (b.match(/Venn|Stacked|Area|Treemap|TagCloud/)) {
				return false
			}
			if (!z) {
				z = window.event
			}
			var j = this.$(this.target);
			if (j) {
				j.style.cursor = "default";
				var w = this.getTargetEvent(z);
				if (w && w.style) {
					w.style.cursor = "default"
				}
			}
			this.panningGlobalX += this.panningX;
			this.panningGlobalY += this.panningY;
			this.panningX = 0;
			this.panningY = 0;
			if ((b == "Scatter3D" && !z.shiftKey && !this.shiftKeyMobile) || this.is3DPlot) {
				this.resetDrag(z)
			} else {
				if (b == "Network" && (this.moveNode || this.moveEdge || this.moveLegend)) {
					if (j) {
						if (this.isSelectNodes && this.movingOn) {
							this.resetSelectedNodes();
							this.draw()
						}
						if (this.userEvents.enddragnode && this.movingOn) {
							var m;
							if (this.moveLegend) {
								m = {
									legend: this.moveLegend
								}
							} else {
								var p = this.moveNodeIndex;
								var k = this.findChildrenNodeIndices(this.data.nodes[p].id);
								if (k) {
									k.push(p)
								} else {
									k = [p]
								}
								m = this.extractDataObject(k)
							}
							this.resetDrag(z);
							this.userEvents.enddragnode.call(this, m)
						} else {
							this.resetDrag(z)
						}
						this.addToNetworkStack()
					}
				} else {
					if (b == "Genome" && (this.moveGenome || (!z.shiftKey && !this.shiftKeyMobile))) {
						if (this.movingOn && this.moveGenome) {
							var B = this.adjustedCoordinates(z);
							var C = this.subtracksInfo;
							var D = [];
							if (B) {
								var n = B.y;
								if (n != this.yMouseDown) {
									var A = this.moveGenome.replace("track-", "").split(":");
									var a = parseInt(A[0]);
									var u = A.length > 1 ? parseInt(A[1]) : null;
									for (var v = 0; v < C.length; v++) {
										if (C[v]) {
											var q = C[v].start;
											var h = C[v].track;
											var g = C[v].index;
											if (q > n) {
												if (a != h && a != h - 1) {
													if (h > a) {
														h--
													}
													var o = this.data.tracks.splice(a, 1)[0];
													this.data.tracks.splice(h, 0, o);
													this.draw()
												} else {
													if (u != null) {
														if (a == h - 1) {
															g = C[v - 1].index;
															g++
														}
														u = C[u].index;
														if (u != g) {
															if (g > u) {
																g--
															}
															var o = this.data.tracks[a].data.splice(u, 1)[0];
															this.data.tracks[a].data.splice(g, 0, o);
															this.draw()
														}
													}
												}
												break
											}
										}
									}
								}
							}
						}
						this.resetDrag(z)
					} else {
						if (b.match(/Scatter/) && this.moveLegend) {
							this.resetDrag(z)
						} else {
							if (this.moveLegend) {
								this.resetDrag(z)
							} else {
								if (this.movingOn && !this.panningOn) {
									var B = this.adjustedCoordinates(z);
									if (B) {
										var r = B.x;
										var n = B.y;
										if (r != this.xMouseDown || n != this.yMouseDown) {
											var A = this.$(this.target + "-cX-Drag");
											var y = parseInt(A.style.left);
											var f = parseInt(A.style.top);
											var x = y + parseInt(A.style.width);
											var c = f + parseInt(A.style.height);
											this.handleDragEvent(z, y, f, x, c);
											this.resetDrag(z)
										}
									}
								} else {
									this.resetDrag(z)
								}
							}
						}
					}
				}
			}
		} else {
			this.resetDrag(z)
		}
	};
	this.validateMinMax = function(c, a, d, b) {
		if (!isNaN(c) && !isNaN(a)) {
			if (c > a || d > c || b < a) {
				return false
			}
			return true
		} else {
			return false
		}
	};
	this.handleDragEventNetwork = function(m, c, r, b, p) {
		this.functionCaller = "handleDragEventNetwork";
		var f = {};
		var k = [];
		var v = [];
		var u = [];
		var o = [];
		var q = {};
		for (var j = 0; j < this.dataEvent.length; j++) {
			var g = this.dataEvent[j][0];
			var a = this.dataEvent[j][1];
			var l = this.dataEvent[j][2];
			if (this.isObjectInsideArea(a, l, c, r, b, p)) {
				if (g < this.data.nodes.length) {
					f[g] = 1
				}
			}
		}
		for (var j = 0; j < this.data.nodes.length; j++) {
			if (!f[j]) {
				k.push(this.data.nodes[j].id)
			} else {
				v.push(this.data.nodes[j].id);
				u.push(j)
			}
		}
		if (k.length < this.data.nodes.length) {
			if (m.shiftKey || this.shiftKeyMobile) {
				this.addRemoveToSelectedDataPoints(v, false, true);
				this.isSelectNodes = v.length;
				this.draw();
				this.draggingOn = false;
				this.showInfoSpan(m, "While mouse-over nodes:<br>1. Press Shift and drag mouse to resize nodes<br>2. Drag mouse to move nodes")
			} else {
				this.resetZoomPan();
				this.hideUnhideNodes(k, true);
				this.translateCanvas(-this.offsetX, -this.offsetY);
				this.scaleCanvas(1 / this.scaleFactor, 1 / this.scaleFactor);
				this.draw(false, false, false, true)
			}
			if (this.showDataTableOnSelect) {
				if (this.networkShowDataTable == "edges") {
					for (var j = 0; j < v.length; j++) {
						q[v[j]] = 1
					}
					for (var j = 0; j < this.data.edges.length; j++) {
						if (q[this.data.edges[j].id1] || q[this.data.edges[j].id2]) {
							o.push(this.data.nodes.length + j)
						}
					}
					this.updateDataTable(this.extractDataObject(o))
				} else {
					this.updateDataTable(this.extractDataObject(u))
				}
			}
		}
	};
	this.handleDragEventHeatmap = function(k, m, d, p, a, n) {
		this.functionCaller = "handleDragEventHeatmap";
		var q = [];
		var u = [];
		this.resetAxesResizer();
		var r = this.layoutComb ? this.layoutParams[m] : this;
		var f = this.cloneObject(r.varIndices);
		var l = this.isGroupedData ? this.cloneObject(r.grpIndices) : this.cloneObject(r.smpIndices);
		this.setOriginalIndices(m, f, l);
		r.varIndicesStart = r.varIndicesStart < 0 ? 0 : r.varIndicesStart;
		r.smpIndicesStart = r.smpIndicesStart < 0 ? 0 : r.smpIndicesStart;
		r.varIndices = [];
		if (r.isGroupedData) {
			r.grpIndices = []
		} else {
			r.smpIndices = []
		}
		for (var h = 0; h < this.dataEvent.length; h++) {
			var g = this.dataEvent[h][0];
			var j = this.dataEvent[h][2];
			if ((d < j[0] || d < j[2]) && a > j[0] && (p < j[1] || p < j[3]) && n > j[1]) {
				if (!q[g[0]]) {
					r.varIndices.push(g[0]);
					q[g[0]] = 1
				}
				if (!u[g[1]]) {
					if (r.isGroupedData) {
						r.grpIndices.push(g[1])
					} else {
						r.smpIndices.push(g[1])
					}
					u[g[1]] = 1
				}
			}
		}
		if (r.varIndices.length > 0 && r.smpIndices.length > 0) {
			for (var h = 0; h < f.length; h++) {
				if (f[h] == r.varIndices[0]) {
					r.varIndicesStart += h
				}
			}
			for (var h = 0; h < l.length; h++) {
				if (r.isGroupedData) {
					if (l[h] == r.grpIndices[0]) {
						r.smpIndicesStart += h
					}
				} else {
					if (l[h] == r.smpIndices[0]) {
						r.smpIndicesStart += h
					}
				}
			}
			this.draw();
			if (this.showDataTableOnSelect) {
				var b = this.extractDataObject(this.smpIndices, this.varIndices);
				this.updateDataTable(b)
			}
			this.skipClick = false
		} else {
			this.varIndices = tvi;
			this.smpIndices = tsi;
			this.grpIndices = tgi;
			this.varIndicesStart = tvs;
			this.smpIndicesStart = tss
		}
	};
	this.handleDragEventCorrelation = function(f, b, d, a, c) {
		return this.handleDragEventHeatmap(f, 0, b, d, a, c)
	};
	this.handleDragEventScatter = function(B, C, A, k, y, h) {
		this.functionCaller = "handleDragEventScatter";
		this.selectDataPoint = [];
		this.selectDataPointObject = false;
		this.selectDataPointEvent = B;
		var a = {
			v: {},
			s: {}
		};
		var r = 0;
		var t = false;
		if (B.shiftKey || this.shiftKeyMobile) {
			for (var w = 0; w < this.dataEvent.length; w++) {
				var m = this.dataEvent[w][0];
				var x = this.dataEvent[w][1];
				var l = this.dataEvent[w][2];
				if (m.length > 1) {
					if (this.isObjectInsideArea(x, l, A, k, y, h)) {
						if (!t) {
							t = this.extractDataObject(m)
						} else {
							var p = this.extractDataObject(m);
							t.y.data.push(p.y.data[0]);
							t.y.vars.push(p.y.vars[0])
						}
						this.addRemoveToSelectedDataPoints(m, true);
						a.v[m.shift()] = 1;
						for (var v = 0; v < m.length; v++) {
							a.s[m[v]] = 1
						}
						r++
					}
				}
			}
			if (r > 0) {
				this.isSelectDataPoints = r;
				this.selectDataPointObject = t;
				this.handleUserSelectEvent();
				this.broadcastDraw();
				if (this.showDataTableOnSelect) {
					var u = [];
					var z = [];
					for (w in a.v) {
						u.push(parseInt(w))
					}
					for (w in a.s) {
						z.push(parseInt(w))
					}
					u.sort(function(e, c) {
						return (e - c)
					});
					z.sort(function(e, c) {
						return (e - c)
					});
					var t = this.extractDataObject(z, u);
					this.updateDataTable(t)
				}
			}
		} else {
			var n = this;
			var q = function(e, c) {
				if (n[e + "Transform"]) {
					if (n[e + "Transform"] == "log2") {
						n["setMin" + c] = Math.pow(2, n["setMin" + c]);
						n["setMax" + c] = Math.pow(2, n["setMax" + c])
					} else {
						if (n[e + "Transform"] == "log10") {
							n["setMin" + c] = Math.pow(10, n["setMin" + c]);
							n["setMax" + c] = Math.pow(10, n["setMax" + c])
						} else {
							if (n[e + "Transform"] == "exp2") {
								n["setMin" + c] = Math.log(n["setMin" + c]) / Math.LN2;
								n["setMax" + c] = Math.log(n["setMax" + c]) / Math.LN2
							} else {
								if (n[e + "Transform"] == "exp10") {
									n["setMin" + c] = Math.log(n["setMin" + c]) / Math.LN10;
									n["setMax" + c] = Math.log(n["setMax" + c]) / Math.LN10
								}
							}
						}
					}
				}
			};
			var t = this.layoutComb ? this.layoutParams[C] : this;
			var g = t.xAxisMin + ((A - (this.marginLeft + t.offsetX + t.left)) / t.xAxisUnit);
			var f = t.xAxisMin + ((y - (this.marginLeft + t.offsetX + t.left)) / t.xAxisUnit);
			var b = t.yAxisMax - ((k - (this.marginTop + t.offsetY + t.top)) / t.yAxisUnit);
			var d = t.yAxisMax - ((h - (this.marginTop + t.offsetY + t.top)) / t.yAxisUnit);
			if (this.validateMinMax(g, f, t.xAxisMin, t.xAxisMax) && this.validateMinMax(d, b, t.yAxisMin, t.yAxisMax)) {
				t = this.layoutComb && this.layoutAdjust ? this.layoutParams[C] : this;
				t.setMinX = g;
				t.setMaxX = f;
				t.setMaxY = b;
				t.setMinY = d;
				q("xAxis", "X");
				q("yAxis", "Y");
				this.draw()
			}
		}
	};
	this.handleDragEventGenome = function(f, h, d, j, a, i) {
		this.functionCaller = "handleDragEventGenome";
		var g, k;
		var b = this.layoutComb ? this.layoutParams[h] : this;
		var g = b.xAxisMin + ((d - (this.marginLeft + b.offsetX + b.left)) / b.xAxisUnit);
		var k = b.xAxisMin + ((a - (this.marginLeft + b.offsetX + b.left)) / b.xAxisUnit);
		if (this.validateMinMax(g, k, this.xAxisMin, this.xAxisMax)) {
			this.setMinX = g;
			this.setMaxX = k;
			this.draw()
		}
	};
	this.handleDragEventOneDimension = function(N, P, k, a, j, R, m) {
		this.functionCaller = "handleDragEventOneDimension";
		var C = this.graphType;
		if (this.moveDendrogram) {
			var b = this.layoutComb ? this.layoutParams[P] : this;
			var y;
			if (this.moveDendrogram == "varDendrogram") {
				y = a > this.marginTop + b.offsetY + b.top + b.y ? "bottom" : "top";
				if (this.varDendrogramPosition != y) {
					this.varDendrogramPosition = y;
					this.draw()
				}
			} else {
				if (C == "Heatmap" || this.graphOrientation == "horizontal") {
					y = k > this.marginLeft + b.offsetX + b.left + b.x ? "right" : "left"
				} else {
					y = a > this.marginTop + b.offsetY + b.top + b.y ? "bottom" : "top"
				}
				if (this.smpDendrogramPosition != y) {
					this.smpDendrogramPosition = y;
					this.draw()
				}
			}
			this.skipClick = false
		} else {
			if (this.moveVarOverlay) {
				var b = this.layoutComb ? this.layoutParams[P] : this;
				var A = this.moveVarOverlay.split("-")[1];
				var w = this.varOverlays[A];
				var y = a < this.marginTop + b.offsetY + b.top ? "top" : "bottom";
				this.varOverlays.splice(A, 1);
				var O = this.varOverlays.length;
				for (var I = 0; I < this.varOverlays.length; I++) {
					var H = this.varOverlays[I];
					if (this.varOverlayInfo[H] > a) {
						O = I;
						break
					}
				}
				this.varOverlays.splice(O, 0, w);
				this.varOverlayProperties[w]["position"] = y;
				this.draw();
				this.skipClick = false
			} else {
				if (this.moveVar) {
					var A = this.moveVar.split("-")[1];
					if (this.showVarDendrogram && this.varDendrogram) {
						alert("Ooops. Cannot change order when showing the dendrogram");
						return false
					}
					var M = this.layoutComb ? this.layoutParams[P].varIndices : this.varIndices;
					var L = this.layoutComb ? this.layoutParams[P].varInfo : this.varInfo;
					var O;
					var d = [];
					if (this.moveVar.match(/VarOvr/)) {
						var r = this.moveVar.split("-")[2];
						var h = this.data.z[this.varOverlays[r]];
						for (var I = 0; I < M.length; I++) {
							if (M[I] == A) {
								O = I;
								break
							}
						}
						if (O > 0) {
							while (O > 0 && h[M[O - 1]] == h[M[O]]) {
								O--
							}
						}
						d = [O];
						while (h[M[O + 1]] == h[M[O]]) {
							O++;
							d.push(O)
						}
					} else {
						for (var I = 0; I < M.length; I++) {
							if (M[I] == A) {
								O = I;
								break
							}
						}
						d = [O]
					}
					d = M.splice(d[0], d.length);
					L.splice(d[0], d.length);
					for (var I = 0; I < M.length; I++) {
						if (L[I] > k) {
							O = I;
							break
						}
					}
					for (var I = 0; I < d.length; I++) {
						M.splice(O + I, 0, d[I])
					}
					this.draw();
					this.skipClick = false
				} else {
					if (this.moveSmpOverlay) {
						var q, y;
						var b = this.layoutComb ? this.layoutParams[P] : this;
						var A = this.moveSmpOverlay.split("-")[1];
						var w = this.smpOverlays[A];
						if (C.match(/Heatmap/) || this.graphOrientation == "horizontal") {
							q = k;
							y = q > this.marginLeft + b.offsetX + b.left + b.x ? "right" : "left"
						} else {
							q = a;
							y = q < this.marginTop + b.offsetY + b.top ? "top" : "bottom"
						}
						this.smpOverlays.splice(A, 1);
						var O = this.smpOverlays.length;
						for (var I = 0; I < this.smpOverlays.length; I++) {
							var H = this.smpOverlays[I];
							if (this.smpOverlayInfo[H] > q) {
								O = I;
								break
							}
						}
						this.smpOverlays.splice(O, 0, w);
						this.smpOverlayProperties[w]["position"] = y;
						this.draw();
						this.skipClick = false
					} else {
						if (this.moveSmp) {
							var A = this.moveSmp.split("-")[1];
							var K;
							var f = this.layoutComb ? this.layoutParams[P].smpInfo : this.smpInfo;
							if (this.layoutComb) {
								this.layoutParams[P].dragged = true
							}
							if (this.isGroupedData) {
								K = this.layoutComb ? this.layoutParams[P].grpIndices : this.grpIndices
							} else {
								K = this.layoutComb ? this.layoutParams[P].smpIndices : this.smpIndices;
								if (this.showSmpDendrogram && this.smpDendrogram) {
									alert("Ooops. Cannot change order when showing the dendrogram");
									return false
								}
							}
							var O;
							var d = [];
							if (this.moveSmp.match(/SmpOvr/)) {
								var r = this.moveSmp.split("-")[2];
								var h = this.isGroupedData ? this.data.w.factors[this.smpOverlays[r]] : this.data.x[this.smpOverlays[r]];
								for (var I = 0; I < K.length; I++) {
									if (K[I] == A) {
										O = I;
										break
									}
								}
								if (O > 0) {
									while (O > 0 && h[K[O - 1]] == h[K[O]]) {
										O--
									}
								}
								d = [O];
								while (h[K[O + 1]] == h[K[O]]) {
									O++;
									d.push(O)
								}
							} else {
								for (var I = 0; I < K.length; I++) {
									if (K[I] == A) {
										O = I;
										break
									}
								}
								d = [O]
							}
							d = K.splice(d[0], d.length);
							f.splice(d[0], d.length);
							var q = C.match(/Heatmap/) || this.graphOrientation == "horizontal" ? a : k;
							for (var I = 0; I < K.length; I++) {
								if (f[I] > q) {
									O = I;
									break
								}
							}
							for (var I = 0; I < d.length; I++) {
								K.splice(O + I, 0, d[I])
							}
							this.draw();
							this.skipClick = false
						} else {
							if (N.shiftKey || this.shiftKeyMobile || m) {
								var G = {};
								var l = [];
								var K;
								var M = this.layoutComb ? this.layoutParams[P].varIndices : this.varIndices;
								var J = this.isGroupedData ? this.grpIndices : this.smpIndices;
								var z = false;
								if (this.isGroupedData) {
									K = this.layoutComb ? this.layoutParams[P].grpIndices : this.grpIndices
								} else {
									K = this.layoutComb ? this.layoutParams[P].smpIndices : this.smpIndices
								}
								this.setOriginalIndices(P, M, K);
								for (var I = 0; I < this.dataEvent.length; I++) {
									var x = this.dataEvent[I][0];
									var g = this.dataEvent[I][1];
									var u = this.dataEvent[I][2];
									if (this.isObjectInsideArea(g, u, k, a, j, R)) {
										G[x[1]] = true
									}
								}
								for (var I = 0; I < J.length; I++) {
									if (G.hasOwnProperty(J[I])) {
										l.push(J[I]);
										if (!z) {
											this.smpIndicesStart = I;
											z = true
										}
									}
								}
								this.setSamplesVisible(l, true);
								this.draw();
								if (this.showDataTableOnSelect) {
									var H = this.extractDataObject(l, this.varIndices);
									this.updateDataTable(H)
								}
							} else {
								var H = this.layoutComb ? this.layoutParams[P] : this;
								var F = C == "Candlestick" && P > 0 && this.showVolume;
								var B = this.layoutComb && this.layoutCurrent != P;
								var Q = F && B ? H.xAxis2Min : H.xAxisMin;
								var v = F && B ? H.xAxis2Max : H.xAxisMax;
								var E = this.marginLeft + H.offsetX + H.left;
								var p = E + H.x;
								var D = this.marginTop + H.offsetY + H.top;
								var n = D + H.y;
								if (this.graphOrientation == "vertical") {
									Q = F ? Q + (Math.max(n - R, 0) / H.xAxis2Unit) : Q + (Math.max(n - R, 0) / H.xAxisUnit);
									v = F ? v - (Math.max(a - D, 0) / H.xAxis2Unit) : v - (Math.max(a - D, 0) / H.xAxisUnit)
								} else {
									Q = F ? Q + (Math.max(k - E, 0) / H.xAxis2Unit) : Q + (Math.max(k - E, 0) / H.xAxisUnit);
									v = F ? v - (Math.max(p - j, 0) / H.xAxis2Unit) : v - (Math.max(p - j, 0) / H.xAxisUnit)
								}
								if (this.validateMinMax(Q, v, this.xAxisMin, this.xAxisMax)) {
									H = this.layoutComb && this.layoutAdjust ? this.layoutParams[P] : this;
									if (F) {
										H.setMinX2 = Q;
										H.setMaxX2 = v
									} else {
										H.setMinX = Q;
										H.setMaxX = v
									}
									this.draw()
								}
							}
						}
					}
				}
			}
		}
	};
	this.handleDragEvent = function(h, b, f, a, d) {
		var i = this.layoutComb ? this.layoutValidN : 0;
		var g = this.layoutComb ? this.layoutParams[i].graphType : this.graphType;
		if (g == "Correlation") {
			this.handleDragEventCorrelation(h, b, f, a, d)
		} else {
			if (g == "Network") {
				this.handleDragEventNetwork(h, b, f, a, d)
			} else {
				if (g == "Heatmap" && !this.moveDendrogram && !this.moveVar && !this.moveSmp && !this.moveVarOverlay && !this.moveSmpOverlay) {
					this.handleDragEventHeatmap(h, i, b, f, a, d)
				} else {
					if (g.match(/Scatter/)) {
						this.handleDragEventScatter(h, i, b, f, a, d)
					} else {
						if (g == "Genome") {
							this.handleDragEventGenome(h, i, b, f, a, d)
						} else {
							this.handleDragEventOneDimension(h, i, b, f, a, d)
						}
					}
				}
			}
		}
	};
	this.resetDrag = function(a) {
		var b = this.$(this.target + "-cX-Drag");
		if (b) {
			b.style.left = "0px";
			b.style.top = "0px";
			b.style.width = "0px";
			b.style.height = "0px"
		}
	};
	this.initializeDraggingEvents = function() {
		if (!this.disableEvents) {
			this.addDragDiv()
		}
	};
	this.initializeDraggingEvents()
};
CanvasXpress.prototype.initKeyEvents = function() {
	this.getKeyCode = function(a) {
		if (a) {
			if ((a.charCode) && (a.keyCode == 0)) {
				return a.charCode
			} else {
				return a.keyCode
			}
		}
	};
	this.registerKey = function(g) {
		if (!g) {
			g = window.event
		}
		var b = this.getTargetEvent(g);
		var d = g.shiftKey || this.shiftKeyMobile;
		var f = g.ctrlKey || this.ctrlKeyMobile;
		var a = g.altKey || this.altKeyMobile;
		var h = this.getKeyCode(g);
		if (this.eventKeys || (f && a && h == 107)) {
			if (h == 27) {
				if (this.animationOn) {
					this.animationOn = false;
					return false
				}
				if (f) {
					this.resetFilters()
				}
				this.masterReset(g)
			} else {
				if (h == 16 && this.helpKeyEvents) {
					if (f && a) {
						this.showCtrlShiftAltShorts()
					} else {
						if (f) {
							this.showCtrlShiftShorts()
						} else {
							if (a) {
								this.showShiftAltShorts()
							} else {
								this.showShiftShorts()
							}
						}
					}
				} else {
					if (h == 17 && this.helpKeyEvents) {
						if (d && a) {
							this.showCtrlShiftAltShorts()
						} else {
							if (d) {
								this.showCtrlShiftShorts()
							} else {
								if (a) {
									this.showCtrlAltShorts()
								} else {
									this.showCtrlShorts()
								}
							}
						}
					} else {
						if ((h == 18 || h == 224) && this.helpKeyEvents) {
							if (f && d) {
								this.showCtrlShiftAltShorts()
							} else {
								if (f) {
									this.showCtrlAltShorts()
								} else {
									if (d) {
										this.showShiftAltShorts()
									} else {
										this.showAltShorts()
									}
								}
							}
						} else {
							if (f && d) {
								if (h >= 33 && h <= 40) {
									this.arrowMove(h, true)
								} else {
									if (h == 80 && !this.keyOn) {
										this.keyOn = true;
										this.print()
									} else {
										if (h == 88 && !this.keyOn) {
											this.keyOn = true;
											this.clearNetworkStack()
										} else {
											if (h == 90 && this.graphType == "Network" && !this.keyOn) {
												this.keyOn = true;
												this.alignDistributeSelectedNodes(g, h)
											}
										}
									}
								}
								document.defaultAction = true
							} else {
								if (f && a) {
									if (h == 80 && !this.keyOn) {
										this.keyOn = true;
										this.print()
									} else {
										if (h == 82) {
											this.reproduce()
										}
									}
									document.defaultAction = true
								} else {
									if (d && a) {
										if (h >= 50 && h < 90 && !this.keyOn) {
											this.keyOn = true;
											this.setGraphType(h)
										}
										document.defaultAction = true
									} else {
										if (f) {
											if (h >= 33 && h <= 40) {
												if (h == 36 && this.isSelectDataPoints && this.graphType == "Scatter3D") {
													this.showHideSelectedDataPoint(g, h)
												} else {
													if (h == 36 && this.isSelectNodes && this.graphType == "Network") {
														this.showHideSelectedDataPoint(g, h)
													} else {
														this.arrowMove(h)
													}
												}
											} else {
												if ((h == 45 || h == 46) && !this.keyOn) {
													this.keyOn = true;
													this.showHideSelectedDataPoint(g, h)
												} else {
													if ((h >= 48 && h < 58) && !this.keyOn) {
														this.keyOn = true
													} else {
														if (h >= 65 && h <= 90) {
															if (h == 80 && !this.keyOn) {
																this.keyOn = true;
																this.print()
															}
															if (this.graphType == "Network" && !this.keyOn && !/input|textarea|select/i.test(b.tagName)) {
																this.keyOn = true;
																this.alignDistributeSelectedNodes(g, h)
															}
														}
													}
												}
											}
											document.defaultAction = true
										} else {
											if (h == 107 || h == 109 || h == 61 || h == 187 || h == 189) {
												if (this.eventPlusMinusKeys && !/input|textarea|select/i.test(b.tagName)) {
													if (h == 109 || h == 189) {
														this.handleWheelEvent(g, -1)
													} else {
														this.handleWheelEvent(g, 1)
													}
												}
											} else {
												if (d && h >= 33 && h <= 40) {
													if (this.eventArrowKeys && !/input|textarea|select/i.test(b.tagName)) {
														this.handlePanning(g, h)
													} else {
														document.defaultAction = true
													}
												} else {
													if (h >= 36 && h <= 40) {
														if (this.eventArrowKeys && !/input|textarea|select/i.test(b.tagName)) {
															this.handlePanning(g, h)
														}
													} else {
														if (d) {
															document.defaultAction = true
														} else {
															if (a) {
																document.defaultAction = true
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.handlePanning = function(d, g) {
		this.functionCaller = "handlePanning";
		if (this.graphType == "Correlation" || this.graphType == "Heatmap" || this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/)) {
			this.cancelEvent(d);
			this.resetAxesResizer(d);
			if (this.layoutComb && !this.layoutAdjust && this.graphType != "Correlation" && this.graphType != "Heatmap") {
				return false
			}
			this.setIndicesAfterPannEvent(d, g)
		} else {
			if (this.graphType == "Network") {
				this.cancelEvent(d);
				var a = Math.abs(this.x * this.panningStep);
				var f = Math.abs(this.y * this.panningStep);
				if (g == 33) {
					this.panningY -= f * 5
				} else {
					if (g == 34) {
						this.panningY += f * 5
					} else {
						if (g == 35) {
							this.panningX = a * 20;
							this.panningY = f * 20
						} else {
							if (g == 36) {
								this.panningX = 0;
								this.panningY = 0
							} else {
								if (g == 37) {
									this.panningX -= a
								} else {
									if (g == 38) {
										this.panningY -= f
									} else {
										if (g == 39) {
											this.panningX += a
										} else {
											if (g == 40) {
												this.panningY += f
											}
										}
									}
								}
							}
						}
					}
				}
				this.draw(false, false, false, true)
			} else {
				if (this.graphType == "Genome") {
					var b = this.genomeResolution == "high" ? 1 : this.xAxisRange * this.panningStep;
					if (this.setMinX == null) {
						this.setMinX = this.xAxisMin
					}
					if (this.setMaxX == null) {
						this.setMaxX = this.xAxisMax
					}
					this.cancelEvent(d);
					if (g == 37 || g == 38) {
						this.setMinX -= b;
						this.setMaxX -= b
					} else {
						if (g == 39 || g == 40) {
							this.setMinX += b;
							this.setMaxX += b
						} else {
							if (g == 33) {
								this.setMinX += this.xAxisRange * 0.95;
								this.setMaxX += this.xAxisRange * 0.95
							} else {
								if (g == 34) {
									this.setMinX -= this.xAxisRange * 0.95;
									this.setMaxX -= this.xAxisRange * 0.95
								} else {
									if (g == 35) {
										this.setMaxX = null
									} else {
										if (g == 36) {
											this.setMinX = null
										}
									}
								}
							}
						}
					}
					this.draw()
				}
			}
		}
		return false
	};
	this.showCtrlShiftAltShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Ctrl + Shift + Alt</th></tr>";
		a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showCtrlShiftShorts = function() {
		var b = this.rotationStep;
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Shift + Ctrl</th></tr>";
		if (this.graphType == "Network") {
			if (this.is3DNetwork) {
				a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (b * 3) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (b * 3) + "&deg; continuously</td></tr>"
			} else {
				a += "<tr><td class=k>&rarr; or &darr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>&larr; or &uarr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise " + (b * 3) + "&deg; continuously</td></tr>";
				a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise " + (b * 3) + "&deg; continuously</td></tr>"
			}
		} else {
			if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
				if (this.type2D == "XYZ") {
					if (this.xAxis.length > 1) {
						a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X, Y and Z axes continuously (1x)</td></tr>";
						a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X, Y and Z axes continuously (2x)</td></tr>"
					}
				} else {
					if (this.type2D == "XY") {
						if (this.zAxis.length > 1) {
							a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update sample in Z axis continuously (1x)</td></tr>";
							a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update sample in Z axis continuously (2x)</td></tr>"
						}
					} else {
						if (this.type2D == "X") {
							if (this.yAxis.length > 1) {
								a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in Y and Z axes continuously (1x)</td></tr>";
								a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in Y and Z axes continuously (2x)</td></tr>"
							}
						} else {
							if (this.xAxis.length > 1) {
								a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X and Z axes continuously (1x)</td></tr>";
								a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X and Z axes continuously (2x)</td></tr>"
							}
						}
					}
				}
			} else {
				if (this.graphType == "Scatter3D") {
					a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Rotate continuously</td></tr>";
					a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Rotate continuously</td></tr>"
				}
			}
		}
		a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showCtrlAltShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Ctrl + Alt</th></tr>";
		a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showShiftAltShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Shift + Alt</th></tr>";
		a += "<tr><td class=k>2</td><td class=d>Scatter2D</td></tr>";
		a += "<tr><td class=k>3</td><td class=d>Scatter3D</td></tr>";
		a += "<tr><td class=k>4</td><td class=d>ScatterBubble2D</td></tr>";
		a += "<tr><td class=k>A</td><td class=d>Area</td></tr>";
		a += "<tr><td class=k>B</td><td class=d>Bar</td></tr>";
		a += "<tr><td class=k>C</td><td class=d>BarLine</td></tr>";
		a += "<tr><td class=k>D</td><td class=d>Dotplot</td></tr>";
		a += "<tr><td class=k>E</td><td class=d>DotLine</td></tr>";
		a += "<tr><td class=k>F</td><td class=d>AreaLine</td></tr>";
		a += "<tr><td class=k>G</td><td class=d>Genome</td></tr>";
		a += "<tr><td class=k>H</td><td class=d>Heatmap</td></tr>";
		a += "<tr><td class=k>I</td><td class=d>Boxplot</td></tr>";
		a += "<tr><td class=k>L</td><td class=d>Line</td></tr>";
		a += "<tr><td class=k>M</td><td class=d>Candlestick</td></tr>";
		a += "<tr><td class=k>N</td><td class=d>Network</td></tr>";
		a += "<tr><td class=k>P</td><td class=d>Pie</td></tr>";
		a += "<tr><td class=k>R</td><td class=d>Circular</td></tr>";
		a += "<tr><td class=k>S</td><td class=d>Stacked</td></tr>";
		a += "<tr><td class=k>T</td><td class=d>StackedPercent</td></tr>";
		a += "<tr><td class=k>U</td><td class=d>StackedLine</td></tr>";
		a += "<tr><td class=k>W</td><td class=d>StackedPercentLine</td></tr>";
		a += "<tr><td class=k>V</td><td class=d>Venn</td></tr>";
		a += "<tr><td class=k>X</td><td class=d>Correlation</td></tr>";
		a += "<tr><td class=k>Y</td><td class=d>Treemap</td></tr>";
		a += "<tr><td class=k>Z</td><td class=d>TagCloud</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showCtrlShorts = function() {
		var b = this.rotationStep;
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Ctrl</th></tr>";
		if (this.graphType == "Network") {
			if (this.is3DNetwork) {
				a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (b * 3) + "&deg;</td></tr>";
				a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (b * 3) + "&deg;</td></tr>"
			} else {
				a += "<tr><td class=k>&rarr; or &darr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>&larr; or &uarr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg;</td></tr>";
				a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise " + (b * 3) + "&deg;</td></tr>";
				a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise " + (b * 3) + "&deg;</td></tr>"
			}
			a += "<tr><td class=k>click</td><td class=d>Select/Unselect node</td></tr>";
			if (this.isSelectNodes) {
				a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
				a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>";
				a += "<tr><td class=k>Home</td><td class=d>Show connected nodes to slected nodes</td></tr>";
				a += "<tr><td class=k>t</td><td class=d>Align top</td></tr>";
				a += "<tr><td class=k>r</td><td class=d>Align right</td></tr>";
				a += "<tr><td class=k>b</td><td class=d>Align bottom</td></tr>";
				a += "<tr><td class=k>l</td><td class=d>Align left</td></tr>";
				a += "<tr><td class=k>v</td><td class=d>Distribute verticaly</td></tr>";
				a += "<tr><td class=k>h</td><td class=d>Distribute Horizontaly</td></tr>";
				a += "<tr><td class=k>z</td><td class=d>Undo</td></tr>";
				a += "<tr><td class=k>y</td><td class=d>Redo</td></tr>"
			}
		} else {
			if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
				if (this.type2D == "XYZ") {
					if (this.xAxis.length > 1) {
						a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X, Y and Z axes (1x)</td></tr>";
						a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X, Y and Z axes (2x)</td></tr>"
					}
				} else {
					if (this.type2D == "XY") {
						if (this.zAxis.length > 1) {
							a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update sample in Z axis (1x)</td></tr>";
							a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update sample in Z axis (2x)</td></tr>"
						}
					} else {
						if (this.type2D == "X") {
							if (this.yAxis.length > 1) {
								a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in Y and Z axes (1x)</td></tr>";
								a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in Y and Z axes (2x)</td></tr>"
							}
						} else {
							if (this.xAxis.length > 1) {
								a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X and Z axes (1x)</td></tr>";
								a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X and Z axes (2x)</td></tr>"
							}
						}
					}
				}
				if (this.isSelectDataPoints) {
					a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
					a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>"
				}
			} else {
				if (this.graphType == "Scatter3D") {
					a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (b * 1) + "&deg;</td></tr>";
					a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (b * 1) + "&deg;</td></tr>";
					a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (b * 1) + "&deg;</td></tr>";
					a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (b * 1) + "&deg;</td></tr>";
					a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (b * 3) + "&deg;</td></tr>";
					a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (b * 3) + "&deg;</td></tr>";
					a += "<tr><td class=k>click</td><td class=d>Select/Unselect data points</td></tr>";
					if (this.isSelectDataPoints) {
						a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
						a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>";
						a += "<tr><td class=k>Home</td><td class=d>Zoom to selected nodes</td></tr>"
					}
				} else {
					if (this.isSegregable()) {}
				}
			}
		}
		a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showShiftShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Shift</th></tr>";
		if (this.isSegregable()) {
			a += "<tr><td class=k>Click and Drag</td><td class=d>Select Samples</td></tr>"
		} else {
			a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>"
		}
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.showAltShorts = function() {
		var a = "<table class=shorts>";
		a += "<tr><th colspan=2>Alt</th></tr>";
		a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>";
		a += "</table>";
		this.showInfoSpan(false, a)
	};
	this.arrowMove = function(k, b) {
		this.functionCaller = "arrowMove";
		var f = this.graphType;
		if (this.is3DPlot) {
			f = "Scatter3D"
		}
		var e = this.rotationStep;
		switch (f) {
			case "Network":
				if (this.is3DNetwork) {
					if (k == 33) {
						this.xRotate += (e * 3);
						this.yRotate -= (e * 3)
					} else {
						if (k == 34) {
							this.xRotate -= (e * 3);
							this.yRotate += (e * 3)
						} else {
							if (k == 37) {
								this.xRotate += e
							} else {
								if (k == 38) {
									this.yRotate -= e
								} else {
									if (k == 39) {
										this.xRotate -= e
									} else {
										if (k == 40) {
											this.yRotate += e
										}
									}
								}
							}
						}
					}
				} else {
					if (k == 33) {
						this.network2DRotate -= (e * 3)
					} else {
						if (k == 34) {
							this.network2DRotate += (e * 3)
						} else {
							if (k == 37 || k == 38) {
								this.network2DRotate -= e
							} else {
								if (k == 39 || k == 40) {
									this.network2DRotate += e
								}
							}
						}
					}
				}
				break;
			case "Scatter2D":
			case "ScatterBubble2D":
				var h;
				var j;
				if (this.type2D == "XYZ") {
					h = ["xAxisCurrent", "yAxisCurrent", "zAxisCurrent"];
					j = ["xAxis", "yAxis", "zAxis"]
				} else {
					if (this.type2D == "XY") {
						h = ["zAxisCurrent"];
						j = ["zAxis"]
					} else {
						if (this.type2D == "X") {
							h = ["yAxisCurrent", "zAxisCurrent"];
							j = ["yAxis", "zAxis"]
						} else {
							h = ["xAxisCurrent", "zAxisCurrent"];
							j = ["xAxis", "zAxis"]
						}
					}
				}
				if (k == 33) {
					for (var d = 0; d < h.length; d++) {
						this[h[d]] += 2
					}
				} else {
					if (k == 34) {
						for (var d = 0; d < h.length; d++) {
							this[h[d]] -= 2
						}
					} else {
						if (k == 35) {
							for (var d = 0; d < h.length; d++) {
								this[h[d]] = this[j[d]].length - 1
							}
						} else {
							if (k == 36) {
								for (var d = 0; d < h.length; d++) {
									this[h[d]] = 0
								}
							} else {
								if (k == 37 || k == 40) {
									for (var d = 0; d < h.length; d++) {
										this[h[d]]--
									}
								} else {
									if (k == 38 || k == 39) {
										for (var d = 0; d < h.length; d++) {
											this[h[d]]++
										}
									}
								}
							}
						}
					}
				}
				this.xAxisCurrent = this.xAxisCurrent < 0 ? this.xAxis.length - 1 : this.xAxisCurrent > this.xAxis.length - 1 ? 0 : this.xAxisCurrent;
				this.yAxisCurrent = this.yAxisCurrent < 0 ? this.xAxis.length - 1 : this.yAxisCurrent > this.yAxis.length - 1 ? 0 : this.yAxisCurrent;
				this.zAxisCurrent = this.zAxisCurrent < 0 ? this.xAxis.length - 1 : this.zAxisCurrent > this.zAxis.length - 1 ? 0 : this.zAxisCurrent;
				break;
			case "Scatter3D":
				if (k == 33) {
					this.xRotate += (e * 3);
					this.yRotate -= (e * 3)
				} else {
					if (k == 34) {
						this.xRotate -= (e * 3);
						this.yRotate += (e * 3)
					} else {
						if (k == 35) {
							this.xRotate = 0;
							this.yRotate = 0;
							this.zRotate = 45
						} else {
							if (k == 36) {
								this.xRotate = 45;
								this.yRotate = 0;
								this.zRotate = 0
							} else {
								if (k == 37) {
									this.xRotate += e
								} else {
									if (k == 38) {
										this.yRotate -= e
									} else {
										if (k == 39) {
											this.xRotate -= e
										} else {
											if (k == 40) {
												this.yRotate += e
											}
										}
									}
								}
							}
						}
					}
				}
				break
		}
		if (b && !this.animationOn) {
			this.animationOn = true;
			this.animate(k)
		} else {
			this.draw(false, false, false, true)
		}
	};
	this.animate = function(d) {
		var a = this;
		var b = function() {
			this.update = function() {
				if (!a.animationOn) {
					clearInterval(c)
				}
				a.arrowMove(d);
				var f = a.graphType;
				if (a.is3DPlot) {
					f = "Scatter3D"
				}
				var e = this.rotationStep;
				switch (f) {
					case "Network":
						if (this.is3DNetwork) {
							if (d == 33) {
								this.xRotate += (e * 3);
								this.yRotate -= (e * 3)
							} else {
								if (d == 34) {
									this.xRotate -= (e * 3);
									this.yRotate += (e * 3)
								} else {
									if (d == 37) {
										this.xRotate -= e
									} else {
										if (d == 38) {
											this.yRotate -= e
										} else {
											if (d == 39) {
												this.xRotate += e
											} else {
												if (d == 40) {
													this.yRotate += e
												}
											}
										}
									}
								}
							}
						} else {
							if (d == 33) {
								this.network2DRotate += (e * 3)
							} else {
								if (d == 34) {
									this.network2DRotate -= (e * 3)
								} else {
									if (d == 37 || d == 38) {
										this.network2DRotate -= e
									} else {
										if (d == 39 || d == 40) {
											this.network2DRotate += e
										}
									}
								}
							}
						}
						break;
					case "Scatter2D":
					case "ScatterBubble2D":
						if (d != 37) {
							if (a.graphType == "ScatterBubble2D" && a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length && a.xAxisIndices.length == a.zAxisIndices.length) {
								if (a.xAxisCurrent >= a.xAxis.length - 1) {
									a.xAxisCurrent = a.xAxis.length - 1;
									a.yAxisCurrent = a.yAxis.length - 1;
									a.zAxisCurrent = a.zAxis.length - 1;
									d = 37
								}
							} else {
								if (a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length) {
									if (a.zAxisCurrent >= a.zAxis.length - 1) {
										a.zAxisCurrent = a.zAxis.length - 1;
										d = 37
									}
								} else {
									if (a.xAxisIndices.length > a.yAxisIndices.length) {
										if (a.yAxisCurrent >= a.yAxis.length - 1) {
											a.yAxisCurrent = a.yAxis.length - 1
										}
										if (a.zAxisCurrent >= a.zAxis.length - 1) {
											a.zAxisCurrent = a.zAxis.length - 1
										}
										if (a.yAxisCurrent >= a.yAxis.length - 1 && a.zAxisCurrent >= a.zAxis.length - 1) {
											d = 37
										}
									} else {
										if (a.xAxisCurrent >= a.xAxis.length - 1) {
											a.xAxisCurrent = a.xAxis.length - 1
										}
										if (a.zAxisCurrent >= a.zAxis.length - 1) {
											a.zAxisCurrent = a.zAxis.length - 1
										}
										if (a.xAxisCurrent >= a.xAxis.length - 1 && a.zAxisCurrent >= a.zAxis.length - 1) {
											d = 37
										}
									}
								}
							}
						} else {
							if (d != 39) {
								if (a.graphType == "ScatterBubble2D" && a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length && a.xAxisIndices.length == a.zAxisIndices.length) {
									if (a.xAxisCurrent <= 0) {
										a.xAxisCurrent = 0;
										a.yAxisCurrent = 0;
										a.zAxisCurrent = 0;
										d = 39
									}
								} else {
									if (a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length) {
										if (a.zAxisCurrent <= 0) {
											a.zAxisCurrent = 0;
											d = 39
										}
									} else {
										if (a.xAxisIndices.length > a.yAxisIndices.length) {
											if (a.yAxisCurrent <= 0) {
												a.yAxisCurrent = 0
											}
											if (a.zAxisCurrent <= 0) {
												a.zAxisCurrent = 0
											}
											if (a.yAxisCurrent <= 0 && a.zAxisCurrent <= 0) {
												d = 39
											}
										} else {
											if (a.xAxisCurrent <= 0) {
												a.xAxisCurrent = 0
											}
											if (a.zAxisCurrent <= 0) {
												a.zAxisCurrent = 0
											}
											if (a.xAxisCurrent <= 0 && a.zAxisCurrent <= 0) {
												d = 39
											}
										}
									}
								}
							}
						}
						break;
					case "Scatter3D":
						if (a.xRotate <= 0 && (d == 39 || d < 37)) {
							a.xRotate = 0;
							a.yRotate = 0;
							d = 40
						} else {
							if (a.xRotate >= 90 && (d == 37 || d < 37)) {
								a.xRotate = 90;
								a.yRotate = 90;
								d = 38
							} else {
								if (a.yRotate <= 0 && (d == 38 || d < 37)) {
									a.yRotate = 0;
									a.xRotate = 90;
									d = 39
								} else {
									if (a.yRotate >= 90 && (d == 40 || d < 37)) {
										a.yRotate = 90;
										a.xRotate = 0;
										d = 37
									}
								}
							}
						}
						break
				}
			};
			var c = setInterval(this.update, a.animationTime)
		};
		b.call()
	};
	this.setGraphType = function(b) {
		this.functionCaller = "setGraphType";
		var a;
		if (b == 66) {
			a = "Bar"
		} else {
			if (b == 76) {
				a = "Line"
			} else {
				if (b == 65) {
					a = "Area"
				} else {
					if (b == 70) {
						a = "AreaLine"
					} else {
						if (b == 67) {
							a = "BarLine"
						} else {
							if (b == 73) {
								a = "Boxplot"
							} else {
								if (b == 68) {
									a = "Dotplot"
								} else {
									if (b == 69) {
										a = "DotLine"
									} else {
										if (b == 72) {
											a = "Heatmap"
										} else {
											if (b == 83) {
												a = "Stacked"
											} else {
												if (b == 85) {
													a = "StackedLine"
												} else {
													if (b == 84) {
														a = "StackedPercent"
													} else {
														if (b == 87) {
															a = "StackedPercentLine"
														} else {
															if (b == 50) {
																a = "Scatter2D"
															} else {
																if (b == 52) {
																	a = "ScatterBubble2D"
																} else {
																	if (b == 51) {
																		a = "Scatter3D"
																	} else {
																		if (b == 88) {
																			a = "Correlation"
																		} else {
																			if (b == 86) {
																				a = "Venn"
																			} else {
																				if (b == 80) {
																					a = "Pie"
																				} else {
																					if (b == 78) {
																						a = "Network"
																					} else {
																						if (b == 71) {
																							a = "Genome"
																						} else {
																							if (b == 77) {
																								a = "Candlestick"
																							} else {
																								if (b == 82) {
																									a = "Circular"
																								} else {
																									if (b == 89) {
																										a = "Treemap"
																									} else {
																										if (b == 90) {
																											a = "TagCloud"
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (a && this.isValidGraphType(a)) {
			this.graphType = a;
			this.draw()
		} else {
			alert("Dude! You cannot plot this data in a " + a + " graph")
		}
	};
	this.reset = function(a) {
		this.varIndicesStart = -1;
		this.smpIndicesStart = -1;
		switch (this.graphType) {
			case "Area":
			case "AreaLine":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Heatmap":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Bar":
			case "Line":
			case "BarLine":
			case "Boxplot":
			case "Dotplot":
			case "DotLine":
			case "Candlestick":
			case "Circular":
			case "Treemap":
			case "TagCloud":
				this.setAllVariablesVisible(false, a);
				this.setAllSamplesVisible(false, a);
				break;
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Scatter3D":
				this.resetSelectedDataPoints();
				this.setAllVariablesVisible(false, a);
				this.setAllSamplesVisible(false, a);
				break;
			case "Network":
				this.resetSelectedNodes();
				this.setAllNodesVisible();
				this.translateCanvas(-this.offsetX, -this.offsetY);
				this.scaleCanvas(1 / this.scaleFactor, 1 / this.scaleFactor);
				break;
			case "Genome":
				this.setAllFeaturesVisible(a);
				break
		}
	};
	this.redraw = function(a) {
		this.functionCaller = "redraw";
		this.varIndicesStart = -1;
		this.smpIndicesStart = -1;
		switch (this.graphType) {
			case "Area":
			case "AreaLine":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Circular":
			case "Treemap":
			case "TagCloud":
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				break;
			case "Bar":
			case "Line":
			case "BarLine":
			case "Boxplot":
			case "Dotplot":
			case "DotLine":
			case "Genome":
			case "Candlestick":
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				this.resetRange();
				this.xRotate = 45;
				this.yRotate = 0;
				break;
			case "Scatter2D":
			case "ScatterBubble2D":
				this.resetSelectedDataPoints();
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				this.resetRange();
				break;
			case "Scatter3D":
				this.resetSelectedDataPoints();
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				this.xRotate = 45;
				this.yRotate = 0;
				break;
			case "Heatmap":
				this.setAllVariablesVisible();
				this.setAllSamplesVisible();
				break;
			case "Network":
				this.resetSelectedNodes();
				this.setAllNodesVisible();
				this.network2DRotate = 0;
				if (this.randomData) {
					this.layoutDone = true
				}
				this.translateCanvas(-this.offsetX, -this.offsetY);
				this.scaleCanvas(1 / this.scaleFactor, 1 / this.scaleFactor);
				break
		}
		this.setInitialConfig();
		this.draw();
		return true
	};
	this.resetZoomPan = function() {
		this.zoom = 1;
		this.panningX = 0;
		this.panningY = 0;
		this.panningGlobalX = 0;
		this.panningGlobalY = 0;
		this.padX = this.x / 2;
		this.padY = this.y / 2;
		this.padZ = this.y / 2
	};
	this.resetSelectedObjects = function() {
		this.functionCaller = "resetSelectedObjects";
		if (this.isSelectDataPoints || this.isSelectNodes) {
			this.resetSelectedDataPoints();
			this.resetSelectedNodes();
			this.draw()
		}
	};
	this.resetRange = function() {
		var a = this.layoutComb && this.layoutAdjust && this.layoutValidN != null ? this.layoutParams[this.layoutValidN] : this;
		a.setMinX = null;
		a.setMaxX = null;
		a.setMinX2 = null;
		a.setMaxX2 = null;
		a.setMinY = null;
		a.setMaxY = null
	};
	this.masterReset = function(f) {
		if (this.isDOE) {
			this.resetDOE()
		} else {
			var c = f && (f.shiftKey || this.shiftKeyMobile || f.ctrlKey || this.ctrlKeyMobile || f.altKey || this.altKeyMobile || f.metaKey);
			var a = this.broadcast && c ? CanvasXpress.instances : [this];
			for (var b = 0; b < a.length; b++) {
				var d = a[b];
				d.resetTooltipDivs();
				d.resetDrag(f);
				d.resetSelectedDataPoints();
				d.resetSelectedNodes();
				if (d.dataTableLastState && d.dataTableLastState != "docked") {
					d.hideUnhideDataTable(true)
				}
				d.resetConfigurator();
				d.resetAxesResizer(f);
				d.resetFlags(f);
				d.resetZoomPan();
				if (this.isOncoprint) {
					d.sortIndices("onc", "desc");
					d.zoomOncoprintVariables(50)
				} else {
					d.redraw(f)
				}
			}
		}
	}
};
CanvasXpress.prototype.initSelectEvents = function() {
	this.showHideSelectedDataPoint = function(k, m, g) {
		this.functionCaller = "showHideSelectedDataPoint";
		if (k) {
			this.stopEvent(k)
		}
		var p = this.layoutComb ? this.layoutValidN : 0;
		var s = this.layoutComb ? this.layoutParams[p].graphType : this.graphType;
		var r = [];
		if (m == 45 || m == 46) {
			if (s == "Network") {
				var a = [];
				var l = m == 45 ? false : true;
				for (var d in this.selectNode) {
					a.push(d)
				}
				if (a.length > 0) {
					this.hideUnhideNodes(a, l)
				}
			} else {
				if (s.match(/Scatter/)) {
					if (m == 45) {
						this.selectDataPoint = this.hideDataPoint;
						this.hideDataPoint = []
					} else {
						if (m == 46) {
							this.hideDataPoint = this.selectDataPoint;
							this.selectDataPoint = []
						}
					}
					if (s == "Scatter3D") {
						var o = this.xAxisIndex + ":" + this.yAxisIndex + ":" + this.zAxisIndex;
						for (var h = 0; h < this.data.y.vars.length; h++) {
							if (this.isVisibleSelectedDataPoint(h, o)) {
								r.push(h)
							}
						}
						this.varIndices = r
					}
				}
			}
			if (!g) {
				this.draw()
			}
		} else {
			if (m == 36 || m == 1000) {
				if (s == "Network") {
					var b = {};
					var j = [];
					var a = this.data.nodes;
					var f = this.data.edges;
					for (var h = 0; h < f.length; h++) {
						if (m == 1000) {
							if (this.selectNode.hasOwnProperty(f[h].id1) && this.selectNode.hasOwnProperty(f[h].id2)) {
								b[f[h].id1] = true;
								b[f[h].id2] = true
							}
						} else {
							if (this.selectNode.hasOwnProperty(f[h].id1) || this.selectNode.hasOwnProperty(f[h].id2)) {
								b[f[h].id1] = true;
								b[f[h].id2] = true
							}
						}
					}
					for (var h = 0; h < a.length; h++) {
						if (!b.hasOwnProperty(a[h].id) || a[h].hide) {
							j.push(a[h].id)
						}
					}
					this.resetSelectedNodes();
					if (j.length > 0) {
						this.hideUnhideNodes(j, true);
						if (!g) {
							this.draw()
						}
					}
				} else {
					if (s == "Scatter3D") {
						if (this.isSelectDataPoints) {
							for (var h in this.selectDataPoint) {
								var q = parseInt(h);
								if (!isNaN(q)) {
									r.push(this.varIndices[q])
								}
							}
							this.isSelectDataPoints = 0;
							this.selectDataPoint = [];
							this.varIndices = r;
							if (!g) {
								this.draw()
							}
						}
					}
				}
			}
		}
	};
	this.addRemoveToSelectedDataPointsHistogram = function(e) {
		var g = this[e.h.a].cntx[e.h.d];
		var a = g[0];
		var f = g[1];
		var b = this[e.h.a].hist[e.h.b][e.h.c - 1];
		for (var d = 0; d < b.length; d++) {
			this.addRemoveToSelectedDataPoints([b[d], a, f], true)
		}
		this.broadcastDraw()
	};
	this.broadcastDraw = function() {
		this.functionCaller = "broadcastDraw";
		var a = this.broadcast ? CanvasXpress.instances : [this];
		for (var b = 0; b < a.length; b++) {
			a[b].draw()
		}
	};
	this.addRemoveToSelectedDataPoints = function(a, f, l) {
		this.functionCaller = "addRemoveToSelectedDataPoints";
		var k = this.layoutComb ? this.layoutValidN : 0;
		if (k !== null && k !== false) {
			var m = this.broadcast ? CanvasXpress.instances : [this];
			var p = this.layoutComb ? this.layoutParams[k].graphType : this.graphType;
			var j = this.addRemoveToSelectedDataPointsToNames(p, a, l);
			for (var g = 0; g < m.length; g++) {
				var e = m[g];
				var d = e.layoutComb ? e.layoutParams[0].graphType : e.graphType;
				if (d == "Network") {
					this.addRemoveToSelectedDataPointsNodes(e, j[0]);
					var o = true
				} else {
					if (d == "Circular") {} else {
						if (d == "Venn") {} else {
							if (d == "Genome") {} else {
								if (d == "Correlation") {} else {
									if (p == "Scatter2D" && this.isHistogram) {
										var b = e.getVariableIndices(j[0], true);
										var h = e.getSampleIndices(j[1], false, true);
										var n = h && h.length > 0 ? h.join(":") : "";
										var o = b && b.length > 0 ? true : false;
										if (o) {
											this.addRemoveToSelectedDataPointsData(e, b, n)
										}
									} else {
										var b = e.getVariableIndices(j[0]);
										var h = e.getSampleIndices(j[1]);
										var n = h && h.length > 0 ? h.join(":") : "";
										var o = b && b.length > 0 ? true : false;
										if (o) {
											this.addRemoveToSelectedDataPointsData(e, b, n)
										}
									}
								}
							}
						}
					}
				}
				if (!f && o) {
					e.draw()
				}
			}
		}
	};
	this.addRemoveToSelectedDataPointsToNames = function(q, a, o) {
		var t = this.data.y;
		if (q == "Network") {
			var l = this.data.nodes;
			if (o) {
				return [a, []]
			} else {
				var b = parseInt(a.join(", "));
				if (b < l.length) {
					return [
						[l[b].id],
						[]
					]
				}
			}
		} else {
			if (q == "Pie") {
				var u, n, c;
				if (a.length > 2) {
					u = 1;
					n = a.length;
					c = a[0]
				} else {
					u = 0;
					n = 1;
					c = a[1]
				}
				var f = [];
				var h = [];
				if (this.dataStndBy) {
					var m = this.dataStndBy.y;
					for (var g = u; g < n; g++) {
						f.push(m.vars[a[g]])
					}
					for (var g = 0; g < c.length; g++) {
						h.push(m.smps[c[g]])
					}
				} else {
					for (var g = u; g < n; g++) {
						f.push(t.vars[a[g]])
					}
					for (var g = 0; g < c.length; g++) {
						h.push(t.smps[c[g]])
					}
				}
				return [f, h]
			} else {
				if (q == "Circular") {} else {
					if (q == "Venn") {} else {
						if (q == "Genome") {} else {
							if (q == "Correlation") {} else {
								if (q == "Scatter2D" && this.isHistogram) {
									var m = this.dataStndBy.y;
									var p = a[1] - 1;
									var r = t.histogram[a[0]][p];
									var f = [];
									for (var d = 0; d < r.length; d++) {
										f.push(m.vars[r[d]])
									}
									return [f, [m.smps[p]]]
								} else {
									var h = [];
									if (q.match(/Scatter/)) {
										if (q == "Scatter3D") {
											h.push(t.smps[a[1]]);
											h.push(t.smps[a[2]]);
											h.push(t.smps[a[3]])
										} else {
											h.push(t.smps[a[1]]);
											h.push(t.smps[a[2]])
										}
									} else {
										h.push(t.smps[a[1]])
									}
									return [
										[t.vars[a[0]]], h
									]
								}
							}
						}
					}
				}
			}
		}
	};
	this.addRemoveToSelectedDataPointsNodes = function(c, b) {
		for (var a = 0; a < b.length; a++) {
			var d = b[a];
			if (!c.selectNode) {
				c.selectNode = {};
				c.isSelectNodes = 0
			}
			if (c.selectNode.hasOwnProperty(d)) {
				c.isSelectNodes--;
				delete(c.selectNode[d])
			} else {
				c.isSelectNodes++;
				c.selectNode[d] = true
			}
		}
	};
	this.addRemoveToSelectedDataPointsData = function(c, d, b) {
		for (var a = 0; a < d.length; a++) {
			if (this.broadcastType == "var") {
				if (c.selectDataPoint[d[a]]) {
					delete(c.selectDataPoint[d[a]]);
					c.isSelectDataPoints--
				} else {
					c.selectDataPoint[d[a]] = true;
					c.isSelectDataPoints++
				}
			} else {
				if (b) {
					if (!c.selectDataPoint[d[a]]) {
						c.selectDataPoint[d[a]] = {}
					}
					if (c.selectDataPoint[d[a]].hasOwnProperty(b)) {
						c.isSelectDataPoints--;
						delete(c.selectDataPoint[d[a]][b])
					} else {
						c.isSelectDataPoints++;
						c.selectDataPoint[d[a]][b] = true
					}
				}
			}
		}
	};
	this.handleUserSelectEvent = function() {
		var c = this.userEvents;
		var d = this.selectDataPointObject;
		var b = this.selectDataPointEvent;
		var a = this.selectDataPoint;
		if (c.select) {
			if (typeof(c.select) == "object" && c.select.handler && c.select.scope) {
				c.select.handler.apply(c.select.scope, [d, b, this, a])
			} else {
				if (typeof(c.select) == "object" && c.select.handler) {
					c.select.handler(d, b, this, a)
				} else {
					c.select(d, b, this, a)
				}
			}
		}
	};
	this.resetSelectedDataPoints = function() {
		if (this.isSelectDataPoints) {
			this.selectDataPoint = [];
			this.selectDataPointObject = false;
			this.selectDataPointEvent = false;
			this.hideDataPoint = [];
			this.isSelectDataPoints = 0
		}
	};
	this.resetSelectedNodes = function() {
		if (this.isSelectNodes) {
			this.selectNode = {};
			this.isSelectNodes = 0
		}
	}
};
CanvasXpress.prototype.initDendrogramEvents = function() {
	this.zoomDendrogram = function(e) {
		this.functionCaller = "zoomDendrogram";
		var q = this.layoutComb ? this.layoutParams[e.t.c || 0] : this;
		var h = q.varIndices;
		var n = q.isGroupedData ? q.grpIndices : q.smpIndices;
		this.setOriginalIndices(c, h, n);
		var d = false;
		var k = this[e.t.t].object;
		var b = e.t.d + "-" + e.t.o;
		var m = this.findDendrogramBranch(k, b);
		var f = this.findDendrogramIndices(e.t.t, m);
		var g = f[0];
		var a = f[1];
		if (e.t.t == "varDendrogram") {
			q.varIndices = [];
			for (var j = 0; j < q.startingVarIndices.length; j++) {
				if (q.startingVarIndices[j] == g) {
					q.varIndicesStart = j;
					d = true
				} else {
					if (q.startingVarIndices[j] == a) {
						q.varIndices.push(q.startingVarIndices[j]);
						break
					}
				}
				if (d) {
					q.varIndices.push(q.startingVarIndices[j])
				}
			}
		} else {
			q.smpIndices = [];
			for (var j = 0; j < q.startingSmpIndices.length; j++) {
				if (q.startingSmpIndices[j] == g) {
					q.smpIndicesStart = j;
					d = true
				} else {
					if (q.startingSmpIndices[j] == a) {
						q.smpIndices.push(q.startingSmpIndices[j]);
						break
					}
				}
				if (d) {
					q.smpIndices.push(q.startingSmpIndices[j])
				}
			}
		}
		this.draw()
	};
	this.modifyDendrogram = function(h) {
		this.functionCaller = "modifyDendrogram";
		if (!h || !h.t || !h.t.t) {
			return false
		}
		this.setOriginalIndices();
		this.clusterAxis = h.t.t == "varDendrogram" ? "variables" : "samples";
		var d = h.t.t.replace("Dendrogram", "s");
		var g = this[h.t.t].object;
		var i = h.t.d + "-" + h.t.o;
		var f = this.findDendrogramBranch(g, i);
		var b = this.reverseDendrogramBranch(f);
		var e = this.findDendrogramIndices(h.t.t, f);
		var a = this.writeNewick(g, true);
		this.data.t[d] = a;
		this.reorderOriginalIndices(h.t.c || 0, h.t.t, e);
		this.draw()
	};
	this.findDendrogramBranch = function(b, d, a) {
		if (b.id == d) {
			a = b
		}
		if (!a) {
			if (b.left) {
				a = this.findDendrogramBranch(b.left, d, a)
			}
			if (b.right) {
				a = this.findDendrogramBranch(b.right, d, a)
			}
		} else {
			return a
		}
		return a
	};
	this.findDendrogramIndices = function(d, g) {
		var b, e;
		var f = g.left;
		var a = g.right;
		while (f.left) {
			b = f.id;
			f = f.left
		}
		b = f.id;
		while (a.right) {
			e = a.id;
			a = a.right
		}
		e = a.id;
		if (d == "varDendrogram") {
			b = this.getVariableIndices(b);
			e = this.getVariableIndices(e)
		} else {
			b = this.getSampleIndices(b);
			e = this.getSampleIndices(e)
		}
		return [b, e]
	};
	this.reverseDendrogramBranch = function(b) {
		if (b && b.right && b.left) {
			b.right = this.reverseDendrogramBranch(b.right);
			b.left = this.reverseDendrogramBranch(b.left);
			var a = b.left;
			b.left = b.right;
			b.right = a;
			if (b.mid) {
				b.mid = b.mid.reverse()
			}
		}
		return b
	}
};
CanvasXpress.prototype.initCanvasEvents = function() {
	this.contextmenuCanvas = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			if (c) {
				if (a.Ext && a.Ext.contextmenu) {
					return
				} else {
					a.cancelEvent(c);
					var b = a.getEventDataId(c);
					a.handleMouseEvents(c, "contextmenu", b)
				}
			}
			return false
		}
	}(this);
	this.mousedownCanvas = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			if (c && c.which ? c.which != 3 : c.button != 2) {
				if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
					a.touchEvent = "hold";
					var b = function() {
						clearTimeout(b);
						if (a.meta.system.isTouchScreen && a.touches && a.touches.length == 1 && a.touchEvent == "hold") {
							a.masterReset(c)
						}
					};
					setTimeout(b, 1000);
					if (a.meta.system.isTouchScreen && c.type == "touchstart") {
						if (c.preventDefault) {
							c.preventDefault()
						} else {
							c.returnValue = false
						}
						if (a.wheelKeyMobile || a.mouseKeyMobile) {
							a.registerDrag(c)
						}
					} else {
						a.registerDrag(c)
					}
				}
			}
			return false
		}
	}(this);
	this.clickCanvas = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.isIE) {
				b = a.copyEvent(b)
			}
			a.resetMenus();
			a.resetLinks();
			a.closeHelp();
			a.clickBuffer = function() {
				if (!a.doubleClick) {
					if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
						if (!a.skipClick && (a.lastCanvasEvent != "drag")) {
							if (a.isHelp(b)) {
								a.stopEvent(b);
								a.showInfoSpan(b, 'Modify "helpKeyEvents"<br>&nbsp;&nbsp;&nbsp;to show or hide help<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on key events"')
							} else {
								if (a.isAxis(b)) {
									a.stopEvent(b)
								} else {
									if (a.axesResizerShow && !a.resizerType) {
										a.stopEvent(b);
										a.resetAxesResizer(b)
									} else {
										if (a.mobileApp) {
											a.stopEvent(b);
											a.addConfigurator(b)
										} else {
											var c = a.getEventDataId(b);
											if (c) {
												a.handleMouseEvents(b, "click", c)
											} else {
												if (!b.ctrlKey && !this.ctrlKeyMobile) {
													a.resetSelectedObjects()
												}
											}
										}
									}
								}
							}
						}
					} else {
						a.resetConfigurator()
					}
					a.lastCanvasEvent = "click"
				}
			};
			setTimeout(a.clickBuffer, 250);
			setTimeout(function() {
				a.doubleClick = false
			}, 500)
		}
	}(this);
	this.dblclickCanvas = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			a.doubleClick = true;
			if (a.clickBuffer) {
				clearTimeout(a.clickBuffer);
				a.clickBuffer = null
			}
			if (!a.skipClick) {
				var b = a.getEventDataId(c);
				if (b) {
					a.handleMouseEvents(c, "dblclick", b)
				} else {
					a.cancelEvent(c);
					a.addConfigurator(c)
				}
				a.lastCanvasEvent = "dblclick"
			}
			return false
		}
	}(this);
	this.wheelCanvas = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.lastWheel) {
				if (new Date().getTime() - a.lastWheel < 20) {
					a.cancelEvent(b);
					return false
				}
			}
			a.lastWheel = new Date().getTime();
			var c = 0;
			if (!b) {
				b = window.event
			}
			if (b.wheelDelta) {
				c = b.wheelDelta / 120;
				if (window.opera) {
					c = -c
				}
			} else {
				if (b.detail) {
					c = -b.detail / 3
				}
			}
			if (c) {
				a.handleWheelEvent(b, c)
			}
		}
	}(this);
	this.addRemoveCanvasListeners = function(a) {
		var b = this.meta.canvas.ctx.canvas;
		this[a](b, "contextmenu", this.contextmenuCanvas, false);
		this[a](b, "mousedown", this.mousedownCanvas, false);
		this[a](b, "touchstart", this.mousedownCanvas, false);
		this[a](b, "click", this.clickCanvas, false);
		this[a](b, "dblclick", this.dblclickCanvas, false);
		this[a](b, "mousewheel", this.wheelCanvas, false)
	};
	this.isVersion = function(b) {
		if (this.showVersion) {
			var a = this.adjustedCoordinates(b);
			return a && a.x > 0 && a.x <= 10 && a.y > 0 && a.y <= 10 ? true : false
		}
	};
	this.isHelp = function(b) {
		var a = this.adjustedCoordinates(b);
		return a && a.x > 0 && a.x <= 10 && a.y > 0 && a.y <= 10 ? true : false
	};
	this.handleWheelEvent = function(i, j, m) {
		this.functionCaller = "handleWheelEvent";
		var b = this.getTargetEvent(i);
		if (/CanvasXpress/.test(b.className)) {
			CanvasXpress.current = b.id
		}
		if (this.graphType == "Correlation" || this.graphType == "Heatmap" || (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/) && !this.is3DPlot)) {
			this.cancelEvent(i);
			this.resetAxesResizer(i);
			if (this.layoutComb && !this.layoutAdjust && this.graphType != "Correlation" && this.graphType != "Heatmap") {
				return false
			}
			this.setIndicesAfterWheelEvent(i, j)
		} else {
			if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D" || this.graphType == "Genome") {
				this.cancelEvent(i);
				if (this.graphType == "Genome" && this.xAxisUnit > 100 && j > 0) {
					return
				}
				this.setRangesAfterWheelEvent(i, j)
			} else {
				if (this.graphType == "Scatter3D" || this.is3DPlot) {
					this.cancelEvent(i);
					if (!m) {
						m = this.adjustedCoordinates(i);
						i.ac = {
							x: m.x,
							y: m.y
						}
					}
					if (m) {
						m.x -= (this.marginLeft + this.left);
						m.y -= (this.marginTop + this.top);
						var g = (Math.min(Math.max(m.x, 0), this.x) / this.x) - 0.5;
						var f = (Math.min(Math.max(m.y, 0), this.y) / this.y) - 0.5
					}
					if (j > 0) {
						if (this.zoom >= 4) {
							return
						}
						this.zoom *= 1.1;
						this.padX -= g * this.padX / 4;
						this.padY -= f * this.padY / 4
					} else {
						if (this.zoom <= 0.5) {
							return
						}
						this.zoom *= 0.9;
						this.padX += g * this.padX / 4;
						this.padY += f * this.padY / 4
					}
					this.draw()
				} else {
					if (this.graphType == "Network") {
						this.cancelEvent(i);
						if (!m) {
							m = this.adjustedCoordinates(i);
							i.ac = {
								x: m.x,
								y: m.y
							}
						}
						if (m) {
							if (i.type == "keydown") {
								m.x = this.width / 2;
								m.y = this.height / 2
							}
							var c = this.scaleFactor * this.zoomStep;
							var l = (this.widthBounds / 2) - (m.x / this.scaleFactor);
							var h = (this.heightBounds / 2) - (m.y / this.scaleFactor);
							this.scaleFactor = j > 0 ? this.scaleFactor + c : this.scaleFactor - c;
							this.widthBounds = this.x / this.scaleFactor;
							this.heightBounds = this.y / this.scaleFactor;
							var a = (this.widthBounds / 2) - (m.x / this.scaleFactor);
							var k = (this.heightBounds / 2) - (m.y / this.scaleFactor);
							this.panningX = l - a;
							this.panningY = h - k;
							if (!this.networkFreeze) {
								c = this.zoom * this.zoomStep;
								this.zoom = j > 0 ? this.zoom + c : this.zoom - c
							}
							this.draw(false, false, false, true);
							this.panningGlobalX += this.panningX;
							this.panningGlobalY += this.panningY
						}
					}
				}
			}
		}
		return false
	};
	this.getNetworkEventDataId = function(c) {
		var a = this.isEvent(c, true);
		var d = a[0];
		var b = a[1];
		if (d) {
			return b && b.match(/-legend-/) ? false : d
		} else {
			return false
		}
	};
	this.getEventDataId = function(a) {
		return this.graphType == "Network" ? this.getNetworkEventDataId(a) : this.isEvent(a)
	};
	this.getEventAreaData = function(a) {
		return this.extractDataObject(this.getEventDataId(a))
	};
	this.handleMouseEvents = function(g, k, c) {
		this.functionCaller = "handleMouseEvents";
		if (c[0] == -1) {
			this.showInfoSpan(g, "CanvasXpress<br>ver : " + this.meta.version + "<br>date : " + this.meta.buildDate)
		} else {
			if (this.layoutComb && (this.layoutValidN === false || this.layoutValidN === null)) {
				this.setActiveLayout(g);
				if (!this.layoutValidN == null) {
					return false
				}
			}
			var a = c ? this.extractDataObject(c) : false;
			var h = false;
			var l = true;
			var b = g.shiftKey || this.shiftKeyMobile;
			var j = g.ctrlKey || this.ctrlKeyMobile;
			var f = g.altKey || this.altKeyMobile;
			if (k == "click") {
				if (this.isDOE && c) {
					if (a && this.showDOEData && a.w) {
						if (a.y) {
							this.dataStndBy.l.doe = [c[2]]
						} else {
							this.dataStndBy.l.doe = a.w.grps[0]
						}
					} else {
						if (a && a.y.pie) {
							this.dataStndBy.l.doe = a.y.pie[0]
						} else {
							if (a && a.y.treemap) {
								this.dataStndBy.l.doe = a.y.treemap[0]
							} else {
								if (a && a.y.histogram) {
									this.dataStndBy.l.doe = a.y.histogram[0]
								} else {
									if (this.showDOEData) {
										this.dataStndBy.l.doe = [c[1]]
									}
								}
							}
						}
					}
					h = true
				} else {
					if (j) {
						if (f) {
							alert(this.prettyJSON(a))
						} else {
							this.addRemoveToSelectedDataPoints(this.getEventDataId(g));
							this.handleUserSelectEvent();
							this.draw()
						}
					} else {
						if (b) {
							if (this.graphType == "Network" && this.networkLayoutType == "radial") {
								this.reRootRadialNetwork(this.getEventDataId(g))
							}
						} else {
							if (f) {} else {
								if (c != null && this.isSelectDataPoints && !this.isHistogram && this.selectDataPoint.hasOwnProperty(c[0])) {} else {
									if (c != null && this.isSelectDataPoints && this.isHistogram && this.selectDataPoint.hasOwnProperty(this.data.y.histogram[c[0]][0])) {} else {
										if (c && isNaN(c[0]) && c[0].match(/Histogram/)) {
											this.resetSelectedDataPoints();
											l = false
										} else {
											if (this.isOneDimensionalGraph()) {
												l = false
											} else {
												this.resetSelectedObjects()
											}
										}
									}
								}
								if (l) {
									this.addRemoveToSelectedDataPoints(this.getEventDataId(g))
								}
							}
						}
					}
				}
			}
			if (this.userEvents[k]) {
				if (typeof(this.userEvents[k]) == "object" && this.userEvents[k].handler && this.userEvents[k].scope) {
					this.userEvents[k].handler.apply(this.userEvents[k].scope, [a, g, this, c])
				} else {
					if (typeof(this.userEvents[k]) == "object" && this.userEvents[k].handler) {
						this.userEvents[k].handler(a, g, this, c)
					} else {
						this.userEvents[k](a, g, this, c)
					}
				}
			}
			if (h) {
				this.draw()
			}
			return false
		}
	};
	this.formatCoords = function(j, k) {
		var f = [];
		if (this.graphType != "Network") {
			for (var e = 0; e < k.length; e++) {
				if (e % 2) {
					f.push(sprintf("%.0f", (k[e] + this.translateY) * this.scaleY))
				} else {
					if (this.layoutValid && j == "circle" && e == 2) {
						f.push(sprintf("%.0f", k[e] * ((this.scaleX + this.scaleY) / 2)))
					} else {
						f.push(sprintf("%.0f", (k[e] + this.translateX) * this.scaleX))
					}
				}
			}
		} else {
			for (var e = 0; e < k.length; e++) {
				f.push(sprintf("%.0f", parseInt(k[e])))
			}
		}
		if (j == "rect") {
			var b = Math.min(f[0], f[2]);
			var d = Math.min(f[1], f[3]);
			var a = Math.max(f[0], f[2]);
			var g = Math.max(f[1], f[3]);
			f = [b, d, a, g]
		}
		return f.join(",")
	};
	this.addArea = function(h, d, g) {
		if (!h || !d) {
			return
		}
		var e = h.shift();
		var b = this.layoutComb ? this.layoutCurrent : false;
		var a = this.outlineWidth;
		if (e && h) {
			switch (e) {
				case "rect":
					h[0] -= a;
					h[1] -= a;
					h[2] += (a * 2);
					h[3] += (a * 2);
					break;
				case "circle":
					h[2] += (a * 2);
					break;
				case "poly":
					break
			}
			this.dataEvent.push([d, e, h, g, b])
		}
	};
	this.addAreaNetwork = function(d, a, b) {
		if (this.preScaleNetwork && !this.isAnimation) {
			this.addArea(d, a, b)
		} else {
			this.addArea(this.adjustNetworkObjects(d), a, b)
		}
	};
	this.adjustNetworkObjects = function(b) {
		if (b) {
			if (b[0] == "circle") {
				b[1] = this.adjustNetworkObjectX(b[1]);
				b[2] = this.adjustNetworkObjectY(b[2]);
				b[3] = b[3] * this.scaleFactor
			} else {
				for (var a = 1; a < b.length; a++) {
					if (a % 2) {
						b[a] = this.adjustNetworkObjectX(b[a])
					} else {
						b[a] = this.adjustNetworkObjectY(b[a])
					}
				}
			}
		} else {
			return false
		}
		return b
	};
	this.adjustNetworkObjectX = function(a) {
		return (this.offsetX + a) * this.scaleFactor
	};
	this.adjustNetworkObjectY = function(a) {
		return (this.offsetY + a) * this.scaleFactor
	};
	this.adjustBackNetworkObjectX = function(a) {
		return (a / this.scaleFactor) - this.offsetX
	};
	this.adjustBackNetworkObjectY = function(a) {
		return (a / this.scaleFactor) - this.offsetY
	};
	this.adjustNetworkMouseDownX = function(a) {
		return (a - this.xMouseDown) / this.scaleFactor
	};
	this.adjustNetworkMouseDownY = function(a) {
		return (a - this.yMouseDown) / this.scaleFactor
	};
	this.flash = function(b, p, m, f, k, a) {
		var j = this.$cX("div", {
			id: this.target + "canvasXpressFlash" + new Date().getTime()
		}, {
			left: (b - (m / 2)) + "px",
			top: (p - (f / 2)) + "px",
			width: m + "px",
			height: f + "px",
			borderRadius: "999px",
			WebkitBorderRadius: "999px",
			MozBorderRadius: "999px",
			opacity: 0.6,
			filter: "alpha(opacity = 60)",
			position: "absolute",
			zIndex: 100000,
			display: "block",
			backgroundColor: k ? k : this.resizerBackgroundColor
		});
		this.meta.canvas.ctx.canvas.parentNode.appendChild(j);
		if (!a) {
			a = 3
		}
		var g = this;
		var e = 1;
		var o = function() {
			this.update = function() {
				if (e % 2) {
					j.style.display = "none"
				} else {
					j.style.display = "block"
				}
				if (e >= (a * 2)) {
					g.meta.canvas.ctx.canvas.parentNode.removeChild(j);
					clearInterval(c)
				}
				e++
			};
			var c = setInterval(this.update, 300)
		};
		o.call()
	};
	this.initializeCanvasEvents = function() {
		if (!this.disableEvents) {
			this.addRemoveCanvasListeners("addEvtListener")
		}
	};
	this.initializeCanvasEvents()
};
CanvasXpress.prototype.initCleanupEvents = function() {
	this.destroy = function(a) {
		if (a) {
			if (typeof(a) == "object" && a.target) {
				a = a.target
			}
			if (CanvasXpress.instances.length == 1 && CanvasXpress.instances[0].target == a) {
				return this.destroy()
			} else {
				this.removeReference(a)
			}
		} else {
			this.removeReference(this.target);
			CanvasXpress.cacheImages = {};
			CanvasXpress.cacheText = {};
			CanvasXpress.stack = {};
			CanvasXpress.current = false
		}
	};
	this.monitorReference = function() {
		var b = [];
		for (var a = 0; a < CanvasXpress.instances.length; a++) {
			var d = this.$(CanvasXpress.instances[a].target);
			if (!d) {
				b.push(CanvasXpress.instances[a].target)
			}
		}
		for (var a = 0; a < b.length; a++) {
			this.destroy(b[a])
		}
	};
	this.removeReference = function(f, b) {
		var e = CanvasXpress.instances;
		CanvasXpress.instances = [];
		for (var d = 0; d < e.length; d++) {
			if (e[d].target != f) {
				CanvasXpress.instances.push(e[d])
			} else {
				var h = e[d];
				if (h.isR) {
					var g = h.$("container-" + h.target).parentNode;
					var c = h.$cX("canvas", {
						id: h.target,
						width: h.meta.canvas.ctx.canvas.originalWidth,
						height: h.meta.canvas.ctx.canvas.originalHeight
					});
					h.resetTooltipDivs();
					h.cleanEvtListeners(b);
					h.removeTarget("container-" + h.target);
					h.removeTarget(h.target + "-cX-Info");
					delete CanvasXpress.stack[h.target];
					g.appendChild(c)
				} else {
					h.resetTooltipDivs();
					h.cleanEvtListeners(b);
					h.removeTarget("container-" + h.target);
					h.removeTarget(h.target + "-cX-Info");
					delete CanvasXpress.stack[h.target]
				}
			}
		}
	};
	this.cleanEvtListeners = function(b) {
		this.addRemoveLinkListeners("removeEvtListener");
		this.addRemoveToolbarListeners("removeEvtListener");
		this.addRemoveTouchToolbarListeners("removeEvtListener");
		this.addRemoveCodeListeners("removeEvtListener");
		this.addRemoveBinListeners("removeEvtListener");
		this.addRemoveDataExplorerListeners("removeEvtListener");
		this.addRemoveItemListeners("removeEvtListener");
		this.addRemoveConfiguratorListeners("removeEvtListener");
		this.addRemoveDataTableListeners("removeEvtListener");
		this.removeGenericDataFilterListenersOrReset();
		this.addRemoveDataFilterListeners("removeEvtListener");
		this.addRemoveCanvasListeners("removeEvtListener");
		this.addRemoveMotionListeners("removeEvtListener");
		this.addRemoveAxesResizerListeners("removeEvtListener");
		this.addRemoveNavigationListeners("removeEvtListener");
		this.removeEvtListener(document, "mousemove", this.mousemoveDoc, false);
		this.removeEvtListener(document, "touchmove", this.mousemoveDoc, false);
		this.removeEvtListener(document, "mouseup", this.mouseupDoc, false);
		this.removeEvtListener(document, "touchend", this.mouseupDoc, false);
		this.removeEvtListener(document, "keydown", this.keydownDoc, false);
		this.removeEvtListener(document, "keyup", this.keyupDoc, false);
		this.removeEvtListener(window, "resize", this.resizeWindow, false)
	};
	this.initializeCleanupEvents = function() {
		if (this.destroyCanvasXpressZombies) {
			var b = this;
			var a = function() {
				this.monitor = function() {
					if (CanvasXpress.instances.length < 1) {
						clearInterval(c)
					}
					b.monitorReference()
				};
				var c = setInterval(this.monitor, b.monitorCanvasXpressZombiesTime)
			};
			a.call()
		}
	};
	this.initializeCleanupEvents()
};
CanvasXpress.prototype.initEvents = function() {
	this.cloneEvent = function(g) {
		var f = ["ac", "altKey", "bubbles", "button", "buttons", "cancelBubble", "cancelable", "charCode", "code", "clientX", "clientY", "ctrlKey", "defaultPrevented", "deltaMode", "deltaX", "deltaY", "deltaZ", "detail", "eventPhase", "isTrusted", "isTrusted", "keyCode", "keyIdentifier", "location", "layerX", "layerY", "metaKey", "movementX", "movementY", "offsetX", "offsetY", "pageX", "pageY", "repeat", "returnValue", "screenX", "screenY", "shiftKey", "timeStamp", "type", "wheelDelta", "wheelDeltaX", "wheelDeltaY", "which", "x", "y"];
		var d = ["clientX", "clientY", "force", "identifier", "pageX", "pageY", "radiusX", "radiusY", "rotationAngle", "screenX", "screenY"];
		var a = {
			srcElement: g.srcElement ? g.srcElement.id : g.target.id,
			target: g.target.id
		};
		for (var c = 0; c < f.length; c++) {
			a[f[c]] = g[f[c]]
		}
		if (!a.ac) {
			a.ac = this.adjustedCoordinates(a)
		}
		a.xMouseDown = this.xMouseDown;
		a.yMouseDown = this.yMouseDown;
		if (g.touches) {
			a.touches = [];
			for (var c = 0; c < g.touches.length; c++) {
				a.touches[c] = {
					target: g.touches[c].target.id
				};
				for (var b = 0; b < d.length; b++) {
					a.touches[c][d[b]] = g.touches[c][d[b]]
				}
				if (!a.touches[c].ac) {
					a.touches[c].ac = this.adjustedCoordinates(g.touches[c], g.touches[c].target)
				}
			}
		}
		return a
	};
	this.regularCoordinates = function(i, g) {
		var k = {};
		if (i && i.ac) {
			k.x = i.ac.x;
			k.y = i.ac.y
		} else {
			if (i.pageX == null && g.clientX != null) {
				var h = i.target.ownerDocument || document;
				var j = h.documentElement;
				var a = h.body;
				k.x = g.clientX + (j && j.scrollLeft || a && a.scrollLeft || 0) - (j && j.clientLeft || a && a.clientLeft || 0);
				k.y = g.clientY + (j && j.scrollTop || a && a.scrollTop || 0) - (j && j.clientTop || a && a.clientTop || 0)
			} else {
				k.x = i.pageX;
				k.y = i.pageY
			}
		}
		return k
	};
	this.relativeCoordinates = function(a) {
		var b = {
			x: 0,
			y: 0
		};
		if (a && a.ac) {
			b.x = a.ac.x;
			b.y = a.ac.y
		} else {
			while (a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop)) {
				b.x += a.offsetLeft;
				b.y += a.offsetTop;
				a = a.offsetParent
			}
		}
		return b
	};
	this.absoluteCoordinates = function(a) {
		var b = {
			x: 0,
			y: 0
		};
		if (a && a.ac) {
			b.x = a.ac.x;
			b.y = a.ac.y
		} else {
			while (a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop)) {
				b.x += a.offsetLeft - a.scrollLeft;
				b.y += a.offsetTop - a.scrollTop;
				a = a.offsetParent
			}
		}
		return b
	};
	this.adjustedCoordinates = function(g, b) {
		if (!g) {
			g = window.event
		}
		if (!b) {
			b = this.$(this.target)
		}
		if (b) {
			var h = {};
			var a = b.parentNode.getClientRects();
			var d = g && g.changedTouches ? g.changedTouches[0] : false;
			if (g && g.ac) {
				h.x = g.ac.x;
				h.y = g.ac.y
			} else {
				if (a && a[0]) {
					var f = a[0].left;
					var k = a[0].top;
					var j = g && g.clientX ? g.clientX : d ? d.clientX : g && g[0] ? g[0] : f;
					var i = g && g.clientY ? g.clientY : d ? d.clientY : g && g[1] ? g[1] : k;
					h.x = document.body.scrollLeft > Math.abs(f) + j && j > document.body.scrollLeft - f ? Math.abs(f) + j : j - f;
					h.y = document.body.scrollTop > Math.abs(k) + i && i > document.body.scrollTop - k ? Math.abs(k) + i : (i - k)
				} else {
					h.x = 0;
					h.y = 0
				}
			}
			return h
		}
	};
	this.isObjectInsideArea = function(b, g, d, l, c, j) {
		var k, h;
		switch (b) {
			case "rect":
				k = (g[0] + g[2]) / 2;
				h = (g[1] + g[3]) / 2;
				break;
			case "circle":
				k = g[0];
				h = g[1];
				break;
			case "poly":
				var e = [];
				var a = [];
				for (var f = 0; f < g.length; f++) {
					if (f % 2) {
						a.push(g[f])
					} else {
						e.push(g[f])
					}
				}
				e.sort(function(m, i) {
					return (m - i)
				});
				a.sort(function(m, i) {
					return (m - i)
				});
				k = (e[0] + e[e.length - 1]) / 2;
				h = (a[0] + a[a.length - 1]) / 2;
				break
		}
		return this.isPointInsideArea("rect", k, h, [d, l, c, j])
	};
	this.isPointInsideArea = function(n, m, l, k) {
		switch (n) {
			case "rect":
				if (k[0] > k[2]) {
					k[4] = k[0];
					k[0] = k[2];
					k[2] = k[4]
				}
				if (k[1] > k[3]) {
					k[4] = k[1];
					k[1] = k[3];
					k[3] = k[4]
				}
				if (m >= k[0] && m <= k[2] && l >= k[1] && l <= k[3]) {
					return true
				} else {
					return false
				}
			case "circle":
				var f = k[2] / 2;
				if (m >= k[0] - f && m <= k[0] + f && l >= k[1] - f && l <= k[1] + f) {
					return true
				} else {
					return false
				}
			case "poly":
				var d = [];
				var a = [];
				var g = false;
				for (var e = 0; e < k.length; e++) {
					if (e % 2) {
						a.push(k[e])
					} else {
						d.push(k[e])
					}
				}
				if (a[0] < a[1]) {
					a = a.reverse();
					d = d.reverse()
				}
				for (var e = 0, b = d.length - 1; e < d.length; b = e++) {
					if (((a[e] <= l && l < a[b]) || (a[b] <= l && l < a[e])) && (m < (d[b] - d[e]) * (l - a[e]) / (a[b] - a[e]) + d[e])) {
						g = !g
					}
				}
				return g
		}
	};
	this.getEventArea = function(j) {
		var p = this.adjustedCoordinates(j);
		if (p) {
			var b = this.getTargetEvent(j);
			if (b && b.id && b.id.match(this.target)) {
				var o = p.x;
				var m = p.y;
				var n = this.dataEvent;
				for (var g = n.length - 1; g >= 0; g--) {
					var q = n[g][1];
					var k = n[g][2];
					var h = n[g][3];
					var d = n[g][4];
					if (this.isPointInsideArea(q, o, m, k)) {
						return n[g]
					}
				}
			}
		}
		return false
	};
	this.isEvent = function(q, h, j) {
		var w = this.adjustedCoordinates(q);
		if (w) {
			var d = this.getTargetEvent(q);
			if (d && d.id && d.id.match(this.target)) {
				var v = w.x;
				var t = w.y;
				var u = this.dataEvent;
				var b = [];
				for (var o = u.length - 1; o >= 0; o--) {
					var g = u[o][0];
					var z = u[o][1];
					var r = u[o][2];
					var p = u[o][3];
					var k = u[o][4];
					if (this.isPointInsideArea(z, v, t, r)) {
						if (k != null) {
							this.layoutValidN = k
						}
						if (p) {
							p = g[0] + p
						}
						if (j) {
							if (p) {
								b.push(p)
							} else {
								b.push(g[0])
							}
						} else {
							return h ? [g, p] : p ? [p] : g
						}
					}
				}
				if (b.length > 0) {
					return b
				}
			}
		}
		return false
	};
	this.getBoundsXY = function(e) {
		var d = this.layoutComb ? this.layoutParams[e] : this;
		var a = this.graphType == "Network" ? 0 : this.marginLeft + d.offsetX;
		var b = this.graphType == "Network" ? 0 : this.marginTop + d.offsetY;
		return [a + d.left, a + d.left + d.x, b + d.top, b + d.top + d.y, a, a + d.left + d.x + d.right, b, b + d.top + d.y + d.bottom]
	};
	this.getUngroupedDataObject = function(a) {
		if (this.isGroupedData) {
			this.isGroupedData = false;
			a = this.extractDataObject(a.w.grps[0], this.getVariableIndices(a.w.vars));
			this.isGroupedData = true
		}
		return a
	};
	this.extractDataObject = function(m, b) {
		var q = this;
		var w = this.layoutParams;
		var h = this.layoutValidN;
		var r = this.data;
		var M = this.layoutComb && h !== false ? w[h].graphType : this.graphType;
		var S = [];
		var Q = [];
		var P = [];
		var E = function(d) {
			var k = {};
			for (var j in r.x) {
				k[j] = [];
				for (var g = 0; g < d.length; g++) {
					k[j].push(r.x[j][d[g]])
				}
			}
			return k
		};
		var C = function(d) {
			var k = {};
			for (var j in r.z) {
				k[j] = [];
				for (var g = 0; g < d.length; g++) {
					k[j].push(r.z[j][d[g]])
				}
			}
			return k
		};
		var N = function(d) {
			var j = [];
			if (q.isDOE) {
				for (var g = 0; g < d.length; g++) {
					j.push(w[h].data.y.vars[d[g]])
				}
			} else {
				for (var g = 0; g < d.length; g++) {
					j.push(r.y.vars[d[g]])
				}
			}
			return j
		};
		var u = function(j, n) {
			var d = n ? n : r.y.smps;
			var p = [];
			if (q.isDOE) {
				p.push(w[h].data.y.smps[j[0]])
			} else {
				for (var k = 0; k < j.length; k++) {
					p.push(d[j[k]])
				}
			}
			return p
		};
		var l = function(g, d) {
			var k = [];
			for (var j = 0; j < g.length; j++) {
				k.push(d.grps[g[j]])
			}
			return k
		};
		var f = function(g, d, s) {
			var p = [];
			if (q.isDOE) {
				for (var n = 0; n < g.length; n++) {
					p[n] = [];
					p[n].push(w[h].data.y.data[g[n]][d[0]])
				}
			} else {
				if (!s) {
					s = "data"
				}
				if (d) {
					for (var n = 0; n < g.length; n++) {
						p[n] = [];
						if (q.isTransformedData) {
							for (var k = 0; k < d.length; k++) {
								p[n].push(q.bestFormatNumber(r.y.trans[g[n]][d[k]]))
							}
						} else {
							for (var k = 0; k < d.length; k++) {
								p[n].push(r.y[s][g[n]][d[k]])
							}
						}
					}
				} else {
					if (q.isTransformedData) {
						for (var n = 0; n < g.length; n++) {
							p.push(q.bestFormatNumber(r.y.trans[g[n]]))
						}
					} else {
						for (var n = 0; n < g.length; n++) {
							p.push(r.y[s][g[n]])
						}
					}
				}
			}
			return p
		};
		switch (M) {
			case "Area":
			case "AreaLine":
			case "Bar":
			case "Line":
			case "BarLine":
			case "Boxplot":
			case "Dotplot":
			case "DotLine":
			case "Heatmap":
			case "Pie":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Scatter3D":
			case "Candlestick":
			case "Circular":
			case "Treemap":
			case "TagCloud":
				if (!m || m.length == 0 || m[0] == null) {
					return
				} else {
					if (isNaN(m[0])) {
						if (m[0] && m[0].match(/Confidence/)) {
							var O = m[0].split(":");
							var F = {
								display: O[0],
								objectType: "Confidence"
							};
							return F
						} else {
							if (m[0] && m[0].match(/Connect/)) {
								var O = m[0].split(":");
								var F = {
									display: O[1],
									objectType: "Connect"
								};
								return F
							} else {
								if (m[0] && m[0].match(/Histogram/)) {
									var D = m[0].split("-");
									var F = {
										h: {
											a: D[0],
											b: D[1],
											c: D[2],
											d: D[3]
										}
									};
									F.objectType = "Histogram";
									return F
								} else {
									if (m[0] && m[0].match(/Dendrogram/)) {
										var F = {
											t: {}
										};
										var D = m[0].split("-");
										if (D.length > 1) {
											F.t.d = parseInt(D[1]);
											F.t.o = parseInt(D[2]);
											F.t.t = D[3]
										} else {
											F.display = m[0].match(/var/) ? "Variable Dendrogram" : "Sample Dendrogram"
										}
										F.objectType = "Dendrogram";
										return F
									} else {
										if (m[0] && m[0].match(/Var/)) {
											var D = m[0].split("-");
											var L = parseInt(D[1]);
											var R = [L];
											R = R.concat(this.smpIndices);
											var F = this.extractDataObject(R);
											if (m[0].match(/VarOvr/)) {
												F.display = r.y.vars[L] + " : " + this.varOverlays[D[2]] + " : " + r.z[this.varOverlays[D[2]]][L];
												F.objectType = "VarOverlay"
											} else {
												if (m[0].match(/VarOverlay/)) {
													F.display = this.varOverlays[D[1]];
													F.objectType = "VarOverlay"
												} else {
													F.display = r.y.vars[L];
													F.objectType = "Var"
												}
											}
											return F
										} else {
											if (m[0] && m[0].match(/Smp/)) {
												var D = m[0].split("-");
												var L = parseInt(D[1]);
												var F = this.extractDataObject([L], this.varIndices);
												if (m[0].match(/SmpOvrSgr/)) {
													F.display = this.smpOverlays[D[1]] + " : " + D[2];
													F.objectType = "SmpOverlaySgr"
												} else {
													if (m[0].match(/SmpOvr/)) {
														F.display = this.isGroupedData ? r.w.smps[L] + " : " + this.smpOverlays[D[2]] + " : " + r.w.factors[this.smpOverlays[D[2]]][L] : r.y.smps[L] + " : " + this.smpOverlays[D[2]] + " : " + r.x[this.smpOverlays[D[2]]][L];
														F.objectType = "SmpOverlay"
													} else {
														if (m[0].match(/SmpOverlay/)) {
															F.display = this.smpOverlays[D[1]];
															F.objectType = "SmpOverlay"
														} else {
															F.display = this.isGroupedData ? r.w.smps[L] : r.y.smps[L];
															F.objectType = "Smp"
														}
													}
												}
												return F
											} else {
												if (m[0] && m[0].match(/Cat/)) {
													var F = {};
													var D = m[0].split("-");
													F.display = D[1];
													F.objectType = "Cat";
													return F
												} else {
													if (m[0] && m[0].match(/Onc/)) {
														var F = {};
														var D = m[0].split("-");
														F.display = D[1];
														F.objectType = "Onc";
														return F
													} else {
														return
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						if (M == "Pie" && m.length > 2) {
							Q = [m[0]];
							for (var L = 1; L < m.length; L++) {
								S.push(m[L])
							}
						} else {
							if (b) {
								S = b;
								Q = m
							} else {
								S = [m[0]];
								Q = [];
								for (var L = 1; L < m.length; L++) {
									if (m[L] !== false) {
										Q.push(m[L])
									}
								}
							}
						}
						if (M.match(/Scatter/)) {
							if (this.colorBy && this.getSampleIndices(this.colorBy) > -1) {
								Q.push(this.getSampleIndices(this.colorBy))
							}
							if (this.shapeBy && this.getSampleIndices(this.shapeBy) > -1) {
								Q.push(this.getSampleIndices(this.shapeBy))
							}
							if (this.sizeBy && this.getSampleIndices(this.sizeBy) > -1) {
								Q.push(this.getSampleIndices(this.sizeBy))
							}
						}
					}
				}
				if (M.match(/Area/)) {
					return {
						x: r.x,
						y: {
							vars: N(S),
							smps: r.y.smps,
							data: f(S)
						},
						z: C(S)
					}
				} else {
					if ((this.isGroupedData && r.w) || (this.isDOE && this.showDOEData && h == 0 && r.w) || (this.layoutValid && r.l.group)) {
						var F = {
							x: {},
							w: {},
							z: C(S)
						};
						if (M.match(/Boxplot|Dotplot|DotLine/) && Q[1] != null) {
							F.y = {
								data: r.y.data[S[0]][Q[1]],
								vars: r.y.vars[S[0]],
								smps: r.y.smps[Q[1]]
							};
							Q.pop()
						}
						var e = this.layoutValid && r.l.group && w[h].w ? w[h].w : r.w;
						for (var D in e) {
							if (D == "smps") {
								F.w[D] = u(Q, e.smps)
							} else {
								if (D == "grps") {
									F.w[D] = l(Q, e)
								} else {
									if (D == "vars") {
										F.w[D] = N(S)
									} else {
										if (e[D].length > S[0] && e[D][S[0]].length > Q[0]) {
											F.w[D] = [];
											F.w[D].push(e[D][S[0]][Q[0]])
										}
									}
								}
							}
						}
						for (var D in r.x) {
							var x = [];
							for (var L = 0; L < F.w.grps[0].length; L++) {
								x.push(r.x[D][F.w.grps[0][L]])
							}
							F.x[D] = x
						}
					} else {
						var F = {
							x: E(Q),
							y: {
								vars: N(S),
								smps: u(Q)
							},
							z: C(S)
						};
						if (this.isHistogram && !this.isDOE) {
							F.y.histogram = r.y.histogram[S]
						}
						if (this.isDOE) {
							if (w[h].data.y.pie) {
								F.y.pie = [];
								for (var L = 0; L < S.length; L++) {
									F.y.pie.push(w[h].data.y.pie[S[L]])
								}
							} else {
								if (w[h].data.y.treemap) {
									F.y.treemap = [];
									for (var L = 0; L < S.length; L++) {
										F.y.treemap.push(w[h].data.y.treemap[S[L]])
									}
								} else {
									if (w[h].data.y.histogram) {
										F.y.histogram = w[h].data.y.histogram[S]
									}
								}
							}
						}
						if (M == "Candlestick") {
							for (var D in r.y) {
								if (D && D != "vars" && D != "smps" && D != "desc") {
									F.y[D] = [];
									for (var L = 0; L < S.length; L++) {
										F.y[D][L] = [];
										for (var K = 0; K < Q.length; K++) {
											F.y[D][L].push(r.y[D][S[L]][Q[K]])
										}
									}
								}
							}
						} else {
							F.y.data = f(S, Q);
							if (this.isMultidimensionalData) {
								var H = ["outline", "shape", "size"];
								for (var L = 0; L < H.length; L++) {
									var I = H[L] + "ByData";
									if (r.y[this[I]]) {
										F.y[this[I]] = f(S, Q, this[I])
									}
								}
							}
						}
					}
				}
				return F;
			case "Correlation":
				var O;
				if (!m || (isNaN(m[0]) && !m[0].match(/^\d/))) {
					return
				} else {
					O = this.isGroupedData ? r.w.cor : r.y.cor
				}
				if (this.correlationAxis == "samples") {
					var F = {
						x: {},
						y: {}
					};
					for (var D in r.x) {
						var x = [];
						for (var L = 0; L < m.length; L++) {
							x.push(r.x[D][m[L]])
						}
						F.x[D] = x
					}
					F.y.smps = [r.y.smps[m[0]], r.y.smps[m[1]]]
				} else {
					var F = {
						y: {},
						z: {}
					};
					for (var D in r.y) {
						var c = [];
						for (var L = 0; L < m.length; L++) {
							c.push(r.y[D][m[L]])
						}
						F.z[D] = c
					}
					F.y.vars = [r.y.vars[m[0]], r.y.vars[m[1]]]
				}
				F.y.data = O[m[0]][m[1]];
				return F;
			case "Venn":
				var F = {
					venn: {
						data: {}
					}
				};
				F.venn.data[this.vennCompartments[m[0]]] = r.venn.data[this.vennCompartments[m[0]]];
				return F;
			case "Network":
				var F = {};
				if (!m || m.length == 0) {
					return
				}
				if (isNaN(m[0])) {
					m[0] = m[0].toString();
					if (m[0].match(/legend/)) {
						if (m[0].match(/Nodes/)) {
							F = {
								nodeLegend: r.legend.nodes
							}
						} else {
							if (m[0].match(/Edges/)) {
								F = {
									edgeLegend: r.legend.edges
								}
							} else {
								if (m[0].match(/Decorations/)) {
									F = {
										decorationLegend: r.legend.decorations
									}
								} else {
									if (m[0].match(/-legend-indicator-color/)) {
										F = {
											indicatorLegend: "ColorIndicator"
										}
									} else {
										var z = parseInt(m[0].replace("-1-legend-Text", ""));
										F = {
											textLegend: r.legend.text[z]
										}
									}
								}
							}
						}
					} else {
						if (m[0].match(/-dec/)) {
							var L = m[0].split("-");
							var G = r.nodes[L[0]];
							var O = this.decorations[L[1]];
							var y = G[O] ? G[O] : G.decorations && G.decorations[O] ? G.decorations[O] : false;
							var J = L[3] ? L[2] : false;
							if (J) {
								if (y) {
									if (y[J] != null) {
										F.display = O + " : " + J + " : " + y[J]
									} else {
										F.display = O + " : " + J + " : NA"
									}
								} else {
									F.display = O + " : NA"
								}
							} else {
								F.display = O + " : " + y
							}
						} else {
							if (m[0].match(/-elbow/)) {
								F = {
									edges: [r.edges[parseInt(m[0].split("-")) - r.nodes.length]]
								}
							}
						}
					}
				} else {
					for (var L = 0; L < m.length; L++) {
						if (m[L] >= r.nodes.length) {
							if (!F.edges) {
								F.edges = []
							}
							F.edges.push(r.edges[m[L] - r.nodes.length])
						} else {
							if (!F.nodes) {
								F.nodes = []
							}
							F.nodes.push(r.nodes[m[L]])
						}
					}
				}
				return F;
			case "Genome":
				var M;
				var F = [];
				F[0] = {
					data: []
				};
				var z = 0;
				var A = isNaN(m[0]) && m[0].match(":") ? m[0].match(/:(\d+)/)[1] : false;
				for (var L = 0; L < r.tracks.length; L++) {
					var G = r.tracks[L].data.length;
					z += G;
					if (isNaN(m[0])) {
						if (m[0] == "track-" + L) {
							return {
								name: r.tracks[L].name
							}
						} else {
							if (m[0] == "track-" + L + ":" + A) {
								var B = parseInt(A) - (z - G);
								for (var D in r.tracks[L]) {
									if (D == "data") {
										F[0][D].push(r.tracks[L][D][B])
									} else {
										F[0][D] = r.tracks[L][D]
									}
								}
								return F
							}
						}
						continue
					}
					if (m[m.length - 1] < z) {
						for (var K = 0; K < m.length; K++) {
							var B = m[K] - (z - G);
							for (var D in r.tracks[L]) {
								if (D == "data") {
									F[0][D].push(r.tracks[L][D][B])
								} else {
									F[0][D] = r.tracks[L][D]
								}
							}
						}
						return F
					}
				}
		}
	};
	this.getSummaryDataObject = function(b) {
		if (b) {
			switch (this.graphType) {
				case "Bar":
				case "Line":
				case "Area":
				case "AreaLine":
				case "BarLine":
				case "Boxplot":
				case "Dotplot":
				case "DotLine":
				case "Heatmap":
				case "Stacked":
				case "StackedLine":
				case "StackedPercent":
				case "StackedPercentLine":
				case "Scatter2D":
				case "ScatterBubble2D":
				case "Scatter3D":
				case "Circular":
				case "Treemap":
				case "TagCloud":
					var i = "";
					if (b.display) {
						return "<b>" + b.display + "</b><br>"
					} else {
						if ((this.isGroupedData && b.w) || (this.showDOEData && this.configStndBy && this.configStndBy.groupingFactors && b.w)) {
							i = "<b>" + b.w.vars[0] + "</b><br>";
							if (this.summaryType == "mean") {
								i += "<b>" + b.w.smps[0] + "</b>: " + this.bestFormatNumber(b.w.mean[0]);
								if (b.w.stdev && b.w.stdev[0] != null) {
									i += " <i>&plusmn;" + this.bestFormatNumber(b.w.stdev[0]) + "</i>"
								}
								if (b.w.n && b.w.n[0] != null) {
									i += " (" + b.w.n + ")"
								}
								i += "<br>"
							} else {
								if (this.summaryType == "median" || this.summaryType == "iqr" || (this.showDOEData && this.graphType == "Boxplot")) {
									i += "<b>" + b.w.smps[0] + "</b>: " + this.bestFormatNumber(b.w.median[0]);
									if (b.w.stdev && b.w.stdev[0] != null) {
										i += " <i>&plusmn;" + this.bestFormatNumber(b.w.stdev[0]) + "</i>"
									}
									if (b.w.n && b.w.n[0] != null) {
										i += " (" + b.w.n + ")"
									}
									i += "<br>"
								} else {
									if (this.summaryType == "sum") {
										i += "<b>" + b.w.smps[0] + "</b>: " + this.bestFormatNumber(b.w.sum[0]);
										if (b.w.stdev && b.w.stdev[0] != null) {
											i += " <i>&plusmn;" + this.bestFormatNumber(b.w.stdev[0]) + "</i>"
										}
										if (b.w.n && b.w.n[0] != null) {
											i += " (" + b.w.n + ")"
										}
										i += "<br>"
									}
								}
							}
							if (this.graphType.match(/Boxplot|Dotplot|DotLine/) && b.y && b.y.smps) {
								i += "<b>" + b.y.smps + "</b>: " + this.bestFormatNumber(b.y.data) + "<br>"
							}
						} else {
							if (b.y) {
								i = "<b>" + b.y.vars[0] + "</b><br>";
								for (var d = 0; d < b.y.smps.length; d++) {
									if (this.isMultidimensionalData) {
										var l = [b.y.data[0][d]];
										var g = ["outline", "shape", "size"];
										for (var c = 0; c < g.length; c++) {
											var m = g[c] + "ByData";
											if (b.y[this[m]] && b.y[this[m]][0][d]) {
												l.push(b.y[this[m]][0][d])
											}
										}
										i += "<b>" + b.y.smps[d] + "</b>: " + l.join(", ") + "<br>"
									} else {
										i += "<b>" + b.y.smps[d] + "</b>: " + b.y.data[0][d] + "<br>"
									}
								}
							} else {
								if (b.h) {
									i = "<b>" + this[b.h.a].vars[b.h.b] + "</b><br>n: " + this[b.h.a].data[b.h.b][b.h.c] + "<br>"
								} else {
									if (b.t) {
										i = "<b>" + b.t.t + "</b><br>Depth: " + b.t.d + "<br>"
									}
								}
							}
						}
					}
					return i;
				case "Pie":
					var n = "<b>" + b.y.smps[0] + "</b><br>";
					for (var d = 0; d < b.y.vars.length; d++) {
						var a = sprintf("%." + this.pieSegmentPrecision + "f", (b.y.data[d] / this.varPie.tot) * 100);
						n += "<b>" + b.y.vars[d] + "</b>: " + b.y.data[d] + " (" + a + "%)<br>"
					}
					return n;
				case "Candlestick":
					return dateFormat(b.y.smps[0], this.timeFormat) + ", " + b.y.close[0];
				case "Correlation":
					var n;
					if (this.correlationAxis == "samples") {
						n = b.y.smps[0] + " vs " + b.y.smps[1]
					} else {
						n = b.y.vars[0] + " vs " + b.y.vars[1]
					}
					return n;
				case "Venn":
					for (var e in b.venn.data) {
						return e + " = " + b.venn.data[e]
					}
				case "Network":
					var n;
					if (b.display) {
						return "<b>" + b.display + "</b><br>"
					} else {
						if (b && b.nodes) {
							if (b.nodes[0]) {
								n = b.nodes[0].hideTooltip ? "" : b.nodes[0].tooltip || b.nodes[0].name || b.nodes[0].label || b.nodes[0].id
							}
						} else {
							if (b && b.edges) {
								var h = this.nodes[b.edges[0].id1];
								var f = this.nodes[b.edges[0].id2];
								n = (h.label || h.id) + " - " + (f.label || f.id);
								n = b.edges[0].hideTooltip ? "" : b.edges[0].tooltip || b.edges[0].name || b.edges[0].label || n
							}
						}
					}
					return n;
				case "Genome":
					return b.name || b[0].data[0].id
			}
		} else {
			return ""
		}
	};
	this.setUserEvents = function() {
		var d = {};
		var c = this.events;
		if (this.disableEvents) {
			this.userEvents = {};
			return
		}
		var b = this;
		if (c && c.enddragnode) {
			d.enddragnode = c.enddragnode
		}
		if (c && c.stackchange) {
			d.stackchange = c.stackchange
		}
		if (c && c.select) {
			d.select = c.select
		}
		if (c && c.enddraw) {
			d.enddraw = c.enddraw
		}
		if (c && c.remoteupdate) {
			d.remoteupdate = c.remoteupdate
		}
		if (c && c.mouseout) {
			d.mouseout = c.mouseout
		} else {
			d.mouseout = function(j, h, g, f) {
				g.resetInfoSpan(h)
			}
		}
		if (c && c.mouseup) {
			d.mouseup = c.mouseup
		}
		if (c && c.contextmenu) {
			d.contextmenu = c.contextmenu
		} else {
			d.contextmenu = function(j, h, g, f) {
				if (g.graphType == "Network") {
					if (j && j.nodes && j.nodes.length == 1) {
						if (g.selectNode && !g.selectNode[j.nodes[0].id]) {
							g.resetSelectedObjects();
							g.addRemoveToSelectedDataPoints(f);
							g.handleUserSelectEvent()
						}
					}
				}
				g.addMenu(h)
			}
		}
		if (c && c.click) {
			d.click = c.click
		} else {
			d.click = function(j, h, g, f) {
				if (j && j.h) {
					g.addRemoveToSelectedDataPointsHistogram(j)
				} else {
					if (j && j.t) {
						g.modifyDendrogram(j)
					} else {
						if (j && j.objectType) {
							if (j.objectType == "Onc") {
								g.filterOncoprint(j.display)
							} else {
								alert("Click on " + j.display)
							}
						} else {
							if (j && j.nodes && j.nodes.length == 1 && j.nodes[0].links) {
								g.showLinkDiv(h, j.nodes[0].links, j.nodes[0].label != null ? j.nodes[0].label : j.nodes[0].name ? j.nodes[0].name : j.nodes[0].id)
							} else {
								if (j && j.edges && j.edges.length == 1 && j.edges[0].links) {
									g.showLinkDiv(h, j.edges[0].links, j.edges[0].label != null ? j.edges[0].label : j.edges[0].name ? j.edges[0].name : j.edges[0].id1 + "-" + j.edges[0].id2)
								} else {}
							}
						}
					}
				}
				return false
			}
		}
		if (c && c.dblclick) {
			d.dblclick = c.dblclick
		} else {
			d.dblclick = function(j, h, g, f) {
				if (j && j.t) {
					g.zoomDendrogram(j)
				} else {
					if (j && j.objectType) {
						alert("Double Click on " + j.display)
					} else {
						if (g.graphType == "Network" || g.graphType == "Genome") {
							g.addConfigurator(h, f)
						} else {
							if (j) {
								g.showTooltipDiv(h, g.arrayToHTML(g.getDataClassAsArray(g.getUngroupedDataObject(j))))
							}
						}
					}
				}
				return false
			}
		}
		var e = ["mouseover", "mousemove"];
		for (var a = 0; a < e.length; a++) {
			if (c && c[e[a]]) {
				d[e[a]] = c[e[a]]
			} else {
				d[e[a]] = function(k, i, g, h) {
					var j = g.getSummaryDataObject(k);
					if (j && j != "") {
						g.showInfoSpan(i, j);
						if (h && h[0].toString().match("elbow")) {
							var f = g.getTargetEvent(i);
							f.style.cursor = "move"
						}
					}
				}
			}
		}
		this.userEvents = d
	};
	this.resetFlags = function(a) {
		this.resetOn = true;
		this.animationOn = false;
		this.draggingOn = false;
		this.movingOn = false;
		this.panningOn = false;
		this.changingColorOn = false;
		this.changingColorItemOn = false;
		this.changingSliderItemOn = false;
		this.keyOn = false;
		this.xMouseDown = false;
		this.yMouseDown = false;
		this.touches = false;
		this.toucheEvent = false;
		this.moveNode = false;
		this.moveNodeIndex = false;
		this.moveNodeLab = false;
		this.moveNodeDec = false;
		this.moveLegend = false;
		this.moveLegendX = false;
		this.moveLegendY = false;
		this.moveNodeX = false;
		this.moveNodeY = false;
		this.moveNodeW = false;
		this.moveNodeH = false;
		this.moveEdge = false;
		this.moveEdgeIndex = false;
		this.moveEdgeElbow = false;
		this.moveEdgeX = false;
		this.moveEdgeY = false;
		this.resizeNode = false;
		this.resizeLegend = false;
		this.moveGenome = false;
		this.moveDendrogram = false;
		this.moveVar = false;
		this.moveSmp = false;
		this.moveVarOverlay = false;
		this.moveSmpOverlay = false;
		if (a) {
			this.stopEvent(a)
		}
		document.defaultAction = true;
		document.body.style.cursor = "default"
	};
	this.mousemoveDoc = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var b = f.target || f.srcElement;
			if (b.className == "CanvasXpress" && !CanvasXpress.resizing) {
				CanvasXpress.current = b.id
			}
			if ((CanvasXpress.current && CanvasXpress.current == a.target) || CanvasXpress.resizing || b.id.match(/-cX-API-Example/)) {
				if (a.lastMousemove) {
					if (new Date().getTime() - a.lastMousemove < 20) {
						return
					}
				}
				a.lastMousemove = new Date().getTime();
				a.isToolbar(f);
				if (a.isVersion(f)) {
					var g = a.$(a.target);
					g.style.cursor = "help";
					a.showInfoSpan([f.clientX, f.clientY + 50], "CanvasXpress<br>ver : " + a.meta.version + "<br>date : " + a.meta.buildDate)
				} else {
					if (a.filteringNumericOn) {
						a.preventSelection();
						a.updateNumericFilter(f)
					} else {
						if (a.filteringStringOn) {
							a.preventSelection();
							a.updateStringFilter(f)
						} else {
							if (a.draggingTargetOn) {
								a.preventSelection();
								a.updateMousemove(f)
							} else {
								if (a.resizingDataTableOn) {
									a.preventSelection();
									a.updateDataTableResizerDiv(f)
								} else {
									if (a.motionOn) {
										a.preventSelection();
										a.updateMotion(f)
									} else {
										if (a.axesResizingOn) {
											a.preventSelection();
											a.mousemoveAxesResize(f)
										} else {
											if (a.resizingDataTableColumnOn) {
												a.preventSelection();
												a.mousemoveDataTableHeader(f)
											} else {
												if (a.changingColorOn) {
													a.preventSelection();
													a.updateColorValue(f)
												} else {
													if (a.changingColorItemOn) {
														a.preventSelection();
														a.updateColorItemValue(false, f)
													} else {
														if (a.changingSliderItemOn) {
															a.preventSelection();
															a.updateSliderItemValue(f)
														} else {
															if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
																if (a.draggingOn) {
																	a.preventSelection();
																	a.cancelEvent(f);
																	a.updateDrag(f);
																	a.lastCanvasEvent = "drag"
																} else {
																	if (a.resizingCanvasOn && a.resizeCanvasCursorShow) {
																		a.preventSelection();
																		a.cancelEvent(f);
																		a.updateCanvasResizer(f);
																		a.lastCanvasEvent = "resize"
																	} else {
																		if (a.mobileApp) {} else {
																			a.cancelEvent(f);
																			a.updateCanvasResizerCursor(f)
																		}
																	}
																}
																var d = a.graphType == "Genome" ? a.isEvent(f, false, true) : a.isEvent(f);
																if (d) {
																	if (b.className == "CanvasXpress") {
																		if (a.varIndicesStart > 0 || a.smpIndicesStart > 0) {
																			b.style.cursor = "move"
																		}
																		a.handleMouseEvents(f, "mousemove", d)
																	}
																} else {
																	a.resetInfoSpan(f, true)
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			} else {
				a.cancelEvent(f)
			}
			return false
		}
	}(this);
	this.registerMousemove = function(a) {
		return function(d) {
			if (!d) {
				d = window.event
			}
			var b = d.target || d.srcElement;
			if (a.hasClass(this, "CanvasXpressMenu")) {
				if (a.draggableTarget) {
					return
				}
				var c = this;
				while (a.hasClass(c.previousSibling, "CanvasXpressMenu")) {
					c = c.previousSibling
				}
				a.draggableTarget = c;
				a.activeTarget = a.draggableTarget;
				a.activeTarget.style.zIndex = 10001;
				a.xMouseDown = d.clientX;
				a.yMouseDown = d.clientY;
				a.draggableXoffset = parseInt(a.draggableTarget.style.left) || 0;
				a.draggableYoffset = parseInt(a.draggableTarget.style.top) || 0;
				a.draggingTargetOn = true
			} else {
				if ((d.button == 1 && window.event != null || d.button == 0) && a.hasClass(b, "draggable")) {
					if (a.activeTarget) {
						a.activeTarget.style.zIndex = 10000
					}
					a.draggableTarget = b.parentNode && a.hasClass(b.parentNode, "draggable-container") ? b.parentNode : b;
					a.activeTarget = a.draggableTarget;
					a.activeTarget.style.zIndex = 10001;
					a.xMouseDown = d.clientX;
					a.yMouseDown = d.clientY;
					a.draggableXoffset = parseInt(a.draggableTarget.style.left) || 0;
					a.draggableYoffset = parseInt(a.draggableTarget.style.top) || 0;
					a.draggingTargetOn = true;
					a.removeMenus()
				}
			}
		}
	}(this);
	this.updateMousemove = function(h) {
		if (!h) {
			h = window.event
		}
		if (this.draggableTarget && this.draggableTarget.style) {
			var g = parseInt(this.draggableTarget.style.left);
			var f = parseInt(this.draggableTarget.style.top);
			var a = this.draggableXoffset + h.clientX - this.xMouseDown;
			var i = this.draggableYoffset + h.clientY - this.yMouseDown;
			this.draggableTarget.style.left = a + "px";
			this.draggableTarget.style.top = i + "px";
			this.draggableLastX = a;
			this.draggableLastY = i;
			if (this.draggableTarget.id == this.target + "-cX-DataTable" && this.dataTableLastState == "docked") {
				this.moveDataTableDiv("release")
			} else {
				if (this.hasClass(this.draggableTarget, "CanvasXpressMenu")) {
					var c = a - g;
					var b = i - f;
					var d = this.draggableTarget.nextSibling;
					while (d && this.hasClass(d, "CanvasXpressMenu")) {
						d.style.left = (parseInt(d.style.left) + c) + "px";
						d.style.top = (parseInt(d.style.top) + b) + "px";
						d = d.nextSibling
					}
				}
			}
		}
	};
	this.endMousemove = function(a) {
		if (this.draggableTarget != null) {
			this.moveDataTableDiv();
			document.onselectstart = null;
			this.xMouseDown = null;
			this.yMouseDown = null;
			this.draggableXoffset = null;
			this.draggableYoffset = null;
			this.draggableTarget.ondragstart = null;
			this.draggableTarget = false;
			this.draggingTargetOn = false
		}
	};
	this.mouseupDoc = function(a) {
		return function(f) {
			if (!f) {
				f = window.event
			}
			var d = f.target || f.srcElement;
			var c = d.className;
			var b = c && c.match(/canvasxpress|-cx-/i) ? true : false;
			if ((CanvasXpress.current && CanvasXpress.current == a.target && b) || d.id.match(/-cX-API-Example/) || a.resizingCanvasOn) {
				if (a.draggingTargetOn) {
					a.endMousemove(f)
				} else {
					if (a.motionOn) {
						a.endMotion(f)
					} else {
						if (a.resizingDataTableOn) {
							a.endDataTableResizerDiv(f)
						} else {
							if (a.resizingDataTableColumnOn) {
								a.endDataTableColumnResize(f)
							} else {
								if (a.changingColorOn) {
									a.endColorChange(f)
								} else {
									if (a.changingColorItemOn) {
										a.endColorItemChange(f)
									} else {
										if (a.changingSliderItemOn) {
											a.endSliderItemChange(f)
										} else {
											if (!a.configuringOn || (a.configuratorLastState && a.configuratorLastState == "docked")) {
												a.stopEvent(f);
												a.endDrag(f);
												a.endCanvasResizer(f);
												a.endAxesResizer(f);
												a.endNumericFilter(f);
												a.endStringFilter(f);
												a.resetFlags(f)
											}
										}
									}
								}
							}
						}
					}
				}
				if (a.userEvents[f.type]) {
					a.handleMouseEvents(f, f.type)
				}
			}
		}
	}(this);
	this.touchendDoc = function(a) {
		return function(g) {
			if (CanvasXpress.current && CanvasXpress.current == a.target) {
				if (!a.touchEvent || !a.mobileApp || !a.touches) {
					return a.mouseupDoc(g)
				}
				var f = a.layoutComb ? a.layoutParams[a.layoutValidN].graphType : a.graphType;
				var d = a;
				var b = function() {
					clearTimeout(b);
					if (d.touches.length > 1) {
						var k = d.touches[0];
						var j = d.touches[1];
						var q = Math.abs(j[0] - k[0]);
						var p = Math.abs(j[1] - k[1]);
						if (q < 20 && p < 20) {
							d.touchEvent = "dbltap"
						} else {
							d.touchEvent = "pinch"
						}
					} else {
						if (d.touchEvent != "drag") {
							if (d.touchEvent == "dbltap" || d.touchEvent == "pinch") {
								return false
							}
							d.touchEvent = "tap"
						}
					}
					if (d.touchEvent == "pinch" && d.touchesEnd.length > 1) {
						if (d.graphType.match(/Network|Genome|Heatmap|Bar|Line|Dotplot|Boxplot|Area|Stacked|Scatter3D|Circular/)) {
							var n = d.euclidianDistance([d.touches[0][0], d.touches[1][0]], [d.touches[0][1], d.touches[1][1]]);
							var e = d.euclidianDistance([d.touchesEnd[0][0], d.touchesEnd[1][0]], [d.touchesEnd[0][1], d.touchesEnd[1][1]]);
							var o = (d.touchesEnd[0][0] + d.touchesEnd[1][0]) / 2;
							var m = (d.touchesEnd[0][1] + d.touchesEnd[1][1]) / 2;
							var l = d.zoomStep;
							d.zoomStep *= 3;
							d.resetFlags(g);
							d.handleWheelEvent(g, e - n, {
								x: o,
								y: m
							});
							d.zoomStep = l
						}
						d.touchesEnd = false;
						return false
					} else {
						if (d.touchEvent == "dbltap") {
							d.stopEvent(g);
							d.addConfigurator(g, false, 3, 3);
							d.resetFlags(g);
							return false
						} else {
							if (d.touchEvent == "tap") {
								var h = d.getEventDataId(g);
								if (h) {
									d.handleMouseEvents(g, "click", h)
								} else {
									d.resetSelectedObjects()
								}
								d.resetFlags(g);
								return false
							}
						}
					}
					d.stopEvent(g);
					d.endDrag(g);
					d.endCanvasResizer(g);
					d.endAxesResizer(g);
					d.resetFlags(g)
				};
				var c = a.adjustedCoordinates(g);
				if (c) {
					if (!a.touchesEnd) {
						a.touchesEnd = []
					}
					a.touchesEnd.push([c.x, c.y, new Date().getTime()]);
					setTimeout(b, 250)
				}
			}
		}
	}(this);
	this.keydownDoc = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = c.target || c.srcElement;
			if (CanvasXpress.current && CanvasXpress.current == a.target) {
				if (!a.configuringOn && !b.id.match(/cX-DataFilter.+ContentSearch/) && !b.id.match(/cX-DataFilterInput/) && b.className != "CanvasXpressListItemScrollSearch") {
					a.registerKey(c)
				}
			}
		}
	}(this);
	this.keyupDoc = function(a) {
		return function(c) {
			if (!c) {
				c = window.event
			}
			var b = c.target || c.srcElement;
			if (CanvasXpress.current && CanvasXpress.current == a.target) {
				a.keyOn = false;
				if (b.id.match(/cX-DataFilter.+ContentSearch/)) {
					a.updateSearchFilters(b.id)
				} else {
					if (b.id.match(/cX-DataFilterInput/)) {
						a.updateSelectStringFilter(b.id)
					} else {
						if (b.className == "CanvasXpressListItemScrollSearch") {
							a.filterScrollSearch(b.id)
						} else {
							if (a.configuringOn) {
								a.selectConfig(c)
							} else {
								if (a.remoteService) {
									a.selectDataSet(c)
								}
							}
						}
					}
				}
			}
		}
	}(this);
	this.resizeWindow = function(a) {
		return function(b) {
			if (!b) {
				b = window.event
			}
			if (a.resizeImage) {
				a.resizeImage(true)
			}
			a.resizeCanvasDimension();
			return false
		}
	}(this);
	this.resizeCanvasDimension = function() {
		if (this.targetParentNodeResponsive) {
			var b = this;
			var a = function() {
				var g = b.$(b.target);
				var f = b.$(b.targetParentNode);
				var d = f.clientWidth - 27;
				var e = parseInt(d * b.targetParentNodeAspectRatio[1] / b.targetParentNodeAspectRatio[0]);
				b.setDimensions(d, e)
			};
			clearTimeout(a);
			setTimeout(a, 250)
		}
	};
	this.initDocEvents = function() {
		this.addEvtListener(document, "mousemove", this.mousemoveDoc, false);
		this.addEvtListener(document, "touchmove", this.mousemoveDoc, false);
		this.addEvtListener(document, "mouseup", this.mouseupDoc, false);
		this.addEvtListener(document, "touchend", this.touchendDoc, false);
		this.addEvtListener(document, "keydown", this.keydownDoc, false);
		this.addEvtListener(document, "keyup", this.keyupDoc, false);
		this.addEvtListener(window, "resize", this.resizeWindow, false)
	};
	this.initializeEvents = function() {
		this.setUserEvents();
		this.initDraggingEvents();
		this.initCanvasResizerEvents();
		this.initMotionEvents();
		this.initAxisResizerEvents();
		this.initKeyEvents();
		this.initSelectEvents();
		this.initDendrogramEvents();
		this.initCanvasEvents();
		this.initDocEvents();
		this.initCleanupEvents()
	};
	this.initializeEvents()
};
CanvasXpress.prototype.initAnimation = function() {
	this.saveSnapshot = function() {
		var a = this.cloneVisualData(this.data);
		if (a) {
			this.snapshots.push(a)
		}
	};
	this.playSnapshot = function(b, d, c) {
		if (this.snapshots.length < 1) {
			return
		}
		this.stopSnapshotPlay();
		var a = this;
		this.snapshotPlay = {
			idx: 0,
			time: b,
			task: setTimeout(function() {
				a.nextSnapshot(c)
			}, 0),
			callback: d,
			oldData: this.data
		};
		this.snapshotPaused = false
	};
	this.nextSnapshot = function(c) {
		if (this.snapshotPlay.idx >= this.snapshots.length) {
			if (this.snapshotPlay.callback) {
				this.snapshotPlay.callback.call(this, c)
			} else {
				this.snapshotPlay.idx = 0
			}
		}
		if (this.snapshotPlay) {
			var b = this.snapshotPlay.time || this.snapshots[this.snapshotPlay.idx].time || 50;
			this.loadData(this.snapshots[this.snapshotPlay.idx++], true);
			var a = this;
			this.snapshotPlay.task = setTimeout(function() {
				a.nextSnapshot(c)
			}, b);
			this.snapshotPaused = false
		}
	};
	this.stopSnapshotPlay = function(a) {
		if (!this.snapshotPlay) {
			return
		}
		clearTimeout(this.snapshotPlay.task);
		this.loadData(this.snapshotPlay.oldData, a);
		delete(this.snapshotPlay);
		this.snapshotPaused = false
	};
	this.clearSnapshot = function() {
		this.stopSnapshotPlay(true);
		this.snapshots = [];
		this.snapshotPaused = false
	};
	this.duplicateSnapshot = function() {
		if (this.snapshots.length < 1) {
			return
		}
		var a = (this.snapshotPlay ? this.snapshotPlay.idx : this.snapshots.length) - 1;
		var b = this.cloneVisualData(this.snapshots[a]);
		if (this.snapshotPlay) {
			this.snapshots.splice(a + 1, 0, b);
			this.snapshotPlay.idx++
		} else {
			this.snapshots.push(b)
		}
	};
	this.makeSnapshotPlay = function() {
		if (!this.snapshotPlay) {
			this.snapshotPlay = {
				idx: this.snapshots.length,
				oldData: this.data
			}
		} else {
			this.pauseSnapshot()
		}
	};
	this.moveSnapshot = function(c) {
		if (this.snapshots.length < 1) {
			return
		}
		this.makeSnapshotPlay();
		var b = this.snapshotPlay.idx - 1,
			a = b + c;
		if (a >= 0 && a <= this.snapshots.length) {
			this.snapshots.splice(a, 0, (this.snapshots.splice(b, 1))[0])
		}
		this.snapshotPlay.idx = a + 1
	};
	this.prevSnapshotOnce = function() {
		if (this.snapshots.length < 2) {
			return
		}
		this.makeSnapshotPlay();
		this.snapshotPlay.idx -= 2;
		if (this.snapshotPlay.idx < 0) {
			this.snapshotPlay.idx = 0
		}
		this.loadData(this.snapshots[this.snapshotPlay.idx++], true);
		this.snapshotPaused = true
	};
	this.nextSnapshotOnce = function() {
		if (!this.snapshotPlay) {
			return
		}
		if (this.snapshotPlay.idx < this.snapshots.length) {
			this.loadData(this.snapshots[this.snapshotPlay.idx++], true)
		}
		this.snapshotPaused = true
	};
	this.hasNextSnapshot = function() {
		return this.snapshots.length > 1 && this.snapshotPlay && this.snapshotPaused && this.snapshotPlay.idx < this.snapshots.length
	};
	this.hasPrevSnapshot = function() {
		return this.snapshots.length > 1 && (!this.snapshotPlay || (this.snapshotPlay.idx > 1 && this.snapshotPaused))
	};
	this.updateSnapshot = function() {
		if (this.snapshotPlay) {
			this.snapshots[this.snapshotPlay.idx - 1] = this.cloneVisualData(this.data)
		}
	};
	this.pauseSnapshot = function() {
		if (!this.snapshotPlay) {
			return
		}
		if (this.snapshotPlay.task) {
			clearTimeout(this.snapshotPlay.task)
		}
		this.snapshotPaused = true
	};
	this.setSnapshotTime = function(a) {
		if (a > 0) {
			this.snapshots[this.snapshotPlay.idx - 1].time = a
		}
	};
	this.getSnapshotTime = function() {
		return this.snapshots[this.snapshotPlay.idx - 1].time || 50
	};
	this.assembleObj = function(b, k, m) {
		var e = [];
		if (!k[m]) {
			return b[m]
		}
		if (!k[m].indices) {
			k[m].indices = {}
		}
		for (var h = 0; h < b[m].length; h++) {
			var f = b[m][h],
				a = f.id || f.id1 + "-" + f.id2;
			if (!k[m].deleted[a]) {
				var l = k[m].changed[a];
				if (l) {
					for (var g in l) {
						f[g] = l[g]
					}
				}
				var p = k[m].indices[a] != null ? k[m].indices[a] : m == "nodes" ? b.nodeIndices[a] : b.edgeIndices[a];
				e[p] = f;
				k[m].indices[a] = p
			}
		}
		for (var a in k[m].added) {
			e[k[m].indices[a]] = k[m].added[a]
		}
		return e
	};
	this.assembleData = function(b, c) {
		var a = {};
		a.nodes = this.assembleObj(b, c, "nodes");
		a.nodeIndices = c.nodes && c.nodes.indices ? c.nodes.indices : b.nodeIndices;
		a.edges = this.assembleObj(b, c, "edges");
		a.legend = c.legend || b.legend;
		return a
	};
	this.loadData = function(d, e) {
		this.functionCaller = "loadData";
		this.data = d;
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Circular":
				break;
			case "Scatter3D":
			case "Area":
			case "AreaLine":
			case "Boxplot":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Candlestick":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Genome":
				return false;
				break;
			case "Network":
				if (this.data.type == "changedData") {
					this.data = this.assembleData(this.cloneObject(this.snapshotsBase), this.cloneObject(this.data))
				}
				this.edges = this.data.edges;
				var b = {};
				for (var c = 0; c < this.data.nodes.length; c++) {
					var a = this.data.nodes[c];
					b[a.id] = a
				}
				this.nodes = b;
				break
		}
		if (e) {
			this.draw(false, false, true)
		}
	};
	this.changedNodeData = function(c, g) {
		var i = {
			deleted: {},
			changed: {},
			added: {}
		};
		for (var b in c.nodeIndices) {
			var j = g.nodeIndices[b];
			if (j == null) {
				i.deleted[b] = 1
			} else {
				var h = c.nodes[c.nodeIndices[b]],
					e = g.nodes[j],
					k = {
						id: b
					},
					f = false;
				for (var a in e) {
					if (!this.isSameObject(e[a], h[a])) {
						k[a] = e[a];
						f = true
					}
				}
				if (f) {
					i.changed[b] = k
				}
			}
		}
		for (var b in g.nodeIndices) {
			if (c.nodeIndices[b] == null) {
				i.added[b] = g.nodes[g.nodeIndices[b]]
			}
		}
		i.indices = this.changedIndices(c.nodeIndices, g.nodeIndices);
		return i
	};
	this.getEdgeIndices = function(f) {
		var b = {};
		if (f.edges.length) {
			for (var a = 0; a < f.edges.length; a++) {
				var c = f.edges[a];
				b[c.id1 + "-" + c.id2] = a
			}
		}
		return b
	};
	this.changedEdgeData = function(f, g) {
		var c = {
			deleted: {},
			changed: {},
			added: {}
		};
		if (!f.edgeIndices) {
			f.edgeIndices = this.getEdgeIndices(f)
		}
		var e = this.getEdgeIndices(g);
		for (var h in f.edgeIndices) {
			var a = e[h];
			if (a == null) {
				c.deleted[h] = 1
			} else {
				var b = g.edges[a];
				if (!this.isSameObject(f.edges[f.edgeIndices[h]], b)) {
					c.changed[h] = b
				}
			}
		}
		for (var h in e) {
			if (f.edgeIndices[h] == null) {
				c.added[h] = g.edges[e[h]]
			}
		}
		c.indices = this.changedIndices(f.edgeIndices, e);
		return c
	};
	this.changedIndices = function(b, c) {
		var a = {};
		for (var e in c) {
			if (b[e] == null || b[e] != c[e]) {
				a[e] = c[e]
			}
		}
		return a
	};
	this.getSnapshotChanged = function(b) {
		var a = this.snapshotsBase;
		return {
			type: "changedData",
			nodes: this.changedNodeData(a, b),
			edges: this.changedEdgeData(a, b),
			legend: this.isSameObject(a.legend, b.legend) ? null : b.legend
		}
	};
	this.cloneVisualData = function(f) {
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Scatter2D":
			case "ScatterBubble2D":
			case "Circular":
				return this.cloneObject(f);
				break;
			case "Scatter3D":
			case "Area":
			case "AreaLine":
			case "Boxplot":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Candlestick":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Genome":
				return false;
				break;
			case "Network":
				if (this.snapshotCopyChangeOnly) {
					if (this.snapshots.length) {
						return f.type == "changedData" ? this.cloneObject(f) : this.getSnapshotChanged(f)
					} else {
						this.snapshotsBase = this.cloneObject(f);
						return {
							type: "changedData"
						}
					}
				}
				if (!this.snapshotNoCopyData) {
					return this.cloneObject(f)
				}
				var c = {
					nodes: [],
					edges: []
				};
				if (f.nodes && f.nodes.length) {
					for (var b = 0; b < f.nodes.length; b++) {
						var g = {};
						var e = f.nodes[b];
						var h = ["outline", "width", "height", "pattern", "rotate", "color", "shape", "size", "x", "y", "id", "hideLabel", "hideChildren", "hideParent", "label", "labelX", "labelY", "labelSize", "name", "hide", "anchor", "parentNode", "imagePath"];
						for (var a = 0; a < h.length; a++) {
							g[h[a]] = e[h[a]]
						}
						c.nodes.push(g)
					}
				}
				if (f.edges && f.edges.length) {
					for (var b = 0; b < f.edges.length; b++) {
						var g = {};
						var e = f.edges[b];
						var h = ["color", "width", "type", "id1", "id2", "anchor"];
						for (var a = 0; a < h.length; a++) {
							g[h[a]] = e[h[a]]
						}
						c.edges.push(g)
					}
				}
				return c;
				break
		}
	};
	this.isValidAnimation = function() {
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Scatter2D":
			case "ScatterBubble2D":
				return true;
			case "Scatter3D":
			case "Area":
			case "AreaLine":
			case "Boxplot":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Candlestick":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Genome":
			case "Network":
			case "Circular":
				return false
		}
	};
	this.createAnimation = function(e) {
		switch (this.graphType) {
			case "Bar":
			case "Line":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Scatter2D":
			case "ScatterBubble2D":
				this.isAnimation = true;
				var f = this.cloneVisualData(this.data);
				if (e.match(/grow|spring|random/) && this.data.y.data) {
					var d = this.animationCycles;
					for (var c = 0; c < d; c++) {
						for (var b = 0; b < this.data.y.data.length; b++) {
							for (var a = 0; a < this.data.y.data[b].length; a++) {
								if (!isNaN(this.data.y.data[b][a])) {
									var g = this.data.y.data[b][a];
									if (e == "grow") {
										this.data.y.data[b][a] = g / d * c
									} else {
										if (e == "spring") {
											this.data.y.data[b][a] = g / (d - 1.5) * (c + 1)
										} else {
											this.data.y.data[b][a] = g / d * Math.floor(this.random() * c)
										}
									}
								}
							}
						}
						this.saveSnapshot();
						this.data = this.cloneVisualData(f)
					}
				}
				this.data = f;
				this.saveSnapshot();
				this.playSnapshot(this.animationTime, this.stopAnimation);
				break;
			case "Scatter3D":
			case "Area":
			case "AreaLine":
			case "Boxplot":
			case "Heatmap":
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
			case "Candlestick":
			case "Correlation":
			case "Venn":
			case "Pie":
			case "Genome":
			case "Network":
			case "Circular":
				return;
				break
		}
	};
	this.stopAnimation = function() {
		this.stopSnapshotPlay();
		this.snapshots = [];
		this.isAnimation = false
	};
	this.setSnapshotsData = function(a) {
		this.snapshots = a.ss || a;
		this.snapshotsBase = a.base
	};
	this.getSnapshotsData = function() {
		return {
			base: this.snapshotsBase,
			ss: this.snapshots
		}
	};
	this.createDemoNetworkAnimation = function(h) {
		var p = [],
			e = {},
			q = [];
		for (var u = 0; u < h; u++) {
			var n = u + 1;
			p.push({
				size: 0.5,
				x: Math.floor(this.random() * h * 5),
				y: Math.floor(this.random() * h * 5),
				outline: "rgb(255,255,255)",
				color: "rgb(255,0,0)",
				id: n,
				label: n,
				hideLabel: true,
				labelSize: 0.7,
				name: "Node " + n,
				pattern: "closed",
				shape: "star"
			});
			e[n] = u
		}
		var d = {
			nodes: p,
			nodeIndices: e,
			edges: [],
			edgeIndices: {}
		};
		q.push({
			type: "changedData"
		});
		var s = 10;
		var b = 5;
		var o = 255 / b;
		var a = 0.5 / b;
		var k = 5;
		for (var t = 0; t < s; t++) {
			var m = Math.floor(this.random() * p.length);
			for (var u = 0; u < b; u++) {
				var g = Math.floor(255 - (u + 1) * o);
				var l = Math.floor((u + 1) * o),
					v = [g, l, l];
				var f = {};
				f[p[m].id] = {
					size: 0.5 + a * (u + 1),
					color: "rgb(" + v.join(",") + ")"
				};
				q.push({
					type: "changedData",
					nodes: {
						deleted: {},
						added: {},
						changed: f
					},
					time: 5
				})
			}
		}
		this.setSnapshotsData({
			base: d,
			ss: q
		})
	};
	this.createDemoNetworkAnimation1 = function() {
		var b = [];
		var l = {};
		var o = [];
		var n = 10;
		var m = 200;
		var a = "ball";
		var f = {
			width: n,
			x: 100,
			y: 0,
			color: "rgb(0,255,0)",
			id: a,
			label: a,
			hideLabel: true,
			labelSize: 0.7,
			name: a,
			pattern: "closed",
			shape: "sphere"
		};
		a = "plank";
		var g = {
			width: 200,
			height: 5,
			x: 100,
			y: m,
			color: "rgb(255,255,0)",
			id: a,
			label: a,
			hideLabel: true,
			labelSize: 0.7,
			name: a,
			pattern: "closed",
			shape: "rectangle"
		};
		a = "ref";
		var d = {
			width: 10,
			x: 80,
			y: 0,
			color: "rgb(0,0,255)",
			id: a,
			label: a,
			hideLabel: true,
			labelSize: 0.7,
			name: a,
			pattern: "closed",
			shape: "sphere"
		};
		var c = {
			nodes: [f, g, d],
			nodeIndices: {
				ball: 0,
				plank: 1,
				ref: 2
			},
			edges: [],
			edgeIndices: {}
		};
		o.push({
			type: "changedData"
		});
		for (var k = 1, h = 0; h < m - n / 2; h += n / 2, k += 0.1) {
			var e = k * k;
			o.push({
				type: "changedData",
				nodes: {
					deleted: {},
					added: {},
					changed: {
						ball: {
							y: h,
							time: 25 * n > h ? 50 - h * 2 / n : 5
						}
					}
				},
				time: 100 / e
			})
		}
		this.setSnapshotsData({
			base: c,
			ss: o
		})
	};
	this.moveMenu = function(e, c) {
		var b = parseInt(e.style.left);
		var a = b - c;
		var d = (a - b) / 5;
		this.updateMoveMenu(e, b, a, d)
	};
	this.updateMoveMenu = function(e, b, a, d) {
		var c = this;
		b = this.stepResizeMove(b, a, d);
		e.style.left = Math.round(b) + "px";
		if (b == a) {
			return
		}
		setTimeout(function() {
			c.updateMoveMenu(e, b, a, d)
		}, 40)
	};
	this.fade = function(e, a, f, d) {
		if (e) {
			if (this.showFadeResizeMoveAnimation) {
				if (!a) {
					a = 1000
				}
				if (e.fadeState == null) {
					if (e.style.opacity == null || e.style.opacity == "" || e.style.opacity == "1") {
						e.fadeState = 2
					} else {
						e.fadeState = -2
					}
				}
				if (e.fadeState == 1 || e.fadeState == -1) {
					e.fadeState = e.fadeState == 1 ? -1 : 1;
					e.fadeleft = a - e.fadeleft
				} else {
					var b = this;
					e.fadeState = e.fadeState == 2 ? -1 : 1;
					e.fadeleft = a;
					setTimeout(function() {
						b.animateFade(new Date().getTime(), e, f, d)
					}, 33)
				}
			} else {
				e.style.opacity = 0;
				e.style.filter = "alpha(opacity = 0)";
				if (f != null) {
					f()
				}
			}
		}
	};
	this.animateFade = function(a, h, j, d) {
		var b = this;
		var g = new Date().getTime();
		var f = g - a;
		if (h.fadeleft <= f) {
			h.style.opacity = h.fadeState == 1 ? "1" : "0";
			h.style.filter = "alpha(opacity = " + (h.fadeState == 1 ? "100" : "0") + ")";
			h.fadeState = h.fadeState == 1 ? 2 : -2;
			if (j != null) {
				j()
			}
			if (d) {
				setTimeout(function() {
					b.resetFade(h);
					for (var c = 0; c < d.length; c++) {
						delete(h.style[d[c]])
					}
				}, 500)
			}
			return
		}
		h.fadeleft -= f;
		var i = h.fadeleft / 1000;
		if (h.fadeState == 1) {
			i = 1 - i
		}
		h.style.opacity = i;
		h.style.filter = "alpha(opacity = " + (i * 100) + ")";
		setTimeout(function() {
			b.animateFade(g, h, j)
		}, 33)
	};
	this.resetFade = function(a) {
		if (a) {
			a.style.opacity = 1;
			a.style.filter = "alpha(opacity = 100)";
			if (!this.meta.system.isIE) {
				delete(a.fadeState);
				delete(a.fadeleft)
			}
		}
	};
	this.resizeMove = function(d, b, m, k, e, q, l) {
		if (d) {
			if (this.showFadeResizeMoveAnimation) {
				if (!q) {
					q = 500
				}
				var p = parseInt(d.style.left) || 0;
				var i = parseInt(d.style.top) || 0;
				var g = parseInt(d.style.width) || d.clientWidth || 0;
				var a = parseInt(d.style.height) || d.clientHeight || 0;
				var j = 1;
				if (q > 0) {
					j = q / 40
				}
				var n = b - p;
				if (n != 0) {
					n /= j
				}
				var h = m - i;
				if (h != 0) {
					h /= j
				}
				var f = k - g;
				if (f != 0) {
					f /= j
				}
				var r = e - a;
				if (r != 0) {
					r /= j
				}
				this.updateResizeMove(d, p, b, n, i, m, h, g, k, f, a, e, r, l)
			} else {
				d.style.left = Math.round(b) + "px";
				d.style.top = Math.round(m) + "px";
				d.style.width = Math.round(k) + "px";
				d.style.height = Math.round(e) + "px";
				if (l != null) {
					l()
				}
			}
		}
	};
	this.updateResizeMove = function(d, n, b, m, i, l, h, g, j, f, a, e, q, k) {
		if (d) {
			var p = this;
			n = this.stepResizeMove(n, b, m);
			i = this.stepResizeMove(i, l, h);
			g = this.stepResizeMove(g, j, f);
			a = this.stepResizeMove(a, e, q);
			d.style.left = Math.round(n) + "px";
			d.style.top = Math.round(i) + "px";
			d.style.width = Math.round(g) + "px";
			d.style.height = Math.round(a) + "px";
			if (n == b && i == l && a == e && g == j) {
				if (k != null) {
					k()
				}
				return
			}
			setTimeout(function() {
				p.updateResizeMove(d, n, b, m, i, l, h, g, j, f, a, e, q, k)
			}, 40)
		}
	};
	this.stepResizeMove = function(d, b, a) {
		if (a == 0 || d == b) {
			return b
		}
		d += a;
		if ((a > 0 && d >= b) || (a < 0 && d <= b)) {
			return b
		}
		return d
	};
	this.transitionAccordion = function(i, x, f, r) {
		var k = this;
		var w = new Date().getTime();
		var m = w - i;
		var v = function(d) {
			var c = 0;
			for (var a = 0; a < d.childNodes.length; a++) {
				c += d.childNodes[a].clientHeight
			}
			return c
		};
		if (x <= m) {
			if (f) {
				f.style.height = this.dataFilterHeight + "px"
			}
			if (r) {
				r.style.height = "0px";
				r.style.display = "none"
			}
			if (f) {
				var s = f.clientWidth - this.dataFilterWidth < 18;
				var p = f.clientHeight < this.meta.canvas.ctx.canvas.height;
				var b = f.lastChild.clientHeight;
				var j = v(f.lastChild);
				if (j && j > 0) {
					if (j >= b || j > this.dataFilterHeight) {
						if (s) {
							this.resizeDataFilterForScroller(true)
						}
					} else {
						if (p && this.dataFilterScroller) {
							this.resizeDataFilterForScroller()
						}
					}
				}
			} else {
				if (this.dataFilterScroller) {
					this.resizeDataFilterForScroller()
				}
			}
			return
		}
		x -= m;
		var g = Math.round((x / 250) * this.dataFilterHeight);
		if (f) {
			if (f.style.display != "block") {
				f.style.display = "block"
			}
			f.style.height = (this.dataFilterHeight - g) + "px"
		}
		if (r) {
			r.style.height = g + "px"
		}
		setTimeout(function() {
			k.transitionAccordion(w, x, f, r)
		}, 33)
	}
};
CanvasXpress.prototype.initExample = function() {
	this.dataSetGeneric = {
		z: {
			Annt1: ["Desc:1", "Desc:2", "Desc:3", "Desc:4"],
			Annt2: ["Desc:A", "Desc:B", "Desc:A", "Desc:B"],
			Annt3: ["Desc:X", "Desc:X", "Desc:Y", "Desc:Y"]
		},
		x: {
			Factor1: ["Lev:1", "Lev:2", "Lev:3", "Lev:1", "Lev:2", "Lev:3"],
			Factor2: ["Lev:A", "Lev:B", "Lev:A", "Lev:B", "Lev:A", "Lev:B"],
			Factor3: ["Lev:X", "Lev:X", "Lev:Y", "Lev:Y", "Lev:Z", "Lev:Z"]
		},
		y: {
			vars: ["Variable1", "Variable2", "Variable3", "Variable4"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6"],
			data: [
				[5, 10, 25, 40, 45, 50],
				[95, 80, 75, 70, 55, 40],
				[25, 30, 45, 60, 65, 70],
				[55, 40, 35, 30, 15, 1]
			]
		},
		a: {
			xAxis: ["Variable1", "Variable2"],
			xAxis2: ["Variable3", "Variable4"]
		},
		t: {
			vars: "(((Variable1,Variable3),Variable4),Variable2)",
			smps: "(((((Sample1,Sample2),Sample3),Sample4),Sample5),Sample6)"
		}
	};
	this.dataSetCircular = {
		z: {
			Ring: ["1", "2", "2", "3"]
		},
		x: {
			Segment: ["Seg1", "Seg1", "Seg1", "Seg1", "Seg1", "Seg2", "Seg2", "Seg2", "Seg2", "Seg2", "Seg3", "Seg3", "Seg3", "Seg3", "Seg3"],
			Factor1: ["L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5"]
		},
		y: {
			vars: ["Variable1", "Variable2", "Variable3", "Variable4"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12", "Sample13", "Sample14", "Sample15"],
			data: [
				[5, 15, 25, 35, 45, 55, 65, 75, 85, 75, 65, 55, 45, 35, 25],
				[95, 85, 75, 65, 55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55],
				[25, 35, 45, 55, 65, 75, 85, 95, 85, 75, 65, 55, 45, 35, 25],
				[55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55, 65, 75, 85, 95]
			]
		},
		c: [
			["rgb(51,125,255)", "Sample1", "Sample10"],
			["rgb(125,255,51)", "Sample8", "Sample11"],
			["rgb(255,51,125)", "Sample12", "Sample4"],
			["rgb(125,255,51)", "Sample9", "Sample2"],
			["rgb(51,125,255)", "Sample3", "Sample6"]
		]
	};
	this.dataSetCircular2 = {
		z: {
			Ring: ["-1", "1", "2", "2", "3"]
		},
		x: {
			Segment: ["Seg1", "Seg1", "Seg1", "Seg1", "Seg1", "Seg2", "Seg2", "Seg2", "Seg2", "Seg2", "Seg3", "Seg3", "Seg3", "Seg3", "Seg3"],
			Factor1: ["L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5", "L1", "L2", "L3", "L4", "L5"]
		},
		y: {
			vars: ["Number", "Variable1", "Variable2", "Variable3", "Variable4"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12", "Sample13", "Sample14", "Sample15"],
			data: [
				[1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5],
				[5, 15, 25, 35, 45, 55, 65, 75, 85, 75, 65, 55, 45, 35, 25],
				[95, 85, 75, 65, 55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55],
				[25, 35, 45, 55, 65, 75, 85, 95, 85, 75, 65, 55, 45, 35, 25],
				[55, 45, 35, 25, 15, 5, 15, 25, 35, 45, 55, 65, 75, 85, 95]
			]
		},
		c: [
			["rgb(51,125,255)", "Seg1", 1, "Seg2", 5, 1, 1],
			["rgb(125,255,51)", "Seg2", 3, "Seg3", 1, 1, 2],
			["rgb(255,51,125)", "Seg3", 2, "Seg1", 4, 2, 1],
			["rgb(125,255,51)", "Seg2", 4, "Seg1", 2, 1, 1],
			["rgb(51,125,255)", "Seg1", 3, "Seg3", 4, 1, 1]
		]
	};
	this.dataSetBoxplot = {
		x: {
			Factor1: ["Lev1", "Lev1", "Lev1", "Lev1", "Lev1", "Lev1", "Lev2", "Lev2", "Lev2", "Lev2", "Lev2", "Lev2"]
		},
		y: {
			vars: ["Variable1", "Variable2"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			data: [
				[5, 8, 10, 6, 8, 20, 25, 27, 30, 27, 6, 29],
				[49, 18, 14, 16, 18, 15, 65, 67, 60, 72, 76, 9]
			]
		}
	};
	this.dataSetMultidimensionalHeatmap = {
		y: {
			vars: ["Variable1", "Variable2", "Variable3", "Variable4", "Variable5"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10"],
			data: [
				[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
				[10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
				[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
				[10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
				[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
			],
			data2: [
				[1, 1, 2, 2, 3, 3, 4, 4, 5, 5],
				[6, 6, 7, 7, 8, 8, 9, 9, 10, 10],
				[10, 10, 9, 9, 8, 8, 7, 7, 6, 6],
				[5, 5, 4, 4, 3, 3, 2, 2, 1, 1],
				[3, 3, 4, 4, 5, 5, 6, 6, 7, 7]
			],
			data3: [
				["A", "A", "B", "B", "C", "C", "D", "D", "E", "E"],
				["E", "E", "D", "D", "C", "C", "B", "B", "A", "A"],
				["A", "A", "B", "B", "C", "C", "D", "D", "E", "E"],
				["E", "E", "D", "D", "C", "C", "B", "B", "A", "A"],
				["A", "A", "B", "B", "C", "C", "D", "D", "E", "E"]
			],
			data4: [
				["A", "A", "B", "B", "A", "A", "B", "B", "A", "A"],
				["B", "B", "A", "A", "B", "B", "A", "A", "B", "B"],
				["A", "A", "B", "B", "A", "A", "B", "B", "A", "A"],
				["B", "B", "A", "A", "B", "B", "A", "A", "B", "B"],
				["A", "A", "B", "B", "A", "A", "B", "B", "A", "A"]
			]
		},
		x: {
			Factor: ["Lev:1", "Lev:2", "Lev:1", "Lev:2", "Lev:1", "Lev:2", "Lev:1", "Lev:2", "Lev:1", "Lev:2"]
		},
		z: {
			Annt: ["Desc:1", "Desc:2", "Desc:1", "Desc:2", "Desc:1", "Desc:2", "Desc:1", "Desc:2", "Desc:1", "Desc:2"]
		}
	};
	this.dataSet3DScatter = {
		y: {
			vars: ["Variable1", "Variable2", "Variable3", "Variable4", "Variable5", "Variable6", "Variable7", "Variable8", "Variable9", "Variable10", "Variable11", "Variable12", "Variable13", "Variable14", "Variable15", "Variable16", "Variable17", "Variable18", "Variable19", "Variable20", "Variable21", "Variable22", "Variable23", "Variable24", "Variable25", "Variable26", "Variable27", "Variable28", "Variable29", "Variable30", "Variable31", "Variable32", "Variable33", "Variable34", "Variable35", "Variable36", "Variable37", "Variable38", "Variable39", "Variable40", "Variable41", "Variable42", "Variable43", "Variable44", "Variable45", "Variable46", "Variable47", "Variable48", "Variable49", "Variable50", "Variable51", "Variable52", "Variable53", "Variable54", "Variable55", "Variable56", "Variable57", "Variable58", "Variable59", "Variable60", "Variable61", "Variable62", "Variable63", "Variable64", "Variable65", "Variable66", "Variable67", "Variable68", "Variable69", "Variable70", "Variable71", "Variable72", "Variable73", "Variable74", "Variable75", "Variable76", "Variable77", "Variable78", "Variable79", "Variable80", "Variable81"],
			smps: ["Sample1", "Sample2", "Sample3"],
			data: [
				[-5, 5, 5],
				[-5, 15, 15],
				[-5, 25, 25],
				[-5, 35, 35],
				[-5, 45, 45],
				[-5, 35, 55],
				[-5, 25, 65],
				[-5, 15, 75],
				[-5, 5, 85],
				[-15, 15, 5],
				[-15, 25, 15],
				[-15, 35, 25],
				[-15, 45, 35],
				[-15, 55, 45],
				[-15, 45, 55],
				[-15, 35, 65],
				[-15, 25, 75],
				[-15, 15, 85],
				[-25, 25, 5],
				[-25, 35, 15],
				[-25, 45, 25],
				[-25, 55, 35],
				[-25, 65, 45],
				[-25, 55, 55],
				[-25, 45, 65],
				[-25, 35, 75],
				[-25, 25, 85],
				[-35, 35, 5],
				[-35, 45, 15],
				[-35, 55, 25],
				[-35, 65, 35],
				[-35, 75, 45],
				[-35, 65, 55],
				[-35, 55, 65],
				[-35, 45, 75],
				[-35, 35, 85],
				[-45, 45, 5],
				[-45, 55, 15],
				[-45, 65, 25],
				[-45, 75, 35],
				[-45, 85, 45],
				[-45, 75, 55],
				[-45, 65, 65],
				[-45, 55, 75],
				[-45, 45, 85],
				[-55, 35, 5],
				[-55, 45, 15],
				[-55, 55, 25],
				[-55, 65, 35],
				[-55, 75, 45],
				[-55, 65, 55],
				[-55, 55, 65],
				[-55, 45, 75],
				[-55, 35, 85],
				[-65, 25, 5],
				[-65, 35, 15],
				[-65, 45, 25],
				[-65, 55, 35],
				[-65, 65, 45],
				[-65, 55, 55],
				[-65, 45, 65],
				[-65, 35, 75],
				[-65, 25, 85],
				[-75, 15, 5],
				[-75, 25, 15],
				[-75, 35, 25],
				[-75, 45, 35],
				[-75, 55, 45],
				[-75, 45, 55],
				[-75, 35, 65],
				[-75, 25, 75],
				[-75, 15, 85],
				[-85, 5, 5],
				[-85, 15, 15],
				[-85, 25, 25],
				[-85, 35, 35],
				[-85, 45, 45],
				[-85, 35, 55],
				[-85, 25, 65],
				[-85, 15, 75],
				[-85, 5, 85]
			]
		}
	};
	this.dataSetFunction = {
		fx: "sin(2y) * cos(3x) / sec(xy)"
	};
	this.dataSetNonLinearFit = {
		y: {
			vars: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			smps: ["Concentration", "Variable1"],
			data: [
				[0.0009, 172],
				[0.0018, 177],
				[0.0037, 160],
				[0.0073, 166],
				[0.0146, 211],
				[0.0293, 248],
				[0.0586, 269],
				[0.117, 283],
				[0.234, 298],
				[0.469, 314],
				[0.938, 328],
				[1.88, 316]
			]
		},
		d: {
			nlfit: [{
				param: [164, 313, 0.031, -1.5, 0.0000012, 1.9],
				label: "Custom Fit",
				type: "cst"
			}, {
				param: [164, 313, 0.031, 1.5, 0.0000012, 1.9],
				label: "Regular Fit",
				type: "reg"
			}]
		}
	};
	this.dataSetDecorationLine = {
		y: {
			vars: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			smps: ["Concentration", "Variable1"],
			data: [
				[0.0009, 172],
				[0.0018, 177],
				[0.0037, 160],
				[0.0073, 166],
				[0.0146, 211],
				[0.0293, 248],
				[0.0586, 269],
				[0.117, 283],
				[0.234, 298],
				[0.469, 314],
				[0.938, 328],
				[1.88, 316]
			]
		},
		d: {
			line: [{
				x: 0.4,
				y: 200,
				color: "rgb(255,125,51)",
				type: "dashedLine"
			}, {
				x: 0.15,
				color: "rgb(51,255,125)",
				type: "line"
			}]
		}
	};
	this.dataSetDecorationLines = {
		y: {
			vars: ["Concentration"],
			smps: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			data: [
				[0.0009, 0.0018, 0.0037, 0.0073, 0.0146, 0.0293, 0.0586, 0.117, 0.234, 0.469, 0.938, 1.88]
			]
		},
		d: {
			lines: [{
				value: 0.25,
				label: "Background",
				color: "rgb(255,125,51)",
				type: "dashedLine"
			}]
		}
	};
	this.dataSetDecorationArea = {
		y: {
			vars: ["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6", "Sample7", "Sample8", "Sample9", "Sample10", "Sample11", "Sample12"],
			smps: ["Concentration", "Variable1"],
			data: [
				[0.0009, 172],
				[0.0018, 177],
				[0.0037, 160],
				[0.0073, 166],
				[0.0146, 211],
				[0.0293, 248],
				[0.0586, 269],
				[0.117, 283],
				[0.234, 298],
				[0.469, 314],
				[0.938, 328],
				[1.88, 316]
			]
		},
		d: {
			area: [{
				x: 1.42,
				y: 322,
				label: "Area",
				width: 1.2,
				height: 30,
				color: "rgb(255,125,51,0.5)",
				ouline: "rgb(255,125,51,0.5)",
				pattern: "closed",
				rotate: 0.1,
				type: "oval"
			}]
		}
	};
	this.dataSetKaplanMeier = {
		y: {
			vars: ["p1", "p2", "p3", "p4", "p5", "p6", "p7", "p8", "p9", "p10", "p11", "p12", "p13", "p14", "p15", "p16", "p17", "p18", "p19", "p20"],
			smps: ["Time", "Censored-1", "Censored-2"],
			data: [
				[1, 0, 1],
				[2, 0, 1],
				[3, 0, 1],
				[3, 0, 1],
				[1, 1, 1],
				[2, 1, 1],
				[2, 1, 2],
				[3, 1, 1],
				[3, 1, 1],
				[4, 0, 0],
				[5, 0, 0],
				[6, 0, 0],
				[6, 0, 0],
				[7, 1, 0],
				[8, 0, 1],
				[9, 0, 0],
				[9, 0],
				[9, 0],
				[10, 1],
				[11, 1]
			]
		},
		z: {
			grp: ["A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B", "A", "B"],
			cls: ["A", "A", "A", "A", "A", "A", "A", "A", "A", "B", "B", "B", "B", "B", "B", "B", "B", "B", "B", "B"]
		}
	};
	this.dataSetDashDot = {
		nodes: [{
			id: "Id1",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 0
		}, {
			id: "Id2",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 0
		}, {
			id: "Id3",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 50
		}, {
			id: "Id4",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 50
		}, {
			id: "Id5",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 100
		}, {
			id: "Id6",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 100
		}],
		edges: [{
			id1: "Id1",
			id2: "Id2",
			color: "rgb(0,255,0)",
			type: "line"
		}, {
			id1: "Id3",
			id2: "Id4",
			color: "rgb(0,255,0)",
			type: "dashedLine"
		}, {
			id1: "Id5",
			id2: "Id6",
			color: "rgb(0,255,0)",
			type: "dottedLine"
		}]
	};
	this.dataSetLines = {
		nodes: [{
			id: "Id1",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 0
		}, {
			id: "Id2",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 0
		}, {
			id: "Id3",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 0
		}, {
			id: "Id4",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 0
		}, {
			id: "Id5",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 100
		}, {
			id: "Id6",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 100
		}, {
			id: "Id7",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 100
		}, {
			id: "Id8",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 100
		}, {
			id: "Id9",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 200
		}, {
			id: "Id10",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 200
		}, {
			id: "Id11",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 200
		}, {
			id: "Id12",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 200
		}, {
			id: "Id13",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 300
		}, {
			id: "Id14",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 300
		}, {
			id: "Id15",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 300
		}, {
			id: "Id16",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 300
		}, {
			id: "Id17",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 400
		}, {
			id: "Id18",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 400
		}, {
			id: "Id19",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 400
		}, {
			id: "Id20",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 400
		}, {
			id: "Id21",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 500
		}, {
			id: "Id22",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 500
		}, {
			id: "Id23",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 500
		}, {
			id: "Id24",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 500
		}, {
			id: "Id25",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 600
		}, {
			id: "Id26",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 600
		}, {
			id: "Id27",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 600
		}, {
			id: "Id28",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 600
		}, {
			id: "Id29",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 700
		}, {
			id: "Id30",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 700
		}, {
			id: "Id31",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 700
		}, {
			id: "Id32",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 700
		}, {
			id: "Id33",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 800
		}, {
			id: "Id34",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 800
		}, {
			id: "Id35",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 800
		}, {
			id: "Id36",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 800
		}, {
			id: "Id37",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 900
		}, {
			id: "Id39",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 900
		}, {
			id: "Id40",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 1000
		}, {
			id: "Id41",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1100
		}, {
			id: "Id42",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1000
		}, {
			id: "Id43",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1100
		}, {
			id: "Id44",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1000
		}, {
			id: "Id45",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 1100
		}, {
			id: "Id46",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 1200
		}, {
			id: "Id47",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1300
		}, {
			id: "Id48",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1200
		}, {
			id: "Id49",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1300
		}, {
			id: "Id50",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1200
		}, {
			id: "Id51",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 1300
		}, {
			id: "Id52",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 1400
		}, {
			id: "Id54",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 200,
			y: 1400
		}, {
			id: "Id56",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 400,
			y: 1400
		}, {
			id: "Id57",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 600,
			y: 1400
		}],
		edges: [{
			id1: "Id1",
			id2: "Id2",
			color: "rgb(0,255,0)",
			type: "line"
		}, {
			id1: "Id2",
			id2: "Id3",
			color: "rgb(0,255,0)",
			type: "dashedLine"
		}, {
			id1: "Id3",
			id2: "Id4",
			color: "rgb(0,255,0)",
			type: "dottedLine"
		}, {
			id1: "Id5",
			id2: "Id6",
			color: "rgb(0,255,0)",
			type: "arrowHeadLine"
		}, {
			id1: "Id6",
			id2: "Id7",
			color: "rgb(0,255,0)",
			type: "arrowLine"
		}, {
			id1: "Id7",
			id2: "Id8",
			color: "rgb(0,255,0)",
			type: "arrowTailLine"
		}, {
			id1: "Id9",
			id2: "Id10",
			color: "rgb(0,255,0)",
			type: "arrowHeadDashedLine"
		}, {
			id1: "Id10",
			id2: "Id11",
			color: "rgb(0,255,0)",
			type: "arrowDashedLine"
		}, {
			id1: "Id11",
			id2: "Id12",
			color: "rgb(0,255,0)",
			type: "arrowTailDashedLine"
		}, {
			id1: "Id13",
			id2: "Id14",
			color: "rgb(0,255,0)",
			type: "arrowHeadDottedLine"
		}, {
			id1: "Id14",
			id2: "Id15",
			color: "rgb(0,255,0)",
			type: "arrowDottedLine"
		}, {
			id1: "Id15",
			id2: "Id16",
			color: "rgb(0,255,0)",
			type: "arrowTailDottedLine"
		}, {
			id1: "Id17",
			id2: "Id18",
			color: "rgb(0,255,0)",
			type: "squareHeadLine"
		}, {
			id1: "Id18",
			id2: "Id19",
			color: "rgb(0,255,0)",
			type: "squareLine"
		}, {
			id1: "Id19",
			id2: "Id20",
			color: "rgb(0,255,0)",
			type: "squareTailLine"
		}, {
			id1: "Id21",
			id2: "Id22",
			color: "rgb(0,255,0)",
			type: "squareHeadDashedLine"
		}, {
			id1: "Id22",
			id2: "Id23",
			color: "rgb(0,255,0)",
			type: "squareDashedLine"
		}, {
			id1: "Id23",
			id2: "Id24",
			color: "rgb(0,255,0)",
			type: "squareTailDashedLine"
		}, {
			id1: "Id25",
			id2: "Id26",
			color: "rgb(0,255,0)",
			type: "squareHeadDottedLine"
		}, {
			id1: "Id26",
			id2: "Id27",
			color: "rgb(0,255,0)",
			type: "squareDottedLine"
		}, {
			id1: "Id27",
			id2: "Id28",
			color: "rgb(0,255,0)",
			type: "squareTailDottedLine"
		}, {
			id1: "Id29",
			id2: "Id30",
			color: "rgb(0,255,0)",
			type: "squareHeadArrowTailLine"
		}, {
			id1: "Id30",
			id2: "Id31",
			color: "rgb(0,255,0)",
			type: "squareHeadArrowTailDashedLine"
		}, {
			id1: "Id31",
			id2: "Id32",
			color: "rgb(0,255,0)",
			type: "squareHeadArrowTailDottedLine"
		}, {
			id1: "Id33",
			id2: "Id34",
			color: "rgb(0,255,0)",
			type: "arrowHeadSquareTailLine"
		}, {
			id1: "Id34",
			id2: "Id35",
			color: "rgb(0,255,0)",
			type: "arrowHeadSquareTailDashedLine"
		}, {
			id1: "Id35",
			id2: "Id36",
			color: "rgb(0,255,0)",
			type: "arrowHeadSquareTailDottedLine"
		}, {
			id1: "Id37",
			id2: "Id42",
			color: "rgb(0,255,0)",
			type: "bezierLine"
		}, {
			id1: "Id44",
			id2: "Id39",
			color: "rgb(0,255,0)",
			type: "bezierYLine"
		}, {
			id1: "Id40",
			id2: "Id41",
			color: "rgb(0,255,0)",
			type: "arrowBezierLine"
		}, {
			id1: "Id42",
			id2: "Id43",
			color: "rgb(0,255,0)",
			type: "arrowTailBezierLine"
		}, {
			id1: "Id44",
			id2: "Id45",
			color: "rgb(0,255,0)",
			type: "arrowHeadBezierLine"
		}, {
			id1: "Id46",
			id2: "Id47",
			color: "rgb(0,255,0)",
			type: "squareBezierLine"
		}, {
			id1: "Id48",
			id2: "Id49",
			color: "rgb(0,255,0)",
			type: "squareTailBezierLine"
		}, {
			id1: "Id50",
			id2: "Id51",
			color: "rgb(0,255,0)",
			type: "squareHeadBezierLine"
		}, {
			id1: "Id49",
			id2: "Id57",
			color: "rgb(0,255,0)",
			type: "arrowBezierYLine"
		}, {
			id1: "Id47",
			id2: "Id56",
			color: "rgb(0,255,0)",
			type: "arrowTailBezierYLine"
		}, {
			id1: "Id35",
			id2: "Id42",
			color: "rgb(0,255,0)",
			type: "arrowHeadBezierYLine"
		}, {
			id1: "Id46",
			id2: "Id41",
			color: "rgb(0,255,0)",
			type: "squareBezierYLine"
		}, {
			id1: "Id48",
			id2: "Id43",
			color: "rgb(0,255,0)",
			type: "squareTailBezierYLine"
		}, {
			id1: "Id50",
			id2: "Id45",
			color: "rgb(0,255,0)",
			type: "squareHeadBezierYLine"
		}, {
			id1: "Id9",
			id2: "Id1",
			color: "rgb(0,255,0)",
			type: "curvedLine"
		}, {
			id1: "Id13",
			id2: "Id5",
			color: "rgb(0,255,0)",
			type: "squareCurvedLine"
		}, {
			id1: "Id25",
			id2: "Id17",
			color: "rgb(0,255,0)",
			type: "squareHeadCurvedLine"
		}, {
			id1: "Id29",
			id2: "Id21",
			color: "rgb(0,255,0)",
			type: "squareTailCurvedLine"
		}, {
			id1: "Id40",
			id2: "Id33",
			color: "rgb(0,255,0)",
			type: "arrowCurvedLine"
		}, {
			id1: "Id52",
			id2: "Id46",
			color: "rgb(0,255,0)",
			type: "arrowHeadCurvedLine"
		}, {
			id1: "Id4",
			id2: "Id12",
			color: "rgb(0,255,0)",
			type: "arrowTailCurvedLine"
		}, {
			id1: "Id8",
			id2: "Id16",
			color: "rgb(0,255,0)",
			type: "arrowHeadSquareTailCurvedLine"
		}, {
			id1: "Id20",
			id2: "Id28",
			color: "rgb(0,255,0)",
			type: "squareTailArrowHeadCurvedLine"
		}, {
			id1: "Id24",
			id2: "Id32",
			color: "rgb(0,255,0)",
			type: "squareHeadArrowTailCurvedLine"
		}, {
			id1: "Id39",
			id2: "Id45",
			color: "rgb(0,255,0)",
			type: "arrowTailSquareHeadCurvedLine"
		}]
	};
	this.dataSetShapes = {
		nodes: [{
			id: "Id1",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 0,
			y: 0
		}, {
			id: "Id2",
			color: "rgb(255,0,0)",
			shape: "square",
			size: 1,
			x: 200,
			y: 0
		}, {
			id: "Id3",
			color: "rgb(255,0,0)",
			shape: "triangle",
			size: 1,
			x: 400,
			y: 0
		}, {
			id: "Id4",
			color: "rgb(255,0,0)",
			shape: "star",
			size: 1,
			x: 600,
			y: 0
		}, {
			id: "Id5",
			color: "rgb(255,0,0)",
			shape: "rhombus",
			size: 1,
			x: 0,
			y: 100
		}, {
			id: "Id6",
			color: "rgb(255,0,0)",
			shape: "octagon",
			size: 1,
			x: 200,
			y: 100
		}, {
			id: "Id7",
			color: "rgb(255,0,0)",
			shape: "oval",
			size: 1,
			x: 400,
			y: 100
		}, {
			id: "Id8",
			color: "rgb(255,0,0)",
			shape: "plus",
			size: 1,
			x: 600,
			y: 100
		}, {
			id: "Id9",
			color: "rgb(255,0,0)",
			shape: "minus",
			size: 1,
			x: 0,
			y: 200
		}, {
			id: "Id10",
			color: "rgb(255,0,0)",
			shape: "pacman",
			size: 1,
			x: 200,
			y: 200
		}, {
			id: "Id11",
			color: "rgb(255,0,0)",
			shape: "pacman2",
			size: 1,
			x: 400,
			y: 200
		}, {
			id: "Id12",
			color: "rgb(255,0,0)",
			shape: "mdavid",
			size: 1,
			x: 600,
			y: 200
		}, {
			id: "Id13",
			color: "rgb(255,0,0)",
			shape: "rect2",
			size: 1,
			x: 0,
			y: 300
		}, {
			id: "Id14",
			color: "rgb(255,0,0)",
			shape: "rect3",
			size: 1,
			x: 200,
			y: 300
		}, {
			id: "Id15",
			color: "rgb(255,0,0)",
			shape: "arc",
			size: 1,
			x: 400,
			y: 300
		}, {
			id: "Id16",
			color: "rgb(255,0,0)",
			shape: "rectangle",
			size: 1,
			x: 600,
			y: 300
		}, {
			id: "Id17",
			color: "rgb(255,0,0)",
			shape: "image",
			imagePath: "http://www.canvasxpress.org/images/cx.png",
			size: 1,
			x: 0,
			y: 400
		}, {
			id: "Id18",
			color: "rgb(255,0,0)",
			shape: "pie0",
			size: 1,
			x: 200,
			y: 400
		}, {
			id: "Id19",
			color: "rgb(255,0,0)",
			shape: "pie1",
			size: 1,
			x: 400,
			y: 400
		}, {
			id: "Id20",
			color: "rgb(255,0,0)",
			shape: "pie2",
			size: 1,
			x: 600,
			y: 400
		}, {
			id: "Id21",
			color: "rgb(255,0,0)",
			shape: "pie3",
			size: 1,
			x: 0,
			y: 500
		}, {
			id: "Id22",
			color: "rgb(255,0,0)",
			shape: "pie4",
			size: 1,
			x: 200,
			y: 500
		}, {
			id: "Id23",
			color: "rgb(255,0,0)",
			shape: "pie5",
			size: 1,
			x: 400,
			y: 500
		}, {
			id: "Id24",
			color: "rgb(255,0,0)",
			shape: "pie6",
			size: 1,
			x: 600,
			y: 500
		}, {
			id: "Id25",
			color: "rgb(255,0,0)",
			shape: "pie7",
			size: 1,
			x: 0,
			y: 600
		}, {
			id: "Id26",
			color: "rgb(255,0,0)",
			shape: "pie8",
			size: 1,
			x: 200,
			y: 600
		}, {
			id: "Id27",
			color: "rgb(255,0,0)",
			shape: "pie9",
			size: 1,
			x: 400,
			y: 600
		}, {
			id: "Id28",
			color: "rgb(255,0,0)",
			shape: "circle",
			size: 1,
			x: 600,
			y: 600
		}, {
			id: "Id29",
			color: "rgb(255,0,0)",
			shape: "box",
			size: 1,
			x: 0,
			y: 700
		}, {
			id: "Id30",
			color: "rgb(255,0,0)",
			shape: "rect",
			size: 1,
			x: 200,
			y: 700
		}, {
			id: "Id31",
			color: "rgb(255,0,0)",
			shape: "rect2",
			size: 1,
			x: 400,
			y: 700
		}, {
			id: "Id32",
			color: "rgb(255,0,0)",
			shape: "rect3",
			size: 1,
			x: 600,
			y: 700
		}, {
			id: "Id33",
			color: "rgb(255,0,0)",
			shape: "roundrect",
			size: 1,
			x: 0,
			y: 800
		}, {
			id: "Id34",
			color: "rgb(255,0,0)",
			shape: "triangle2",
			size: 1,
			x: 200,
			y: 800
		}, {
			id: "Id35",
			color: "rgb(255,0,0)",
			shape: "equilateral",
			size: 1,
			x: 400,
			y: 800
		}, {
			id: "Id36",
			color: "rgb(255,0,0)",
			shape: "equilateral2",
			size: 1,
			x: 600,
			y: 800
		}, {
			id: "Id37",
			color: "rgb(255,0,0)",
			shape: "hexagon",
			size: 1,
			x: 0,
			y: 900
		}, {
			id: "Id38",
			color: "rgb(255,0,0)",
			shape: "oval2",
			size: 1,
			x: 200,
			y: 900
		}, {
			id: "Id39",
			color: "rgb(255,0,0)",
			shape: "oval3",
			size: 1,
			x: 400,
			y: 900
		}, {
			id: "Id40",
			color: "rgb(255,0,0)",
			shape: "ellipse",
			size: 1,
			x: 600,
			y: 900
		}, {
			id: "Id41",
			color: "rgb(255,0,0)",
			shape: "ellipse2",
			size: 1,
			x: 0,
			y: 1000
		}, {
			id: "Id42",
			color: "rgb(255,0,0)",
			shape: "ellipse3",
			size: 1,
			x: 200,
			y: 1000
		}],
		edges: []
	};
	this.dataSetNetworkDecorations = {
		nodes: [{
			id: "Gene1",
			exp1: 1,
			exp2: 2,
			exp3: 4,
			exp4: {
				cl1: 2,
				cl2: 4,
				cl3: 3
			},
			exp5: {
				cl1: 12,
				cl2: 1,
				cl3: 5
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 155,
			y: 160
		}, {
			id: "Gene2",
			exp1: 2,
			exp2: 4,
			exp3: 1,
			exp4: {
				cl1: 7,
				cl2: 1,
				cl3: 8
			},
			exp5: {
				cl1: 1,
				cl2: 11,
				cl3: 8
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 155,
			y: 340
		}, {
			id: "Gene3",
			exp1: 1,
			exp2: 5,
			exp3: 1,
			exp4: {
				cl1: 12,
				cl2: 4,
				cl3: 8
			},
			exp5: {
				cl1: 3,
				cl2: 7,
				cl3: 5
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 355,
			y: 160
		}, {
			id: "Gene4",
			exp1: 4,
			exp2: 2,
			exp3: 1,
			exp4: {
				cl1: 1,
				cl2: 14,
				cl3: 7
			},
			exp5: {
				cl1: 2,
				cl2: 1,
				cl3: 15
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 355,
			y: 340
		}, {
			id: "Gene5",
			exp1: 1,
			exp2: 3,
			exp3: 2,
			exp4: {
				cl1: 4,
				cl2: 4,
				cl3: 8
			},
			exp5: {
				cl1: 6,
				cl2: 7,
				cl3: 2
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 255,
			y: 100
		}, {
			id: "Gene6",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 255,
			y: 400
		}, {
			id: "Gene7",
			exp1: 3,
			exp2: 3,
			exp3: 4,
			exp4: {
				cl1: 2,
				cl2: 14,
				cl3: 1
			},
			exp5: {
				cl1: 9,
				cl2: 3,
				cl3: 5
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 50,
			y: 250
		}, {
			id: "Gene8",
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 450,
			y: 250
		}],
		edges: [{
			id1: "Gene1",
			id2: "Gene2",
			color: "rgb(51,12,255)",
			width: "3",
			type: "curvedArrowHeadLine"
		}, {
			id1: "Gene4",
			id2: "Gene3",
			color: "rgb(51,12,255)",
			width: "3",
			type: "curvedArrowHeadLine"
		}, {
			id1: "Gene5",
			id2: "Gene6",
			color: "rgb(51,12,255)",
			width: "3",
			type: "arrowHeadLine"
		}, {
			id1: "Gene3",
			id2: "Gene8",
			color: "rgb(51,12,255)",
			width: "3",
			type: "bezierArrowHeadLine"
		}, {
			id1: "Gene7",
			id2: "Gene1",
			color: "rgb(51,12,255)",
			width: "3",
			type: "bezierArrowHeadLine"
		}]
	};
	this.dataSetNetworkRadial = {
		nodes: [{
			id: "Gene1",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene2",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene3",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene4",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene5",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene6",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene7",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "Gene8",
			color: "rgb(255,0,0)",
			shape: "square"
		}, {
			id: "SNP1",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP2",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP3",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP4",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP5",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP6",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP7",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "SNP8",
			color: "rgb(0,255,0)",
			shape: "sphere"
		}, {
			id: "PH1",
			color: "rgb(0,255,255)",
			shape: "star"
		}, {
			id: "PH1a",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH1"
		}, {
			id: "PH1b",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH1"
		}, {
			id: "PH2",
			color: "rgb(0,255,255)",
			shape: "star"
		}, {
			id: "PH2a",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH2"
		}, {
			id: "PH2b",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH2"
		}, {
			id: "PH2ba",
			color: "rgb(0,255,255)",
			shape: "star",
			parentNode: "PH2b"
		}, {
			id: "PH3",
			color: "rgb(0,255,255)",
			shape: "star"
		}, {
			id: "PH4",
			color: "rgb(0,255,255)",
			shape: "star"
		}],
		edges: [{
			id1: "Gene1",
			id2: "Gene2",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP1",
			id2: "PH1",
			color: "rgb(51,12,152)",
			type: "line"
		}, {
			id1: "Gene2",
			id2: "Gene7",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene2",
			id2: "Gene8",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene1",
			id2: "Gene3",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP4",
			id2: "PH4",
			color: "rgb(51,12,152)",
			type: "line"
		}, {
			id1: "PH1",
			id2: "PH1a",
			color: "rgb(102,12,152)",
			type: "line"
		}, {
			id1: "PH1",
			id2: "PH1b",
			color: "rgb(102,12,152)",
			type: "line"
		}, {
			id1: "Gene4",
			id2: "SNP3",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene6",
			id2: "SNP4",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "PH2",
			id2: "PH2a",
			color: "rgb(51,12,152)",
			type: "line"
		}, {
			id1: "PH2",
			id2: "PH2b",
			color: "rgb(102,12,152)",
			type: "line"
		}, {
			id1: "Gene6",
			id2: "SNP5",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene7",
			id2: "SNP6",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP6",
			id2: "SNP7",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene1",
			id2: "Gene4",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene1",
			id2: "Gene5",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP7",
			id2: "Gene6",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP6",
			id2: "SNP8",
			color: "rgb(153,12,255)",
			type: "line"
		}, {
			id1: "Gene3",
			id2: "SNP1",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "Gene3",
			id2: "SNP2",
			color: "rgb(51,12,255)",
			type: "line"
		}, {
			id1: "SNP2",
			id2: "PH2",
			color: "rgb(153,12,255)",
			type: "line"
		}, {
			id1: "SNP3",
			id2: "PH3",
			color: "rgb(51,12,152)",
			type: "line"
		}, {
			id1: "PH2b",
			id2: "PH2ba",
			color: "rgb(102,12,152)",
			type: "line"
		}]
	};
	this.dataSetNetworkBasic = {
		nodes: [{
			id: "Cell",
			shape: "image",
			eventless: true,
			width: 525,
			height: 400,
			imagePath: "http://www.canvasxpress.org/images/cell.png",
			x: 250,
			y: 250,
			hideLabel: true
		}, {
			id: "Gene1",
			exp1: 1,
			exp2: 2,
			exp3: 4,
			exp4: {
				cl1: 2,
				cl2: 4,
				cl3: 3
			},
			exp5: {
				cl1: 12,
				cl2: 1,
				cl3: 5
			},
			shape: "image",
			width: 40,
			height: 40,
			imagePath: "http://www.canvasxpress.org/images/prot.png",
			x: 155,
			y: 160
		}, {
			id: "Gene2",
			exp1: 2,
			exp2: 4,
			exp3: 1,
			exp4: {
				cl1: 7,
				cl2: 1,
				cl3: 8
			},
			exp5: {
				cl1: 1,
				cl2: 11,
				cl3: 8
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 155,
			y: 340
		}, {
			id: "Gene3",
			exp1: 1,
			exp2: 5,
			exp3: 1,
			exp4: {
				cl1: 12,
				cl2: 4,
				cl3: 8
			},
			exp5: {
				cl1: 3,
				cl2: 7,
				cl3: 5
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 355,
			y: 160
		}, {
			id: "Gene4",
			label: "Receptor\nGene4",
			exp1: 4,
			exp2: 2,
			exp3: 1,
			exp4: {
				cl1: 1,
				cl2: 14,
				cl3: 7
			},
			exp5: {
				cl1: 2,
				cl2: 1,
				cl3: 15
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			size: 1,
			x: 355,
			y: 340
		}, {
			id: "Gene5",
			exp1: 1,
			exp2: 3,
			exp3: 2,
			exp4: {
				cl1: 4,
				cl2: 4,
				cl3: 8
			},
			exp5: {
				cl1: 6,
				cl2: 7,
				cl3: 2
			},
			color: "rgb(255,0,0)",
			shape: "sphere",
			width: 20,
			height: 20,
			x: 255,
			y: 100
		}, {
			id: "Met",
			shape: "image",
			width: 40,
			height: 40,
			imagePath: "http://www.canvasxpress.org/images/met.png",
			x: 255,
			y: 400,
			hideLabel: true
		}, {
			id: "Gene7",
			exp1: 3,
			exp2: 3,
			exp3: 4,
			exp4: {
				cl1: 2,
				cl2: 14,
				cl3: 1
			},
			exp5: {
				cl1: 9,
				cl2: 3,
				cl3: 5
			},
			shape: "image",
			width: 40,
			height: 40,
			imagePath: "http://www.canvasxpress.org/images/prot7.png",
			x: 50,
			y: 250
		}, {
			id: "DNA",
			shape: "image",
			width: 40,
			height: 40,
			imagePath: "http://www.canvasxpress.org/images/dna1.png",
			x: 450,
			y: 250,
			hideLabel: true
		}],
		edges: [{
			id1: "Gene1",
			id2: "Gene2",
			color: "rgb(51,12,255)",
			width: "3",
			type: "curvedArrowHeadLine"
		}, {
			id1: "Gene4",
			id2: "Gene3",
			color: "rgb(51,12,255)",
			width: "3",
			type: "curvedArrowHeadLine"
		}, {
			id1: "Gene5",
			id2: "Met",
			color: "rgb(51,12,255)",
			width: "3",
			type: "arrowHeadLine"
		}, {
			id1: "Gene3",
			id2: "DNA",
			color: "rgb(51,12,255)",
			width: "3",
			type: "bezierArrowHeadLine"
		}, {
			id1: "Gene7",
			id2: "Gene1",
			color: "rgb(51,12,255)",
			width: "3",
			type: "bezierArrowHeadLine"
		}],
		legend: {
			nodes: [{
				shape: "sphere",
				color: "rgb(255,0,0)",
				text: "Gene",
				id: "nodesLegendId0"
			}],
			edges: [{
				type: "arrowHeadLine",
				text: "Activate",
				id: "edgesLegendId0"
			}],
			text: [{
				text: "Cool Pathway",
				x: 150,
				y: 460,
				id: "textLegendId0"
			}],
			pos: {
				nodes: {
					x: -5,
					y: -5
				},
				edges: {
					x: 360,
					y: -5
				},
				decorations: {
					x: 20,
					y: 80
				}
			}
		}
	};
	this.dataSetVenn = {
		venn: {
			data: {
				A: 340,
				B: 562,
				C: 620,
				D: 592,
				AB: 639,
				AC: 456,
				AD: 257,
				BC: 915,
				BD: 354,
				CD: 143,
				ABC: 552,
				ABD: 578,
				ACD: 298,
				BCD: 613,
				ABCD: 148
			},
			legend: {
				A: "List 1",
				B: "List 2",
				C: "List 3",
				D: "List 4"
			}
		}
	};
	this.dataSetMarket = {
		market: [{
			symbol: "BMY",
			data: [
				[20100824, 26.26, 26.37, 25.95, 26.02, 11625900, 26.02],
				[20100823, 26.48, 26.76, 26.38, 26.48, 12146600, 26.48],
				[20100820, 26.31, 26.54, 26.08, 26.44, 18140100, 26.44],
				[20100819, 26.2, 26.29, 25.81, 26.06, 8218000, 26.06],
				[20100818, 26.53, 26.57, 26.23, 26.28, 12235800, 26.28],
				[20100817, 26.4, 26.79, 26.26, 26.59, 12325700, 26.59],
				[20100816, 26.24, 26.34, 26.04, 26.28, 10377700, 26.28],
				[20100813, 26.24, 26.46, 26.1, 26.32, 5760100, 26.32],
				[20100812, 26.01, 26.39, 26, 26.33, 7350500, 26.33],
				[20100811, 26.32, 26.5, 26.15, 26.25, 8808100, 26.25],
				[20100810, 26.32, 26.78, 26.3, 26.66, 7009500, 26.66],
				[20100809, 26.37, 26.54, 26.3, 26.51, 6825300, 26.51],
				[20100806, 26.29, 26.45, 26.05, 26.37, 8774900, 26.37],
				[20100805, 25.83, 26.38, 25.8, 26.38, 12264600, 26.38],
				[20100804, 25.7, 26.13, 25.61, 26.03, 10233700, 26.03],
				[20100803, 25.65, 25.85, 25.58, 25.68, 6842900, 25.68],
				[20100802, 25.33, 25.61, 25.29, 25.53, 9770900, 25.53],
				[20100730, 24.98, 25.13, 24.78, 24.92, 11435700, 24.92],
				[20100729, 25.37, 25.5, 24.85, 25.08, 9463800, 25.08],
				[20100728, 25.25, 25.36, 25.02, 25.12, 8072400, 25.12],
				[20100727, 25.09, 25.35, 24.84, 25.32, 14152600, 25.32],
				[20100726, 24.57, 25.03, 24.57, 24.97, 8817400, 24.97],
				[20100723, 24.94, 24.95, 24.26, 24.65, 13043700, 24.65],
				[20100722, 24.96, 25.22, 24.75, 24.93, 10385300, 24.93],
				[20100721, 24.92, 25.11, 24.59, 24.75, 9830000, 24.75],
				[20100720, 24.65, 25.09, 24.46, 25.02, 10655500, 25.02],
				[20100719, 25.27, 25.27, 24.78, 24.84, 11804800, 24.84],
				[20100716, 25.44, 25.47, 25.1, 25.17, 13136300, 25.17]
			]
		}]
	};
	this.dataSetGenomeAdvanced = {
		tracks: [{
			name: "Affymetrix Probes",
			type: "box",
			connect: true,
			data: [{
				id: "123456_at",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "right",
				data: [
					[10, 20],
					[30, 40],
					[50, 60],
					[70, 80],
					[90, 100],
					[110, 120]
				],
				sequences: ["GTTTTACGTAC", "TACGTACGTAC", "GGTTTACGTAC", "GGTTTACGTAC", "GGTTTACGTAC", "GGTTTACGTAC"],
				index: 0,
				counter: 0,
				start: 10,
				end: 120,
				measureText: 56
			}, {
				id: "345678_at",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "right",
				data: [
					[100, 110],
					[120, 130],
					[140, 150],
					[160, 170],
					[180, 190]
				],
				index: 2,
				counter: 2,
				start: 100,
				end: 190,
				measureText: 56
			}],
			startY: 50,
			endY: 82,
			displayedFeatures: 3,
			totalFeatures: 3
		}, {
			name: "Sanger Sequencing (Multiple sequeneces)",
			highlight: [{
				offset: 80,
				width: 1,
				color: "rgb(120,120,180)"
			}, {
				offset: 185,
				width: 1,
				color: "rgb(180,20,180)"
			}],
			subtype: "DNA",
			type: "sequence",
			data: [{
				id: "Reference Sequence",
				fill: "rgb(51,255,255)",
				outline: "rgb(0,0,0)",
				dir: "right",
				offset: 1,
				sequence: "AAAACCCGGGTTTTACGTACGTACGTACGTACGTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTAAACC",
				translate: [-3, -2, -1, 1, 2, 3],
				index: 0,
				counter: 3,
				measureText: 108
			}, {
				id: "R1-0000-1234",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "right",
				offset: 1,
				gaps: [
					[18, 1],
					[22, 1]
				],
				sequence: "AAAACCCGGGTTTTACGTCGTAGTACGTACGTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAA",
				coordinate: 50,
				trace: {
					A: [57, 127, 237, 371, 486, 531, 486, 371, 237, 127, 57, 54, 117, 217, 339, 442, 484, 442, 339, 217, 117, 54, 10, 24, 60, 130, 240, 375, 490, 535, 490, 375, 240, 130, 60, 24, 10, 56, 121, 222, 346, 452, 494, 452, 346, 222, 121, 56, 7, 14, 27, 48, 74, 95, 104, 95, 74, 48, 27, 14, 7, 6, 8, 14, 27, 46, 69, 90, 98, 90, 69, 46, 27, 14, 8, 6, 4, 5, 7, 14, 27, 47, 72, 93, 101, 93, 72, 47, 27, 14, 7, 5, 4, 5, 11, 23, 42, 65, 85, 92, 85, 65, 42, 23, 11, 5, 7, 14, 27, 48, 74, 95, 104, 95, 74, 48, 27, 14, 7, 1, 2, 4, 10, 22, 42, 65, 85, 93, 85, 65, 42, 22, 10, 4, 2, 1, 5, 12, 24, 44, 68, 88, 97, 88, 68, 44, 24, 12, 5, 4, 5, 7, 14, 27, 47, 72, 94, 102, 94, 72, 47, 27, 14, 7, 5, 4, 2, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 2, 12, 24, 43, 67, 87, 95, 87, 67, 43, 24, 12, 21, 52, 113, 210, 328, 429, 469, 429, 328, 210, 113, 52, 21, 4, 6, 13, 26, 47, 72, 93, 102, 93, 72, 47, 26, 13, 6, 4, 4, 6, 13, 26, 46, 71, 92, 100, 92, 71, 46, 26, 13, 6, 4, 6, 8, 14, 27, 46, 69, 89, 97, 89, 69, 46, 27, 14, 8, 6, 4, 5, 8, 14, 28, 49, 76, 98, 107, 98, 76, 49, 28, 14, 8, 5, 4, 7, 13, 25, 45, 68, 88, 96, 88, 68, 45, 25, 13, 7, 5, 11, 24, 43, 67, 88, 96, 88, 67, 43, 24, 11, 5, 22, 54, 118, 219, 342, 447, 489, 447, 342, 219, 118, 54, 22, 5, 12, 25, 46, 71, 93, 102, 93, 71, 46, 25, 12, 5, 5, 12, 24, 44, 68, 89, 97, 89, 68, 44, 24, 12, 5, 20, 54, 121, 226, 355, 465, 508, 465, 355, 226, 121, 54, 20, 3, 4, 6, 13, 25, 45, 70, 91, 99, 91, 70, 45, 25, 13, 6, 4, 3, 6, 8, 15, 27, 47, 71, 91, 99, 91, 71, 47, 27, 15, 8, 6, 1, 2, 4, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 4, 2, 1, 6, 11, 25, 60, 128, 237, 369, 482, 527, 482, 369, 237, 128, 60, 25, 11, 6, 2, 5, 12, 25, 47, 74, 97, 106, 97, 74, 47, 25, 12, 5, 2, 5, 8, 15, 29, 51, 78, 101, 110, 101, 78, 51, 29, 15, 8, 5, 5, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 5, 6, 18, 48, 107, 201, 315, 412, 451, 412, 315, 201, 107, 48, 18, 6, 9, 16, 31, 53, 81, 105, 114, 105, 81, 53, 31, 16, 9, 6, 8, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 8, 6, 11, 23, 42, 65, 85, 92, 85, 65, 42, 23, 11, 19, 51, 113, 212, 332, 434, 475, 434, 332, 212, 113, 51, 19, 8, 15, 28, 49, 74, 95, 104, 95, 74, 49, 28, 15, 8, 12, 26, 49, 76, 99, 109, 99, 76, 49, 26, 12, 12, 24, 43, 67, 86, 94, 86, 67, 43, 24, 12, 22, 54, 118, 218, 341, 445, 487, 445, 341, 218, 118, 54, 22, 21, 52, 112, 208, 324, 423, 462, 423, 324, 208, 112, 52, 21, 10, 23, 54, 115, 212, 330, 430, 471, 430, 330, 212, 115, 54, 23, 10, 2, 3, 5, 12, 25, 45, 69, 91, 99, 91, 69, 45, 25, 12, 5, 3, 2, 2, 3, 5, 12, 24, 44, 68, 88, 97, 88, 68, 44, 24, 12, 5, 3, 2, 8, 15, 28, 50, 77, 100, 109, 100, 77, 50, 28, 15, 8, 12, 26, 48, 74, 96, 105, 96, 74, 48, 26, 12, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 13, 25, 45, 70, 91, 99, 91, 70, 45, 25, 13, 7, 14, 28, 49, 75, 97, 105, 97, 75, 49, 28, 14, 7, 2, 5, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 5, 2, 16, 30, 53, 80, 103, 113, 103, 80, 53, 30, 16, 25, 61, 133, 246, 384, 501, 548, 501, 384, 246, 133, 61, 25, 6, 13, 25, 45, 69, 90, 98, 90, 69, 45, 25, 13, 6, 5, 6, 9, 15, 29, 50, 77, 99, 108, 99, 77, 50, 29, 15, 9, 6, 5, 10, 23, 42, 65, 86, 94, 86, 65, 42, 23, 10, 9, 23, 55, 120, 223, 348, 454, 497, 454, 348, 223, 120, 55, 23, 9, 2, 4, 11, 23, 43, 67, 88, 96, 88, 67, 43, 23, 11, 4, 2, 2, 3, 6, 12, 26, 48, 74, 96, 105, 96, 74, 48, 26, 12, 6, 3, 2, 15, 28, 49, 74, 96, 104, 96, 74, 49, 28, 15, 22, 55, 120, 223, 348, 455, 498, 455, 348, 223, 120, 55, 22, 22, 53, 115, 213, 332, 434, 474, 434, 332, 213, 115, 53, 22, 7, 20, 53, 118, 221, 346, 454, 496, 454, 346, 221, 118, 53, 20, 7, 2, 3, 5, 11, 24, 44, 67, 88, 96, 88, 67, 44, 24, 11, 5, 3, 2, 15, 28, 50, 75, 97, 106, 97, 75, 50, 28, 15, 1, 2, 5, 12, 25, 47, 74, 96, 105, 96, 74, 47, 25, 12, 5, 2, 1, 6, 8, 15, 28, 49, 74, 96, 104, 96, 74, 49, 28, 15, 8, 6, 5, 12, 26, 47, 72, 94, 103, 94, 72, 47, 26, 12, 5, 8, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 8, 3, 5, 11, 23, 42, 65, 84, 92, 84, 65, 42, 23, 11, 5, 3, 5, 12, 25, 45, 70, 91, 100, 91, 70, 45, 25, 12, 5, 1, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 1, 7, 20, 51, 113, 212, 331, 433, 474, 433, 331, 212, 113, 51, 20, 7, 2, 3, 5, 12, 25, 46, 72, 94, 102, 94, 72, 46, 25, 12, 5, 3, 2, 2, 4, 11, 25, 46, 72, 94, 102, 94, 72, 46, 25, 11, 4, 2, 2, 3, 6, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 6, 3, 2, 10, 25, 61, 133, 247, 386, 504, 551, 504, 386, 247, 133, 61, 25, 10, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 5, 8, 15, 28, 50, 76, 99, 108, 99, 76, 50, 28, 15, 8, 5, 2, 3, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 3, 2, 8, 22, 57, 127, 238, 372, 487, 532, 487, 372, 238, 127, 57, 22, 8, 60, 129, 237, 370, 483, 528, 483, 370, 237, 129, 60],
					C: [6, 13, 23, 34, 45, 49, 45, 34, 23, 13, 6, 9, 16, 28, 41, 53, 58, 53, 41, 28, 16, 9, 4, 5, 9, 15, 26, 39, 49, 54, 49, 39, 26, 15, 9, 5, 4, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 21, 51, 111, 206, 321, 419, 459, 419, 321, 206, 111, 51, 21, 11, 26, 62, 134, 248, 387, 505, 552, 505, 387, 248, 134, 62, 26, 11, 5, 10, 24, 58, 126, 233, 364, 475, 520, 475, 364, 233, 126, 58, 24, 10, 5, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 3, 6, 13, 22, 34, 45, 49, 45, 34, 22, 13, 6, 3, 4, 4, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 4, 4, 1, 2, 6, 12, 23, 36, 47, 51, 47, 36, 23, 12, 6, 2, 1, 7, 13, 23, 34, 44, 48, 44, 34, 23, 13, 7, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 8, 21, 52, 113, 211, 329, 431, 471, 431, 329, 211, 113, 52, 21, 8, 3, 4, 8, 14, 24, 37, 47, 51, 47, 37, 24, 14, 8, 4, 3, 5, 6, 10, 16, 27, 39, 50, 54, 50, 39, 27, 16, 10, 6, 5, 5, 9, 22, 52, 114, 210, 328, 428, 468, 428, 328, 210, 114, 52, 22, 9, 5, 6, 9, 16, 27, 41, 53, 57, 53, 41, 27, 16, 9, 6, 3, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 3, 4, 8, 15, 25, 38, 49, 54, 49, 38, 25, 15, 8, 4, 4, 7, 14, 25, 38, 49, 54, 49, 38, 25, 14, 7, 4, 3, 7, 14, 24, 37, 48, 52, 48, 37, 24, 14, 7, 3, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 4, 8, 21, 52, 114, 212, 331, 433, 474, 433, 331, 212, 114, 52, 21, 8, 4, 5, 6, 10, 16, 27, 39, 50, 54, 50, 39, 27, 16, 10, 6, 5, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 5, 5, 7, 10, 17, 29, 43, 54, 59, 54, 43, 29, 17, 10, 7, 5, 5, 6, 18, 49, 109, 203, 319, 417, 457, 417, 319, 203, 109, 49, 18, 6, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 1, 25, 61, 131, 242, 376, 492, 538, 492, 376, 242, 131, 61, 25, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 24, 56, 121, 224, 348, 454, 497, 454, 348, 224, 121, 56, 24, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 8, 14, 24, 36, 47, 51, 47, 36, 24, 14, 8, 5, 9, 15, 25, 38, 48, 53, 48, 38, 25, 15, 9, 5, 5, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 5, 5, 7, 10, 17, 29, 42, 54, 59, 54, 42, 29, 17, 10, 7, 5, 3, 7, 20, 52, 116, 217, 339, 443, 485, 443, 339, 217, 116, 52, 20, 7, 3, 3, 8, 22, 55, 123, 229, 358, 469, 513, 469, 358, 229, 123, 55, 22, 8, 3, 22, 52, 114, 210, 328, 428, 468, 428, 328, 210, 114, 52, 22, 7, 14, 25, 38, 49, 54, 49, 38, 25, 14, 7, 7, 13, 23, 35, 45, 49, 45, 35, 23, 13, 7, 8, 14, 24, 36, 47, 51, 47, 36, 24, 14, 8, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 1, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 1, 10, 16, 26, 39, 49, 54, 49, 39, 26, 16, 10, 5, 8, 14, 24, 36, 46, 49, 46, 36, 24, 14, 8, 5, 22, 54, 119, 222, 346, 453, 495, 453, 346, 222, 119, 54, 22, 5, 5, 6, 10, 16, 26, 38, 49, 53, 49, 38, 26, 16, 10, 6, 5, 5, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 4, 5, 9, 15, 26, 38, 49, 53, 49, 38, 26, 15, 9, 5, 4, 7, 20, 53, 119, 223, 349, 457, 500, 457, 349, 223, 119, 53, 20, 7, 2, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 2, 2, 10, 16, 27, 39, 50, 55, 50, 39, 27, 16, 10, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 6, 9, 16, 27, 40, 51, 56, 51, 40, 27, 16, 9, 6, 1, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 3, 8, 22, 56, 124, 232, 362, 474, 519, 474, 362, 232, 124, 56, 22, 8, 3, 56, 120, 221, 345, 450, 492, 450, 345, 221, 120, 56, 2, 7, 21, 55, 122, 229, 358, 469, 513, 469, 358, 229, 122, 55, 21, 7, 2, 5, 7, 10, 17, 27, 40, 51, 56, 51, 40, 27, 17, 10, 7, 5, 3, 7, 13, 23, 35, 45, 50, 45, 35, 23, 13, 7, 3, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 2, 3, 7, 13, 24, 37, 48, 52, 48, 37, 24, 13, 7, 3, 2, 4, 7, 14, 25, 39, 50, 55, 50, 39, 25, 14, 7, 4, 1, 1, 2, 6, 12, 22, 34, 44, 49, 44, 34, 22, 12, 6, 2, 1, 1, 2, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 2, 3, 8, 23, 58, 129, 240, 376, 492, 539, 492, 376, 240, 129, 58, 23, 8, 3, 1, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 1, 2, 2, 3, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 3, 2, 2, 4, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 4, 57, 122, 225, 350, 457, 500, 457, 350, 225, 122, 57, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 2, 2, 3, 6, 13, 22, 34, 45, 49, 45, 34, 22, 13, 6, 3, 2, 2, 2, 3, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 3, 2, 10, 16, 26, 38, 48, 52, 48, 38, 26, 16, 10],
					G: [4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 6, 9, 14, 20, 26, 28, 26, 20, 14, 9, 6, 4, 5, 6, 10, 15, 22, 27, 29, 27, 22, 15, 10, 6, 5, 4, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 5, 5, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 5, 5, 4, 4, 5, 6, 10, 15, 22, 28, 30, 28, 22, 15, 10, 6, 5, 4, 4, 22, 57, 127, 237, 370, 485, 530, 485, 370, 237, 127, 57, 22, 24, 60, 130, 242, 377, 493, 539, 493, 377, 242, 130, 60, 24, 2, 7, 21, 55, 123, 230, 361, 472, 517, 472, 361, 230, 123, 55, 21, 7, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 5, 8, 14, 20, 25, 28, 25, 20, 14, 8, 5, 3, 3, 9, 22, 55, 120, 224, 349, 457, 499, 457, 349, 224, 120, 55, 22, 9, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 5, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 22, 54, 116, 215, 335, 438, 479, 438, 335, 215, 116, 54, 22, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 22, 57, 127, 237, 371, 485, 530, 485, 371, 237, 127, 57, 22, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 3, 3, 3, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 3, 3, 3, 11, 25, 59, 127, 234, 364, 476, 520, 476, 364, 234, 127, 59, 25, 11, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 5, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 5, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 10, 23, 56, 121, 223, 348, 455, 498, 455, 348, 223, 121, 56, 23, 10, 1, 3, 6, 12, 18, 23, 25, 23, 18, 12, 6, 3, 1, 1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 11, 25, 61, 131, 243, 378, 494, 540, 494, 378, 243, 131, 61, 25, 11, 4, 8, 14, 20, 26, 29, 26, 20, 14, 8, 4, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 50, 112, 211, 330, 432, 473, 432, 330, 211, 112, 50, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 2, 2, 2, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 2, 2, 2, 2, 2, 3, 4, 8, 13, 20, 25, 27, 25, 20, 13, 8, 4, 3, 2, 2, 5, 6, 10, 15, 22, 28, 30, 28, 22, 15, 10, 6, 5, 59, 130, 243, 381, 498, 545, 498, 381, 243, 130, 59, 54, 118, 218, 341, 446, 488, 446, 341, 218, 118, 54, 57, 126, 234, 365, 477, 522, 477, 365, 234, 126, 57, 4, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 4, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 4, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 4, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 6, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 6, 3, 6, 12, 18, 23, 25, 23, 18, 12, 6, 3, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 3, 8, 23, 59, 131, 244, 382, 500, 547, 500, 382, 244, 131, 59, 23, 8, 3, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 3, 5, 8, 13, 19, 24, 27, 24, 19, 13, 8, 5, 3, 5, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 5, 1, 2, 3, 7, 13, 20, 25, 28, 25, 20, 13, 7, 3, 2, 1, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 11, 24, 57, 122, 225, 350, 457, 500, 457, 350, 225, 122, 57, 24, 11, 23, 58, 129, 241, 377, 494, 540, 494, 377, 241, 129, 58, 23, 26, 62, 133, 246, 384, 501, 548, 501, 384, 246, 133, 62, 26, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 2, 2, 4, 8, 13, 19, 25, 27, 25, 19, 13, 8, 4, 2, 2, 2, 7, 20, 54, 120, 224, 351, 460, 503, 460, 351, 224, 120, 54, 20, 7, 2, 2, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 2, 2, 4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 7, 10, 16, 22, 27, 29, 27, 22, 16, 10, 7, 10, 23, 57, 124, 230, 359, 469, 513, 469, 359, 230, 124, 57, 23, 10, 2, 2, 3, 4, 8, 14, 21, 27, 29, 27, 21, 14, 8, 4, 3, 2, 2, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 7, 11, 17, 24, 29, 32, 29, 24, 17, 11, 7],
					T: [3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 4, 4, 4, 5, 6, 8, 10, 13, 14, 13, 10, 8, 6, 5, 4, 4, 4, 2, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 2, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 1, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 23, 59, 131, 244, 382, 501, 548, 501, 382, 244, 131, 59, 23, 5, 10, 24, 59, 129, 239, 373, 488, 534, 488, 373, 239, 129, 59, 24, 10, 5, 6, 19, 50, 112, 210, 329, 431, 472, 431, 329, 210, 112, 50, 19, 6, 54, 118, 219, 342, 447, 488, 447, 342, 219, 118, 54, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 10, 23, 54, 115, 213, 331, 433, 473, 433, 331, 213, 115, 54, 23, 10, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 21, 54, 119, 223, 348, 456, 498, 456, 348, 223, 119, 54, 21, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 2, 3, 4, 6, 8, 11, 12, 11, 8, 6, 4, 3, 2, 23, 58, 129, 242, 378, 495, 541, 495, 378, 242, 129, 58, 23, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 5, 2, 6, 19, 51, 113, 212, 332, 435, 476, 435, 332, 212, 113, 51, 19, 6, 2, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 20, 53, 119, 222, 349, 456, 499, 456, 349, 222, 119, 53, 20, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 5, 6, 7, 9, 12, 15, 15, 15, 12, 9, 7, 6, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 57, 126, 235, 367, 481, 526, 481, 367, 235, 126, 57, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 58, 128, 237, 371, 485, 530, 485, 371, 237, 128, 58, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 5, 5, 6, 7, 9, 11, 14, 15, 14, 11, 9, 7, 6, 5, 5, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 23, 55, 119, 221, 345, 451, 493, 451, 345, 221, 119, 55, 23, 7, 22, 58, 130, 243, 381, 499, 546, 499, 381, 243, 130, 58, 22, 7, 61, 133, 245, 381, 498, 545, 498, 381, 245, 133, 61, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 50, 111, 207, 325, 426, 466, 426, 325, 207, 111, 50, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 56, 119, 220, 342, 447, 489, 447, 342, 220, 119, 56, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 4, 5, 6, 8, 11, 14, 14, 14, 11, 8, 6, 5, 4, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 7, 21, 53, 117, 219, 343, 449, 491, 449, 343, 219, 117, 53, 21, 7, 21, 55, 122, 228, 356, 466, 510, 466, 356, 228, 122, 55, 21, 2, 6, 18, 48, 108, 202, 316, 414, 452, 414, 316, 202, 108, 48, 18, 6, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 8, 23, 59, 132, 246, 385, 504, 551, 504, 385, 246, 132, 59, 23, 8, 3, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 6, 7, 9, 11, 13, 14, 13, 11, 9, 7, 6, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 3, 7, 21, 53, 117, 219, 343, 448, 491, 448, 343, 219, 117, 53, 21, 7, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5],
					peak: [5, 16, 29, 42, 54, 68, 84, 99, 112, 127, 142, 157, 173, 186, 198, 212, 227, 242, 258, 273, 286, 299, 312, 325, 338, 353, 369, 385, 402, 418, 433, 447, 461, 475, 489, 502, 514, 527, 539, 550, 562, 575, 589, 605, 622, 637, 649, 660, 671, 683, 697, 710, 722, 735, 750, 764, 777, 792, 808, 822, 834, 847, 861, 877, 891, 905, 921, 935, 948, 962, 976, 991, 1007, 1023, 1039, 1055, 1071, 1084, 1097, 1113, 1129, 1142]
				},
				index: 1,
				counter: 4,
				measureText: 74
			}, {
				id: "R1-0000-3456",
				fill: "rgb(255,51,255)",
				outline: "rgb(0,0,0)",
				dir: "left",
				offsetLeft: "134",
				sequence: "AAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAAC",
				coordinate: 230,
				trace: {
					A: [6, 18, 49, 109, 203, 319, 417, 457, 417, 319, 203, 109, 49, 18, 6, 2, 6, 19, 50, 112, 210, 330, 432, 472, 432, 330, 210, 112, 50, 19, 6, 2, 5, 10, 23, 57, 124, 230, 359, 469, 513, 469, 359, 230, 124, 57, 23, 10, 5, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 5, 11, 23, 42, 65, 85, 93, 85, 65, 42, 23, 11, 5, 2, 4, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 4, 2, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 6, 13, 28, 50, 78, 102, 111, 102, 78, 50, 28, 13, 6, 12, 26, 49, 76, 100, 109, 100, 76, 49, 26, 12, 2, 4, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 4, 2, 2, 4, 10, 23, 42, 66, 86, 94, 86, 66, 42, 23, 10, 4, 2, 1, 2, 4, 11, 24, 46, 71, 93, 102, 93, 71, 46, 24, 11, 4, 2, 1, 3, 8, 21, 55, 122, 228, 357, 468, 512, 468, 357, 228, 122, 55, 21, 8, 3, 15, 28, 49, 75, 96, 105, 96, 75, 49, 28, 15, 1, 2, 5, 11, 25, 46, 72, 95, 104, 95, 72, 46, 25, 11, 5, 2, 1, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 7, 22, 58, 130, 243, 381, 499, 546, 499, 381, 243, 130, 58, 22, 7, 4, 6, 12, 24, 43, 65, 85, 93, 85, 65, 43, 24, 12, 6, 4, 5, 12, 26, 48, 75, 98, 107, 98, 75, 48, 26, 12, 5, 2, 4, 11, 24, 44, 68, 89, 98, 89, 68, 44, 24, 11, 4, 2, 24, 58, 125, 230, 358, 468, 512, 468, 358, 230, 125, 58, 24, 50, 109, 203, 317, 414, 453, 414, 317, 203, 109, 50, 8, 22, 54, 119, 220, 344, 450, 492, 450, 344, 220, 119, 54, 22, 8, 4, 10, 23, 42, 65, 86, 94, 86, 65, 42, 23, 10, 4, 5, 12, 26, 48, 75, 99, 108, 99, 75, 48, 26, 12, 5, 9, 16, 29, 51, 78, 100, 109, 100, 78, 51, 29, 16, 9, 3, 4, 6, 13, 25, 45, 69, 90, 98, 90, 69, 45, 25, 13, 6, 4, 3, 1, 2, 5, 12, 26, 48, 74, 97, 106, 97, 74, 48, 26, 12, 5, 2, 1, 3, 5, 11, 23, 42, 65, 84, 92, 84, 65, 42, 23, 11, 5, 3, 4, 5, 7, 14, 27, 48, 73, 95, 103, 95, 73, 48, 27, 14, 7, 5, 4, 15, 28, 49, 74, 95, 104, 95, 74, 49, 28, 15, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 5, 9, 22, 54, 116, 215, 336, 439, 480, 439, 336, 215, 116, 54, 22, 9, 5, 11, 24, 45, 70, 91, 99, 91, 70, 45, 24, 11, 7, 14, 27, 48, 73, 95, 103, 95, 73, 48, 27, 14, 7, 2, 3, 5, 12, 25, 45, 70, 91, 100, 91, 70, 45, 25, 12, 5, 3, 2, 23, 59, 132, 246, 385, 504, 551, 504, 385, 246, 132, 59, 23, 11, 23, 43, 66, 86, 94, 86, 66, 43, 23, 11, 7, 14, 27, 49, 76, 99, 108, 99, 76, 49, 27, 14, 7, 1, 2, 5, 12, 26, 49, 76, 100, 109, 100, 76, 49, 26, 12, 5, 2, 1, 50, 113, 211, 331, 433, 474, 433, 331, 211, 113, 50, 2, 7, 20, 54, 120, 225, 352, 461, 505, 461, 352, 225, 120, 54, 20, 7, 2, 7, 21, 56, 125, 234, 366, 480, 525, 480, 366, 234, 125, 56, 21, 7, 9, 15, 29, 50, 76, 99, 108, 99, 76, 50, 29, 15, 9, 16, 30, 52, 79, 103, 112, 103, 79, 52, 30, 16, 13, 25, 44, 67, 87, 95, 87, 67, 44, 25, 13, 7, 14, 28, 51, 78, 102, 111, 102, 78, 51, 28, 14, 7, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 2, 4, 11, 23, 43, 67, 88, 96, 88, 67, 43, 23, 11, 4, 2, 5, 7, 13, 25, 45, 68, 88, 96, 88, 68, 45, 25, 13, 7, 5, 4, 5, 8, 15, 28, 50, 76, 99, 108, 99, 76, 50, 28, 15, 8, 5, 4, 15, 27, 47, 71, 92, 100, 92, 71, 47, 27, 15, 7, 21, 56, 125, 235, 368, 482, 528, 482, 368, 235, 125, 56, 21, 7, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 2, 3, 5, 11, 23, 42, 66, 85, 93, 85, 66, 42, 23, 11, 5, 3, 2, 2, 4, 10, 22, 41, 65, 85, 93, 85, 65, 41, 22, 10, 4, 2, 4, 8, 22, 54, 118, 220, 343, 448, 490, 448, 343, 220, 118, 54, 22, 8, 4, 13, 26, 45, 69, 90, 98, 90, 69, 45, 26, 13, 4, 5, 8, 15, 30, 52, 80, 104, 113, 104, 80, 52, 30, 15, 8, 5, 4, 2, 3, 6, 13, 27, 49, 76, 99, 108, 99, 76, 49, 27, 13, 6, 3, 2, 9, 23, 55, 120, 222, 347, 453, 496, 453, 347, 222, 120, 55, 23, 9, 60, 131, 243, 380, 496, 543, 496, 380, 243, 131, 60, 11, 26, 61, 132, 244, 380, 496, 542, 496, 380, 244, 132, 61, 26, 11, 2, 4, 11, 24, 44, 69, 90, 98, 90, 69, 44, 24, 11, 4, 2, 4, 11, 24, 45, 70, 91, 100, 91, 70, 45, 24, 11, 4, 8, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 8, 12, 26, 47, 74, 96, 105, 96, 74, 47, 26, 12, 5, 6, 9, 15, 29, 51, 77, 99, 108, 99, 77, 51, 29, 15, 9, 6, 5, 3, 5, 11, 23, 42, 66, 86, 94, 86, 66, 42, 23, 11, 5, 3, 4, 5, 7, 14, 26, 47, 71, 92, 100, 92, 71, 47, 26, 14, 7, 5, 4, 5, 8, 15, 29, 52, 79, 102, 112, 102, 79, 52, 29, 15, 8, 5, 5, 6, 9, 16, 30, 53, 80, 104, 113, 104, 80, 53, 30, 16, 9, 6, 5, 20, 50, 110, 204, 318, 416, 455, 416, 318, 204, 110, 50, 20, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 3, 4, 6, 13, 26, 46, 71, 93, 101, 93, 71, 46, 26, 13, 6, 4, 3, 13, 27, 50, 77, 101, 110, 101, 77, 50, 27, 13, 60, 132, 245, 383, 501, 548, 501, 383, 245, 132, 60, 13, 27, 50, 77, 101, 110, 101, 77, 50, 27, 13, 10, 23, 42, 66, 86, 95, 86, 66, 42, 23, 10, 4, 6, 12, 25, 44, 67, 87, 95, 87, 67, 44, 25, 12, 6, 4, 58, 129, 242, 380, 498, 544, 498, 380, 242, 129, 58, 6, 18, 49, 109, 204, 320, 419, 458, 419, 320, 204, 109, 49, 18, 6, 23, 57, 125, 232, 362, 474, 518, 474, 362, 232, 125, 57, 23, 4, 5, 8, 15, 29, 52, 80, 103, 112, 103, 80, 52, 29, 15, 8, 5, 4],
					C: [1, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 1, 1, 1, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 1, 4, 4, 5, 8, 15, 24, 36, 46, 50, 46, 36, 24, 15, 8, 5, 4, 4, 60, 132, 246, 385, 504, 551, 504, 385, 246, 132, 60, 19, 50, 110, 206, 322, 421, 460, 421, 322, 206, 110, 50, 19, 7, 21, 56, 124, 233, 365, 478, 523, 478, 365, 233, 124, 56, 21, 7, 6, 13, 25, 38, 50, 55, 50, 38, 25, 13, 6, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 6, 13, 23, 36, 47, 52, 47, 36, 23, 13, 6, 1, 2, 5, 11, 21, 33, 43, 47, 43, 33, 21, 11, 5, 2, 1, 1, 2, 5, 11, 21, 33, 42, 46, 42, 33, 21, 11, 5, 2, 1, 1, 1, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 1, 1, 2, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 2, 2, 56, 120, 221, 344, 449, 491, 449, 344, 221, 120, 56, 1, 1, 3, 6, 13, 24, 37, 48, 52, 48, 37, 24, 13, 6, 3, 1, 1, 4, 7, 14, 26, 39, 51, 56, 51, 39, 26, 14, 7, 4, 1, 2, 6, 12, 22, 35, 45, 50, 45, 35, 22, 12, 6, 2, 1, 8, 21, 53, 116, 216, 337, 441, 482, 441, 337, 216, 116, 53, 21, 8, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 1, 6, 10, 16, 26, 38, 48, 53, 48, 38, 26, 16, 10, 6, 8, 15, 26, 39, 50, 55, 50, 39, 26, 15, 8, 3, 4, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 3, 20, 53, 119, 224, 350, 459, 502, 459, 350, 224, 119, 53, 20, 19, 50, 112, 211, 330, 432, 473, 432, 330, 211, 112, 50, 19, 23, 55, 118, 218, 340, 444, 485, 444, 340, 218, 118, 55, 23, 3, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 3, 1, 1, 3, 6, 13, 24, 37, 48, 52, 48, 37, 24, 13, 6, 3, 1, 1, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 4, 4, 5, 8, 14, 24, 36, 45, 49, 45, 36, 24, 14, 8, 5, 4, 4, 10, 17, 29, 43, 55, 59, 55, 43, 29, 17, 10, 10, 17, 28, 42, 53, 58, 53, 42, 28, 17, 10, 4, 4, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 4, 4, 54, 121, 226, 354, 464, 508, 464, 354, 226, 121, 54, 5, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 5, 2, 2, 3, 7, 13, 23, 36, 47, 51, 47, 36, 23, 13, 7, 3, 2, 2, 4, 7, 14, 25, 39, 51, 55, 51, 39, 25, 14, 7, 4, 51, 113, 210, 329, 430, 471, 430, 329, 210, 113, 51, 4, 8, 14, 24, 37, 47, 51, 47, 37, 24, 14, 8, 4, 1, 1, 2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 1, 1, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 1, 1, 2, 5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 2, 1, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 22, 52, 112, 206, 321, 419, 458, 419, 321, 206, 112, 52, 22, 55, 117, 216, 337, 440, 481, 440, 337, 216, 117, 55, 53, 115, 212, 331, 432, 472, 432, 331, 212, 115, 53, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 1, 2, 6, 12, 22, 35, 46, 50, 46, 35, 22, 12, 6, 2, 1, 1, 2, 5, 11, 21, 32, 42, 46, 42, 32, 21, 11, 5, 2, 1, 4, 6, 9, 16, 28, 41, 53, 58, 53, 41, 28, 16, 9, 6, 4, 4, 4, 5, 9, 16, 26, 39, 50, 54, 50, 39, 26, 16, 9, 5, 4, 4, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 1, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 23, 57, 125, 233, 364, 476, 521, 476, 364, 233, 125, 57, 23, 2, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 2, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 3, 3, 5, 8, 15, 27, 41, 52, 57, 52, 41, 27, 15, 8, 5, 3, 3, 54, 116, 215, 335, 437, 478, 437, 335, 215, 116, 54, 4, 4, 6, 9, 16, 26, 39, 50, 55, 50, 39, 26, 16, 9, 6, 4, 4, 2, 2, 4, 7, 14, 24, 37, 49, 53, 49, 37, 24, 14, 7, 4, 2, 2, 4, 6, 9, 16, 26, 39, 51, 55, 51, 39, 26, 16, 9, 6, 4, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 6, 9, 16, 25, 37, 47, 51, 47, 37, 25, 16, 9, 6, 5, 7, 22, 57, 128, 239, 375, 491, 537, 491, 375, 239, 128, 57, 22, 7, 22, 58, 130, 244, 383, 501, 548, 501, 383, 244, 130, 58, 22, 22, 53, 113, 208, 324, 423, 463, 423, 324, 208, 113, 53, 22, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 5, 5, 7, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 7, 5, 5, 2, 4, 7, 14, 26, 40, 52, 56, 52, 40, 26, 14, 7, 4, 2, 4, 4, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 4, 4, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4, 5, 5, 6, 9, 16, 25, 37, 48, 52, 48, 37, 25, 16, 9, 6, 5, 5, 4, 7, 14, 24, 35, 46, 50, 46, 35, 24, 14, 7, 4, 51, 113, 212, 332, 435, 476, 435, 332, 212, 113, 51, 3, 3, 5, 8, 15, 26, 39, 50, 55, 50, 39, 26, 15, 8, 5, 3, 3, 6, 12, 22, 34, 43, 47, 43, 34, 22, 12, 6, 8, 14, 24, 37, 47, 52, 47, 37, 24, 14, 8, 56, 123, 230, 360, 471, 515, 471, 360, 230, 123, 56, 6, 13, 23, 36, 47, 52, 47, 36, 23, 13, 6, 3, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 3, 5, 11, 21, 33, 43, 46, 43, 33, 21, 11, 5, 1, 2, 6, 12, 23, 36, 47, 51, 47, 36, 23, 12, 6, 2, 1, 4, 7, 13, 23, 34, 44, 48, 44, 34, 23, 13, 7, 4, 5, 10, 23, 57, 123, 228, 355, 465, 508, 465, 355, 228, 123, 57, 23, 10, 5],
					G: [1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 1, 1, 1, 3, 6, 11, 17, 22, 25, 22, 17, 11, 6, 3, 1, 1, 1, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 5, 8, 14, 20, 26, 28, 26, 20, 14, 8, 5, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 1, 1, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 1, 1, 58, 129, 242, 379, 497, 543, 497, 379, 242, 129, 58, 21, 55, 122, 228, 356, 466, 510, 466, 356, 228, 122, 55, 21, 51, 114, 214, 335, 438, 480, 438, 335, 214, 114, 51, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 1, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 2, 6, 18, 49, 109, 204, 319, 418, 457, 418, 319, 204, 109, 49, 18, 6, 2, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3, 1, 1, 3, 6, 11, 16, 21, 23, 21, 16, 11, 6, 3, 1, 1, 3, 3, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 3, 3, 20, 53, 118, 222, 348, 456, 498, 456, 348, 222, 118, 53, 20, 1, 2, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 2, 1, 6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 5, 8, 13, 19, 24, 25, 24, 19, 13, 8, 5, 3, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 3, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 6, 7, 11, 16, 23, 28, 31, 28, 23, 16, 11, 7, 6, 4, 9, 24, 59, 130, 242, 378, 494, 540, 494, 378, 242, 130, 59, 24, 9, 4, 2, 7, 22, 58, 130, 244, 382, 500, 547, 500, 382, 244, 130, 58, 22, 7, 2, 7, 20, 51, 113, 210, 329, 431, 471, 431, 329, 210, 113, 51, 20, 7, 4, 4, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 4, 4, 4, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 4, 4, 4, 6, 9, 14, 20, 26, 28, 26, 20, 14, 9, 6, 4, 4, 4, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 25, 61, 134, 248, 387, 506, 553, 506, 387, 248, 134, 61, 25, 2, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 2, 2, 4, 7, 12, 18, 24, 26, 24, 18, 12, 7, 4, 2, 4, 7, 12, 18, 23, 26, 23, 18, 12, 7, 4, 24, 60, 132, 246, 384, 502, 549, 502, 384, 246, 132, 60, 24, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 7, 11, 17, 23, 29, 31, 29, 23, 17, 11, 7, 6, 9, 15, 21, 27, 29, 27, 21, 15, 9, 6, 21, 52, 114, 211, 330, 431, 471, 431, 330, 211, 114, 52, 21, 6, 18, 49, 109, 205, 321, 420, 459, 420, 321, 205, 109, 49, 18, 6, 7, 21, 55, 124, 232, 363, 476, 521, 476, 363, 232, 124, 55, 21, 7, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 4, 4, 4, 4, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 4, 4, 4, 7, 10, 16, 22, 27, 29, 27, 22, 16, 10, 7, 1, 2, 3, 7, 13, 19, 25, 28, 25, 19, 13, 7, 3, 2, 1, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 3, 7, 20, 52, 114, 213, 333, 436, 477, 436, 333, 213, 114, 52, 20, 7, 3, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 3, 3, 4, 5, 9, 14, 21, 26, 28, 26, 21, 14, 9, 5, 4, 3, 3, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 5, 10, 24, 58, 126, 234, 365, 477, 521, 477, 365, 234, 126, 58, 24, 10, 5, 2, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 4, 4, 6, 9, 15, 21, 26, 28, 26, 21, 15, 9, 6, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 5, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 5, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 5, 7, 10, 16, 22, 27, 29, 27, 22, 16, 10, 7, 5, 56, 124, 232, 364, 476, 521, 476, 364, 232, 124, 56, 6, 11, 25, 60, 129, 239, 372, 486, 531, 486, 372, 239, 129, 60, 25, 11, 6, 8, 22, 56, 123, 230, 360, 471, 515, 471, 360, 230, 123, 56, 22, 8, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 5, 5, 5, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 5, 5, 5, 3, 5, 8, 13, 19, 24, 27, 24, 19, 13, 8, 5, 3, 3, 6, 11, 17, 23, 25, 23, 17, 11, 6, 3, 4, 8, 21, 52, 114, 212, 331, 433, 474, 433, 331, 212, 114, 52, 21, 8, 4, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 5, 9, 14, 20, 26, 28, 26, 20, 14, 9, 5, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 56, 126, 236, 370, 485, 530, 485, 370, 236, 126, 56, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 1, 1, 3, 6, 12, 18, 23, 26, 23, 18, 12, 6, 3, 1, 1, 4, 5, 9, 15, 22, 27, 30, 27, 22, 15, 9, 5, 4, 4, 4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 4],
					T: [1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 4, 4, 4, 5, 6, 8, 10, 13, 14, 13, 10, 8, 6, 5, 4, 4, 4, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 6, 19, 51, 114, 213, 334, 438, 479, 438, 334, 213, 114, 51, 19, 6, 6, 19, 51, 115, 215, 336, 440, 482, 440, 336, 215, 115, 51, 19, 6, 2, 6, 19, 51, 115, 215, 337, 441, 482, 441, 337, 215, 115, 51, 19, 6, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 21, 54, 120, 224, 351, 459, 503, 459, 351, 224, 120, 54, 21, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 6, 19, 50, 111, 209, 327, 429, 469, 429, 327, 209, 111, 50, 19, 6, 5, 6, 7, 9, 12, 15, 15, 15, 12, 9, 7, 6, 5, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 2, 2, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 2, 2, 5, 9, 22, 52, 113, 210, 327, 427, 467, 427, 327, 210, 113, 52, 22, 9, 5, 57, 123, 227, 354, 462, 505, 462, 354, 227, 123, 57, 58, 125, 230, 359, 469, 512, 469, 359, 230, 125, 58, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 7, 20, 52, 114, 213, 333, 436, 477, 436, 333, 213, 114, 52, 20, 7, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 2, 7, 21, 56, 125, 235, 368, 482, 527, 482, 368, 235, 125, 56, 21, 7, 2, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 3, 4, 5, 7, 10, 13, 13, 13, 10, 7, 5, 4, 3, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 9, 22, 53, 115, 214, 333, 435, 476, 435, 333, 214, 115, 53, 22, 9, 5, 10, 24, 59, 128, 238, 371, 485, 531, 485, 371, 238, 128, 59, 24, 10, 5, 56, 120, 221, 344, 450, 492, 450, 344, 221, 120, 56, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 7, 21, 55, 122, 229, 359, 470, 514, 470, 359, 229, 122, 55, 21, 7, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 3, 8, 22, 56, 125, 232, 364, 476, 521, 476, 364, 232, 125, 56, 22, 8, 3, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 5, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 5, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 2, 3, 5, 7, 10, 11, 10, 7, 5, 3, 2, 1, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 5, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 5, 5, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 5, 9, 21, 52, 112, 207, 323, 422, 461, 422, 323, 207, 112, 52, 21, 9, 5, 9, 22, 54, 118, 218, 340, 445, 486, 445, 340, 218, 118, 54, 22, 9, 6, 10, 23, 53, 113, 209, 325, 425, 464, 425, 325, 209, 113, 53, 23, 10, 6, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 51, 113, 212, 331, 433, 474, 433, 331, 212, 113, 51, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 8, 21, 53, 116, 216, 338, 441, 483, 441, 338, 216, 116, 53, 21, 8, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 4, 5, 7, 10, 13, 13, 13, 10, 7, 5, 4, 3, 4, 4, 4, 5, 6, 8, 11, 14, 14, 14, 11, 8, 6, 5, 4, 4, 4],
					peak: [7, 23, 40, 54, 66, 80, 93, 105, 117, 130, 145, 161, 178, 192, 206, 221, 235, 250, 264, 278, 292, 304, 317, 331, 344, 357, 372, 389, 405, 421, 435, 446, 460, 474, 486, 501, 516, 528, 540, 555, 569, 583, 599, 613, 625, 636, 648, 662, 677, 692, 708, 722, 735, 749, 764, 780, 796, 810, 824, 841, 857, 870, 883, 898, 912, 925, 937, 951, 967, 983, 999, 1015, 1030, 1042, 1056, 1070, 1081, 1092, 1103, 1116, 1129, 1142, 1156, 1171]
				},
				index: 3,
				counter: 6,
				offset: 51,
				measureText: 74
			}, {
				id: "R1-0000-5678",
				fill: "rgb(51,255,255)",
				outline: "rgb(0,0,0)",
				dir: "right",
				offset: 126,
				gaps: [
					[5, 1],
					[58, 1]
				],
				sequence: "CCCGGTTTACGTACGTAAACCCGGGTTTACGTACGTAAACCCGGGTTTACGTACGTAACCCGGGTTTAAACC",
				coordinate: 150,
				trace: {
					A: [14, 26, 46, 70, 91, 99, 91, 70, 46, 26, 14, 6, 12, 26, 47, 74, 96, 105, 96, 74, 47, 26, 12, 6, 4, 10, 23, 43, 67, 87, 95, 87, 67, 43, 23, 10, 4, 4, 10, 22, 42, 65, 85, 93, 85, 65, 42, 22, 10, 4, 13, 26, 48, 73, 95, 104, 95, 73, 48, 26, 13, 6, 9, 16, 30, 52, 78, 101, 111, 101, 78, 52, 30, 16, 9, 6, 13, 26, 46, 71, 92, 101, 92, 71, 46, 26, 13, 1, 2, 4, 11, 24, 45, 70, 92, 100, 92, 70, 45, 24, 11, 4, 2, 1, 52, 115, 213, 332, 435, 475, 435, 332, 213, 115, 52, 4, 5, 7, 13, 25, 44, 67, 87, 95, 87, 67, 44, 25, 13, 7, 5, 4, 13, 27, 49, 77, 100, 109, 100, 77, 49, 27, 13, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 24, 60, 130, 242, 377, 493, 539, 493, 377, 242, 130, 60, 24, 12, 25, 44, 68, 89, 97, 89, 68, 44, 25, 12, 4, 7, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 7, 4, 4, 6, 13, 25, 45, 69, 90, 98, 90, 69, 45, 25, 13, 6, 4, 3, 7, 21, 53, 117, 218, 341, 446, 488, 446, 341, 218, 117, 53, 21, 7, 3, 9, 23, 58, 127, 237, 370, 483, 529, 483, 370, 237, 127, 58, 23, 9, 57, 123, 228, 355, 464, 508, 464, 355, 228, 123, 57, 3, 5, 12, 26, 47, 73, 95, 103, 95, 73, 47, 26, 12, 5, 3, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 10, 22, 41, 63, 83, 91, 83, 63, 41, 22, 10, 1, 2, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 2, 1, 4, 5, 8, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 8, 5, 4, 4, 6, 13, 25, 45, 70, 90, 99, 90, 70, 45, 25, 13, 6, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 11, 24, 44, 69, 90, 99, 90, 69, 44, 24, 11, 4, 3, 6, 12, 26, 48, 74, 97, 105, 97, 74, 48, 26, 12, 6, 3, 52, 116, 216, 338, 443, 484, 443, 338, 216, 116, 52, 5, 6, 8, 15, 29, 50, 76, 98, 107, 98, 76, 50, 29, 15, 8, 6, 5, 5, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 5, 11, 25, 46, 72, 94, 103, 94, 72, 46, 25, 11, 10, 23, 56, 121, 223, 348, 455, 498, 455, 348, 223, 121, 56, 23, 10, 2, 3, 6, 13, 27, 50, 77, 100, 109, 100, 77, 50, 27, 13, 6, 3, 2, 3, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 3, 1, 2, 5, 11, 25, 46, 72, 95, 104, 95, 72, 46, 25, 11, 5, 2, 1, 11, 24, 58, 124, 229, 357, 466, 509, 466, 357, 229, 124, 58, 24, 11, 21, 54, 119, 223, 349, 457, 500, 457, 349, 223, 119, 54, 21, 19, 49, 109, 202, 317, 414, 453, 414, 317, 202, 109, 49, 19, 2, 3, 6, 13, 27, 50, 78, 101, 110, 101, 78, 50, 27, 13, 6, 3, 2, 1, 2, 4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 2, 1, 4, 5, 7, 13, 25, 44, 67, 87, 95, 87, 67, 44, 25, 13, 7, 5, 4, 6, 8, 15, 28, 48, 73, 94, 102, 94, 73, 48, 28, 15, 8, 6, 10, 23, 42, 66, 86, 94, 86, 66, 42, 23, 10, 5, 11, 23, 42, 65, 85, 93, 85, 65, 42, 23, 11, 5, 4, 6, 12, 25, 44, 68, 88, 96, 88, 68, 44, 25, 12, 6, 4, 7, 13, 27, 48, 75, 97, 106, 97, 75, 48, 27, 13, 7, 3, 6, 13, 27, 50, 77, 101, 110, 101, 77, 50, 27, 13, 6, 3, 58, 129, 241, 377, 494, 540, 494, 377, 241, 129, 58, 5, 12, 26, 48, 75, 99, 108, 99, 75, 48, 26, 12, 5, 5, 12, 25, 45, 70, 92, 100, 92, 70, 45, 25, 12, 5, 5, 6, 8, 15, 28, 49, 74, 96, 104, 96, 74, 49, 28, 15, 8, 6, 5, 59, 129, 241, 376, 492, 538, 492, 376, 241, 129, 59, 1, 2, 4, 11, 24, 44, 69, 91, 99, 91, 69, 44, 24, 11, 4, 2, 1, 6, 8, 14, 27, 46, 69, 90, 98, 90, 69, 46, 27, 14, 8, 6, 16, 29, 51, 78, 100, 109, 100, 78, 51, 29, 16, 5, 10, 24, 58, 126, 233, 363, 475, 519, 475, 363, 233, 126, 58, 24, 10, 5, 58, 129, 243, 380, 498, 545, 498, 380, 243, 129, 58, 12, 24, 45, 69, 90, 98, 90, 69, 45, 24, 12, 8, 15, 28, 48, 73, 94, 102, 94, 73, 48, 28, 15, 8, 2, 5, 12, 25, 47, 73, 96, 105, 96, 73, 47, 25, 12, 5, 2, 15, 29, 51, 78, 101, 110, 101, 78, 51, 29, 15, 8, 15, 29, 51, 78, 102, 111, 102, 78, 51, 29, 15, 8, 11, 24, 44, 67, 88, 96, 88, 67, 44, 24, 11, 10, 23, 42, 66, 86, 94, 86, 66, 42, 23, 10, 5, 6, 8, 15, 28, 48, 73, 94, 103, 94, 73, 48, 28, 15, 8, 6, 5, 8, 14, 27, 46, 70, 90, 98, 90, 70, 46, 27, 14, 8, 25, 60, 129, 239, 372, 486, 532, 486, 372, 239, 129, 60, 25, 9, 21, 51, 110, 204, 319, 416, 455, 416, 319, 204, 110, 51, 21, 9, 56, 119, 220, 343, 448, 489, 448, 343, 220, 119, 56, 3, 4, 7, 14, 28, 50, 78, 101, 110, 101, 78, 50, 28, 14, 7, 4, 3, 14, 28, 51, 79, 103, 112, 103, 79, 51, 28, 14],
					C: [53, 114, 212, 330, 431, 472, 431, 330, 212, 114, 53, 20, 52, 115, 215, 336, 440, 481, 440, 336, 215, 115, 52, 20, 19, 49, 110, 206, 323, 423, 463, 423, 323, 206, 110, 49, 19, 2, 6, 12, 23, 35, 46, 51, 46, 35, 23, 12, 6, 2, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 5, 7, 10, 17, 28, 42, 53, 58, 53, 42, 28, 17, 10, 7, 5, 8, 14, 25, 38, 49, 53, 49, 38, 25, 14, 8, 1, 1, 2, 5, 11, 21, 32, 42, 46, 42, 32, 21, 11, 5, 2, 1, 1, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 5, 9, 22, 52, 113, 209, 326, 426, 465, 426, 326, 209, 113, 52, 22, 9, 5, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 4, 7, 13, 23, 35, 44, 48, 44, 35, 23, 13, 7, 4, 6, 9, 16, 27, 40, 52, 56, 52, 40, 27, 16, 9, 6, 50, 110, 204, 319, 417, 455, 417, 319, 204, 110, 50, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 3, 4, 8, 14, 24, 37, 48, 52, 48, 37, 24, 14, 8, 4, 3, 2, 2, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 2, 2, 3, 4, 8, 14, 25, 38, 49, 53, 49, 38, 25, 14, 8, 4, 3, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 7, 21, 53, 118, 221, 345, 452, 494, 452, 345, 221, 118, 53, 21, 7, 19, 49, 110, 205, 322, 421, 461, 421, 322, 205, 110, 49, 19, 57, 127, 238, 373, 489, 535, 489, 373, 238, 127, 57, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 4, 4, 6, 9, 16, 27, 40, 51, 56, 51, 40, 27, 16, 9, 6, 4, 4, 3, 5, 8, 15, 26, 40, 51, 56, 51, 40, 26, 15, 8, 5, 3, 6, 13, 24, 38, 50, 54, 50, 38, 24, 13, 6, 3, 6, 13, 24, 37, 48, 53, 48, 37, 24, 13, 6, 3, 2, 4, 7, 14, 25, 38, 50, 54, 50, 38, 25, 14, 7, 4, 2, 7, 13, 23, 36, 46, 50, 46, 36, 23, 13, 7, 6, 11, 26, 62, 134, 248, 387, 505, 553, 505, 387, 248, 134, 62, 26, 11, 6, 2, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 2, 6, 12, 23, 35, 46, 50, 46, 35, 23, 12, 6, 4, 5, 9, 15, 26, 38, 49, 54, 49, 38, 26, 15, 9, 5, 4, 3, 8, 22, 58, 128, 239, 374, 489, 535, 489, 374, 239, 128, 58, 22, 8, 3, 2, 3, 7, 14, 24, 37, 48, 52, 48, 37, 24, 14, 7, 3, 2, 1, 1, 3, 6, 13, 24, 38, 49, 54, 49, 38, 24, 13, 6, 3, 1, 1, 5, 7, 10, 17, 28, 41, 53, 57, 53, 41, 28, 17, 10, 7, 5, 3, 7, 13, 24, 37, 48, 52, 48, 37, 24, 13, 7, 3, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 3, 7, 21, 53, 118, 221, 345, 452, 494, 452, 345, 221, 118, 53, 21, 7, 3, 2, 6, 18, 49, 109, 204, 320, 419, 458, 419, 320, 204, 109, 49, 18, 6, 2, 5, 9, 21, 52, 111, 206, 321, 420, 459, 420, 321, 206, 111, 52, 21, 9, 5, 5, 7, 10, 17, 28, 41, 52, 57, 52, 41, 28, 17, 10, 7, 5, 6, 13, 25, 38, 50, 55, 50, 38, 25, 13, 6, 3, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 3, 3, 5, 8, 15, 25, 38, 50, 54, 50, 38, 25, 15, 8, 5, 3, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 4, 2, 4, 7, 14, 24, 37, 48, 53, 48, 37, 24, 14, 7, 4, 2, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 22, 57, 128, 240, 376, 492, 538, 492, 376, 240, 128, 57, 22, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 5, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 5, 8, 14, 24, 36, 47, 51, 47, 36, 24, 14, 8, 2, 6, 20, 52, 116, 217, 341, 446, 488, 446, 341, 217, 116, 52, 20, 6, 2, 5, 6, 10, 16, 26, 39, 49, 53, 49, 39, 26, 16, 10, 6, 5, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 4, 4, 5, 9, 15, 25, 38, 49, 53, 49, 38, 25, 15, 9, 5, 4, 4, 6, 12, 22, 34, 45, 49, 45, 34, 22, 12, 6, 54, 119, 221, 346, 453, 496, 453, 346, 221, 119, 54, 25, 61, 131, 242, 376, 492, 538, 492, 376, 242, 131, 61, 25, 7, 21, 55, 123, 230, 361, 473, 517, 473, 361, 230, 123, 55, 21, 7, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 7, 13, 24, 36, 47, 51, 47, 36, 24, 13, 7, 6, 12, 23, 35, 46, 50, 46, 35, 23, 12, 6, 5, 5, 6, 10, 16, 27, 39, 50, 54, 50, 39, 27, 16, 10, 6, 5, 5, 6, 10, 16, 26, 39, 49, 53, 49, 39, 26, 16, 10, 6, 6, 9, 15, 25, 37, 46, 50, 46, 37, 25, 15, 9, 6, 4, 5, 9, 15, 25, 37, 47, 51, 47, 37, 25, 15, 9, 5, 4, 10, 16, 27, 40, 50, 55, 50, 40, 27, 16, 10, 4, 9, 23, 58, 128, 238, 371, 485, 531, 485, 371, 238, 128, 58, 23, 9, 4, 58, 128, 237, 371, 485, 530, 485, 371, 237, 128, 58],
					G: [6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 3, 7, 13, 20, 26, 28, 26, 20, 13, 7, 3, 2, 20, 53, 119, 222, 349, 457, 499, 457, 349, 222, 119, 53, 20, 58, 126, 235, 367, 480, 525, 480, 367, 235, 126, 58, 5, 6, 7, 11, 16, 23, 28, 30, 28, 23, 16, 11, 7, 6, 5, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 1, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 4, 4, 5, 6, 10, 15, 22, 27, 29, 27, 22, 15, 10, 6, 5, 4, 4, 51, 113, 211, 331, 433, 473, 433, 331, 211, 113, 51, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 5, 8, 13, 20, 25, 27, 25, 20, 13, 8, 5, 9, 22, 56, 123, 228, 356, 466, 510, 466, 356, 228, 123, 56, 22, 9, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 2, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 2, 3, 4, 5, 9, 14, 21, 27, 29, 27, 21, 14, 9, 5, 4, 3, 6, 10, 15, 22, 27, 29, 27, 22, 15, 10, 6, 2, 2, 4, 7, 12, 18, 23, 25, 23, 18, 12, 7, 4, 2, 2, 2, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 2, 3, 7, 13, 20, 25, 28, 25, 20, 13, 7, 3, 2, 7, 20, 53, 119, 223, 350, 459, 502, 459, 350, 223, 119, 53, 20, 7, 2, 5, 9, 21, 51, 111, 205, 319, 417, 456, 417, 319, 205, 111, 51, 21, 9, 5, 8, 21, 53, 116, 215, 336, 439, 480, 439, 336, 215, 116, 53, 21, 8, 3, 6, 11, 17, 23, 25, 23, 17, 11, 6, 3, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 2, 2, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 5, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 5, 5, 21, 56, 124, 233, 365, 478, 523, 478, 365, 233, 124, 56, 21, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 2, 2, 2, 4, 7, 13, 19, 24, 27, 24, 19, 13, 7, 4, 2, 2, 2, 7, 19, 50, 110, 205, 321, 420, 459, 420, 321, 205, 110, 50, 19, 7, 1, 1, 1, 3, 6, 11, 18, 23, 25, 23, 18, 11, 6, 3, 1, 1, 1, 5, 6, 7, 11, 16, 23, 28, 30, 28, 23, 16, 11, 7, 6, 5, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 3, 4, 8, 14, 21, 27, 29, 27, 21, 14, 8, 4, 3, 2, 2, 2, 4, 7, 13, 19, 24, 26, 24, 19, 13, 7, 4, 2, 2, 2, 1, 1, 2, 3, 7, 13, 19, 25, 28, 25, 19, 13, 7, 3, 2, 1, 1, 4, 4, 5, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 5, 4, 4, 10, 22, 52, 112, 206, 321, 419, 458, 419, 321, 206, 112, 52, 22, 10, 57, 127, 238, 373, 488, 534, 488, 373, 238, 127, 57, 20, 51, 112, 209, 327, 428, 468, 428, 327, 209, 112, 51, 20, 3, 4, 5, 9, 14, 21, 26, 28, 26, 21, 14, 9, 5, 4, 3, 3, 5, 8, 13, 19, 25, 27, 25, 19, 13, 8, 5, 3, 2, 2, 4, 7, 12, 19, 24, 26, 24, 19, 12, 7, 4, 2, 2, 4, 8, 13, 20, 25, 28, 25, 20, 13, 8, 4, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 21, 54, 119, 222, 347, 454, 496, 454, 347, 222, 119, 54, 21, 5, 5, 5, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 5, 5, 5, 5, 9, 15, 21, 27, 30, 27, 21, 15, 9, 5, 1, 1, 2, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 2, 1, 1, 11, 24, 57, 123, 227, 354, 463, 506, 463, 354, 227, 123, 57, 24, 11, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 4, 4, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 4, 4, 4, 3, 7, 12, 19, 24, 26, 24, 19, 12, 7, 3, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 6, 7, 11, 17, 23, 29, 32, 29, 23, 17, 11, 7, 6, 1, 2, 3, 7, 12, 19, 25, 27, 25, 19, 12, 7, 3, 2, 1, 55, 120, 222, 346, 452, 494, 452, 346, 222, 120, 55, 23, 57, 123, 229, 357, 466, 510, 466, 357, 229, 123, 57, 23, 53, 118, 220, 344, 450, 492, 450, 344, 220, 118, 53, 3, 6, 12, 18, 24, 26, 24, 18, 12, 6, 3, 5, 5, 5, 7, 11, 16, 22, 28, 30, 28, 22, 16, 11, 7, 5, 5, 5, 5, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 4, 7, 10, 15, 22, 27, 29, 27, 22, 15, 10, 7, 3, 3, 3, 5, 9, 14, 20, 26, 28, 26, 20, 14, 9, 5, 3, 3, 3, 5, 8, 14, 20, 25, 28, 25, 20, 14, 8, 5],
					T: [5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 51, 112, 208, 324, 424, 463, 424, 324, 208, 112, 51, 2, 6, 19, 49, 109, 205, 321, 421, 460, 421, 321, 205, 109, 49, 19, 6, 2, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 22, 56, 122, 227, 355, 464, 508, 464, 355, 227, 122, 56, 22, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 8, 21, 52, 113, 210, 328, 429, 469, 429, 328, 210, 113, 52, 21, 8, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 48, 108, 202, 316, 414, 453, 414, 316, 202, 108, 48, 20, 52, 116, 218, 341, 446, 488, 446, 341, 218, 116, 52, 20, 7, 20, 51, 112, 209, 327, 428, 468, 428, 327, 209, 112, 51, 20, 7, 3, 4, 6, 9, 12, 12, 12, 9, 6, 4, 3, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 56, 126, 237, 371, 486, 531, 486, 371, 237, 126, 56, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 6, 19, 49, 110, 205, 322, 422, 461, 422, 322, 205, 110, 49, 19, 6, 2, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 2, 2, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 9, 22, 55, 120, 223, 348, 455, 497, 455, 348, 223, 120, 55, 22, 9, 23, 57, 126, 234, 365, 477, 522, 477, 365, 234, 126, 57, 23, 8, 22, 58, 128, 239, 374, 490, 536, 490, 374, 239, 128, 58, 22, 8, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 2, 6, 10, 22, 52, 111, 205, 320, 417, 456, 417, 320, 205, 111, 52, 22, 10, 6, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 1, 1, 1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 1, 1, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 54, 117, 215, 335, 437, 478, 437, 335, 215, 117, 54, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 2, 3, 5, 8, 11, 11, 11, 8, 5, 3, 2, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 1, 1, 2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 1, 1, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 4, 6, 9, 11, 12, 11, 9, 6, 4, 3, 55, 123, 231, 363, 475, 520, 475, 363, 231, 123, 55, 6, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 6, 23, 54, 115, 213, 331, 432, 472, 432, 331, 213, 115, 54, 23, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 4, 4, 5, 6, 8, 10, 12, 13, 12, 10, 8, 6, 5, 4, 4, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4],
					peak: [5, 17, 30, 43, 55, 68, 81, 95, 109, 123, 137, 149, 162, 174, 187, 202, 218, 234, 247, 260, 274, 286, 300, 317, 333, 346, 358, 372, 385, 399, 414, 426, 439, 455, 471, 487, 503, 517, 530, 545, 562, 579, 595, 608, 620, 634, 648, 662, 675, 687, 700, 715, 729, 743, 759, 772, 786, 800, 811, 823, 837, 850, 862, 874, 885, 899, 914, 927, 941, 954, 968, 982]
				},
				index: 5,
				counter: 8,
				measureText: 74
			}],
			startY: 137,
			endY: 226,
			displayedFeatures: 6,
			totalFeatures: 6
		}, {
			name: "Copy Number Variation",
			type: "heatmap",
			autowidth: true,
			height: 20,
			data: [{
				id: "Cell Line-123",
				offset: 10,
				data: [7, 5, 5, 5, 6, 7, 9, 8, 8, 8, 8, 5, 7, 9, 15, 15, 16, 9, 9, 7, 8, 10, 9, 21, 22, 22, 24, 20, 24, 26, 24, 25, 24, 31, 29, 33, 33, 33, 33, 33, 20, 17, 19, 18, 18, 18, 27, 23, 31, 26, 31, 31, 31, 34, 32, 31, 30, 30, 30, 30, 30, 24, 24, 20, 21, 17, 17, 27, 29, 25, 31, 31, 31],
				index: 0,
				counter: 9,
				measureText: 67
			}],
			startY: 281,
			endY: 281,
			displayedFeatures: 1,
			totalFeatures: 1
		}, {
			name: "Tissue Distribution (Heart, Liver, Kidney)",
			type: "heatmap",
			height: 20,
			data: [{
				id: "123456_at",
				offset: 100,
				data: [25, 35, 46],
				index: 0,
				counter: 10,
				measureText: 56
			}, {
				id: "345678_at",
				offset: 181,
				data: [65, 46, 29],
				index: 2,
				counter: 12,
				measureText: 56
			}],
			startY: 336,
			endY: 386,
			displayedFeatures: 3,
			totalFeatures: 3
		}, {
			name: "Another CNV",
			type: "line",
			autowidth: true,
			height: 20,
			fill: ["rgb(255,0,0)", "rgb(0,255,0)"],
			outline: ["rgb(255,0,0)", "rgb(0,255,0)"],
			data: [{
				id: "Cell Line-124",
				offset: 10,
				data: [30, 31, 31, 33, 29, 29, 30, 31, 32, 33, 33, 31, 31, 29, 30, 30, 27, 32, 31, 31, 28, 31, 31, 29, 31, 31, 31, 26, 25, 29, 26, 26, 21, 26, 21, 31, 31, 28, 28, 23, 25, 28, 28, 31, 33, 33, 32, 31, 31, 31, 24, 28, 28, 28, 31, 32, 32, 31, 31, 28, 24, 28, 24, 29, 31, 29, 31],
				index: 0,
				counter: 13,
				measureText: 67
			}],
			startY: 441,
			endY: 466,
			displayedFeatures: 2,
			totalFeatures: 2
		}, {
			type: "bar",
			height: 20,
			fill: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,255,0)"],
			outline: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,255,0)"],
			data: [{
				id: "123456_at",
				offset: 100,
				data: [25, 35, 46],
				index: 0,
				counter: 15,
				measureText: 56
			}, {
				id: "345678_at",
				offset: 181,
				data: [65, 46, 29],
				index: 2,
				counter: 17,
				measureText: 56
			}],
			startY: 501,
			endY: 551,
			displayedFeatures: 3,
			totalFeatures: 3
		}, {
			name: "Clones",
			type: "box",
			data: [{
				id: "clone-1234567",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "left",
				data: [
					[121, 196]
				],
				index: 0,
				counter: 18,
				start: 121,
				end: 196,
				measureText: 77
			}, {
				id: "clone-2345678",
				fill: "rgb(255,255,51)",
				outline: "rgb(0,0,0)",
				dir: "right",
				data: [
					[371, 400]
				],
				landmarks: [{
					offset: 157,
					text: "Gap "
				}, {
					offset: 137,
					text: "Insertion "
				}],
				index: 1,
				counter: 19,
				start: 371,
				end: 400,
				measureText: 77
			}],
			startY: 606,
			endY: 619,
			displayedFeatures: 2,
			totalFeatures: 2
		}, {
			name: "SNP Location",
			type: "triangle",
			data: [{
				id: "SNP123",
				fill: "rgb(100,0,0)",
				outline: "rgb(0,0,0)",
				offset: 23,
				index: 0,
				counter: 20,
				measureText: 43
			}, {
				id: "SNP789",
				fill: "rgb(100,0,0)",
				outline: "rgb(0,0,0)",
				offset: 195,
				index: 6,
				counter: 26,
				measureText: 43
			}],
			startY: 674,
			endY: 782,
			displayedFeatures: 7,
			totalFeatures: 7
		}, {
			name: "SNP Sequences",
			type: "sequence",
			subtype: "DNA",
			data: [{
				id: "SNP123",
				offset: 19,
				sequence: "CACA[AT]GCACCTTGTA",
				index: 0,
				counter: 27,
				measureText: 43
			}, {
				id: "SNP234",
				offset: 41,
				sequence: "ATCG[TG]AATA",
				index: 1,
				counter: 28,
				measureText: 43
			}, {
				id: "SNP789",
				offset: 116,
				sequence: "GCCC[CT]AGGG",
				index: 2,
				counter: 29,
				measureText: 43
			}]
		}]
	};
	this.dataSetLesMiserables = {
		nodes: [{
			id: "Id0",
			name: "Myriel",
			group: 1
		}, {
			id: "Id1",
			name: "Napoleon",
			group: 1
		}, {
			id: "Id2",
			name: "Mlle. Baptistine",
			group: 1
		}, {
			id: "Id3",
			name: "Mme. Magloire",
			group: 1
		}, {
			id: "Id4",
			name: "Countess de Lo",
			group: 1
		}, {
			id: "Id5",
			name: "Geborand",
			group: 1
		}, {
			id: "Id6",
			name: "Champtercier",
			group: 1
		}, {
			id: "Id7",
			name: "Cravatte",
			group: 1
		}, {
			id: "Id8",
			name: "Count",
			group: 1
		}, {
			id: "Id9",
			name: "Old Man",
			group: 1
		}, {
			id: "Id10",
			name: "Labarre",
			group: 2
		}, {
			id: "Id11",
			name: "Valjean",
			group: 2
		}, {
			id: "Id12",
			name: "Marguerite",
			group: 3
		}, {
			id: "Id13",
			name: "Mme. de R",
			group: 2
		}, {
			id: "Id14",
			name: "Isabeau",
			group: 2
		}, {
			id: "Id15",
			name: "Gervais",
			group: 2
		}, {
			id: "Id16",
			name: "Tholomyes",
			group: 3
		}, {
			id: "Id17",
			name: "Listolier",
			group: 3
		}, {
			id: "Id18",
			name: "Fameuil",
			group: 3
		}, {
			id: "Id19",
			name: "Blacheville",
			group: 3
		}, {
			id: "Id20",
			name: "Favourite",
			group: 3
		}, {
			id: "Id21",
			name: "Dahlia",
			group: 3
		}, {
			id: "Id22",
			name: "Zephine",
			group: 3
		}, {
			id: "Id23",
			name: "Fantine",
			group: 3
		}, {
			id: "Id24",
			name: "Mme. Thenardier",
			group: 4
		}, {
			id: "Id25",
			name: "Thenardier",
			group: 4
		}, {
			id: "Id26",
			name: "Cosette",
			group: 5
		}, {
			id: "Id27",
			name: "Javert",
			group: 4
		}, {
			id: "Id28",
			name: "Fauchelevent",
			group: 0
		}, {
			id: "Id29",
			name: "Bamatabois",
			group: 2
		}, {
			id: "Id30",
			name: "Perpetue",
			group: 3
		}, {
			id: "Id31",
			name: "Simplice",
			group: 2
		}, {
			id: "Id32",
			name: "Scaufflaire",
			group: 2
		}, {
			id: "Id33",
			name: "Woman 1",
			group: 2
		}, {
			id: "Id34",
			name: "Judge",
			group: 2
		}, {
			id: "Id35",
			name: "Champmathieu",
			group: 2
		}, {
			id: "Id36",
			name: "Brevet",
			group: 2
		}, {
			id: "Id37",
			name: "Chenildieu",
			group: 2
		}, {
			id: "Id38",
			name: "Cochepaille",
			group: 2
		}, {
			id: "Id39",
			name: "Pontmercy",
			group: 4
		}, {
			id: "Id40",
			name: "Boulatruelle",
			group: 6
		}, {
			id: "Id41",
			name: "Eponine",
			group: 4
		}, {
			id: "Id42",
			name: "Anzelma",
			group: 4
		}, {
			id: "Id43",
			name: "Woman 2",
			group: 5
		}, {
			id: "Id44",
			name: "Mother Innocent",
			group: 0
		}, {
			id: "Id45",
			name: "Gribier",
			group: 0
		}, {
			id: "Id46",
			name: "Jondrette",
			group: 7
		}, {
			id: "Id47",
			name: "Mme. Burgon",
			group: 7
		}, {
			id: "Id48",
			name: "Gavroche",
			group: 8
		}, {
			id: "Id49",
			name: "Gillenormand",
			group: 5
		}, {
			id: "Id50",
			name: "Magnon",
			group: 5
		}, {
			id: "Id51",
			name: "Mlle. Gillenormand",
			group: 5
		}, {
			id: "Id52",
			name: "Mme. Pontmercy",
			group: 5
		}, {
			id: "Id53",
			name: "Mlle. Vaubois",
			group: 5
		}, {
			id: "Id54",
			name: "Lt. Gillenormand",
			group: 5
		}, {
			id: "Id55",
			name: "Marius",
			group: 8
		}, {
			id: "Id56",
			name: "Baroness T",
			group: 5
		}, {
			id: "Id57",
			name: "Mabeuf",
			group: 8
		}, {
			id: "Id58",
			name: "Enjolras",
			group: 8
		}, {
			id: "Id59",
			name: "Combeferre",
			group: 8
		}, {
			id: "Id60",
			name: "Prouvaire",
			group: 8
		}, {
			id: "Id61",
			name: "Feuilly",
			group: 8
		}, {
			id: "Id62",
			name: "Courfeyrac",
			group: 8
		}, {
			id: "Id63",
			name: "Bahorel",
			group: 8
		}, {
			id: "Id64",
			name: "Bossuet",
			group: 8
		}, {
			id: "Id65",
			name: "Joly",
			group: 8
		}, {
			id: "Id66",
			name: "Grantaire",
			group: 8
		}, {
			id: "Id67",
			name: "Mother Plutarch",
			group: 9
		}, {
			id: "Id68",
			name: "Gueulemer",
			group: 4
		}, {
			id: "Id69",
			name: "Babet",
			group: 4
		}, {
			id: "Id70",
			name: "Claquesous",
			group: 4
		}, {
			id: "Id71",
			name: "Montparnasse",
			group: 4
		}, {
			id: "Id72",
			name: "Toussaint",
			group: 5
		}, {
			id: "Id73",
			name: "Child 1",
			group: 10
		}, {
			id: "Id74",
			name: "Child 2",
			group: 10
		}, {
			id: "Id75",
			name: "Brujon",
			group: 4
		}, {
			id: "Id76",
			name: "Mme. Hucheloup",
			group: 8
		}],
		edges: [{
			id1: "Id1",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id2",
			id2: "Id0",
			value: 8
		}, {
			id1: "Id3",
			id2: "Id0",
			value: 10
		}, {
			id1: "Id3",
			id2: "Id2",
			value: 6
		}, {
			id1: "Id4",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id5",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id6",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id7",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id8",
			id2: "Id0",
			value: 2
		}, {
			id1: "Id9",
			id2: "Id0",
			value: 1
		}, {
			id1: "Id11",
			id2: "Id10",
			value: 1
		}, {
			id1: "Id11",
			id2: "Id3",
			value: 3
		}, {
			id1: "Id11",
			id2: "Id2",
			value: 3
		}, {
			id1: "Id11",
			id2: "Id0",
			value: 5
		}, {
			id1: "Id12",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id13",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id14",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id15",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id17",
			id2: "Id16",
			value: 4
		}, {
			id1: "Id18",
			id2: "Id16",
			value: 4
		}, {
			id1: "Id18",
			id2: "Id17",
			value: 4
		}, {
			id1: "Id19",
			id2: "Id16",
			value: 4
		}, {
			id1: "Id19",
			id2: "Id17",
			value: 4
		}, {
			id1: "Id19",
			id2: "Id18",
			value: 4
		}, {
			id1: "Id20",
			id2: "Id16",
			value: 3
		}, {
			id1: "Id20",
			id2: "Id17",
			value: 3
		}, {
			id1: "Id20",
			id2: "Id18",
			value: 3
		}, {
			id1: "Id20",
			id2: "Id19",
			value: 4
		}, {
			id1: "Id21",
			id2: "Id16",
			value: 3
		}, {
			id1: "Id21",
			id2: "Id17",
			value: 3
		}, {
			id1: "Id21",
			id2: "Id18",
			value: 3
		}, {
			id1: "Id21",
			id2: "Id19",
			value: 3
		}, {
			id1: "Id21",
			id2: "Id20",
			value: 5
		}, {
			id1: "Id22",
			id2: "Id16",
			value: 3
		}, {
			id1: "Id22",
			id2: "Id17",
			value: 3
		}, {
			id1: "Id22",
			id2: "Id18",
			value: 3
		}, {
			id1: "Id22",
			id2: "Id19",
			value: 3
		}, {
			id1: "Id22",
			id2: "Id20",
			value: 4
		}, {
			id1: "Id22",
			id2: "Id21",
			value: 4
		}, {
			id1: "Id23",
			id2: "Id16",
			value: 3
		}, {
			id1: "Id23",
			id2: "Id17",
			value: 3
		}, {
			id1: "Id23",
			id2: "Id18",
			value: 3
		}, {
			id1: "Id23",
			id2: "Id19",
			value: 3
		}, {
			id1: "Id23",
			id2: "Id20",
			value: 4
		}, {
			id1: "Id23",
			id2: "Id21",
			value: 4
		}, {
			id1: "Id23",
			id2: "Id22",
			value: 4
		}, {
			id1: "Id23",
			id2: "Id12",
			value: 2
		}, {
			id1: "Id23",
			id2: "Id11",
			value: 9
		}, {
			id1: "Id24",
			id2: "Id23",
			value: 2
		}, {
			id1: "Id24",
			id2: "Id11",
			value: 7
		}, {
			id1: "Id25",
			id2: "Id24",
			value: 13
		}, {
			id1: "Id25",
			id2: "Id23",
			value: 1
		}, {
			id1: "Id25",
			id2: "Id11",
			value: 12
		}, {
			id1: "Id26",
			id2: "Id24",
			value: 4
		}, {
			id1: "Id26",
			id2: "Id11",
			value: 31
		}, {
			id1: "Id26",
			id2: "Id16",
			value: 1
		}, {
			id1: "Id26",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id27",
			id2: "Id11",
			value: 17
		}, {
			id1: "Id27",
			id2: "Id23",
			value: 5
		}, {
			id1: "Id27",
			id2: "Id25",
			value: 5
		}, {
			id1: "Id27",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id27",
			id2: "Id26",
			value: 1
		}, {
			id1: "Id28",
			id2: "Id11",
			value: 8
		}, {
			id1: "Id28",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id29",
			id2: "Id23",
			value: 1
		}, {
			id1: "Id29",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id29",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id30",
			id2: "Id23",
			value: 1
		}, {
			id1: "Id31",
			id2: "Id30",
			value: 2
		}, {
			id1: "Id31",
			id2: "Id11",
			value: 3
		}, {
			id1: "Id31",
			id2: "Id23",
			value: 2
		}, {
			id1: "Id31",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id32",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id33",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id33",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id34",
			id2: "Id11",
			value: 3
		}, {
			id1: "Id34",
			id2: "Id29",
			value: 2
		}, {
			id1: "Id35",
			id2: "Id11",
			value: 3
		}, {
			id1: "Id35",
			id2: "Id34",
			value: 3
		}, {
			id1: "Id35",
			id2: "Id29",
			value: 2
		}, {
			id1: "Id36",
			id2: "Id34",
			value: 2
		}, {
			id1: "Id36",
			id2: "Id35",
			value: 2
		}, {
			id1: "Id36",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id36",
			id2: "Id29",
			value: 1
		}, {
			id1: "Id37",
			id2: "Id34",
			value: 2
		}, {
			id1: "Id37",
			id2: "Id35",
			value: 2
		}, {
			id1: "Id37",
			id2: "Id36",
			value: 2
		}, {
			id1: "Id37",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id37",
			id2: "Id29",
			value: 1
		}, {
			id1: "Id38",
			id2: "Id34",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id35",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id36",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id37",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id38",
			id2: "Id29",
			value: 1
		}, {
			id1: "Id39",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id40",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id41",
			id2: "Id24",
			value: 2
		}, {
			id1: "Id41",
			id2: "Id25",
			value: 3
		}, {
			id1: "Id42",
			id2: "Id41",
			value: 2
		}, {
			id1: "Id42",
			id2: "Id25",
			value: 2
		}, {
			id1: "Id42",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id43",
			id2: "Id11",
			value: 3
		}, {
			id1: "Id43",
			id2: "Id26",
			value: 1
		}, {
			id1: "Id43",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id44",
			id2: "Id28",
			value: 3
		}, {
			id1: "Id44",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id45",
			id2: "Id28",
			value: 2
		}, {
			id1: "Id47",
			id2: "Id46",
			value: 1
		}, {
			id1: "Id48",
			id2: "Id47",
			value: 2
		}, {
			id1: "Id48",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id48",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id48",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id49",
			id2: "Id26",
			value: 3
		}, {
			id1: "Id49",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id50",
			id2: "Id49",
			value: 1
		}, {
			id1: "Id50",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id51",
			id2: "Id49",
			value: 9
		}, {
			id1: "Id51",
			id2: "Id26",
			value: 2
		}, {
			id1: "Id51",
			id2: "Id11",
			value: 2
		}, {
			id1: "Id52",
			id2: "Id51",
			value: 1
		}, {
			id1: "Id52",
			id2: "Id39",
			value: 1
		}, {
			id1: "Id53",
			id2: "Id51",
			value: 1
		}, {
			id1: "Id54",
			id2: "Id51",
			value: 2
		}, {
			id1: "Id54",
			id2: "Id49",
			value: 1
		}, {
			id1: "Id54",
			id2: "Id26",
			value: 1
		}, {
			id1: "Id55",
			id2: "Id51",
			value: 6
		}, {
			id1: "Id55",
			id2: "Id49",
			value: 12
		}, {
			id1: "Id55",
			id2: "Id39",
			value: 1
		}, {
			id1: "Id55",
			id2: "Id54",
			value: 1
		}, {
			id1: "Id55",
			id2: "Id26",
			value: 21
		}, {
			id1: "Id55",
			id2: "Id11",
			value: 19
		}, {
			id1: "Id55",
			id2: "Id16",
			value: 1
		}, {
			id1: "Id55",
			id2: "Id25",
			value: 2
		}, {
			id1: "Id55",
			id2: "Id41",
			value: 5
		}, {
			id1: "Id55",
			id2: "Id48",
			value: 4
		}, {
			id1: "Id56",
			id2: "Id49",
			value: 1
		}, {
			id1: "Id56",
			id2: "Id55",
			value: 1
		}, {
			id1: "Id57",
			id2: "Id55",
			value: 1
		}, {
			id1: "Id57",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id57",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id58",
			id2: "Id55",
			value: 7
		}, {
			id1: "Id58",
			id2: "Id48",
			value: 7
		}, {
			id1: "Id58",
			id2: "Id27",
			value: 6
		}, {
			id1: "Id58",
			id2: "Id57",
			value: 1
		}, {
			id1: "Id58",
			id2: "Id11",
			value: 4
		}, {
			id1: "Id59",
			id2: "Id58",
			value: 15
		}, {
			id1: "Id59",
			id2: "Id55",
			value: 5
		}, {
			id1: "Id59",
			id2: "Id48",
			value: 6
		}, {
			id1: "Id59",
			id2: "Id57",
			value: 2
		}, {
			id1: "Id60",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id60",
			id2: "Id58",
			value: 4
		}, {
			id1: "Id60",
			id2: "Id59",
			value: 2
		}, {
			id1: "Id61",
			id2: "Id48",
			value: 2
		}, {
			id1: "Id61",
			id2: "Id58",
			value: 6
		}, {
			id1: "Id61",
			id2: "Id60",
			value: 2
		}, {
			id1: "Id61",
			id2: "Id59",
			value: 5
		}, {
			id1: "Id61",
			id2: "Id57",
			value: 1
		}, {
			id1: "Id61",
			id2: "Id55",
			value: 1
		}, {
			id1: "Id62",
			id2: "Id55",
			value: 9
		}, {
			id1: "Id62",
			id2: "Id58",
			value: 17
		}, {
			id1: "Id62",
			id2: "Id59",
			value: 13
		}, {
			id1: "Id62",
			id2: "Id48",
			value: 7
		}, {
			id1: "Id62",
			id2: "Id57",
			value: 2
		}, {
			id1: "Id62",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id62",
			id2: "Id61",
			value: 6
		}, {
			id1: "Id62",
			id2: "Id60",
			value: 3
		}, {
			id1: "Id63",
			id2: "Id59",
			value: 5
		}, {
			id1: "Id63",
			id2: "Id48",
			value: 5
		}, {
			id1: "Id63",
			id2: "Id62",
			value: 6
		}, {
			id1: "Id63",
			id2: "Id57",
			value: 2
		}, {
			id1: "Id63",
			id2: "Id58",
			value: 4
		}, {
			id1: "Id63",
			id2: "Id61",
			value: 3
		}, {
			id1: "Id63",
			id2: "Id60",
			value: 2
		}, {
			id1: "Id63",
			id2: "Id55",
			value: 1
		}, {
			id1: "Id64",
			id2: "Id55",
			value: 5
		}, {
			id1: "Id64",
			id2: "Id62",
			value: 12
		}, {
			id1: "Id64",
			id2: "Id48",
			value: 5
		}, {
			id1: "Id64",
			id2: "Id63",
			value: 4
		}, {
			id1: "Id64",
			id2: "Id58",
			value: 10
		}, {
			id1: "Id64",
			id2: "Id61",
			value: 6
		}, {
			id1: "Id64",
			id2: "Id60",
			value: 2
		}, {
			id1: "Id64",
			id2: "Id59",
			value: 9
		}, {
			id1: "Id64",
			id2: "Id57",
			value: 1
		}, {
			id1: "Id64",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id65",
			id2: "Id63",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id64",
			value: 7
		}, {
			id1: "Id65",
			id2: "Id48",
			value: 3
		}, {
			id1: "Id65",
			id2: "Id62",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id58",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id61",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id60",
			value: 2
		}, {
			id1: "Id65",
			id2: "Id59",
			value: 5
		}, {
			id1: "Id65",
			id2: "Id57",
			value: 1
		}, {
			id1: "Id65",
			id2: "Id55",
			value: 2
		}, {
			id1: "Id66",
			id2: "Id64",
			value: 3
		}, {
			id1: "Id66",
			id2: "Id58",
			value: 3
		}, {
			id1: "Id66",
			id2: "Id59",
			value: 1
		}, {
			id1: "Id66",
			id2: "Id62",
			value: 2
		}, {
			id1: "Id66",
			id2: "Id65",
			value: 2
		}, {
			id1: "Id66",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id66",
			id2: "Id63",
			value: 1
		}, {
			id1: "Id66",
			id2: "Id61",
			value: 1
		}, {
			id1: "Id66",
			id2: "Id60",
			value: 1
		}, {
			id1: "Id67",
			id2: "Id57",
			value: 3
		}, {
			id1: "Id68",
			id2: "Id25",
			value: 5
		}, {
			id1: "Id68",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id68",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id68",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id68",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id68",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id69",
			id2: "Id25",
			value: 6
		}, {
			id1: "Id69",
			id2: "Id68",
			value: 6
		}, {
			id1: "Id69",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id69",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id69",
			id2: "Id27",
			value: 2
		}, {
			id1: "Id69",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id69",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id25",
			value: 4
		}, {
			id1: "Id70",
			id2: "Id69",
			value: 4
		}, {
			id1: "Id70",
			id2: "Id68",
			value: 4
		}, {
			id1: "Id70",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id24",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id70",
			id2: "Id58",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id69",
			value: 2
		}, {
			id1: "Id71",
			id2: "Id68",
			value: 2
		}, {
			id1: "Id71",
			id2: "Id70",
			value: 2
		}, {
			id1: "Id71",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id71",
			id2: "Id25",
			value: 1
		}, {
			id1: "Id72",
			id2: "Id26",
			value: 2
		}, {
			id1: "Id72",
			id2: "Id27",
			value: 1
		}, {
			id1: "Id72",
			id2: "Id11",
			value: 1
		}, {
			id1: "Id73",
			id2: "Id48",
			value: 2
		}, {
			id1: "Id74",
			id2: "Id48",
			value: 2
		}, {
			id1: "Id74",
			id2: "Id73",
			value: 3
		}, {
			id1: "Id75",
			id2: "Id69",
			value: 3
		}, {
			id1: "Id75",
			id2: "Id68",
			value: 3
		}, {
			id1: "Id75",
			id2: "Id25",
			value: 3
		}, {
			id1: "Id75",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id75",
			id2: "Id41",
			value: 1
		}, {
			id1: "Id75",
			id2: "Id70",
			value: 1
		}, {
			id1: "Id75",
			id2: "Id71",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id64",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id65",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id66",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id63",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id62",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id48",
			value: 1
		}, {
			id1: "Id76",
			id2: "Id58",
			value: 1
		}],
		m: {
			Name: "Les Miserables",
			Description: "Coappearance network of characters in the novel Les Miserables",
			Reference: "D. E. Knuth, The Stanford GraphBase: A Platform for Combinatorial Computing, Addison-Wesley, Reading, MA (1993)."
		}
	};
	this.getDataSet = function(e) {
		if (e && this["dataSet" + e]) {
			return this["dataSet" + e]
		} else {
			if (e && e.match(/Random/)) {
				var c;
				var b = e.split(":");
				var a = {
					randomDataVariables: this.randomDataVariables,
					randomDataSamples: this.randomDataSamples,
					randomDataVariableAnnotations: this.randomDataVariableAnnotations,
					randomDataSampleAnnotations: this.randomDataSampleAnnotations,
					randomDataUniform: this.randomDataUniform,
					randomDataSymmetrical: this.randomDataSymmetrical,
					randomDataGraphTime: this.isGraphTime,
					randomMissingDataPercentage: this.randomMissingDataPercentage
				};
				if (b.length > 0) {
					if (b[1] != null) {
						this.randomDataVariables = Number(b[1])
					}
					if (b[2] != null) {
						this.randomDataSamples = Number(b[2])
					}
					if (b[3] != null) {
						this.randomDataVariableAnnotations = Number(b[3])
					}
					if (b[4] != null) {
						this.randomDataSampleAnnotations = Number(b[4])
					}
					if (b[5] != null && Number(b[5]) > 0) {
						this.randomDataUniform = true
					} else {
						this.randomDataUniform = false
					}
					if (b[6] != null && Number(b[6]) > 0) {
						this.randomDataSymmetrical = true
					} else {
						this.randomDataSymmetrical = false
					}
					if (b[7] != null && Number(b[7]) > 0) {
						this.isGraphTime = true
					} else {
						this.isGraphTime = false
					}
					if (b[8] != null) {
						this.randomMissingDataPercentage = Number(b[8])
					}
				}
				c = this.createRandomData(true);
				this.randomDataVariables = a.randomDataVariables;
				this.randomDataSamples = a.randomDataSamples;
				this.randomDataVariableAnnotations = a.randomDataVariableAnnotations;
				this.randomDataSampleAnnotations = a.randomDataSampleAnnotations;
				this.randomDataUniform = a.randomDataUniform;
				this.randomDataSymmetrical = a.randomDataSymmetrical;
				this.isGraphTime = a.randomDataGraphTime;
				this.randomMissingDataPercentage = a.randomMissingDataPercentage;
				return c
			} else {
				return this.dataSetExample
			}
		}
	};
	this.getGenericDataSet = function() {
		return {
			x: this.dataSetGeneric.x,
			y: this.dataSetGeneric.y,
			z: this.dataSetGeneric.z,
			a: this.dataSetGeneric.a,
			venn: this.dataSetVenn.venn,
			market: this.dataSetMarket.market,
			nodes: this.dataSetNetworkRadial.nodes,
			edges: this.dataSetNetworkRadial.edges,
			tracks: this.dataSetGenomeAdvanced.tracks
		}
	};
	this.initializeExample = function() {
		this.dataSetExample = {
			x: this.dataSetGeneric.x,
			y: this.dataSetGeneric.y,
			z: this.dataSetGeneric.z,
			a: this.dataSetGeneric.a,
			venn: this.dataSetVenn.venn,
			market: this.dataSetMarket.market,
			nodes: this.dataSetNetworkRadial.nodes,
			edges: this.dataSetNetworkRadial.edges,
			tracks: this.dataSetGenomeAdvanced.tracks
		};
		this.dataSetSummaryExample = {
			x: this.dataSetGeneric.x,
			y: {
				vars: this.dataSetGeneric.y["vars"],
				smps: this.dataSetGeneric.y["smps"],
				mean: this.dataSetGeneric.y["data"],
				stdev: [
					[1, 2, 3, 1, 2, 3],
					[1, 2, 3, 1, 2, 3],
					[1, 2, 3, 1, 2, 3],
					[1, 2, 3, 1, 2, 3]
				],
				n: [
					[4, 5, 4, 5, 4, 5],
					[4, 5, 4, 5, 4, 5],
					[4, 5, 4, 5, 4, 5],
					[4, 5, 4, 5, 4, 5]
				],
				desc: this.dataSetGeneric.y["desc"]
			},
			z: this.dataSetGeneric.z,
			a: this.dataSetGeneric.a
		}
	};
	this.initializeExample()
};
CanvasXpress.prototype.initData = function(a) {
	this.isValidPlotData = function(b) {
		var c = this.isGroupedData ? this.data.w : this.data.y;
		if (b == "cor" && c.cor) {
			return true
		} else {
			if (b == "venn" && this.data.venn) {
				return true
			} else {
				if (b == "network" && this.data.nodes) {
					return true
				} else {
					if (b == "genome" && this.data.tracks) {
						return true
					} else {
						if (b == "sum" && c.sum && c.sum[0].length > 0) {
							return true
						} else {
							if (b == "mean" && c.mean && c.mean[0].length > 0) {
								return true
							} else {
								if (b == "median" && c.median && c.median[0].length > 0) {
									return true
								} else {
									if (b == "iqr" && c.iqr1 && c.qtl1 && c.median && c.qtl3 && c.iqr3 && c.median[0].length > 0) {
										return true
									} else {
										if (b == "candle" && c.close && c.open && c.high && c.low && c.close[0].length > 0) {
											return true
										} else {
											if (b == "volume" && c.volume && c.volume[0].length > 0) {
												return true
											} else {
												if (b == "raw" && this.isRawData) {
													return true
												} else {
													if (b == "video" && this.data.video) {
														return true
													} else {
														return false
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.setRangeData = function(e, f, b, D, K) {
		var c = this.isGroupedData && !f ? this.data.w : this.data.y;
		var w = Number.POSITIVE_INFINITY;
		var A = Number.NEGATIVE_INFINITY;
		if (this.setMin != null && this.setMax != null) {
			this.minData = this.setMin;
			this.maxData = this.setMax;
			return
		}
		if (this.isGroupedData && !e) {
			e = this.graphType == "Boxplot" ? "iqr" : this.summaryType;
			if (this.graphType == "Boxplot" && !this.isBoxPlotCalc) {
				this.groupSamples(this.groupingFactors, false, false, false, true);
				c = this.data.w
			}
		}
		if (e == "genome") {
			for (var B = 0; B < this.data.tracks.length; B++) {
				for (var y = 0; y < this.data.tracks[B].data.length; y++) {
					if (this.data.tracks[B].type == "box") {
						for (var x = 0; x < this.data.tracks[B].data[y].data.length; x++) {
							s = this.data.tracks[B].data[y].data[x];
							A = Math.max(A, Math.max(s[0], s[1]));
							w = Math.min(w, Math.min(s[0], s[1]))
						}
					} else {
						if (this.data.tracks[B].type == "sequence") {
							s = this.data.tracks[B].data[y].offset;
							A = Math.max(A, s + this.data.tracks[B].data[y].sequence.length);
							w = Math.min(w, s)
						} else {
							if (this.data.tracks[B].type.match(/bar|heatmap|line|stacked/)) {
								s = this.data.tracks[B].data[y].offset;
								A = this.data.tracks[B].autowidth ? Math.max(A, s + this.data.tracks[B].data[y].data.length) : Math.max(A, s);
								w = Math.min(w, s)
							} else {
								s = this.data.tracks[B].data[y].offset;
								A = Math.max(A, s);
								w = Math.min(w, s)
							}
						}
					}
				}
			}
		} else {
			if (e == "circular") {
				var u = this.getVariableIndices(this.rAxis);
				if (u >= 0) {
					var l = this.range(this.data.y.data[u]);
					w = l[0];
					A = l[1]
				} else {
					w = 0;
					A = 1
				}
			} else {
				if (e == "km" && !f) {
					w = 0;
					A = 1
				} else {
					if (e == "video") {
						w = 0;
						A = 1
					} else {
						if (e == "percentile" && !f) {
							w = 0;
							A = 100
						} else {
							if ((e == "mean" || e == "median" || e == "sum") && (!f)) {
								if (D) {
									A = 0;
									w = 0;
									var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
									var H = this.isTransformedData ? c.trans : c[this.summaryType];
									for (var B = 0; B < g.length; B++) {
										var r = g[B];
										var o = 0;
										var q = 0;
										for (var y = 0; y < this.varIndices.length; y++) {
											var C = this.varIndices[y];
											var J = H[C][r];
											if (!isNaN(J)) {
												if (J > 0) {
													o += J
												} else {
													if (J < 0) {
														q += J
													}
												}
											}
										}
										A = Math.max(o, A);
										w = Math.min(q, w)
									}
								} else {
									if (this.treemapBy && this.data.z.hasOwnProperty(this.treemapBy)) {
										var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
										var H = this.isTransformedData ? c.trans : c[this.summaryType];
										var t = this.getVariableLevelsByAnnotation(this.treemapBy);
										for (var B = 0; B < g.length; B++) {
											var r = g[B];
											var p = 0;
											for (var y = 0; y < t.length; y++) {
												var v = this.getVariablesByAnnotationLevel(this.treemapBy, t[y]);
												for (var x = 0; x < v.length; x++) {
													var d = this.varIndices[x];
													var J = H[d][r];
													if (!isNaN(J) && J > 0) {
														p += J
													} else {
														if (J < 0) {
															this.treemapBy = false;
															return this.setRangeData(e, f, b, D, K)
														}
													}
												}
											}
											A = Math.max(p, A)
										}
										w = 0
									} else {
										for (var B = 0; B < this.varIndices.length; B++) {
											var r = this.varIndices[B];
											var s;
											var n;
											if (this.isTransformedData) {
												s = c.trans[r];
												n = c.tstdev ? c.tstdev[r] : false
											} else {
												if (this.summaryType == "mean") {
													s = c.mean[r]
												} else {
													if (this.summaryType == "median") {
														s = c.median[r]
													} else {
														if (this.summaryType == "sum") {
															s = c.sum[r]
														}
													}
												}
												n = c.stdev ? c.stdev[r] : false
											}
											for (var y = 0; y < s.length; y++) {
												var G;
												var J = s[y];
												if (n) {
													G = n[y]
												} else {
													G = Number.NaN
												}
												if (!isNaN(J)) {
													if (!isNaN(G)) {
														if (b) {
															if (J > 0) {
																w = Math.min(J, w);
																A = Math.max(J + G, A)
															}
														} else {
															w = Math.min(J, w);
															A = Math.max(J + G, A)
														}
													} else {
														if (b) {
															if (J > 0) {
																w = Math.min(J, w);
																A = Math.max(J, A)
															}
														} else {
															w = Math.min(J, w);
															A = Math.max(J, A)
														}
													}
												}
											}
										}
									}
								}
							} else {
								if (e == "iqr" && !f && this.grpIndices) {
									for (var B = 0; B < this.varIndices.length; B++) {
										var r = this.varIndices[B];
										for (var y = 0; y < this.grpIndices.length; y++) {
											var C = this.grpIndices[y];
											var F = c.iqr1[r][C];
											var E = c.iqr3[r][C];
											var z = c.out[r][C];
											if (!isNaN(F) && !isNaN(E)) {
												if (b) {
													if (F > 0 && E > 0) {
														w = Math.min(F, w);
														A = Math.max(E, A)
													}
												} else {
													w = Math.min(F, w);
													A = Math.max(E, A)
												}
											}
											if (z) {
												for (var x = 0; x < z.length; x++) {
													if (!isNaN(z[x])) {
														if (b) {
															if (z[x] > 0) {
																w = Math.min(z[x], w);
																A = Math.max(z[x], A)
															}
														} else {
															w = Math.min(z[x], w);
															A = Math.max(z[x], A)
														}
													}
												}
											}
										}
									}
								} else {
									if (e == "candle") {
										if (this.isTransformedData) {
											alert("Transformation not allowed");
											this.isTransformedData = false
										}
										var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
										for (var B = 0; B < this.varIndices.length; B++) {
											var r = this.varIndices[B];
											for (var y = 0; y < g.length; y++) {
												var C = g[y];
												var m = c.high[r][C];
												var I = c.low[r][C];
												if (!isNaN(m) && !isNaN(I)) {
													w = Math.min(I, w);
													A = Math.max(m, A)
												}
											}
										}
									} else {
										if (e == "volume") {
											var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
											for (var B = 0; B < this.varIndices.length; B++) {
												var r = this.varIndices[B];
												for (var y = 0; y < g.length; y++) {
													var C = g[y];
													if (!isNaN(c.volume[r][C])) {
														w = Math.min(c.volume[r][C], w);
														A = Math.max(c.volume[r][C], A)
													}
												}
											}
										} else {
											if (e == "cor") {
												var g = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
												for (var B = 0; B < g.length; B++) {
													for (var y = 0; y < g.length; y++) {
														var J = this.isTransformedData ? c.trans[B][y] : c.cor[B][y];
														if (!isNaN(J)) {
															if (b) {
																if (J > 0) {
																	w = Math.min(J, w);
																	A = Math.max(J, A)
																}
															} else {
																w = Math.min(J, w);
																A = Math.max(J, A)
															}
														}
													}
												}
											} else {
												var H = this.isTransformedData ? c.trans : c.data;
												if (H.length > 0) {
													if (D) {
														A = 0;
														w = 0;
														for (var B = 0; B < this.smpIndices.length; B++) {
															var o = 0;
															var q = 0;
															for (var y = 0; y < this.varIndices.length; y++) {
																var J = H[this.varIndices[y]][this.smpIndices[B]];
																if (!isNaN(J)) {
																	if (J > 0) {
																		o += J
																	} else {
																		if (J < 0) {
																			q += J
																		}
																	}
																}
															}
															A = Math.max(o, A);
															w = Math.min(q, w)
														}
													} else {
														if (this.treemapBy && this.data.z.hasOwnProperty(this.treemapBy)) {
															var t = this.getVariableLevelsByAnnotation(this.treemapBy);
															for (var B = 0; B < this.smpIndices.length; B++) {
																var p = 0;
																for (var y = 0; y < t.length; y++) {
																	var v = this.getVariablesByAnnotationLevel(this.treemapBy, t[y]);
																	for (var x = 0; x < v.length; x++) {
																		var J = H[this.varIndices[x]][this.smpIndices[B]];
																		if (!isNaN(J) && J > 0) {
																			p += J
																		} else {
																			if (J < 0) {
																				this.treemapBy = false;
																				return this.setRangeData(e, f, b, D, K)
																			}
																		}
																	}
																}
																A = Math.max(p, A)
															}
															w = 0
														} else {
															for (var B = 0; B < this.varIndices.length; B++) {
																for (var y = 0; y < this.smpIndices.length; y++) {
																	var J = H[this.varIndices[B]][this.smpIndices[y]];
																	if (!isNaN(J)) {
																		if (b) {
																			if (J > 0) {
																				w = Math.min(J, w);
																				A = Math.max(J, A)
																			}
																		} else {
																			w = Math.min(J, w);
																			A = Math.max(J, A)
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		this.minData = this.setMin != null ? this.setMin : w == Number.POSITIVE_INFINITY || w == Number.NEGATIVE_INFINITY ? -1 : w;
		this.maxData = this.setMax != null ? this.setMax : A == Number.NEGATIVE_INFINITY || A == Number.POSITIVE_INFINITY ? 1 : A
	};
	this.setRangeDataObject = function(f) {
		var e = Number.POSITIVE_INFINITY;
		var b = Number.NEGATIVE_INFINITY;
		for (var d = 0; d < this.varIndices.length; d++) {
			for (var c = 0; c < this.smpIndices.length; c++) {
				var g = f[this.varIndices[d]][this.smpIndices[c]];
				if (!isNaN(g)) {
					e = Math.min(g, e);
					b = Math.max(g, b)
				}
			}
		}
		e = e == Number.POSITIVE_INFINITY || e == Number.NEGATIVE_INFINITY ? -1 : e;
		b = b == Number.NEGATIVE_INFINITY || b == Number.POSITIVE_INFINITY ? 1 : b;
		return [e, b]
	};
	this.checkObject = function() {
		var d = this.data.y;
		if (this.isGroupedData) {
			this.data.w = {};
			d = this.data.w
		}
		var c = ["vars", "smps", "labs", "desc", "data", "mean", "median", "stdev", "n", "qtl1", "qtl3", "iqr1", "iqr3", "out", "trans", "tstdev", "cor", "sum", "grps", "close", "open", "high", "low", "volume", "factors"];
		for (var b = 0; b < c.length; b++) {
			if (!d[c[b]]) {
				if (c[b] == "factors") {
					d[c[b]] = {}
				} else {
					d[c[b]] = []
				}
			}
		}
	};
	this.resetObject = function(b) {
		var d = ["mean", "median", "stdev", "n", "qtl1", "qtl3", "iqr1", "iqr3", "out", "cor", "sum", "grps", "close", "open", "high", "low", "volume", "factors"];
		if (this.isGroupedData) {
			if (!this.isTransformedData) {
				d.push("trans");
				d.push("tstdev")
			}
			for (var c = 0; c < d.length; c++) {
				delete(this.data.y[d[c]])
			}
			delete(this.data.w)
		} else {
			if (!this.isTransformedData) {
				d.push("trans");
				d.push("tstdev")
			}
			if (this.isRawData) {
				for (var c = 0; c < d.length; c++) {
					delete(this.data.y[d[c]])
				}
			} else {
				delete(this.data.y.data)
			}
		}
		if (b) {
			this.checkObject()
		}
	};
	this.summarize = function(q, t) {
		var b = this.isGroupedData ? this.data.w : this.data.y;
		var e = this.isGroupedData ? false : true;
		if (!this.isGroupedData) {
			this.checkObject()
		}
		if (q == "cor") {
			this.isBoxPlotCalc = false;
			if (this.correlationAxis == "samples") {
				var u = this.isGroupedData ? this.grpIndices : this.smpIndices;
				for (var l = 0; l < u.length; l++) {
					var v = u[l];
					var r = this.getDataForSmpGrpAtIndex(v);
					if (!b.cor[v]) {
						b.cor[v] = []
					}
					for (var g = l; g < u.length; g++) {
						var n = u[g];
						if (!b.cor[n]) {
							b.cor[n] = []
						}
						var p = this.getDataForSmpGrpAtIndex(n);
						if (l == g) {
							if (this.isTransformedData) {
								b.trans[v][n] = 1
							}
							b.cor[v][n] = 1
						} else {
							b.cor[v][n] = this.correlation(r, p);
							b.cor[n][v] = b.cor[v][n];
							if (this.isTransformedData) {
								b.trans[v][n] = b.cor[v][n];
								b.trans[n][v] = b.cor[n][v]
							}
						}
					}
				}
			} else {
				for (var l = 0; l < this.varIndices.length; l++) {
					var v = this.varIndices[l];
					if (!b.cor[v]) {
						b.cor[v] = []
					}
					for (var g = l; g < this.varIndices.length; g++) {
						var n = this.varIndices[g];
						if (!b.cor[n]) {
							b.cor[n] = []
						}
						if (l == g) {
							b.cor[v][n] = 1;
							if (this.isTransformedData) {
								b.trans[v][n] = 1
							}
						} else {
							b.cor[v][n] = this.correlation(b.data[v], b.data[n], e);
							b.cor[n][v] = b.cor[v][n];
							if (this.isTransformedData) {
								b.trans[v][n] = b.cor[v][n];
								b.trans[n][v] = b.cor[n][v]
							}
						}
					}
				}
			}
		} else {
			this.isBoxPlotCalc = q == "iqr" ? true : false;
			for (var l = 0; l < this.varIndices.length; l++) {
				var m;
				var v = this.varIndices[l];
				if (!b.mean[v]) {
					b.trans[v] = [];
					b.tstdev[v] = [];
					b.mean[v] = [];
					b.median[v] = [];
					b.stdev[v] = [];
					b.qtl1[v] = [];
					b.qtl3[v] = [];
					b.iqr1[v] = [];
					b.iqr3[v] = [];
					b.out[v] = [];
					b.n[v] = [];
					b.sum[v] = []
				}
				if (this.isGroupedData) {
					if (!t) {
						var d = this.isTransformedData ? this.data.y.trans : this.data.y.data;
						m = [];
						for (var g = 0; g < this.data.w.grps.length; g++) {
							m[g] = [];
							for (var f = 0; f < this.data.w.grps[g].length; f++) {
								var c = this.data.w.grps[g][f];
								m[g].push(d[v][c])
							}
						}
					} else {
						m = t[v]
					}
				} else {
					b.grps = [];
					m = [];
					for (var g = 0; g < this.smpIndices.length; g++) {
						var n = this.smpIndices[g];
						b.grps[g] = [];
						b.grps[g].push(n);
						m[g] = [this.isTransformedData ? b.trans[v][n] : b.data[v][n]]
					}
				}
				if (q == "iqr") {
					this.summaryType = "iqr";
					if (!this.isGroupedData) {
						for (var g = 0; g < m.length; g++) {
							if (this.isTransformedData) {
								b.trans[v][g] = m[g][0]
							}
							b.mean[v][g] = m[g][0];
							b.median[v][g] = m[g][0];
							b.qtl1[v][g] = m[g][0];
							b.qtl3[v][g] = m[g][0];
							b.iqr1[v][g] = m[g][0];
							b.iqr3[v][g] = m[g][0];
							b.out[v][g] = [];
							b.n[v][g] = 1
						}
					} else {
						for (var g = 0; g < m.length; g++) {
							var s = this.quantiles(m[g], e);
							if (this.isTransformedData) {
								b.trans[v][g] = s[1]
							}
							b.mean[v][g] = s[0];
							b.median[v][g] = s[2];
							b.qtl1[v][g] = s[1];
							b.qtl3[v][g] = s[3];
							b.iqr1[v][g] = s[4];
							b.iqr3[v][g] = s[5];
							b.out[v][g] = s[6];
							b.n[v][g] = s[7]
						}
					}
				} else {
					if (q == "median") {
						this.summaryType = "median";
						for (var g = 0; g < m.length; g++) {
							var s = this.median(m[g], e);
							if (this.isTransformedData) {
								b.trans[v][g] = s[1]
							}
							b.median[v][g] = s[0];
							b.n[v][g] = s[1]
						}
					} else {
						if (q == "mean") {
							this.summaryType = "mean";
							for (var g = 0; g < m.length; g++) {
								var s = this.sumarizeErrorData(m[g], e);
								if (this.isTransformedData) {
									b.trans[v][g] = s[0];
									b.tstdev[v][g] = s[1]
								}
								b.mean[v][g] = s[0];
								b.stdev[v][g] = s[1];
								b.n[v][g] = s[2]
							}
						} else {
							if (q == "sum") {
								this.summaryType = "sum";
								for (var g = 0; g < m.length; g++) {
									var o = this.sum(m[g], e);
									if (this.isTransformedData) {
										b.trans[v][g] = o
									}
									b.sum[v][g] = o;
									b.n[v][g] = m[g].length
								}
							}
						}
					}
				}
			}
		}
	};
	this.copySummarizedData = function() {
		var f = this.isGroupedData ? this.data.w : this.data.y;
		var e;
		for (var c = 0; c < this.varIndices.length; c++) {
			var d = this.varIndices[c];
			f.data[d] = [];
			f.trans[d] = [];
			if (this.summaryType == "mean") {
				for (var b = 0; b < f.mean[d].length; b++) {
					f.data[d][b] = f.mean[d][b]
				}
			} else {
				if (this.summaryType == "median" || this.summaryType == "iqr") {
					for (var b = 0; b < f.median[d].length; b++) {
						f.data[d][b] = f.median[d][b]
					}
				} else {
					if (this.summaryType == "candle") {
						for (var b = 0; b < f.close[d].length; b++) {
							f.data[d][b] = f.close[d][b]
						}
					} else {
						if (this.summaryType == "volume") {
							for (var b = 0; b < f.volume[d].length; b++) {
								f.data[d][b] = f.volume[d][b]
							}
						} else {
							if (this.summaryType == "sum") {
								for (var b = 0; b < f.volume[d].length; b++) {
									f.data[d][b] = f.sum[d][b]
								}
							}
						}
					}
				}
			}
			if (!e) {
				e = d
			}
		}
		return e
	};
	this.transformValue = function(c, d, b) {
		switch (c) {
			case "log2":
				return b ? Math.pow(2, d) : Math.log(d) / Math.LN2;
			case "log10":
				return b ? Math.pow(10, d) : Math.log(d) / Math.LN10;
			case "exp2":
				return b ? Math.log(d) / Math.LN2 : Math.pow(2, d);
			case "exp10":
				return b ? Math.log(d) / Math.LN10 : Math.pow(10, d);
			default:
				return d
		}
	};
	this.transform = function(e, d, b, c) {
		this.functionCaller = "transform";
		var f = 0;
		if (!this.isGroupedData) {
			this.checkObject()
		}
		if (!this.isRawData || this.isGroupedData) {
			f = this.copySummarizedData()
		}
		this.transformType = e;
		this.transformAxis = d;
		this.xAxisMaxStrLength = false;
		this.xAxis2MaxStrLength = false;
		this.yAxisMaxStrLength = false;
		this.zAxisMaxStrLength = false;
		if (e == "reset" || e == "undo") {
			this.transformReset();
			this.transformType = false;
			this.isTransformedData = false;
			this.isLogData = false;
			if (this.tempIndices) {
				if (this.isGroupedData) {
					this.grpIndices = this.tempIndices
				} else {
					this.spIndices = this.tempIndices
				}
				this.tempIndices = false
			}
		} else {
			if (e == "save") {
				this.transformSave();
				this.transformType = false;
				this.isTransformedData = false;
				this.isLogData = false
			} else {
				if (e == "log2" || e == "log10" || e == "exp2" || e == "exp10") {
					if (this.transformLogExpCeilFloor(e)) {
						this.isTransformedData = e
					} else {
						return
					}
				} else {
					if (e == "ceil") {
						if (this.transformCeilValue != null) {
							this.transformLogExpCeilFloor(e);
							this.isTransformedData = e
						} else {
							return
						}
					} else {
						if (e == "floor") {
							if (this.transformFloorValue != null) {
								this.transformLogExpCeilFloor(e);
								this.isTransformedData = e
							} else {
								return
							}
						} else {
							if (e == "ratio" || e == "ratio2" || e == "ratio10") {
								this.transformRatio(e, b);
								this.isTransformedData = e
							} else {
								this.transformRelative(e, d, f);
								this.isTransformedData = e
							}
						}
					}
				}
			}
		}
		delete(this.meta.def.colorBrew);
		if (this.graphType == "Boxplot") {
			this.summarizeBoxplot = true
		}
		if (!c) {
			this.draw()
		}
	};
	this.transformReset = function() {
		var e = this.data.y;
		for (var c = 0; c < this.varIndices.length; c++) {
			var d = this.varIndices[c];
			for (var b = 0; b < e.data[d].length; b++) {
				if (e.trans && e.trans[d] && !isNaN(e.data[d][b])) {
					e.trans[d][b] = e.data[d][b]
				}
			}
		}
		if (this.isGroupedData) {
			this.isTransformedData = false;
			this.groupSamples(this.groupingFactors, false, false, false, true)
		}
	};
	this.transformSave = function() {
		var b = this.isGroupedData ? this.groupingFactors : false;
		var f = this.data.y;
		this.ungroupSamples();
		for (var d = 0; d < this.varIndices.length; d++) {
			var e = this.varIndices[d];
			for (var c = 0; c < f.data[e].length; c++) {
				if (!isNaN(f.data[e][c])) {
					f.data[e][c] = f.trans[e][c]
				}
			}
		}
		if (b) {
			this.isTransformedData = false;
			this.groupSamples(b, false, false, false, true)
		}
	};
	this.transformLogExpCeilFloor = function(e) {
		var f = this.data.y;
		if (e.match(/log/)) {
			if (this.minData <= 0) {
				alert("Cannot log transform values < 0. Transformation will only done with values > 0 only")
			}
			e = this.transformBase == 2 ? "log2" : "log10"
		} else {
			if (e == "exp") {
				e = this.transformBase == 2 ? "exp2" : "exp10"
			}
		}
		if (!f.trans) {
			f.trans = []
		}
		if (!f.tstdev) {
			f.tstdev = []
		}
		for (var c = 0; c < this.varIndices.length; c++) {
			var d = this.varIndices[c];
			if (!f.trans[d]) {
				f.trans[d] = []
			}
			if (!f.tstdev[d]) {
				f.tstdev[d] = []
			}
			for (var b = 0; b < f.data[d].length; b++) {
				if (!isNaN(f.data[d][b])) {
					if (e == "log2") {
						this.isLogData = true;
						this.transformBase = 2;
						f.trans[d][b] = Math.log(f.data[d][b]) / Math.LN2
					} else {
						if (e == "log10") {
							this.isLogData = true;
							this.transformBase = 10;
							f.trans[d][b] = Math.log(f.data[d][b]) / Math.LN10
						} else {
							if (e == "exp2") {
								this.isLogData = false;
								this.transformBase = 2;
								f.trans[d][b] = Math.pow(2, f.data[d][b])
							} else {
								if (e == "exp10") {
									this.isLogData = false;
									this.transformBase = 10;
									f.trans[d][b] = Math.pow(10, f.data[d][b])
								} else {
									if (e == "ceil") {
										f.trans[d][b] = Math.min(this.transformCeilValue, f.data[d][b])
									} else {
										if (e == "floor") {
											f.trans[d][b] = Math.max(this.transformFloorValue, f.data[d][b])
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (this.isGroupedData) {
			this.isTransformedData = e;
			this.groupSamples(this.groupingFactors, false, false, true, true)
		}
		return true
	};
	this.transformRatio = function() {
		var m = [];
		var p = this.data;
		var b = this.isGroupedData && !this.graphType.match(/dotplot|boxplot/i) ? p.w : p.y;
		if (this.isGroupedData && this.ratioGroupReference && p.x.hasOwnProperty(this.ratioGroupReference)) {
			if (!this.ratioLevelReference) {
				for (var u = 0; u < p.x[this.ratioGroupReference].length; u++) {
					if (p.x[this.ratioGroupReference][u] != null) {
						this.ratioLevelReference = p.x[this.ratioGroupReference][u];
						break
					}
				}
			}
			if (this.groupingFactors.length == 1) {
				this.ratioReference = this.getSampleIndices(this.ratioLevelReference);
				if (this.ratioReference < 0) {
					this.ratioLevelReference = p.w.smps[0];
					this.ratioReference = 0
				}
				m = [this.ratioReference]
			} else {
				var g = [];
				for (var u = 0; u < this.groupingFactors.length; u++) {
					if (this.groupingFactors[u] != this.ratioGroupReference) {
						g.push(this.groupingFactors[u])
					}
				}
				var c = {};
				var w = [];
				var t = 0;
				for (var u = 0; u < this.smpIndices.length; u++) {
					var n = this.smpIndices[u];
					var o = [];
					var z;
					for (var s = 0; s < g.length; s++) {
						var v = g[s];
						z = p.x[v][n];
						if (!z) {
							z = "NA"
						}
						o.push(z)
					}
					z = o.join(" - ");
					if (!c.hasOwnProperty(z)) {
						p.w.smps.push(z);
						w[t] = z;
						c[z] = [];
						c[z].push(n);
						t++
					} else {
						c[z].push(n)
					}
				}
				m = this.getSamplesByAnnotationLevel(this.ratioGroupReference, this.ratioLevelReference);
				this.ratioReference = [];
				for (var u = 0; u < p.w.grps.length; u++) {
					var k = p.w.grps[u][0];
					var q = false;
					for (var r in c) {
						for (var s = 0; s < c[r].length; s++) {
							if (k == c[r][s]) {
								q = this.getObjectArray(c[r]);
								break
							}
						}
						if (q) {
							break
						}
					}
					for (var s = 0; s < m.length; s++) {
						if (q.hasOwnProperty(m[s])) {
							this.ratioReference.push(m[s]);
							break
						}
					}
				}
			}
		} else {
			if (this.ratioSampleReference) {
				var x = this.isGroupedData && this.graphType.match(/dotplot|boxplot/i);
				if (x) {
					this.isGroupedData = false;
					this.ratioReference = this.getSampleIndices(this.ratioSampleReference);
					this.isGroupedData = true
				} else {
					this.ratioReference = this.getSampleIndices(this.ratioSampleReference)
				}
			}
			if (this.ratioReference < 0) {
				this.ratioSampleReference = p.y.smps[0];
				this.ratioReference = 0
			}
			m = [this.ratioReference]
		}
		for (var u = 0; u < this.varIndices.length; u++) {
			var n = this.varIndices[u];
			if (!b.trans) {
				b.trans = []
			}
			if (!b.stdev) {
				b.stdev = []
			}
			if (!b.trans[n]) {
				b.trans[n] = []
			}
			if (!b.stdev[n]) {
				b.stdev[n] = []
			}
			for (var s = 0; s < b.data[n].length; s++) {
				var f;
				if (this.isGroupedData && this.ratioGroupReference && p.x.hasOwnProperty(this.ratioGroupReference)) {
					if (this.groupingFactors.length == 1) {
						f = p.w.mean[n][this.ratioReference]
					} else {
						f = p.w.mean[n][this.ratioReference[s]]
					}
				} else {
					f = b.data[n][this.ratioReference]
				}
				if (!isNaN(b.data[n][s]) && !isNaN(f) && f > 0) {
					var d = this.transformBase == 2 ? "ratio2" : "ratio10";
					var y = b.data[n][s] / f;
					var e = b.stdev[n][s];
					if (d == "ratio2") {
						b.trans[n][s] = Math.log(y) / Math.LN2;
						if (e && e > 0) {
							b.tstdev[n][s] = Math.log(e) / Math.LN2
						}
					} else {
						if (d == "ratio10") {
							b.trans[n][s] = Math.log(y) / Math.LN10;
							if (e && e > 0) {
								b.tstdev[n][s] = Math.log(e) / Math.LN10
							}
						}
					}
				}
			}
		}
	};
	this.transformRelative = function(r, o, n) {
		var c = this.isGroupedData && !this.graphType.match(/dotplot|boxplot/i) ? this.data.w : this.data.y;
		var m = this.isGroupedData ? false : true;
		var p;
		o = o ? o : this.transformAxis;
		if (o == "samples") {
			for (var g = 0; g < c.data[n].length; g++) {
				var b = [];
				for (var d = 0; d < this.varIndices.length; d++) {
					var k = this.varIndices[d];
					b.push(c.data[k][g])
				}
				if (r == "percentile") {
					p = this.range(b, m)
				} else {
					if (r == "zscore") {
						p = this.sumarizeErrorData(b, m)
					}
				}
				for (var d = 0; d < this.varIndices.length; d++) {
					var k = this.varIndices[d];
					if (!c.trans) {
						c.trans = []
					}
					if (!c.trans[k]) {
						c.trans[k] = []
					}
					if (!isNaN(c.data[k][g])) {
						if (r == "percentile") {
							c.trans[k][g] = this.percentile(p[0], p[1], c.data[k][g])
						} else {
							if (r == "zscore") {
								c.trans[k][g] = (c.data[k][g] - p[0]) / p[1]
							}
						}
					}
				}
			}
		} else {
			for (var g = 0; g < this.varIndices.length; g++) {
				var q = this.varIndices[g];
				if (!c.trans) {
					c.trans = []
				}
				if (!c.trans[q]) {
					c.trans[q] = []
				}
				var b = c.data[q];
				if (r == "percentile") {
					p = this.range(b, m)
				} else {
					if (r == "zscore") {
						p = this.sumarizeErrorData(b, m)
					}
				}
				for (var d = 0; d < b.length; d++) {
					if (!isNaN(c.data[q][d])) {
						if (r == "percentile") {
							c.trans[q][d] = this.percentile(p[0], p[1], c.data[q][d])
						} else {
							if (r == "zscore") {
								c.trans[q][d] = (c.data[q][d] - p[0]) / p[1]
							}
						}
					}
				}
			}
		}
	};
	this.groupSamples = function(H, v, E, b, o, f) {
		this.functionCaller = "groupSamples";
		var G = this.data;
		if (!this.isArray(H)) {
			H = [H]
		}
		if (!H || H.length < 1 || !G.x) {
			return this.ungroupSamples()
		}
		for (var C = 0; C < H.length; C++) {
			if (!H || !G.x[H[C]]) {
				return this.ungroupSamples()
			}
		}
		if (!this.isDOE && this.layoutComb && !G.l.group) {
			G.l.group = H;
			if (!o) {
				this.draw()
			}
			return
		}
		if (G.l && G.l.group) {
			G.l.group = H
		}
		if (this.isDOE && this.layoutComb && G.l.comp) {
			this.varIndices = [];
			for (var C = 0; C < G.l.comp.length; C++) {
				for (var A = 0; A < G.l.comp[C].length; A++) {
					this.varIndices.push(G.l.comp[C][A])
				}
			}
		}
		var e = {};
		var I = [];
		var B = 0;
		var m = this.getObjectArray(this.smpOverlays);
		var p = G.w && G.w.smps ? G.w.smps : false;
		if (!b) {
			this.resetIndices()
		}
		this.isGroupedData = true;
		this.groupingFactors = H;
		this.resetObject(true);
		this.hiddenGrps = [];
		for (var C = 0; C < this.smpIndices.length; C++) {
			var r = this.smpIndices[C];
			var w = [];
			var x = [];
			var K;
			var y;
			for (var A = 0; A < H.length; A++) {
				var D = H[A];
				K = G.x[D][r];
				if (!K) {
					K = "NA"
				}
				w.push(K);
				if (!m.hasOwnProperty(D)) {
					x.push(K)
				}
			}
			K = w.join(" - ");
			y = x.length > 0 ? x.join(" - ") : "";
			if (!e.hasOwnProperty(K)) {
				G.w.smps.push(K);
				G.w.labs.push(y);
				I[B] = K;
				e[K] = [];
				e[K].push(r);
				B++
			} else {
				e[K].push(r)
			}
		}
		if (I.length < 1) {
			G.w.smps = p;
			this.draw();
			return
		}
		for (var C = 0; C < I.length; C++) {
			var K = I[C];
			G.w.grps.push(e[K])
		}
		this.grpIndices = [];
		if (E) {
			for (var C = 0; C < E.length; C++) {
				this.grpIndices.push(E[C]);
				this.hiddenGrps.push(false)
			}
		} else {
			for (var C = 0; C < G.w.grps.length; C++) {
				this.grpIndices.push(C);
				this.hiddenGrps.push(false)
			}
		}
		for (var C = 0; C < this.varIndices.length; C++) {
			G.w.vars.push(G.y.vars[this.varIndices[C]])
		}
		var q = {};
		for (var K in G.x) {
			q[K] = this.isNumeric(G.x[K])
		}
		for (var C = 0; C < G.w.grps.length; C++) {
			for (var K in G.x) {
				if (!G.w.factors.hasOwnProperty(K)) {
					G.w.factors[K] = []
				}
				var n;
				if (q[K]) {
					n = [];
					for (var A = 0; A < G.w.grps[C].length; A++) {
						var J = G.x[K][G.w.grps[C][A]];
						if (!isNaN(J)) {
							n.push(J)
						}
					}
					G.w.factors[K].push(this.mean(n))
				} else {
					n = {};
					for (var A = 0; A < G.w.grps[C].length; A++) {
						var J = G.x[K][G.w.grps[C][A]];
						if (J != null && J != "") {
							n[G.x[K][G.w.grps[C][A]]] = true
						}
					}
					var c = this.getKeys(n);
					G.w.factors[K].push(c.join(" + "))
				}
			}
		}
		var q = [];
		if (v) {
			if (this.isArray(v)) {
				q = v
			} else {
				q.push(v)
			}
		} else {
			v = this.graphType == "Boxplot" ? "iqr" : "mean";
			q.push(v)
		}
		for (var u = 0; u < q.length; u++) {
			var F = [];
			var l = q[u];
			if (this.isTransformedData) {
				a = G.y.trans
			} else {
				if (this.isRawData) {
					a = G.y.data
				} else {
					if (this.summaryType == "median" || this.summaryType == "iqr") {
						a = G.y.median
					} else {
						if (this.summaryType == "mean") {
							a = G.y.mean
						} else {
							if (this.summaryType == "cor") {
								a = G.y.cor
							} else {
								if (this.summaryType == "sum") {
									a = G.y.sum
								} else {
									a = G.y[this.summaryType]
								}
							}
						}
					}
				}
			}
			for (var C = 0; C < this.varIndices.length; C++) {
				var r = this.varIndices[C];
				F[r] = [];
				for (var A = 0; A < G.w.grps.length; A++) {
					F[r][A] = [];
					for (var z = 0; z < G.w.grps[A].length; z++) {
						var g = G.w.grps[A][z];
						F[r][A].push(a[r][g])
					}
				}
			}
			this.summarize(l, F)
		}
		this.updateMetaData("w");
		if (!f) {
			this.xAxisValues = [];
			this.xAxis2Values = [];
			this.yAxisValues = [];
			this.zAxisValues = [];
			if (!this.layoutComb || !this.layoutAdjust) {
				if (typeof(this.setAxes) == "function") {
					this.setAxes()
				}
			}
		}
		if (!o) {
			this.draw()
		}
	};
	this.ungroupSamples = function(f, c, b) {
		this.functionCaller = "ungroupSamples";
		this.isGroupedData = false;
		var e = this.data;
		if (e.l) {
			delete(e.l.group)
		}
		if (e.w && !b) {
			delete(e.w)
		}
		this.groupingFactors = [];
		this.grpIndices = [];
		this.hiddenGrps = [];
		this.updateMetaData("w");
		if (!c) {
			this.setOriginalIndices(false, false, false, true)
		}
		if (!f) {
			this.draw()
		}
		return
	};
	this.regroupSamples = function() {
		this.isGroupedData = false;
		this.groupSamples(this.groupingFactors, false, false, false, true)
	};
	this.pivot = function(e, l) {
		this.functionCaller = "pivot";
		var g = this.rebuildDataTableFilter();
		var f = {
			y: {
				data: [],
				vars: [],
				smps: []
			}
		};
		var k = e.shift();
		for (var d = 0; d < e.length; d++) {
			f.y.vars.push(e[d][0]);
			var b = [];
			for (var c = 1; c < k.length; c++) {
				b.push(e[d][c])
			}
			f.y.data.push(b)
		}
		k.shift();
		f.y.smps = k;
		this.initializeData(f);
		this.resetObject();
		if (!l) {
			this.draw()
		}
		this.rebuildDataTableFilter(g)
	};
	this.pivotXX = function(k, b, g) {
		var e = [];
		var f = this.data;
		for (var c = 0; c < f.y.smps.length; c++) {
			e.push([f.x[k][c], f.x[b][c], f.y.data[0][c]])
		}
		return this.pivot(this.pivotMatrix(e, 0, 1, 2), g)
	};
	this.pivotXY = function(l, b, k) {
		var f = [];
		var e;
		var g = this.data;
		if (g.x.hasOwnProperty(l)) {
			for (var c = 0; c < g.y.smps.length; c++) {
				f.push([g.x[l][c], g.y.data[0][c], g.y.data[1][c]])
			}
			if (g.y.vars[0] == b) {
				e = this.pivotMatrix(f, 0, 1, 2)
			} else {
				if (g.y.vars[1] == b) {
					e = this.pivotMatrix(f, 0, 2, 1)
				}
			}
		} else {
			if (g.x.hasOwnProperty(b)) {
				for (var c = 0; c < g.y.smps.length; c++) {
					f.push([g.x[b][c], g.y.data[0][c], g.y.data[1][c]])
				}
				if (g.y.vars[0] == l) {
					e = this.pivotMatrix(f, 1, 0, 2)
				} else {
					if (g.y.vars[1] == l) {
						e = this.pivotMatrix(f, 2, 0, 1)
					}
				}
			}
		}
		return this.pivot(e, k)
	};
	this.pivotYY = function(g, b, f) {
		var e;
		g = this.getVariableIndices(g);
		b = this.getVariableIndices(b);
		var d = [];
		for (var c = 0; c < this.data.y.vars.length; c++) {
			if (c != g && c != b) {
				e = c;
				break
			}
		}
		return this.pivot(this.pivotMatrix(this.transposeMatrix(this.data.y.data), g, b, e), f)
	};
	this.transpose = function(l, g) {
		this.functionCaller = "transpose";
		var b = this.rebuildDataTableFilter();
		var o = this.data;
		var c = this.meta.data;
		if (l) {
			return this.transposeMatrix(l)
		} else {
			this.ungroupSamples(noDraw);
			this.transform("reset", false, false, noDraw);
			if (o.l) {
				delete(o.l)
			}
			if (o.d) {
				delete(o.d)
			}
			if (o.a) {
				delete(o.a)
			}
			if (o.t) {
				var y = o.t.vars;
				var B = o.t.smps;
				if (y) {
					o.t.smps = y
				}
				if (B) {
					o.t.vars = B
				}
			}
			var t = o.x;
			var r = o.z;
			var n = c.x;
			var u = c.z;
			c.x = u;
			c.z = n;
			var f = c.y.maxSmpChr;
			var A = c.y.maxSmpLen;
			var q = c.y.maxSmpStr;
			c.y.maxSmpChr = c.y.maxVarChr;
			c.y.maxSmpLen = c.y.maxVarLen;
			c.y.maxSmpStr = c.y.maxVarStr;
			c.y.maxVarChr = f;
			c.y.maxVarLen = A;
			c.y.maxVarStr = q;
			if (t) {
				o.z = t
			} else {
				delete(o.z)
			}
			if (r) {
				o.x = r
			} else {
				delete(o.x)
			}
			var B = o.y.smps;
			o.y.smps = o.y.vars;
			o.y.vars = B;
			var w = o.y.data;
			o.y.data = [];
			for (var k = 0; k < o.y.vars.length; k++) {
				o.y.data[k] = [];
				for (var e = 0; e < o.y.smps.length; e++) {
					o.y.data[k][e] = w[e][k]
				}
			}
			this.initializeData(this.data);
			this.resetObject();
			if (!g) {
				this.draw()
			}
			this.rebuildDataTableFilter(b)
		}
	};
	this.summarizeOncoprint = function() {
		if (this.isOncoprint && !this.isOncoprintSumarized) {
			var f = {};
			var g = [];
			var o = [];
			var c = [];
			var l = [];
			var n = this.data;
			for (var e = 0; e < n.y.vars.length; e++) {
				g[e] = 0
			}
			for (var e = 0; e < n.y.smps.length; e++) {
				o[e] = 0;
				c[e] = 0;
				l[e] = 0
			}
			for (var e = 0; e < n.y.vars.length; e++) {
				for (var d = 0; d < n.y.smps.length; d++) {
					var k, b;
					if (this.xAxisTransform && this.xAxisTransform.match(/ceil|floor/)) {
						k = this.getDataAtPos(e, d, false, this.xAxisTransform, this.xAxisTransformFloorValue, this.xAxisTransformCeilValue);
						b = this.getDataAtPos(e, d, false, false, false, false, true)
					} else {
						k = this.getDataAtPos(e, d, false, this.xAxisTransform, this.minData, this.maxData);
						b = this.getDataAtPos(e, d, false, false, false, false, true)
					}
					if (k >= this.oncoprintAmplification) {
						f[e] = true;
						g[e]++;
						c[d]++
					} else {
						if (k <= this.oncoprintDeletion) {
							f[e] = true;
							g[e]++;
							l[d]++
						}
					}
					if (b && ((isNaN(b) && !b.toString().match(/^no$|^-$|^neg$/i)) || b > 0)) {
						f[e] = true;
						g[e]++;
						o[d]++
					}
				}
			}
			if (!n.z) {
				n.z = {}
			}
			n.z.Altered = [];
			n.z.Alterations = [];
			for (var e = 0; e < n.y.vars.length; e++) {
				n.z.Alterations.push(g[e]);
				if (f[e]) {
					n.z.Altered[e] = "True"
				} else {
					n.z.Altered[e] = "False"
				}
			}
			if (!n.x) {
				n.x = {}
			}
			n.x.Amplified = [];
			n.x.Deleted = [];
			n.x.Altered = [];
			n.x.Mutated = [];
			for (var e = 0; e < n.y.smps.length; e++) {
				n.x.Amplified.push(c[e]);
				n.x.Deleted.push(l[e]);
				n.x.Altered.push(o[e]);
				n.x.Mutated.push(c[e] + l[e] + o[e])
			}
			this.smpOverlayProperties.Altered = {
				type: "Stacked",
				position: "left",
				thickness: 50
			};
			this.smpOverlayProperties.Amplified = {
				type: "Stacked",
				position: "left",
				thickness: 50
			};
			this.smpOverlayProperties.Deleted = {
				type: "Stacked",
				position: "left",
				thickness: 50
			};
			this.smpOverlayProperties.Mutated = {
				type: "Bar",
				position: "right",
				thickness: 30
			};
			this.smpOverlays.push("Amplified");
			this.smpOverlays.push("Deleted");
			this.smpOverlays.push("Altered");
			this.smpOverlays.push("Mutated");
			this.isOncoprintSumarized = true;
			this.sortIndices("onc", "desc");
			this.updateMetaData("x", "Amplified", false, true);
			this.updateMetaData("x", "Deleted", false, true);
			this.updateMetaData("x", "Altered", false, true);
			this.updateMetaData("x", "Mutated", false, true);
			this.updateMetaData("z", "Altered", false, true);
			this.updateMetaData("z", "Alterations", false, true)
		}
	};
	this.getDataAtPos = function(g, f, l, d, e, m, k) {
		var c = Number.NaN;
		var b = this.isGroupedData ? this.data.w : this.data.y;
		if (k) {
			c = this.data.y[this.isOncoprint][g][f]
		} else {
			if (this.isGroupedData || !this.isRawData) {
				if (this.isTransformedData) {
					if (!l) {
						c = b.trans[g][f]
					} else {
						if (l == "stdev") {
							c = b.tstdev[g][f]
						} else {
							if (b.hasOwnProperty(l)) {
								c = b[l][g][f]
							}
						}
					}
				} else {
					l = l ? l : this.summaryType;
					if (b.hasOwnProperty(l)) {
						c = b[l][g][f]
					} else {
						c = 0
					}
				}
			} else {
				if (l) {
					if (b[l] && b[l][g]) {
						c = b[l][g][f]
					}
				} else {
					if (this.isTransformedData) {
						c = b.trans[g][f]
					} else {
						c = b.data[g][f]
					}
				}
			}
		}
		if (d) {
			if (!isNaN(c)) {
				if (d == "log2") {
					c = Math.log(c) / Math.LN2
				} else {
					if (d == "log10") {
						c = Math.log(c) / Math.LN10
					} else {
						if (d == "exp2") {
							c = Math.pow(2, c)
						} else {
							if (d == "exp10") {
								c = Math.pow(10, c)
							} else {
								if (d == "percentile") {
									c = this.percentile(e, m, c)
								} else {
									if (d == "ceil") {
										c = Math.min(m, c)
									} else {
										if (d == "floor") {
											c = Math.max(e, c)
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return c
	};
	this.getDataForSmpAtPosition = function(c) {
		var b = [];
		for (var d = 0; d < this.data.y.data.length; d++) {
			b.push(this.data.y.data[d][c])
		}
		return b
	};
	this.getDataForSmpGrpAtIndex = function(c, k, d) {
		var b = [];
		if (!k) {
			k = this.varIndices
		}
		if (this.isGroupedData || !this.isRawData) {
			var l = this.isGroupedData ? this.data.w : this.data.y;
			if (this.isTransformedData) {
				b.push(l.trans[f][c])
			} else {
				d = this.summaryType;
				if (l.hasOwnProperty(d)) {
					for (var e = 0; e < k.length; e++) {
						var f = k[e];
						b.push(l[d][f][c])
					}
				}
			}
		} else {
			var g = d ? this.data.y[d] : this.data.y.data;
			if (this.isTransformedData) {
				for (var e = 0; e < k.length; e++) {
					var f = k[e];
					b.push(this.data.y.trans[f][c])
				}
			} else {
				for (var e = 0; e < k.length; e++) {
					var f = k[e];
					b.push(g[f][c])
				}
			}
		}
		return b
	};
	this.getDataForVariableAtIndex = function(c) {
		var b = [];
		if (this.isTransformedData) {
			for (var d = 0; d < this.smpIndices.length; d++) {
				var e = this.smpIndices[d];
				b.push(this.data.y.trans[c][e])
			}
		} else {
			for (var d = 0; d < this.smpIndices.length; d++) {
				var e = this.smpIndices[d];
				b.push(this.data.y.data[c][e])
			}
		}
		return b
	};
	this.getMetaDataForVariableAtIndex = function(b) {
		var d = {};
		if (this.data.z) {
			for (var c in this.data.z) {
				d[c] = this.data.z[c][b]
			}
		}
		d[name] = this.data.y.vars[b];
		return d
	};
	this.getMetaDataForSampleAtIndex = function(b) {
		if (this.isGroupedData) {
			return this.getMetaDataForGrpAtIndex(b)
		} else {
			return this.getMetaDataForSmpAtIndex(b)
		}
	};
	this.getMetaDataForSmpAtIndex = function(b) {
		var d = {};
		if (this.data.x) {
			for (var c in this.data.x) {
				d[c] = this.data.x[c][b]
			}
		}
		d[name] = this.data.y.vars[b];
		return d
	};
	this.getMetaDataForGrpAtIndex = function(b) {
		var e = [];
		for (var c = 0; c < this.data.w.grps[b].length; c++) {
			var d = this.data.w.grps[b][c];
			e.push(this.getMetaDataForSmpAtIndex[d])
		}
		return e
	};
	this.setOriginalIndices = function(g, b, d, f) {
		var e = this.layoutComb ? this.layoutParams[g || 0] : this;
		if (!b) {
			b = e.varIndices
		}
		if (!d) {
			d = this.isGroupedData ? e.grpIndices : e.smpIndices
		}
		if (f || !e.startingVarIndices || e.startingVarIndices.length == 0) {
			e.startingVarIndices = this.cloneObject(b)
		}
		if (f || !e.startingSmpIndices || e.startingSmpIndices.length == 0) {
			e.startingSmpIndices = this.cloneObject(d)
		}
	};
	this.reorderOriginalIndices = function(o, n, q) {
		var p = this.layoutComb ? this.layoutParams[o || 0] : this;
		var e = n == "varDendrogram" ? this.cloneObject(p.startingVarIndices) : this.cloneObject(p.startingSmpIndices);
		var b = [];
		var l = [];
		var m = false;
		while (e.length > 0) {
			var k = e.shift();
			if (k == q[1]) {
				l.push(k);
				while (!m) {
					var g = e.shift();
					if (g == q[0]) {
						m = true
					}
					l.push(g)
				}
				l = l.reverse();
				b = b.concat(l)
			} else {
				b.push(k)
			}
		}
		if (n == "varDendrogram") {
			p.startingVarIndices = b
		} else {
			p.startingSmpIndices = b
		}
	};
	this.getVocabulary = function(b) {
		return CanvasXpress.vocabulary.byId[b]
	};
	this.updateVocabulary = function(b) {
		for (var c = 0; c < b.length; c++) {
			if (!CanvasXpress.vocabulary.byStr.hasOwnProperty(b[c])) {
				CanvasXpress.vocabulary.byStr[b[c]] = CanvasXpress.vocabulary.n++;
				CanvasXpress.vocabulary.byId.push(b[c])
			}
		}
	};
	this.validatePropertyValues = function(c) {
		var g = ["color", "shape", "size", "pattern", "outline", "transparency", "motion", "ellipse"];
		for (var e = 0; e < g.length; e++) {
			var b = this[g[e] + "By"];
			var f = this[b + "Data"];
			if (b) {
				if (this.isMultidimensionalData) {
					if (f && !this.data.y[f]) {
						this[g[e] + "By"] = false;
						this[b + "Data"] = false
					}
				} else {
					if (this.data.x && !this.data.x.hasOwnProperty(b) && this.data.z && !this.data.z.hasOwnProperty(b)) {
						if (b == "variable" || (this.graphType.match(/Boxplot|Dotplot/))) {
							continue
						} else {
							if (this.getSampleIndices(b) || this.getSampleIndices(b, true)) {
								continue
							} else {
								this[g[e] + "By"] = false
							}
						}
					}
				}
			}
		}
		if (this.shapeBy && !this.isMultidimensionalData && !this.graphType.match(/Boxplot|Dotplot|Scatter/)) {
			this.shapeBy = false
		}
		if (this.sizeBy && !this.isMultidimensionalData && !this.graphType.match(/Boxplot|Dotplot|Scatter/)) {
			this.sizeBy = false
		}
		if (this.colorBy && this.graphType == "Heatmap" && !this.isMultidimensionalData) {
			this.colorBy = false
		}
		if ((this.shapeBy || this.sizeBy || this.patternBy || this.outlineBy || this.transparencyBy) && !this.colorBy && !this.isMultidimensionalData && !this.graphType == "Heatmap") {
			this.colorBy = "variable"
		} else {
			if (!this.shapeBy && !this.sizeBy && !this.patternBy && !this.transparencyBy && this.colorBy == "variable") {
				this.colorBy = false
			}
		}
		if (this.colorBy || this.outlineBy) {
			this.updateMetadataColorProperties()
		}
		if (c) {
			this.setLegends()
		}
	};
	this.updateMetadataColorProperties = function() {
		var e = this;
		var k = this.colorSchemes;
		var d = this.data;
		var f = this.meta.data;
		var b = this.metadataColorProperties;
		var g = function(l, r) {
			var q = r && r.spectrum ? r.spectrum : e.colorSpectrum;
			var t = r && r.spectrumZeroValue != null ? r.spectrumZeroValue : null;
			var c = r && r.spectrumBreaks ? r.spectrumBreaks : false;
			if (l) {
				if (l.type == "Numeric") {
					l.colorBrew = e.getColorBrew(q, l.min, l.max, t, c)
				} else {
					if (r && r.colors) {
						l.colors = r.colors
					} else {
						if (r && r.spectrum) {
							var u = Math.max(3, l.levels.length);
							if (k[r.spectrum][u]) {
								l.colors = k[r.spectrum][u]
							} else {
								var o = e.getKeys(k[r.spectrum]);
								o.sort(function(n, m) {
									return n - m
								});
								if (u > o[o.length - 1]) {
									u--;
									while (!k[r.spectrum][u]) {
										u--
									}
								} else {
									u++;
									while (!k[r.spectrum][u]) {
										u++
									}
								}
								l.colors = k[r.spectrum][u]
							}
						} else {
							l.colors = e.colors
						}
					}
				}
			}
		};
		if (this.colorBy) {
			if (d.x && d.x[this.colorBy]) {
				g(f.x[this.colorBy], b[this.colorBy])
			} else {
				if (d.z && d.z[this.colorBy]) {
					g(f.z[this.colorBy], b[this.colorBy])
				}
			}
		}
		if (this.outlineBy) {
			if (d.x && d.x[this.outlineBy]) {
				g(f.x[this.outlineBy], b[this.outlineBy])
			} else {
				if (d.z && d.z[this.outlineBy]) {
					g(f.z[this.outlineBy], b[this.outlineBy])
				}
			}
		}
	};
	this.getPropertyValueBin = function(d, f, c, k, e) {
		var g = Math.min(Math.floor((Math.max(f, d.min) - d.min) / ((d.max - d.min) / d.vals.length)), d.vals.length - 1);
		return c ? g : parseInt(this[k[e]][g])
	};
	this.getPropertyValueSize = function(b, d, c) {
		var e = b.vals.length - 1;
		return parseFloat((((d - b.min) / (b.max - b.min)) * (this[h[c]][e] - this[h[c]][0]))) + parseInt(this[h[c]][0])
	};
	this.getPropertyValue = function(n, o, w) {
		var k, f, y;
		var d = this[w];
		var u = this.isGroupedData && (this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData));
		var s = this.groupingFactors && this.groupingFactors.length == 1;
		var e = this.data;
		var v = this.meta.data;
		var r = {
			colorBy: "colors",
			outlineBy: "colors",
			outlineByData: "colors",
			shapeBy: "shapes",
			shapeByData: "shapes",
			sizeBy: "sizes",
			sizeByData: "sizes",
			patternBy: "patterns",
			patternByData: "patterns"
		};
		var x = function() {
			var g = {};
			var p = 0;
			for (var m = 0; m < e.w.grps[o].length; m++) {
				var c = e.x[d][e.w.grps[o][m]];
				if (!g.hasOwnProperty(c)) {
					g[c] = true;
					p++
				}
				if (p > 1) {
					return false
				}
			}
			return true
		};
		var b = w ? this[r[w]].length : false;
		if (d && e.y.hasOwnProperty(d)) {
			k = e.y[d][n][o];
			f = v[d];
			y = f.type
		} else {
			if (d && e.x && e.x.hasOwnProperty(d)) {
				f = v.x[d];
				if (u || !this.isGroupedData) {
					k = e.x[d][o];
					y = f.type
				} else {
					if (s && (this.groupingFactors[0] == d || x())) {
						k = e.x[d][e.w.grps[o][0]];
						return w.match(/colorBy|patternBy/) ? this[r[w]][f.order[k] % b] : this[r[w]][0]
					} else {
						return w.match(/colorBy|patternBy/) ? this[r[w]][n % b] : this[r[w]][0]
					}
				}
			} else {
				if (d && e.z && e.z.hasOwnProperty(d)) {
					k = e.z[d][n];
					f = v.z[d];
					y = f.type
				} else {
					if (w && ((this.isGroupedData && v.w.smps.hasOwnProperty(w)) || (!this.isGroupedData && v.y.range.hasOwnProperty(w)))) {
						k = e.y.data[n][o];
						f = v.y.range[w];
						y = f.type
					} else {
						if (n != null) {
							return d && w.match(/colorBy|patternBy/) ? this[r[w]][n % b] : !d && w == "colorBy" ? this[r[w]][n % b] : this[r[w]][0]
						} else {
							return w.match(/sizeBy/) ? 10 : this[r[w]][0]
						}
					}
				}
			}
		}
		if (y == "Numeric") {
			if (w.match(/colorBy|outlineBy/)) {
				return !isNaN(k) ? this.getColorForValue(f.colorBrew, k) : this.missingDataColor
			} else {
				if (w.match(/shapeBy/)) {
					if (!isNaN(k)) {
						return "pie" + this.getPropertyValueBin(f, k, true, r, w)
					} else {
						return "sphere"
					}
				} else {
					if (w.match(/sizeBy/)) {
						if (!isNaN(k)) {
							return this.sizeByContinuous ? this.getPropertyValueSize(f, k) : this.getPropertyValueBin(f, k, false, r, w)
						} else {
							return this[r[w]][0]
						}
					} else {
						if (w.match(/patternBy/)) {
							if (!isNaN(k)) {
								return this.getPropertyValueBin(f, k, false, r, w)
							} else {
								return "closed"
							}
						}
					}
				}
			}
		} else {
			if (y == "String") {
				return w.match(/sizeBy/) ? parseInt(this[r[w]][f.order[k] % b]) : this[r[w]][f.order[k] % b]
			}
		}
	};
	this.resetMetaData = function() {
		delete(this.meta.data);
		this.setMetaData()
	};
	this.getMetadata = function(c, b) {
		var d = this.meta.data;
		if (b) {
			var e = c == "x" ? "z" : "x";
			if (c && d[c] && d[c].hasOwnProperty(b)) {
				return d[c][b]
			} else {
				if (d[e] && d[e].hasOwnProperty(b)) {
					return d[e][b]
				} else {
					if (d.x && d.x.hasOwnProperty(b)) {
						return d.x[b]
					} else {
						if (d.z && d.z.hasOwnProperty(b)) {
							return d.z[b]
						} else {
							return false
						}
					}
				}
			}
		} else {
			if (c) {
				if (c == "x") {
					return d.x
				} else {
					if (c == "z") {
						return d.z
					} else {
						return d[c] ? d[c] : false
					}
				}
			} else {
				return d
			}
		}
	};
	this.updateMetaData = function(l, P, M, q) {
		if (!l || l == "w" || l == "x" || l == "z") {
			var R = this.meta.data;
			var x = this.data;
			var A = this.metadataColorProperties;
			var p = ["x", "z", "w"];
			var v = this.font;
			if (l && M) {
				if (!P) {
					delete(R[l])
				} else {
					if (R[l][P]) {
						delete(R[l][P])
					}
				}
			}
			for (var L = 0; L < p.length; L++) {
				var G = p[L];
				if (l) {
					if (l != G) {
						continue
					}
				}
				v = G == "z" ? this.varLabelFont : this.smpLabelFont;
				if (x[G]) {
					for (var I in x[G]) {
						if (P) {
							if (P != I) {
								continue
							}
						}
						if (G == "w") {
							if (I != "smps" && I != "grps") {
								continue
							}
							if (I = "grps") {
								R[G][I] = x[G][I];
								R[G].smps = {};
								for (var J = 0; J < x[G].smps.length; J++) {
									R[G].smps[x[G].smps[J]] = J
								}
								continue
							}
						}
						R[G][I] = {};
						R[G][I].len = this.measureText(I, v);
						var H = R[G][I].len;
						var N = I.length;
						var w = I;
						var F = this.isNumeric(x[G][I]) && !this.isEmpty(x[G][I]);
						R[G][I].type = F ? "Numeric" : "String";
						var K = 0;
						var Q = 0;
						var z = "";
						if (R[G][I].type == "String") {
							this.updateVocabulary(x[G][I]);
							var B = {};
							for (var J = 0; J < x[G][I].length; J++) {
								B[x[G][I][J]] = true
							}
							B = this.stringRangeSort(this.getKeys(B));
							R[G][I].levels = B;
							R[G][I].order = {};
							for (var J = 0; J < B.length; J++) {
								R[G][I].order[B[J]] = J;
								var f = this.measureText(B[J], v);
								if (f > K) {
									K = f;
									Q = B[J].length;
									z = B[J]
								}
							}
							R[G][I].maxLevLen = K;
							R[G][I].maxLevChr = Q;
							R[G][I].maxLevStr = z;
							if (A.hasOwnProperty(I) && A[I].hasOwnProperty("colors")) {
								R[G][I].colors = A[I].colors
							} else {
								if (A.hasOwnProperty(I) && A[I].hasOwnProperty("spectrum")) {
									var D = B.length;
									if (this.colorSchemes[A[I].spectrum][D]) {
										R[G][I].colors = this.colorSchemes[A[I].spectrum][D]
									} else {
										var S = this.getKeys(this.colorSchemes[A[I].spectrum]);
										S.sort(function(k, d) {
											return k - d
										});
										if (D > S[S.length - 1]) {
											D--;
											while (!this.colorSchemes[A[I].spectrum][D]) {
												D--
											}
										} else {
											D++;
											while (!this.colorSchemes[A[I].spectrum][D]) {
												D++
											}
										}
										R[G][I].colors = this.colorSchemes[A[I].spectrum][D]
									}
								} else {
									R[G][I].colors = [];
									var g = 0;
									for (var J = 0; J < B.length; J++) {
										R[G][I].colors.push(this.colors[g % this.colors.length]);
										g++
									}
								}
							}
						} else {
							for (var J = 0; J < x[G][I].length; J++) {
								if (x[G][I][J] != null) {
									x[G][I][J] = Number(x[G][I][J])
								} else {
									x[G][I][J] = null
								}
							}
							var u = this.range(x[G][I]);
							R[G][I].rmin = u[0];
							R[G][I].rmax = u[1];
							R[G][I].n = x[G][I].length;
							var O = A.hasOwnProperty(I) && A[I].hasOwnProperty("spectrum") ? A[I].spectrum : this.colorSpectrum;
							var c = A.hasOwnProperty(I) && A[I].hasOwnProperty("spectrumZeroValue") ? A[I].spectrumZeroValue : null;
							var b = A.hasOwnProperty(I) && A[I].hasOwnProperty("spectrumBreaks") ? A[I].spectrumBreaks : false;
							R[G][I].colorBrew = this.getColorBrew(O, u[0], u[1], c, b);
							R[G][I].min = R[G][I].colorBrew.min;
							R[G][I].max = R[G][I].colorBrew.max;
							R[G][I].zero = R[G][I].colorBrew.zero;
							R[G][I].vals = R[G][I].colorBrew.vals;
							R[G][I].incr = R[G][I].colorBrew.incr;
							R[G][I].decs = R[G][I].colorBrew.decs;
							R[G][I].levels = R[G][I].colorBrew.vals;
							R[G][I].order = {};
							for (var J = 0; J < R[G][I].levels.length; J++) {
								R[G][I].order[R[G][I].levels[J]] = J;
								var f = this.measureText(R[G][I].levels[J], v);
								if (f > K) {
									K = f;
									Q = R[G][I].levels[J].toString().length;
									z = R[G][I].levels[J]
								}
								R[G][I].maxLevLen = K;
								R[G][I].maxLevChr = Q;
								R[G][I].maxLevStr = z
							}
						}
						if (!R.m[G]) {
							R.m[G] = {}
						}
						if (R.m[G].maxFacLen) {
							if (H > R.m[G].maxFacLen) {
								R.m[G].maxFacLen = H;
								R.m[G].maxFacChr = N;
								R.m[G].maxFacStr = w
							}
						} else {
							R.m[G].maxFacLen = H;
							R.m[G].maxFacChr = N;
							R.m[G].maxFacStr = w
						}
					}
				}
				if (q) {
					return
				}
				var y, e, E;
				if (G == "z") {
					y = "y";
					e = "vars";
					E = "Var"
				}
				if (G == "x") {
					y = "y";
					e = "smps";
					E = "Smp"
				}
				if (G == "w") {
					y = "w";
					e = "smps";
					E = "Smp"
				}
				var K = 0;
				var Q = 0;
				var z = "";
				if (x[y]) {
					for (var J = 0; J < x[y][e].length; J++) {
						var C = x[y][e][J].length;
						if (C >= Q) {
							var f = this.measureText(x[y][e][J], v);
							if (f > K) {
								K = f;
								Q = C;
								z = x[y][e][J]
							}
						}
					}
					R[y]["max" + E + "Len"] = K;
					R[y]["max" + E + "Chr"] = Q;
					R[y]["max" + E + "Str"] = z;
					if (G == "x") {
						if (!R[y]["range"]) {
							R[y]["range"] = {}
						}
						for (var J = 0; J < x.y.smps.length; J++) {
							var u = this.range(this.getDataForSmpAtPosition(J));
							R[y]["range"][x.y.smps[J]] = {};
							R[y]["range"][x.y.smps[J]].min = u[0];
							R[y]["range"][x.y.smps[J]].max = u[1];
							R[y]["range"][x.y.smps[J]].type = "Numeric"
						}
					}
					if (G == "z") {
						if (!R[y]["range"]) {
							R[y]["range"] = {}
						}
						for (var J = 0; J < x.y.data.length; J++) {
							var u = this.range(x.y.data[J]);
							R[y]["range"][x.y.vars[J]] = {};
							R[y]["range"][x.y.vars[J]].min = u[0];
							R[y]["range"][x.y.vars[J]].max = u[1];
							R[y]["range"][x.y.vars[J]].type = "Numeric"
						}
					}
				}
			}
		} else {
			if (x.y[l]) {
				R[l] = {};
				var K = 0;
				var Q = 0;
				var z = "";
				if (this.isNumeric2DArray(x.y[l])) {
					for (var J = 0; J < x.y[l].length; J++) {
						for (var I = 0; I < x.y[l][J].length; I++) {
							if (x.y[l][J][I] != null) {
								x.y[l][J][I] = Number(x.y[l][J][I])
							} else {
								x.y[l][J][I] = null
							}
						}
					}
					var u = this.setRangeDataObject(x.y[l]);
					R[l].rmin = u[0];
					R[l].rmax = u[1];
					R[l].n = x.y[l].length * x.y[l][0].length;
					R[l].type = "Numeric";
					R[l].colorBrew = this.getColorBrew(this.colorSpectrum, u[0], u[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
					R[l].min = R[l].colorBrew.min;
					R[l].max = R[l].colorBrew.max;
					R[l].zero = R[l].colorBrew.zero;
					R[l].vals = R[l].colorBrew.vals;
					R[l].incr = R[l].colorBrew.incr;
					R[l].decs = R[l].colorBrew.decs;
					R[l].levels = R[l].colorBrew.vals;
					R[l].order = {};
					for (var J = 0; J < R[l].levels.length; J++) {
						R[l].order[R[l].levels[J]] = J;
						var f = this.measureText(R[l].levels[J], v);
						if (f > K) {
							K = f;
							Q = R[l].levels[J].toString().length;
							z = R[l].levels[J]
						}
						R[l].maxLevLen = K;
						R[l].maxLevChr = Q;
						R[l].maxLevStr = z
					}
				} else {
					var B = {};
					for (var J = 0; J < x.y[l].length; J++) {
						for (var I = 0; I < x.y[l][J].length; I++) {
							B[x.y[l][J][I]] = true
						}
					}
					B = this.stringRangeSort(this.getKeys(B));
					R[l].levels = B;
					R[l].order = {};
					for (var J = 0; J < B.length; J++) {
						R[l].order[B[J]] = J;
						var f = this.measureText(B[J], v);
						if (f > K) {
							K = f;
							Q = B[J].length;
							z = B[J]
						}
					}
					R[l].maxLevLen = K;
					R[l].maxLevChr = Q;
					R[l].maxLevStr = z;
					R[l].type = "String";
					R[l].colors = [];
					var g = 0;
					for (var J = 0; J < B.length; J++) {
						R[l].colors.push(this.colors[g % this.colors.length]);
						g++
					}
				}
			} else {
				alert("Error while setting metadata. This may not work!")
			}
		}
	};
	this.setMetaData = function() {
		if (!this.meta.data) {
			if (this.graphType == "Network") {
				this.meta.data = {
					nodes: {},
					edges: {}
				}
			} else {
				this.meta.data = {
					w: {},
					x: {},
					y: {},
					z: {},
					m: {}
				};
				if (this.data.y) {
					var e = this.data.y;
					for (var c = 0; c < e.data.length; c++) {
						for (var b = 0; b < e.data[c].length; b++) {
							if (e.data[c][b] != null) {
								e.data[c][b] = Number(e.data[c][b])
							} else {
								e.data[c][b] = null
							}
						}
					}
				}
			}
			this.updateMetaData()
		}
	};
	this.getIndices = function(b, f) {
		if (b != null && f) {
			var e = [];
			if (this.isArray(b)) {
				for (var c = 0; c < b.length; c++) {
					var d = f.indexOf(b[c]);
					if (d > -1) {
						e.push(d)
					}
				}
				return e
			} else {
				return f.indexOf(b)
			}
		}
	};
	this.getLevelsByAnnotation = function(c, m, k) {
		var b = [];
		var g = {};
		if (k && c && k[c]) {
			for (var e = 0; e < m.length; e++) {
				var f = m[e];
				var d = k[c][f] || "";
				if (!g.hasOwnProperty(d)) {
					b.push(d)
				}
				g[d] = true
			}
		}
		return b
	};
	this.getVariablesSamplesByAnnotationLevel = function(c, b, m, g, f) {
		var k = [];
		if (g && c && g[c]) {
			if (b) {
				for (var d = 0; d < m.length; d++) {
					var e = m[d];
					if (g[c][e] == b && !f[e]) {
						k.push(e)
					}
				}
			} else {
				for (var d = 0; d < m.length; d++) {
					var e = m[d];
					if (!g[c][e] && !f[e]) {
						k.push(e)
					}
				}
			}
		}
		return k
	};
	this.getVarSmpAnnotations = function(m, c, l, f, d) {
		var b = {};
		var g = [];
		var k = false;
		if (d && d.hasOwnProperty(m)) {
			for (var e = 0; e < c.length; e++) {
				var n = c[e];
				if (d[m][n] != null) {
					b[d[m][n]] = true;
					g.push(d[m][n])
				} else {
					k = true
				}
			}
			if (k) {
				g.push("")
			}
			if (f) {
				return l ? g.join("+") : g
			} else {
				g = []
			}
			for (var e in b) {
				g.push(e)
			}
			if (k) {
				g.push("")
			}
			return l ? g.join("+") : g
		}
	};
	this.setAllSamplesVisible = function(b, c) {
		var g = this.data;
		if (g.y) {
			var n = g.y.smps;
			if (!n && g.y.vars) {
				if (!g.y.data) {
					alert("Missing data object")
				}
				n = [];
				for (var f = 0; f < g.y.data[0].length; f++) {
					n.push("smp" + (f + 1))
				}
				g.y.smps = n
			}
			var l = [];
			var k = [];
			if (b) {
				for (var f = 0; f < b.length; f++) {
					l.push(indices[f]);
					k.push(false)
				}
			} else {
				for (var f = 0; f < n.length; f++) {
					l.push(f);
					k.push(false)
				}
			}
			if (!c && this.varIndices) {
				this.filterData()
			}
			this.smpIndices = l;
			this.hiddenSmps = k
		}
		if (this.data.w && this.data.w.smps) {
			this.grpIndices = [];
			this.hiddenGrps = [];
			for (var f = 0; f < this.data.w.smps.length; f++) {
				this.grpIndices.push(f);
				this.hiddenGrps.push(false)
			}
		}
		if (this.layoutComb && this.graphType != "Candlestick") {
			var m = this.layoutParams[this.layoutValidN || 0];
			var e = this.isGroupedData ? m.grpIndices : this.smpIndices;
			if (m && m.startingSmpIndices) {
				if (m.isGroupedData) {
					m.grpIndices = m.startingSmpIndices
				} else {
					m.smpIndices = m.startingSmpIndices
				}
				m.smpIndicesStart = -1
			}
		}
	};
	this.getSampleIndices = function(b, d, c) {
		var e = this.isGroupedData && !d ? this.data.w.smps : c ? this.dataStndBy.y.smps : this.data.y.smps;
		return this.getIndices(b, e)
	};
	this.getSamplesByAxis = function(b) {
		return this[b] || []
	};
	this.getSamplesByAnnotationLevel = function(c, b, d) {
		return this.getVariablesSamplesByAnnotationLevel(c, b, d || this.smpIndices, this.data.x, this.hiddenSmps)
	};
	this.getSampleLevelsByAnnotation = function(b, c) {
		return this.getLevelsByAnnotation(b, c || this.smpIndices, this.data.x)
	};
	this.setSamplesVisible = function(b, e) {
		if (this.isGroupedData) {
			this.grpIndices = [];
			for (var d = 0; d < b.length; d++) {
				this.grpIndices.push(b[d])
			}
		} else {
			this.smpIndices = [];
			for (var d = 0; d < b.length; d++) {
				this.smpIndices.push(b[d])
			}
		}
		if (status) {
			var c = this.getObjectArray(b);
			var g = this.isGroupedData ? this.data.w : this.data.y;
			var f = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
			for (var d = 0; d < g.smps.length; d++) {
				if (c.hasOwnProperty(d)) {
					f[d] = false
				} else {
					f[d] = true
				}
			}
		}
	};
	this.hideUnhideSmps = function(k) {
		this.functionCaller = "hideUnhideSmps";
		if (k) {
			var c = this.isGroupedData ? this.data.w : this.data.y;
			var f = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
			var g = [];
			if (this.isArray(k)) {
				for (var e = 0; e < k.length; e++) {
					for (var d = 0; d < c.smps.length; d++) {
						if (c.smps[d] == k[e]) {
							if (f[d]) {
								f[d] = false
							} else {
								f[d] = true
							}
							break
						}
					}
				}
			} else {
				for (var e = 0; e < c.smps.length; e++) {
					if (c.smps[e] == k) {
						if (f[e]) {
							f[e] = false
						} else {
							f[e] = true
						}
						break
					}
				}
			}
			var b = [];
			for (var e = 0; e < c.smps.length; e++) {
				if (!f[e]) {
					b.push(e)
				}
			}
			this.setSamplesVisible(b);
			this.draw()
		}
	};
	this.getSamples = function() {
		var d = [];
		var k = this.isGroupedData ? this.data.w.smps : this.data.y.smps;
		var l = this.isGroupedData ? this.data.w : this.data.y;
		var f = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
		var g = this.isGroupedData ? this.grpIndices : this.smpIndices;
		for (var e = 0; e < k.length; e++) {
			var b = -1;
			for (var c = 0; c < g.length; c++) {
				if (g[c] == e) {
					b = c;
					break
				}
			}
			d.push({
				name: k[e],
				hidden: f[e],
				index: b
			})
		}
		return d
	};
	this.getSmpAnnotations = function(b, e, d, c) {
		return this.getVarSmpAnnotations(b, e, d, c, this.data.x)
	};
	this.setAllVariablesVisible = function(k, l) {
		var m = this.data;
		if (m.y) {
			var e = m.y.vars;
			if (!e && m.y.data) {
				e = [];
				for (var g = 0; g < m.y.data.length; g++) {
					e.push("var" + (g + 1))
				}
				m.y.vars = e
			}
			var b = [];
			var c = [];
			if (k) {
				for (var g = 0; g < k.length; g++) {
					b.push(k[g]);
					c.push(false)
				}
			} else {
				for (var g = 0; g < e.length; g++) {
					b.push(g);
					c.push(false)
				}
			}
			if (!l && this.smpIndices) {
				this.filterData()
			}
			if (this.layoutComb && this.graphType != "Candlestick") {
				var f = this.layoutParams[this.layoutValidN || 0];
				if (f && f.startingVarIndices) {
					f.varIndices = f.startingVarIndices;
					f.varIndicesStart = -1
				}
			}
			this.varIndices = b;
			this.hiddenVars = c
		}
		if (m.y && m.a) {
			this.xAxisVarIndices = [];
			this.xAxis2VarIndices = [];
			if (m.a.xAxis) {
				this.xAxisVarIndices = this.getVariableIndices(m.a.xAxis)
			}
			if (m.a.xAxis2) {
				this.xAxis2VarIndices = this.getVariableIndices(m.a.xAxis2)
			}
		}
	};
	this.getVariableIndices = function(b, d) {
		var c = d ? this.dataStndBy.y.vars : this.data.y.vars;
		return this.getIndices(b, c)
	};
	this.resetVariablesVisibleByAxis = function(b) {
		if (this.data.a) {
			this.setVariablesVisibleByAxis(b, this.getVariableIndices(this.data.a[b]))
		}
	};
	this.setVariablesVisibleByAxis = function(c, b) {
		var d = this[c + "VarIndices"];
		d = [];
		for (var e = 0; e < b.length; e++) {
			d.push(b[e])
		}
	};
	this.getVariablesVisibleByAxis = function(b) {
		return this[b + "VarIndices"]
	};
	this.getVariablesByAxis = function(b) {
		return this.data.a && this.data.a[b] ? this.data.a[b] : []
	};
	this.getVariablesByAnnotationLevel = function(c, b, d) {
		return this.getVariablesSamplesByAnnotationLevel(c, b, d || this.varIndices, this.data.z, this.hiddenVars)
	};
	this.getVariableLevelsByAnnotation = function(b, c) {
		return this.getLevelsByAnnotation(b, c || this.varIndices, this.data.z)
	};
	this.setVariablesVisible = function(b) {
		this.varIndices = [];
		for (var c = 0; c < b.length; c++) {
			this.varIndices.push(b[c])
		}
	};
	this.hideUnhideVars = function(b) {
		this.functionCaller = "hideUnhideVars";
		var l = this.data.y;
		var e = this.hiddenVars;
		if (b) {
			if (this.isArray(b)) {
				for (var d = 0; d < b.length; d++) {
					for (var c = 0; c < l.vars.length; c++) {
						if (l.vars[c] == b[d]) {
							if (e[c]) {
								e[c] = false
							} else {
								e[c] = true
							}
							break
						}
					}
				}
			} else {
				for (var d = 0; d < l.vars.length; d++) {
					if (l.vars[d] == b) {
						if (e[d]) {
							e[d] = false
						} else {
							e[d] = true
						}
						break
					}
				}
			}
			var f = [];
			for (var d = 0; d < l.vars.length; d++) {
				if (!e[d]) {
					f.push(d)
				}
			}
			this.setVariablesVisible(f);
			var k = ["xAxis", "xAxis2"];
			if (this.data.a) {
				for (var d = 0; d < k.length; d++) {
					var m = this.getVariableIndices(this.data.a[k[d]]);
					if (m.length > 0) {
						var f = [];
						for (var c = 0; c < m.length; c++) {
							var g = m[c];
							if (!e[g]) {
								f.push(g)
							}
						}
						this.setVariablesVisibleByAxis(k[d], f)
					}
				}
			}
			this.draw()
		}
	};
	this.getVariables = function() {
		var e = [];
		for (var d = 0; d < this.data.y.vars.length; d++) {
			var b = -1;
			for (var c = 0; c < this.varIndices.length; c++) {
				if (this.varIndices[c] == d) {
					b = c;
					break
				}
			}
			e.push({
				name: this.data.y.vars[d],
				hidden: this.hiddenVars[d],
				index: b
			})
		}
		return e
	};
	this.getVarAnnotations = function(b, e, d, c) {
		return this.getVarSmpAnnotations(b, e, d, c, this.data.z)
	};
	this.setNodeIndices = function() {
		var e = this.data.nodes;
		var g = {};
		var f = {};
		for (var b = 0; b < e.length; b++) {
			var c = e[b];
			g[c.id] = c;
			f[c.id] = b
		}
		this.nodes = g;
		this.data.nodeIndices = f
	};
	this.setNodes = function() {
		if (this.data.nodeIndices) {
			var b = this.data.nodeIndices;
			var e = this.data.nodes;
			var g = {};
			for (var b = 0; b < e.length; b++) {
				var c = e[b];
				g[c.id] = c
			}
			e = [];
			for (var f in b) {
				e[b[f]] = g[f]
			}
			this.data.nodes = e;
			this.nodes = g
		} else {
			this.setNodeIndices()
		}
	};
	this.setAllNodesVisible = function(d) {
		this.nodes = {};
		this.data.nodeIndices = {};
		var g = this.data.nodes;
		for (var b = 0; b < g.length; b++) {
			var c = g[b];
			c.hide = false;
			this.nodes[c.id] = c;
			this.data.nodeIndices[c.id] = b
		}
		var f = this.data.edges;
		for (var b = 0; b < f.length; b++) {
			f[b].hide = false
		}
		if (!d) {
			this.filterData()
		}
	};
	this.hideUnhideNodes = function(c, e) {
		e = e ? true : false;
		var g = this.data.nodes;
		var l = this.nodes;
		if (c) {
			if (this.isArray(c)) {
				for (var b = 0; b < c.length; b++) {
					var k = c[b];
					var f = g[this.data.nodeIndices[k]];
					f.hide = e;
					if (l && l[k]) {
						l[k].hide = e
					}
				}
			}
		} else {
			for (var b = 0; b < g.length; b++) {
				var f = g[b];
				f.hide = e;
				f.hideChildren = e;
				if (l && l[f.id]) {
					l[f.id].hide = e;
					l[f.id].hideChildren = e
				}
			}
		}
	};
	this.hideUnhideChildrenNodes = function(f, c) {
		c = c ? true : false;
		var d = this.nodeParentHood;
		if (d[f] && d[f].children) {
			for (var b = 0; b < d[f].children.length; b++) {
				var e = d[f].children[b];
				this.data.nodes[this.data.nodeIndices[e]].hiddenParent = c;
				this.hideUnhideChildrenNodes(e, c)
			}
		}
	};
	this.setAllFeaturesVisible = function() {
		var e = this.data.tracks;
		for (var d = 0; d < e.length; d++) {
			var b = e[d];
			b.hide = false;
			var f = b.data;
			for (var c = 0; c < f.length; c++) {
				f[c].hide = false
			}
		}
	};
	this.setIndices = function(c, b) {
		if (this.graphType == "Network") {
			this.setNodes()
		} else {
			if (this.graphType != "Genome" && this.graphType != "Venn") {
				this.setAllVariablesVisible(c);
				this.setAllSamplesVisible(b)
			}
		}
	};
	this.resetIndices = function() {
		if (this.isGroupedData) {
			this.setIndices()
		}
	};
	this.initializeDataAttributes = function(f, c) {
		var e = this.graphType;
		var b = ["outlineByData", "shapeByData", "sizeByData", "patternByData"];
		this.setIndices(f, c);
		if (e == "Network") {
			this.setMetaData()
		} else {
			if (e != "Genome" && e != "Venn") {
				this.setMetaData();
				for (var d = 0; d < b.length; d++) {
					if (this[b[d]] && this.data.y.hasOwnProperty(this[b[d]])) {
						this.updateMetaData(this[b[d]])
					} else {
						this[b[d]] = false
					}
				}
			}
		}
	};
	this.setFrameData = function() {
		if (this.data.dataframe) {
			var f = this.data.dataframe;
			var g = f.shift();
			var e = {
				y: {
					vars: [],
					smps: [],
					data: []
				}
			};
			for (i = 0; i < f.length; i++) {
				e.y.data[i] = [];
				e.y.vars.push("V" + (i + 1))
			}
			for (i = 0; i < g.length; i++) {
				var b = [];
				for (j = 0; j < f.length; j++) {
					b.push(f[j][i])
				}
				if (this.isNumeric(b)) {
					e.y.smps.push(g[i]);
					for (j = 0; j < b.length; j++) {
						e.y.data[j].push(b[j])
					}
				} else {
					if (!e.z) {
						e.z = {}
					}
					if (!e.z[g[i]]) {
						e.z[g[i]] = []
					}
					for (j = 0; j < b.length; j++) {
						e.z[g[i]].push(b[j])
					}
				}
			}
			this.data = e
		}
	};
	this.setMarketData = function() {
		if (this.data.market && !this.isMarketDataFormated) {
			var c = this.data.market;
			var k = {};
			k.smps = [];
			k.vars = [];
			k.close = [];
			k.open = [];
			k.high = [];
			k.low = [];
			k.volume = [];
			k.desc = ["Price", "Vol"];
			var b = {};
			var n = 0;
			for (var g = 0; g < c.length; g++) {
				k.vars.push(c[g].symbol);
				k.close[g] = [];
				k.open[g] = [];
				k.high[g] = [];
				k.low[g] = [];
				k.volume[g] = [];
				var f = c[g].data;
				for (var e = f.length - 1; e >= 0; e--) {
					var l = this.parseDate(f[e][0]);
					var m = 0;
					if (!b.hasOwnProperty(l)) {
						m = n;
						b[l] = n;
						k.smps.push(l);
						n++
					} else {
						m = b[l]
					}
					k.open[g][m] = f[e][1];
					k.high[g][m] = f[e][2];
					k.low[g][m] = f[e][3];
					k.close[g][m] = f[e][4];
					k.volume[g][m] = f[e][5]
				}
			}
			this.data.market = k
		}
		this.isMarketDataFormated = true
	};
	this.initializeData = function(b) {
		this.data = a && !b ? a : b || this.dataSetExample;
		this.isExample = a || b ? false : !this.remoteService && !this.dataURL ? true : false;
		this.nodesData = false;
		this.edgesData = false;
		this.featuresData = false;
		this.validGraphTypes = [];
		if (this.data && (this.data.y || this.data.dataframe || this.data.venn || this.data.nodes || this.data.tracks || this.data.market || this.data.fx || this.data.video)) {
			this.FunctionData(this.data.fx ? true : false);
			if (this.data.dataframe) {
				this.setFrameData()
			}
			if (this.data.market) {
				this.setMarketData();
				this.summaryType = "candle";
				this.validGraphTypes.push("Candlestick")
			}
			if (this.data.venn) {
				this.summaryType = "venn";
				this.validGraphTypes.push("Venn")
			}
			if (this.data.video) {
				this.summaryType = "video";
				this.validGraphTypes.push("Video")
			}
			if (this.data.nodes) {
				this.summaryType = "network";
				this.validGraphTypes.push("Network")
			}
			if (this.data.tracks) {
				this.summaryType = "genome";
				this.validGraphTypes.push("Genome")
			}
			if (this.data.y) {
				if (!this.data.y.data && !this.data.y.cor && !this.data.y.close) {
					alert("Dude! there is not a valid data structure");
					return
				} else {
					if (this.data.y.data) {
						this.isRawData = true;
						this.summaryType = "raw"
					} else {
						this.isRawData = false;
						if (this.data.y.iqr1 && this.data.y.qtl1 && this.data.y.median && this.data.y.qtl3 && this.data.y.iqr3) {
							this.summaryType = "iqr"
						} else {
							if (this.data.y.median) {
								this.summaryType = "median"
							} else {
								if (this.data.y.mean) {
									this.summaryType = "mean"
								} else {
									if (this.data.y.cor) {
										this.summaryType = "cor"
									} else {
										if (this.data.y.sum) {
											this.summaryType = "sum"
										}
									}
								}
							}
						}
					}
				}
				this.validGraphTypes.push("Bar");
				this.validGraphTypes.push("Line");
				this.validGraphTypes.push("Area");
				this.validGraphTypes.push("AreaLine");
				this.validGraphTypes.push("BarLine");
				this.validGraphTypes.push("Boxplot");
				this.validGraphTypes.push("Dotplot");
				this.validGraphTypes.push("DotLine");
				this.validGraphTypes.push("Heatmap");
				this.validGraphTypes.push("Stacked");
				this.validGraphTypes.push("StackedLine");
				this.validGraphTypes.push("StackedPercent");
				this.validGraphTypes.push("StackedPercentLine");
				this.validGraphTypes.push("Pie");
				this.validGraphTypes.push("Correlation");
				this.validGraphTypes.push("Circular");
				if (this.data.y.smps || this.isDOE) {
					if (this.data.y.smps.length > 2 || this.isDOE) {
						this.validGraphTypes.push("Scatter2D");
						this.validGraphTypes.push("ScatterBubble2D");
						this.validGraphTypes.push("Scatter3D")
					} else {
						if (this.data.y.smps.length > 1 || this.isDOE) {
							this.validGraphTypes.push("Scatter2D")
						}
					}
				}
			}
			this.validGraphTypes.sort()
		}
		this.initializeDataAttributes()
	};
	this.initializeData()
};
CanvasXpress.prototype.initDataUtils = function() {
	this.switchAnnotationToVar = function(e) {
		this.functionCaller = "switchAnnotationToVar";
		var i = this.data;
		var c = this.meta.data;
		if (i.x.hasOwnProperty(e) && this.isNumeric(i.x[e])) {
			var h = this.rebuildDataTableFilter();
			if (!c.modified) {
				c.modified = {}
			}
			if (!c.modified.z) {
				c.modified.z = {}
			}
			if (!c.modified.z[e]) {
				c.modified.z[e] = {}
			}
			var b = this.groupingFactors;
			i.y.vars.push(e);
			i.y.data.push(i.x[e]);
			delete(i.x[e]);
			var g = this.getKeys(i.x);
			if (g.length < 1) {
				delete(i.x)
			}
			this.updateMetaData("x", e, true);
			if (i.z) {
				var g = this.getKeys(i.z);
				for (var f = 0; f < g.length; f++) {
					i.z[g[f]].push(c.modified.z[e][g[f]] || "")
				}
			}
			this.updateData(i, true);
			if (b && b.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(b)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(h, true)
		}
	};
	this.switchVarToAnnotation = function(h) {
		this.functionCaller = "switchVarToAnnotation";
		var f = this.getVariableIndices(h);
		if (f >= 0) {
			var g = this.data;
			var c = this.meta.data;
			var a = this.rebuildDataTableFilter();
			if (!c.modified) {
				c.modified = {}
			}
			if (!c.modified.z) {
				c.modified.z = {}
			}
			if (!c.modified.z[h]) {
				c.modified.z[h] = {}
			}
			var k = this.groupingFactors;
			if (!g.x) {
				g.x = {}
			}
			g.x[h] = g.y.data[f];
			g.y.vars.splice(f, 1);
			g.y.data.splice(f, 1);
			if (g.z) {
				var l = this.getKeys(g.z);
				for (var e = 0; e < l.length; e++) {
					var b = g.z[l[e]].splice(f, 1);
					c.modified.z[h][l[e]] = b[0]
				}
			}
			this.updateMetaData("x");
			this.updateData(g, true);
			if (k && k.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(k)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(a, true)
		}
	};
	this.rebuildDataTableFilter = function(c, h) {
		if (c) {
			var j = this;
			if (c[3] && !h) {
				j.resetDataExplorer()
			}
			setTimeout(function() {
				if (c[0]) {
					j.clickLayout();
					setTimeout(function() {
						j.activeAccordion = false;
						j.activateAccordion(false, j.$(j.target + "-cX-DataFilterVariableHeader"))
					}, j.showFadeResizeMoveAnimation ? 500 : 0)
				} else {
					if (c[1]) {
						j.clickDataFilter()
					}
					if (c[2]) {
						j.clickDataTable()
					}
				}
			}, 2000)
		} else {
			var j = this;
			var f = this.$(this.target + "-cX-DataFilter");
			var i = f && f.style.display == "block" ? true : false;
			var d = this.$(this.target + "-cX-DataTable");
			var a = this.dataTableLastState;
			var g = this.$(this.target + "-cX-DataExplorer");
			var e = g ? true : false;
			var b = this.appLayout;
			if (b) {
				this.clickLayout()
			} else {
				if (i) {
					this.hideDataFilter()
				}
				if (a) {
					this.hideTable()
				}
			}
			setTimeout(function() {
				j.rebuildDataTable();
				j.rebuildDataFilter()
			}, 500);
			return [b, i, a, e]
		}
	};
	this.switchAnnotationToSmp = function(e) {
		this.functionCaller = "switchAnnotationToSmp";
		var l = this.data;
		var c = this.meta.data;
		if (l.z.hasOwnProperty(e) && this.isNumeric(l.z[e])) {
			var k = this.rebuildDataTableFilter();
			if (!c.modified) {
				c.modified = {}
			}
			if (!c.modified.x) {
				c.modified.x = {}
			}
			if (!c.modified.x[e]) {
				c.modified.x[e] = {}
			}
			var b = this.groupingFactors;
			l.y.smps.push(e);
			for (var g = 0; g < l.y.vars.length; g++) {
				l.y.data[g].push(l.z[e][g])
			}
			delete(l.z[e]);
			var h = this.getKeys(l.z);
			if (h.length < 1) {
				delete(l.z)
			}
			this.updateMetaData("z", e, true);
			if (l.x) {
				var h = this.getKeys(l.x);
				for (var f = 0; f < h.length; f++) {
					l.x[h[f]].push(c.modified.x[e][h[f]] || "")
				}
			}
			this.updateData(l, true);
			if (b && b.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(b)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(k, true)
		}
	};
	this.switchSmpToAnnotation = function(l) {
		this.functionCaller = "switchSmpToAnnotation";
		var f = this.getSampleIndices(l);
		if (f >= 0) {
			var g = this.data;
			var c = this.meta.data;
			var a = this.rebuildDataTableFilter();
			if (!c.modified) {
				c.modified = {}
			}
			if (!c.modified.x) {
				c.modified.x = {}
			}
			if (!c.modified.x[l]) {
				c.modified.x[l] = {}
			}
			var h = this.groupingFactors;
			if (!g.z) {
				g.z = {}
			}
			g.y.smps.splice(f, 1);
			g.z[l] = [];
			for (var e = 0; e < g.y.vars.length; e++) {
				g.z[l].push(g.y.data[e].splice(f, 1))
			}
			if (g.x) {
				var k = this.getKeys(g.x);
				for (var e = 0; e < k.length; e++) {
					var b = g.x[k[e]].splice(f, 1);
					c.modified.x[l][k[e]] = b[0]
				}
			}
			this.updateMetaData("z");
			this.updateData(g, true);
			if (h && h.length > 0) {
				this.ungroupSamples(true);
				this.groupSamples(h)
			} else {
				this.draw()
			}
			this.removeMenus();
			this.rebuildDataTableFilter(a, true)
		}
	};
	this.switchNumericToString = function(f, e) {
		this.functionCaller = "switchNumericToString";
		var d = e ? "x" : "z";
		var b = e ? "smps" : "vars";
		if (f && this.data[d][f]) {
			var c = this.rebuildDataTableFilter();
			for (var a = 0; a < this.data.y[b].length; a++) {
				this.data[d][f][a] = this.data[d][f][a] + "\x00"
			}
			if (e) {
				this.updateMetaData("x", f)
			} else {
				this.updateMetaData("z", f)
			}
			this.rebuildDataTableFilter(c, true)
		}
		this.removeMenus();
		this.draw()
	};
	this.switchStringToNumeric = function(f, e) {
		this.functionCaller = "switchStringToNumeric";
		var d = e ? "x" : "z";
		var b = e ? "smps" : "vars";
		if (f && this.data[d][f]) {
			var c = this.rebuildDataTableFilter();
			for (var a = 0; a < this.data.y[b].length; a++) {
				this.data[d][f][a] = this.data[d][f][a].replace("\x00", "")
			}
			if (e) {
				this.updateMetaData("x", f)
			} else {
				this.updateMetaData("z", f)
			}
			this.rebuildDataTableFilter(c, true)
		}
		this.removeMenus();
		this.draw()
	};
	this.modifyTransform = function(a) {
		v = a.shift();
		t = a[0];
		if (t == "tceil") {
			t = "ceil";
			this.transformCeilValue = parseInt(v)
		} else {
			if (t = "tfloor") {
				t = "floor";
				this.transformFloorValue = parseInt(v)
			}
		}
		this.transform(t)
	};
	this.showSorting = function(e, m, l) {
		var g = this;
		var d = ["sortingSampleCategories", "sortingSamples"];
		var b = ["sortingVariableCategories", "sortingVariables"];
		var h = m == "smp" ? d : b;
		h = e == "cat" ? [h[0]] : [h[1]];
		var j = function(p, k) {
			var n = [];
			for (var o = 0; o < g[p].length; o++) {
				if (g[p][o] != k) {
					n.push(g[p][o])
				}
			}
			if (n.length > 0) {
				g[p] = n
			} else {
				g.removeMenus();
				alert("Data already sorted")
			}
		};
		var a = function(k, i) {
			if (g[k].length < 3) {
				g[k].push(l)
			} else {
				g.removeMenus();
				alert("Maximum of three sorting levels reached")
			}
		};
		for (var f = 0; f < h.length; f++) {
			if (!this[h[f]]) {
				this[h[f]] = []
			}
			var c = this.getObjectArray(this[h[f]]);
			if (c.hasOwnProperty(l)) {
				j(h[f], l)
			} else {
				a(h[f], l)
			}
		}
		if (m == "smp") {
			if (e == "cat") {
				this.sortSamplesByCategory(this.sortingSampleCategories)
			} else {
				if (e == "var") {
					this.sortSamplesByVariable(this.sortingVariables)
				}
			}
		} else {
			if (m == "var") {
				if (e == "cat") {
					this.sortVariablesByCategory(this.sortingVariableCategories)
				} else {
					if (e == "smp") {
						this.sortVariablesBySample(this.sortingSamples)
					}
				}
			}
		}
	};
	this.sortSamples = function(g, i, e, b, f, h) {
		this.functionCaller = "sortSamples";
		this.sortIndices("smps", g, i, false, e, b, f);
		this.setOriginalIndices(false, false, false, true);
		if (!h) {
			this.draw()
		}
	};
	this.sortSamplesByName = function(a) {
		this.sortSamples()
	};
	this.sortSamplesByCategory = function(b, a) {
		this.functionCaller = "sortSamplesByCategory";
		this.sortIndices("smps", false, b);
		this.setOriginalIndices(false, false, false, true);
		if (!a) {
			this.draw()
		}
	};
	this.sortSamplesByVariable = function(c, b, e) {
		this.functionCaller = "sortSamplesByVariable";
		var d = parseInt(this.getVariableIndices(c));
		this.sortIndices("smps", false, false, false, d + 1, b);
		this.setOriginalIndices(false, false, false, true);
		if (!e) {
			this.draw()
		}
	};
	this.sortVariables = function(g, i, e, b, f, h) {
		this.functionCaller = "sortVariables";
		this.sortIndices("vars", g, i, e, false, b, f, h);
		this.setOriginalIndices(false, false, false, true);
		if (!h) {
			this.draw()
		}
	};
	this.sortVariablesByName = function(a) {
		this.sortVariables()
	};
	this.sortVariablesByCategory = function(b, a) {
		this.functionCaller = "sortVariablesByCategory";
		this.sortIndices("vars", false, b);
		this.setOriginalIndices(false, false, false, true);
		if (!a) {
			this.draw()
		}
	};
	this.sortVariablesBySample = function(a, c) {
		this.functionCaller = "sortVariablesBySample";
		var b = parseInt(this.getSampleIndices(a));
		this.sortIndices("vars", false, false, b + 1);
		this.setOriginalIndices(false, false, false, true);
		if (!c) {
			this.draw()
		}
	};
	this.resetLegendPosition = function() {
		this.functionCaller = "resetLegendPosition";
		this.resetLegends(true);
		this.draw()
	};
	this.resetDendrograms = function() {
		delete(this.varDendrogram);
		delete(this.smpDendrogram)
	};
	this.filterOncoprint = function(e) {
		this.functionCaller = "filterOncoprint";
		var g = {};
		for (var d = 0; d < this.data.y.vars.length; d++) {
			for (var c = 0; c < this.data.y.smps.length; c++) {
				var b = this.getDataAtPos(d, c, false, this.xAxisTransform, this.minData, this.maxData);
				var a = this.getDataAtPos(d, c, false, this.xAxisTransform, this.minData, this.maxData, true);
				switch (e) {
					case "Amplification":
						if (b >= this.oncoprintAmplification) {
							g[d] = true
						}
						break;
					case "Deletion":
						if (b <= this.oncoprintDeletion) {
							g[d] = true
						}
						break;
					case "Mutation":
						if (a && ((isNaN(a) && !a.toString().match(/^no$|^-$|^neg$/i)) || a > 0)) {
							g[d] = true
						}
						break
				}
			}
		}
		var f = [];
		for (var d = 0; d < this.data.y.vars.length; d++) {
			if (g[d]) {
				f.push(d)
			}
		}
		this.varIndices = f;
		this.draw()
	};
	this.getGroupingFactors = function(a) {
		if (a) {
			return this.groupingFactors
		} else {
			return this.getObjectArray(this.groupingFactors)
		}
	};
	this.modifyGroupingFactors = function(b, a) {
		this.modifyObjectArray(b, a, "groupingFactors")
	};
	this.showVariableOverlays = function(c) {
		this.functionCaller = "showVariableOverlays";
		var a = {};
		if (this.graphType == "Heatmap" && this.data.z) {
			for (var b = 0; b < this.varOverlays.length; b++) {
				a[this.varOverlays[b]] = true
			}
			if (a[c]) {
				delete(a[c])
			} else {
				a[c] = true
			}
			this.varOverlays = this.getKeys(a);
			this.draw()
		}
	};
	this.showSampleOverlays = function(c) {
		this.functionCaller = "showSampleOverlays";
		var b = {};
		if (this.data.x) {
			for (var a = 0; a < this.smpOverlays.length; a++) {
				b[this.smpOverlays[a]] = true
			}
			if (b[c]) {
				delete(b[c])
			} else {
				b[c] = true
			}
			this.smpOverlays = this.getKeys(b);
			this.draw()
		}
	};
	this.showSampleGroups = function(c) {
		var b = {};
		if (this.data.x) {
			for (var a = 0; a < this.groupingFactors.length; a++) {
				b[this.groupingFactors[a]] = true
			}
			if (b[c]) {
				delete(b[c])
			} else {
				b[c] = true
			}
			this.groupSamples(this.getKeys(b))
		}
	};
	this.showSampleSegregation = function(d) {
		var a = {};
		var c = this.segregateSamplesBy;
		for (var b = 0; b < this.segregateSamplesBy.length; b++) {
			a[this.segregateSamplesBy[b]] = true
		}
		if (a[d]) {
			delete(a[d])
		} else {
			a[d] = true
		}
		this.segregateSamplesBy = this.getKeys(a);
		if (this.validateSegregation()) {
			a = this.segregateSamplesBy;
			this.segregateSamplesBy = [];
			this.segregateSamples(a, false, true)
		} else {
			this.segregateSamplesBy = c
		}
	};
	this.showVariableSegregation = function(d) {
		var a = {};
		var c = this.segregateVariablesBy;
		for (var b = 0; b < this.segregateVariablesBy.length; b++) {
			a[this.segregateVariablesBy[b]] = true
		}
		if (a[d]) {
			delete(a[d])
		} else {
			a[d] = true
		}
		this.segregateVariablesBy = this.getKeys(a);
		if (this.validateSegregation()) {
			a = this.segregateVariablesBy;
			this.segregateVariablesBy = [];
			this.segregateVariables(a, false, true)
		} else {
			this.segregateVariablesBy = c
		}
	};
	this.changeColorScheme = function() {
		this.functionCaller = "changeColorScheme";
		this.setColorScheme();
		this.resetMetaData();
		this.draw()
	};
	this.changeColorSpectrumZeroValue = function(a) {
		this.functionCaller = "changeColorSpectrumZeroValue";
		this.colorSpectrumZeroValue = parseFloat(a[0]);
		this.setColorBrew(true);
		this.resetMetaData();
		this.draw()
	};
	this.changeColorSpectrum = function(a) {
		this.functionCaller = "changeColorSpectrum";
		this.removeMenus();
		if (this.isInArray(a, this.colorSpectrum)) {
			if (this.colorSpectrum.length == 2) {
				alert("Ooops... Can't do... Need at least two colors!");
				return
			} else {
				this.colorSpectrum = this.removeFromArray(a, this.colorSpectrum)
			}
		} else {
			this.colorSpectrum.push(a)
		}
		this.setColorBrew(true);
		this.resetMetaData();
		this.draw()
	};
	this.modifyColorProperties = function(b, d, e, c) {
		this.functionCaller = "modifyColorProperties";
		var a = this.meta.data[e];
		if (!this.metadataColorProperties[d]) {
			this.metadataColorProperties[d] = {}
		}
		if (c == "Numeric") {
			if (!this.metadataColorProperties[d].spectrum) {
				this.metadataColorProperties[d].spectrum = []
			}
			if (this.isInArray(b, a[d].colorBrew.spectrum)) {
				if (a[d].colorBrew.spectrum.length == 2) {
					alert("Ooops... Can't do... Need at least two colors!");
					return
				} else {
					a[d].colorBrew.spectrum = this.removeFromArray(b, a[d].colorBrew.spectrum)
				}
			} else {
				a[d].colorBrew.spectrum.push(b)
			}
			b = a[d].colorBrew.spectrum
		}
		this.metadataColorProperties[d].spectrum = b;
		this.updateMetaData(e, d, false, true);
		this.draw()
	};
	this.toggleAttribute = function(a, d, b) {
		this.functionCaller = "toggleAttribute";
		this[a] = this[a] ? false : true;
		if (this.layoutValid && this.layoutRestore.hasOwnProperty(a)) {
			this.layoutRestore[a] = this[a]
		}
		if (d) {
			this[d](b)
		} else {
			this.draw()
		}
	};
	this.changeAttribute = function(b, a, h, j, g) {
		this.functionCaller = "changeAttribute";
		var f = {
			graphType: true
		};
		if (typeof(a) == "boolean" || this.hasOwnProperty(b)) {
			this[b] = this[b] && this[b] == a && !h ? false : this[b] && this[b] == a && h ? h : a
		} else {
			if (b && a) {
				this[b] = a
			}
		}
		if (this.layoutValid && b == "graphType") {
			for (var e = 0; e < this.data.l.type.length; e++) {
				this.data.l.type[e] = a
			}
		}
		if (this.layoutValid && this.layoutRestore.hasOwnProperty(b)) {
			this.layoutRestore[b] = this[b]
		}
		if (this.layoutValid || f.hasOwnProperty(b)) {
			this.removeMenus()
		}
		if (j) {
			this[j](g)
		} else {
			this.draw()
		}
	};
	this.changeTextColorAttribute = function(b, a) {
		this.updateTextColorAttribute(b, this.$(a).value)
	};
	this.updateTextColorAttribute = function(b, a) {
		this.functionCaller = "updateTextColorAttribute";
		var f = b[0];
		var e = b[1];
		var d = b[2];
		if (f) {
			if (CanvasXpress.doc.P[f].T == "integer") {
				this[f] = a != "" ? parseInt(a) : null
			} else {
				if (CanvasXpress.doc.P[f].T == "float") {
					this[f] = a != "" ? parseFloat(a) : null
				} else {
					this[f] = a
				}
			}
		} else {
			d.unshift(a)
		}
		if (this.layoutValid && this.layoutRestore.hasOwnProperty(f)) {
			this.layoutRestore[f] = this[f]
		}
		if (e) {
			this[e](d)
		} else {
			this.setColorBrew(true);
			this.resetMetaData();
			this.draw()
		}
	};
	this.changeVariableInAxis = function(b, d) {
		this.functionCaller = "changeVariableInAxis";
		if (this.data.a && this.data.a.xAxis && this.data.a.xAxis2) {
			var c = this.getObjectArray(this.data.a.xAxis);
			var a = this.getObjectArray(this.data.a.xAxis2);
			if (d == "xAxis") {
				if (a[b]) {
					if (this.data.a.xAxis2.length > 1) {
						this.removeVariablesFromAxis([b], "xAxis2")
					} else {
						alert("Cannot remove " + b + " from X-Axis 2");
						this.removeMenus();
						return
					}
					this.addVariablesToAxis([b], d)
				} else {
					if (c[b]) {
						if (this.data.a.xAxis.length > 1) {
							this.removeVariablesFromAxis([b], d)
						} else {
							alert("Cannot remove " + b + " from X-Axis");
							this.removeMenus();
							return
						}
					} else {
						this.addVariablesToAxis([b], d)
					}
				}
			} else {
				if (d == "xAxis2") {
					if (c[b]) {
						if (this.data.a.xAxis.length > 1) {
							this.removeVariablesFromAxis([b], "xAxis")
						} else {
							alert("Cannot remove " + b + " from X-Axis");
							this.removeMenus();
							return
						}
						this.addVariablesToAxis([b], d)
					} else {
						if (a[b]) {
							if (this.data.a.xAxis2.length > 1) {
								this.removeVariablesFromAxis([b], d)
							} else {
								alert("Cannot remove " + b + " from X-Axis 2");
								this.removeMenus();
								return
							}
						} else {
							this.addVariablesToAxis([b], d)
						}
					}
				}
			}
		}
		this.draw()
	};
	this.changeTransformRatio = function(a, b) {
		if (a == "sample") {
			if (this.ratioSampleReference == b) {
				this.ratioSampleReference = false;
				this.transform("reset")
			} else {
				this.ratioSampleReference = b;
				this.transform("ratio")
			}
		} else {
			if (a == "group") {
				if (this.ratioGroupReference == b) {
					this.ratioLevelReference = false;
					this.ratioGroupReference = false;
					this.transform("reset")
				} else {
					this.ratioGroupReference = b;
					this.ratioLevelReference = false;
					this.transform("ratio")
				}
				this.removeMenus()
			} else {
				if (a == "level") {
					this.transform("reset");
					if (this.ratioLevelReference == b) {
						this.ratioLevelReference = false
					} else {
						this.ratioLevelReference = b
					}
					this.transform("ratio")
				}
			}
		}
	};
	this.changeSampleInAxis = function(e, f, b) {
		this.functionCaller = "changeSampleInAxis";
		if (this.graphType.match(/Scatter/)) {
			var c, a, g, d;
			c = this.getObjectArray(this.xAxis);
			a = this.getObjectArray(this.yAxis);
			if (this.graphType == "ScatterBubble2D" || this.graphType == "Scatter3D") {
				g = this.getObjectArray(this.zAxis);
				d = true
			}
			if (f == "xAxis") {
				if (b) {
					this.switchSampleInAxis([e], f)
				} else {
					if (a[e] && !d) {
						if (this.yAxis.length > 1) {
							this.removeSamplesFromAxis([e], "yAxis")
						} else {
							alert("Cannot remove " + e + " from Y-Axis");
							this.removeMenus();
							return
						}
						this.addSamplesToAxis([e], f)
					} else {
						if (g && g[e] && !d) {
							if (this.zAxis.length > 1) {
								this.removeSamplesFromAxis([e], "zAxis")
							} else {
								alert("Cannot remove " + e + " from Z-Axis");
								this.removeMenus();
								return
							}
						} else {
							if (c[e] && !d) {
								if (this.xAxis.length > 1) {
									this.removeSamplesFromAxis([e], f)
								} else {
									alert("Cannot remove " + e + " from X-Axis");
									this.removeMenus();
									return
								}
							} else {
								if (d) {
									this[f] = [];
									this.addSamplesToAxis([e], f)
								} else {
									this.addSamplesToAxis([e], f)
								}
							}
						}
					}
				}
			} else {
				if (f == "yAxis") {
					if (b) {
						this.switchSampleInAxis([e], f)
					} else {
						if (c[e] && !d) {
							if (this.xAxis.length > 1) {
								this.removeSamplesFromAxis([e], "xAxis")
							} else {
								alert("Cannot remove " + e + " from X-Axis");
								this.removeMenus();
								return
							}
							this.addSamplesToAxis([e], f)
						} else {
							if (g && g[e] && !d) {
								if (this.zAxis.length > 1) {
									this.removeSamplesFromAxis([e], "zAxis")
								} else {
									alert("Cannot remove " + e + " from Z-Axis");
									this.removeMenus();
									return
								}
							} else {
								if (a[e] && !d) {
									if (this.yAxis.length > 1) {
										this.removeSamplesFromAxis([e], f)
									} else {
										alert("Cannot remove " + e + " from Y-Axis");
										this.removeMenus();
										return
									}
								} else {
									if (d) {
										this[f] = [];
										this.addSamplesToAxis([e], f)
									} else {
										this.addSamplesToAxis([e], f)
									}
								}
							}
						}
					}
				} else {
					if (f == "zAxis") {
						if (b) {
							this.switchSampleInAxis([e], f)
						} else {
							if (c[e] && !d) {
								if (this.xAxis.length > 1) {
									this.removeSamplesFromAxis([e], "xAxis")
								} else {
									alert("Cannot remove " + e + " from X-Axis");
									this.removeMenus();
									return
								}
								this.addSamplesToAxis([e], f)
							} else {
								if (a[e] && !d) {
									if (this.yAxis.length > 1) {
										this.removeSamplesFromAxis([e], "yAxis")
									} else {
										alert("Cannot remove " + e + " from Y-Axis");
										this.removeMenus();
										return
									}
								} else {
									if (g[e] && !d) {
										if (this.zAxis.length > 1) {
											this.removeSamplesFromAxis([e], f)
										} else {
											alert("Cannot remove " + e + " from Z-Axis");
											this.removeMenus();
											return
										}
									} else {
										if (d) {
											this[f] = [];
											this.addSamplesToAxis([e], f)
										} else {
											this.addSamplesToAxis([e], f)
										}
									}
								}
							}
						}
					}
				}
			}
			this.draw()
		}
	};
	this.showConfiguratorCategory = function(b, a) {
		this.removeMenus();
		this.addConfigurator(b);
		this.clickSearch(b);
		this.changeCategory(b, false, a);
		this.hideCategories()
	};
	this.setFontAttributeStyle = function(b, a) {
		this.functionCaller = "setFontAttributeStyle";
		var c = this[b];
		if (a == "bold") {
			if (this[b].match(a)) {
				this[b] = this[b].replace("bold", "")
			} else {
				if (c == "italic") {
					this[b] = "bold italic"
				} else {
					this[b] = "bold"
				}
			}
		} else {
			if (a == "italic") {
				if (this[b].match(a)) {
					this[b] = this[b].replace("italic", "")
				} else {
					if (c == "bold") {
						this[b] = "bold italic"
					} else {
						this[b] = "italic"
					}
				}
			} else {
				this[b] = this[b].replace("bold italic", "");
				this[b] = this[b].replace("bold", "");
				this[b] = this[b].replace("italic", "")
			}
		}
		this.draw()
	};
	this.setFontAttributeSize = function(b, a) {
		this.functionCaller = "setFontAttributeSize";
		if (a == "increase") {
			this[b] = this[b] * 1.1
		} else {
			this[b] = this[b] / 1.1
		}
		this.draw()
	};
	this.showHideDendrogram = function(a) {
		this.functionCaller = "showHideDendrogram";
		if (this[a]) {
			this[a] = false
		} else {
			this[a] = true
		}
		this.draw()
	};
	this.changeDendrogramPosition = function(a) {
		if (this[a] == "left") {
			this[a] = "right"
		} else {
			if (this[a] == "right") {
				this[a] = "left"
			} else {
				if (this[a] == "top") {
					this[a] = "bottom"
				} else {
					if (this[a] == "bottom") {
						this[a] = "top"
					}
				}
			}
		}
	};
	this.exploreData = function() {
		this.addDataExplorer();
		this.removeMenus()
	};
	this.segregateSamplesVariables = function(d) {
		this.functionCaller = "segregateSamplesVariables";
		var b = this.getSegregationObject("x");
		var a = this.getSegregationObject("z");
		var m = b.idx;
		var l = a.idx;
		var h = b.nme;
		var n = a.nme;
		if (this.isGroupedData) {
			this.groupingFactorsStdBy = this.groupingFactors;
			this.ungroupSamples(true, true)
		}
		delete(this.data.l);
		this.data.l = {};
		this.data.l.smps = m;
		this.data.l.vars = l;
		this.data.l.weight = [];
		this.data.l.type = [];
		this.data.l.name = [];
		this.data.l.desc = [];
		if (this.groupingFactorsStdBy) {
			this.data.l.group = this.groupingFactorsStdBy
		}
		var k = 1 / m.length;
		var f = 1 / l.length;
		var g = this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "";
		for (var e = 0; e < m.length; e++) {
			for (var c = 0; c < l.length; c++) {
				this.data.l.weight.push([f, k]);
				this.data.l.type.push(this.graphType);
				this.data.l.name.push([h[e], n[c]]);
				this.data.l.desc.push(g)
			}
		}
		this.layoutIndices = false;
		this.layoutComb = true;
		this.layout = m.length + "X" + l.length;
		this.isValidLayout();
		if (!d) {
			this.draw()
		}
	};
	this.getSegregationObject = function(j) {
		var g = {
			lay: {},
			idx: [],
			nme: [],
			n: 0
		};
		var f = j == "x" ? "smps" : "vars";
		var b = j == "x" ? this.segregateSamplesBy[0] : this.segregateVariablesBy[0];
		var h = 0;
		if (b == "variable") {
			j = "y";
			b = "vars"
		} else {
			if (b == "sample") {
				j = "y";
				b = "smps"
			}
		}
		for (var e = 0; e < this.data[j][b].length; e++) {
			var d = this.data[j][b][e];
			if (!g.lay.hasOwnProperty(d)) {
				g.lay[d] = [];
				g.n++
			}
			g.lay[d].push(this.data.y[f][e])
		}
		for (var d in g.lay) {
			g.nme.push(d);
			g.idx.push(g.lay[d])
		}
		return g
	};
	this.segregate = function(d, g, m, A) {
		this.functionCaller = "segregate";
		var H = "segregate" + d + "By";
		var f = "desegregate" + d;
		var b = d == "Samples" ? "segregateVariablesBy" : "segregateSamplesBy";
		var u = d == "Samples" ? "x" : "z";
		var K = this[H];
		if (A) {
			this.modifyObjectArray(g, false, H, true, false);
			if (this[H].length == 0) {
				this[f](m);
				return
			}
		} else {
			if (this[H].length == 0) {
				if (!this.isArray(g)) {
					g = [g]
				}
				this[H] = g;
				if (!this.validateSegregation()) {
					this[H] = K;
					return
				}
			}
		}
		if (this.isGroupedData) {
			this.groupingFactorsStdBy = this.groupingFactors;
			this.ungroupSamples(true, true)
		}
		this.resetLayout();
		if (this[H].length == 1) {
			var F = this.getSegregationObject(u);
			if (this[b].length > 0) {
				this.segregateSamplesVariables(m);
				m = true
			} else {
				this.data.l = {};
				if (d == "Samples") {
					this.data.l.smps = []
				} else {
					this.data.l.vars = []
				}
				this.data.l.weight = [];
				this.data.l.type = [];
				this.data.l.name = [];
				this.data.l.desc = [];
				if (this.groupingFactorsStdBy) {
					this.data.l.group = this.groupingFactorsStdBy
				}
				for (var w in F.lay) {
					if (d == "Samples") {
						this.data.l.smps.push(F.lay[w])
					} else {
						this.data.l.vars.push(F.lay[w])
					}
					this.data.l.type.push(this.graphType);
					this.data.l.name.push(w);
					this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "")
				}
				this.layoutIndices = false;
				this.layoutComb = this.graphType == "Circular" ? false : true;
				this.showAnimationTemp = this.showAnimation;
				this.showAnimation = false;
				var z = d == "Samples" ? this.data.l.smps.length : this.data.l.vars.length;
				var w = Math.ceil(Math.sqrt(z));
				var x = w * (w - 1) >= z ? w - 1 : w;
				var J = w;
				this.layout = x + "X" + J;
				for (var w in F.lay) {
					this.data.l.weight.push([1 / J, 1 / x])
				}
				this.isValidLayout()
			}
		} else {
			var B = {};
			var q = d == "Samples" ? this.getSampleLevelsByAnnotation(this.segregateSamplesBy[0]) : this.getVariableLevelsByAnnotation(this.segregateVariablesBy[0]);
			var I = d == "Samples" ? this.getSampleLevelsByAnnotation(this.segregateSamplesBy[1]) : this.getVariableLevelsByAnnotation(this.segregateVariablesBy[1]);
			var p = 1 / q.length;
			var a = 1 / I.length;
			var G = this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "";
			for (var E = 0; E < q.length; E++) {
				B[q[E]] = {};
				for (var D = 0; D < I.length; D++) {
					B[q[E]][I[D]] = [];
					if (d == "Samples") {
						for (var C = 0; C < this.data.y.smps.length; C++) {
							if (this.data[u][this[H][0]][C] == q[E] && this.data[u][this[H][1]][C] == I[D]) {
								B[q[E]][I[D]].push(this.data.y.smps[C])
							}
						}
					} else {
						for (var C = 0; C < this.data.y.vars.length; C++) {
							if (this.data[u][this[H][0]][C] == q[E] && this.data[u][this[H][1]][C] == I[D]) {
								B[q[E]][I[D]].push(this.data.y.vars[C])
							}
						}
					}
				}
			}
			var h = 0;
			for (var D = 0; D < I.length; D++) {
				var y = 0;
				for (var E = 0; E < q.length; E++) {
					if (B[q[E]][I[D]].length > 0) {
						y++
					}
				}
				h = Math.max(h, y)
			}
			var e = 0;
			for (var E = 0; E < q.length; E++) {
				var o = 0;
				for (var D = 0; D < I.length; D++) {
					if (B[q[E]][I[D]].length > 0) {
						o++
					}
				}
				e = Math.max(e, o)
			}
			if (this.layoutRemoveEmpty) {
				p = 1 / h;
				a = 1 / e
			}
			this.data.l = {};
			if (d == "Samples") {
				this.data.l.smps = []
			} else {
				this.data.l.vars = []
			}
			this.data.l.weight = [];
			this.data.l.type = [];
			this.data.l.name = [];
			this.data.l.desc = [];
			if (this.groupingFactorsStdBy) {
				this.data.l.group = this.groupingFactorsStdBy
			}
			for (var E = 0; E < q.length; E++) {
				for (var D = 0; D < I.length; D++) {
					if (this.layoutRemoveEmpty) {
						if (B[q[E]][I[D]].length < 1) {
							continue
						}
					}
					this.data.l.weight.push([a, p]);
					this.data.l.type.push(this.graphType);
					this.data.l.name.push([q[E], I[D]]);
					this.data.l.desc.push(G);
					if (d == "Samples") {
						this.data.l.smps.push(B[q[E]][I[D]])
					} else {
						this.data.l.vars.push(B[q[E]][I[D]])
					}
				}
			}
			this.layoutIndices = false;
			this.layoutComb = this.graphType == "Circular" ? false : true;
			this.showAnimationTemp = this.showAnimation;
			this.showAnimation = false;
			this.layout = this.layoutRemoveEmpty ? h + "X" + e : q.length + "X" + I.length;
			this.isValidLayout()
		}
		if (!m) {
			this.draw()
		}
	};
	this.desegregate = function(c, d) {
		this.functionCaller = "desegregate";
		this.showAnimation = this.showAnimationTemp;
		this.resetLayout();
		var b = c == "Samples" ? "segregateSamplesBy" : "segregateVariablesBy";
		var a = c == "Samples" ? "segregateSamples" : "segregateVariables";
		if (this[b].length > 0) {
			this[a](this[b], d)
		} else {
			this.isValidLayout()
		}
		if (this.groupingFactorsStdBy) {
			this.groupSamples(this.groupingFactorsStdBy, false, false, false, true);
			this.groupingFactorsStdBy = false
		}
		if (!d) {
			this.draw()
		}
	};
	this.desegregateSamples = function(a) {
		this.functionCaller = "desegregateSamples";
		this.desegregate("Samples", a);
		return;
		this.showAnimation = this.showAnimationTemp;
		this.resetLayout();
		if (this.segregateVariablesBy.length > 0) {
			this.segregateVariables(this.segregateVariablesBy, a)
		} else {
			this.isValidLayout()
		}
		if (this.groupingFactorsStdBy) {
			this.groupSamples(this.groupingFactorsStdBy, false, false, false, true);
			this.groupingFactorsStdBy = false
		}
		if (!a) {
			this.draw()
		}
	};
	this.segregateSamples = function(c, b, a) {
		this.segregate("Samples", c, b, a);
		return
	};
	this.desegregateVariables = function(a) {
		this.functionCaller = "desegregateVariables";
		this.desegregate("Variables", a);
		return;
		this.showAnimation = this.showAnimationTemp;
		this.resetLayout();
		if (this.segregateSamplesBy.length > 0) {
			this.segregateSamples(this.segregateSamplesBy, a)
		} else {
			this.isValidLayout()
		}
		if (this.groupingFactorsStdBy) {
			this.groupSamples(this.groupingFactorsStdBy, false, false, false, true);
			this.groupingFactorsStdBy = false
		}
		if (!a) {
			this.draw()
		}
	};
	this.segregateVariables = function(b, c, a) {
		this.segregate("Variables", b, c, a);
		return
	};
	this.changeLayoutType = function(a) {
		this.functionCaller = "changeLayoutType";
		this.removeMenus();
		this.unsetScatterPlotMatrix();
		this.scatterPlotMatrixType = a;
		this.scatterPlotMatrix = true;
		this.setScatterPlotMatrix();
		this.draw()
	};
	this.unsetScatterPlotMatrix = function() {
		if (this.graphType.match(/Scatter/)) {
			if (this.xAxisTemp && this.xAxisTemp.length > 0) {
				this.xAxis = this.xAxisTemp;
				this.xAxisTmp = []
			}
			if (this.yAxisTemp && this.yAxisTemp.length > 0) {
				this.yAxis = this.yAxisTemp;
				this.yAxisTmp = []
			}
			if (this.zAxisTemp && this.zAxisTemp.length > 0) {
				this.zAxis = this.zAxisTemp;
				this.zAxisTmp = []
			}
			if (!this.xAxis || !this.yAxis) {
				this.xAxis = [];
				this.yAxis = [];
				this.xAxisIndices = [];
				this.yAxisIndices = [];
				this.xAxis = [this.data.y.smps[0]];
				for (var a = 1; a < this.data.y.smps.length; a++) {
					this.yAxis.push(this.data.y.smps[a])
				}
				this.xAxisIndices = this.getSampleIndices(this.xAxis);
				this.yAxisIndices = this.getSampleIndices(this.yAxis);
				this.initAxes()
			}
			this.scatterPlotMatrix = false;
			if (this.showAnimationTemp) {
				this.showAnimation = this.showAnimationTemp
			}
			this.resetLayout();
			this.isValidLayout()
		}
	};
	this.setScatterPlotMatrix = function() {
		if (this.graphType.match(/Scatter/)) {
			var e, b, h, k, g;
			var a = this.scatterPlotMatrixType.match(/complete/) ? this.data.y.smps.length : this.data.y.smps.length - 1;
			var l = Math.ceil(Math.sqrt(a));
			this.data.l = {};
			this.data.l.smps = [];
			this.data.l.weight = [];
			this.data.l.type = [];
			this.data.l.desc = [];
			this.xAxisTemp = this.xAxisTemp || this.xAxis;
			this.xAxis = [];
			this.yAxisTemp = this.yAxisTemp || this.yAxis;
			this.yAxis = [];
			this.zAxisTemp = this.zAxisTemp || this.zAxis;
			this.zAxis = [];
			if (this.scatterPlotMatrixType.match(/complete/)) {
				k = a;
				h = a;
				e = 1 / h;
				b = 1 / k;
				for (var f = 0; f < a; f++) {
					for (var d = 0; d < a; d++) {
						this.data.l.weight.push([e, b]);
						this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "");
						this.data.l.type.push(this.graphType);
						if (f == d) {
							this.data.l.smps.push({})
						} else {
							if (this.scatterPlotMatrixType.match(/Upper/)) {
								if (d > f) {
									this.data.l.smps.push({
										xAxis: [this.data.y.smps[d]],
										yAxis: [this.data.y.smps[f]]
									})
								} else {
									this.data.l.smps.push({})
								}
							} else {
								if (this.scatterPlotMatrixType.match(/Lower/)) {
									if (f > d) {
										this.data.l.smps.push({
											xAxis: [this.data.y.smps[d]],
											yAxis: [this.data.y.smps[f]]
										})
									} else {
										this.data.l.smps.push({})
									}
								} else {
									this.data.l.smps.push({
										xAxis: [this.data.y.smps[d]],
										yAxis: [this.data.y.smps[f]]
									})
								}
							}
						}
					}
				}
			} else {
				k = l * (l - 1) >= a ? l - 1 : l;
				h = l;
				e = 1 / h;
				b = 1 / k;
				g = 1;
				for (var f = 0; f < k; f++) {
					for (var d = 0; d < h; d++) {
						this.data.l.weight.push([e, b]);
						this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "");
						this.data.l.type.push(this.graphType);
						if (this.data.y.smps[g]) {
							this.data.l.smps.push({
								xAxis: [this.data.y.smps[0]],
								yAxis: [this.data.y.smps[g]]
							})
						} else {
							this.data.l.smps.push({});
							break
						}
						g++
					}
				}
			}
			this.layout = k + "X" + h;
			this.layoutIndices = false;
			this.layoutComb = true;
			this.showAnimationTemp = this.showAnimation;
			this.showAnimation = false;
			this.isValidLayout()
		}
	};
	this.setMultiplePies = function() {
		if (this.graphType.match(/Pie/)) {
			var f, h;
			var g = this.xAxis.length;
			if (this.layout) {
				var b = this.layout.split(/X/i);
				f = parseInt(b[0]);
				h = parseInt(b[1]);
				if (f * h < g) {
					f = Math.ceil(Math.sqrt(g));
					h = Math.floor(Math.sqrt(g));
					this.layout = f + "X" + h
				}
			} else {
				f = Math.ceil(Math.sqrt(g));
				h = Math.floor(Math.sqrt(g));
				this.layout = f + "X" + h
			}
			var a = 1 / f;
			var e = 1 / h;
			delete(this.layoutParams);
			delete(this.data.l);
			this.data.l = {};
			this.data.l.smps = [];
			this.data.l.weight = [];
			this.data.l.type = [];
			this.data.l.desc = [];
			for (var d = 0; d < g; d++) {
				this.data.l.smps.push([this.xAxis[d]]);
				this.data.l.weight.push([e, a]);
				this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "");
				this.data.l.type.push(this.graphType)
			}
			this.layoutIndices = false;
			this.layoutComb = true;
			this.showAnimationTemp = this.showAnimation;
			this.showAnimation = false;
			this.isValidLayout()
		}
	};
	this.createContour = function() {
		this.functionCaller = "createContour";
		var l, A, r, G, f, q, F, m, s;
		if (this.graphType.match(/Scatter/)) {
			l = this.contourXBinSize || this.freedmanDiaconis(this.getDataForSmpGrpAtIndex(this.xAxisIndices[this.xAxisCurrent]));
			A = this.contourYBinSize || this.freedmanDiaconis(this.getDataForSmpGrpAtIndex(this.yAxisIndices[this.yAxisCurrent]));
			r = this.xAxisIndices[this.xAxisCurrent];
			G = this.yAxisIndices[this.yAxisCurrent];
			f = this.zAxisIndices && this.zAxisIndices.length > 0 ? this.zAxisIndices[this.zAxisCurrent] : false;
			q = Math.ceil(this.xAxisRange / l);
			F = Math.ceil(this.yAxisRange / A)
		} else {
			s = this.isGroupedData ? this.data.w : this.data.y;
			m = this.isGroupedData ? this.grpIndices : this.smpIndices;
			l = 1;
			A = 1;
			q = m.length;
			F = this.varIndices.length
		}
		var H = [];
		var a = [];
		var w = [];
		var b = [];
		for (var C = 0; C < q; C++) {
			w.push(C)
		}
		for (var C = 0; C < F; C++) {
			b.push(C)
		}
		if (this.graphType.match(/Scatter/)) {
			for (var C = 0; C < q; C++) {
				H[C] = [];
				for (var B = 0; B < F; B++) {
					H[C][B] = 0
				}
			}
			for (var C = 0; C < this.varIndices.length; C++) {
				var p = this.varIndices[C];
				var g = this.getDataAtPos(p, r) - this.xAxisMin;
				var u = this.getDataAtPos(p, G) - this.yAxisMin;
				var o = Math.min(Math.floor(g / l), q - 1);
				var n = Math.min(Math.floor(u / A), F - 1);
				var k = this.zAxisIndices && this.zAxisIndices.length > 0 ? this.getDataAtPos(p, f) : 1;
				H[o][n] += k
			}
			for (var C = 0; C < q; C++) {
				for (var B = 0; B < F; B++) {
					a.push(H[C][B])
				}
			}
		} else {
			this.setRangeData();
			for (var C = 0; C < m.length; C++) {
				H[C] = [];
				for (var B = 0; B < this.varIndices.length; B++) {
					H[C][B] = this.getDataAtPos(this.varIndices[B], m[C]) - this.minData;
					a.push(H[C][B])
				}
			}
		}
		var D = this.range(a);
		var d = this.contourZBin || this.freedmanDiaconis(a);
		var h = [];
		var e = Math.ceil(D[1] / d);
		for (var C = 0; C < e; C++) {
			h.push(C * d)
		}
		var E = new Conrec();
		if (this.graphType.match(/Scatter/)) {
			E.contour(H, 0, q - 1, 0, F - 1, w, b, h.length, h)
		} else {
			E.contour(this.transpose(H), 0, F - 1, 0, q - 1, b, w, h.length, h)
		}
		this.configStndBy = this.getConfig();
		this.data.y.contour = {};
		this.data.y.contour.list = E.contourList();
		if (this.graphType.match(/Scatter/)) {
			this.data.y.contour.xs = q - 1;
			this.data.y.contour.ys = F - 1;
			this.configStndBy.xAxisExact = this.xAxisExact;
			this.configStndBy.yAxisExact = this.yAxisExact;
			this.xAxisExact = true;
			this.yAxisExact = true
		} else {
			this.data.y.contour.xs = F - 1;
			this.data.y.contour.ys = q - 1;
			this.graphType = "Heatmap"
		}
		this.isContour = true;
		this.draw()
	};
	this.removeContour = function() {
		this.functionCaller = "removeContour";
		if (this.data.y.contour) {
			delete this.data.y.contour;
			this.switchData();
			this.isContour = false;
			this.draw()
		}
	};
	this.createDOE = function(d) {
		this.functionCaller = "createDOE";
		var b, f, m;
		var n = this.groupingFactors && this.groupingFactors.length > 0 ? this.groupingFactors : false;
		var j = this.plotByVariable;
		var k = this.initialGraphType || this.graphType;
		if (n) {
			this.ungroupSamples(true, false, true)
		}
		this.resetFilters();
		if (k.match(/Scatter/i)) {
			this.isDOE = 2;
			b = this.varIndices;
			dat = this.data.z
		} else {
			this.isDOE = 1;
			b = this.smpIndices;
			dat = this.data.x
		}
		m = this.getKeys(dat);
		if (this.includeDOE.length < 1) {
			for (var g = 0; g < m.length; g++) {
				if (g >= this.maxDOENumber) {
					break
				}
				this.includeDOE.push(m[g])
			}
		}
		var a = this.layout.split("X")[0];
		var h = this.layout.split("X")[1];
		if (this.includeDOE.length + (this.showDOEData ? 1 : 0) > (a * h)) {
			a = Math.ceil(Math.sqrt(this.includeDOE.length + (this.showDOEData ? 1 : 0)));
			h = a * (a - 1) >= (this.includeDOE.length + (this.showDOEData ? 1 : 0)) ? a - 1 : a;
			this.layout = a + "X" + h
		}
		delete(this.layoutParams);
		delete(this.data.l);
		this.data.l = {};
		if (this.showDOEData) {
			this.data.l.smps = [
				[b]
			];
			this.data.l.weight = [
				[1 / h, 1 / a]
			];
			this.data.l.type = [this.graphType];
			this.data.l.desc = [""];
			this.data.l.doe = b
		} else {
			this.data.l.smps = [];
			this.data.l.weight = [];
			this.data.l.type = [];
			this.data.l.desc = [];
			this.data.l.doe = b
		}
		for (var g = 0; g < this.includeDOE.length; g++) {
			this.data.l.smps.push([this.includeDOE[g]]);
			this.data.l.weight.push([1 / h, 1 / a]);
			this.data.l.desc.push("");
			if (this.isNumeric(dat[this.includeDOE[g]])) {
				this.data.l.type.push("Scatter2D")
			} else {
				var e = this.getUniqueKeys(dat[this.includeDOE[g]]);
				this.data.l.type.push(e.length < this.maxPieSectors ? "Pie" : "Treemap")
			}
		}
		this.layoutIndices = false;
		this.layoutComb = true;
		this.plotByVariable = false;
		this.isValidLayout();
		this.dataStndBy = this.data;
		this.configStndBy = this.getConfig();
		this.configStndBy.groupingFactors = n;
		this.configStndBy.plotByVariable = j;
		this.showAnimation = false;
		if (!this.initialGraphType) {
			this.initialGraphType = this.graphType
		}
		this.title = "";
		this.subtitle = "";
		if (!d) {
			this.removeMenus();
			this.draw()
		}
	};
	this.removeDOE = function(b) {
		this.functionCaller = "removeDOE";
		var a = this.configStndBy ? this.configStndBy.groupingFactors : false;
		this.graphType = this.initialGraphType;
		this.isDOE = false;
		this.isPie = false;
		this.isPieGroup = false;
		this.isHistogram = false;
		this.isCreateHistogram = false;
		this.layoutValid = false;
		this.removeMenus();
		this.switchData();
		delete(this.data.l);
		this.layoutComb = false;
		this.isValidLayout();
		if (a) {
			this.groupSamples(a, false, false, false, b)
		} else {
			if (!b) {
				this.draw()
			}
		}
	};
	this.resetDOE = function() {
		this.functionCaller = "resetDOE";
		var a = [];
		var b = this.isDOE > 1 ? this.dataStndBy.y.vars.length : this.dataStndBy.y.smps.length;
		for (var c = 0; c < b; c++) {
			a.push(c)
		}
		this.dataStndBy.l.doe = a;
		if (this.configStndBy.groupingFactors.length > 0) {
			this.layoutComb = false;
			this.groupSamples(this.configStndBy.groupingFactors, false, false, false, true);
			this.layoutComb = true
		}
		this.toDoFilter = {};
		this.draw()
	};
	this.modifyDOE = function(d) {
		this.functionCaller = "modifyDOE";
		var b = this.getObjectArray(this.includeDOE);
		if (b.hasOwnProperty(d)) {
			var a = [];
			for (var c = 0; c < this.includeDOE.length; c++) {
				if (this.includeDOE[c] != d) {
					a.push(this.includeDOE[c])
				}
			}
			this.includeDOE = a
		} else {
			this.includeDOE.push(d)
		}
		while (this.includeDOE.length > this.maxDOENumber + (this.showDOEData ? 1 : 0)) {
			this.includeDOE.shift()
		}
		this.createDOE(true);
		this.draw()
	};
	this.createTreemap = function(j) {
		this.functionCaller = "createTreemap";
		var b = this.groupingFactors && this.groupingFactors.length > 0 ? this.groupingFactors : false;
		var h = {
			data: {},
			vars: {}
		};
		var f = {
			y: {
				data: [
					[]
				],
				vars: [],
				smps: [],
				treemap: []
			}
		};
		if (b) {
			this.ungroupSamples(true)
		}
		var a, e;
		if (this.isDOE) {
			a = this.dataStndBy.l.doe;
			e = this.isDOE > 1 ? this.dataStndBy.z[j] : this.dataStndBy.x[j]
		} else {
			a = this.smpIndices;
			e = this.data.x[j]
		}
		for (var d = 0; d < a.length; d++) {
			var g = e[a[d]];
			if (!h.data[g]) {
				h.data[g] = 0;
				h.vars[g] = []
			}
			h.data[g]++;
			h.vars[g].push(a[d])
		}
		f.y.vars.push(j);
		for (var d in h.data) {
			f.y.smps.push(d);
			f.y.data[0].push(h.data[d]);
			f.y.treemap.push(h.vars[d])
		}
		if (this.isDOE) {
			this.graphType = "Treemap";
			this.initializeData(f)
		} else {
			this.dataStndBy = this.data;
			this.configStndBy = this.getConfig();
			this.configStndBy.isTreemap = false;
			this.data = {};
			this.graphType = "Treemap";
			this.isTreemap = true;
			this.isTreemapGroup = b;
			this.initializeData(f);
			this.removeMenus();
			this.draw()
		}
	};
	this.removeTreemap = function() {
		this.functionCaller = "removeTreemap";
		var a = this.isTreemapGroup;
		this.isTreemap = false;
		this.isTreemapGroup = false;
		this.removeMenus();
		this.switchData();
		if (a) {
			this.groupSamples(a)
		} else {
			this.draw()
		}
	};
	this.createPie = function(j) {
		this.functionCaller = "createPie";
		var d = this.groupingFactors && this.groupingFactors.length > 0 ? this.groupingFactors : false;
		var b = {
			data: {},
			smps: {}
		};
		var g = {
			y: {
				data: [],
				vars: [],
				smps: [],
				pie: []
			}
		};
		if (!CanvasXpress.cacheImagesReady) {
			setTimeout(function() {
				that.createPie(j)
			}, 200)
		} else {
			if (d) {
				this.ungroupSamples(true)
			}
			var a, f;
			if (this.isDOE) {
				a = this.dataStndBy.l.doe;
				f = this.isDOE > 1 ? this.dataStndBy.z[j] : this.dataStndBy.x[j]
			} else {
				a = this.smpIndices;
				f = this.data.x[j]
			}
			for (var e = 0; e < a.length; e++) {
				var h = f[a[e]];
				if (!b.data[h]) {
					b.data[h] = 0;
					b.smps[h] = []
				}
				b.data[h]++;
				b.smps[h].push(a[e])
			}
			g.y.smps.push(j);
			for (var e in b.data) {
				g.y.vars.push(e);
				g.y.data.push([b.data[e]]);
				g.y.pie.push(b.smps[e])
			}
			if (this.isDOE) {
				this.graphType = "Pie";
				this.initializeData(g)
			} else {
				this.dataStndBy = this.data;
				this.configStndBy = this.getConfig();
				this.configStndBy.isPie = false;
				this.data = {};
				this.graphType = "Pie";
				this.isPie = true;
				this.isPieGroup = d;
				this.initializeData(g);
				this.removeMenus();
				this.draw()
			}
		}
	};
	this.removePie = function() {
		this.functionCaller = "removePie";
		var a = this.isPieGroup;
		this.isPie = false;
		this.isPieGroup = false;
		this.removeMenus();
		this.switchData();
		if (a) {
			this.groupSamples(a)
		} else {
			this.draw()
		}
	};
	this.getViolin = function(i, c) {
		if (i && i.length > 0) {
			var h, g, f, a;
			var e = this.range(i);
			if (c) {
				h = c;
				g = this.pretty((e[1] - e[0]) / h);
				f = this.getHistogramBin(e[0], g);
				a = this.getHistogramBin(g + e[1], g)
			} else {
				g = this.freedmanDiaconis(i);
				f = this.getHistogramBin(e[0], g);
				a = this.getHistogramBin(g + e[1], g);
				h = (a - f) / g
			}
			return {
				len: i.length,
				size: g,
				kde: this.kde(this.histogramDensityKernel, false, [f, a], g, i)
			}
		} else {
			return false
		}
	};
	this.modifyHistogram = function() {
		if (this.isHistogram) {
			var d = this.isCreateHistogram[2];
			var a = this.isCreateHistogram[3];
			var b = this.histogramBins;
			var c = this.histogramStagger;
			this.removeHistogram();
			this.histogramBins = b;
			this.histogramStagger = c;
			if (d) {
				this.transpose()
			}
			this.createHistogram(d, a)
		}
	};
	this.createHistogramTr = function() {
		var a = this.groupingFactors;
		this.transpose();
		this.createHistogram(true, a)
	};
	this.createHistogram = function(c, d, h) {
		this.functionCaller = "createHistogram";
		var k = this;
		var b = [];
		var C = [];
		var f = [];
		var w = [];
		var E = [];
		var x, A, q, B, a, o, e, p, D, m, s, u;
		var F = {};
		var G = {};
		G.y = {};
		G.y.data = [];
		G.y.vars = [];
		G.y.smps = [];
		G.y.histogram = [];
		G.y.kde = [];
		G.y.stats = [];
		G.y.all = [];
		if (!CanvasXpress.cacheImagesReady || !this.getAxisIncrements) {
			setTimeout(function() {
				k.createHistogram(c, d)
			}, 200)
		} else {
			if (this.isDOE && h) {
				p = this.dataStndBy.l.doe;
				D = this.isDOE > 1 ? this.dataStndBy.z[h] : this.dataStndBy.x[h];
				for (var z = 0; z < p.length; z++) {
					var l = D[p[z]];
					if (l != null && l != "" && !isNaN(l)) {
						b.push(l)
					}
				}
			} else {
				for (var z = 0; z < this.smpIndices.length; z++) {
					for (var y = 0; y < this.varIndices.length; y++) {
						var l = this.data.y.data[this.varIndices[y]][this.smpIndices[z]];
						if (l != null && l != "" && !isNaN(l)) {
							b.push(l)
						}
					}
				}
			}
			o = this.range(b);
			if (this.histogramBins) {
				u = this.histogramBins;
				q = this.pretty(((o[1] * 10) - (o[0] * 10)) / (u * 10));
				x = this.getHistogramBin(o[0], q);
				A = this.getHistogramBin(q + o[1], q)
			} else {
				q = this.freedmanDiaconis(b);
				x = this.getHistogramBin(o[0], q);
				A = this.getHistogramBin(q + o[1], q);
				u = ((A * 10) - (x * 10)) / (q * 10)
			}
			e = this.isDOE && h ? 1 : this.smpIndices.length;
			for (var z = 0; z <= u; z++) {
				F[x + (q * z)] = z;
				G.y.vars.push("Bin" + (z + 1) + " (" + (((x * 10) + (q * z * 10)) / 10) + " - " + (((x * 10) + (q * (z + 1) * 10)) / 10) + ")");
				G.y.data[z] = [];
				G.y.data[z][0] = (q * (z + 1) * 10) / 10;
				G.y.histogram[z] = [];
				for (var y = 0; y < e; y++) {
					G.y.histogram[z][y] = []
				}
			}
			G.y.smps.push("Bin");
			C.push("Bin");
			if (this.isDOE && h) {
				G.y.smps.push(h);
				f.push(h);
				var g = [];
				for (var z = 0; z <= u; z++) {
					g[z] = 0
				}
				for (var z = 0; z < p.length; z++) {
					var l = D[p[z]];
					if (l != null && l != "" && !isNaN(l)) {
						var r = F[this.getHistogramBin(l, q)];
						g[r]++;
						G.y.histogram[r][0].push(z);
						G.y.all.push(z)
					}
				}
				w = [1];
				for (var y = 0; y < u; y++) {
					G.y.data[y][1] = g[y]
				}
				if (this.showHistogramDensity) {
					G.y.kde.push(this.kde(this.histogramDensityKernel, false, [x, A], q, b));
					G.y.stats.push([b.length, q])
				}
			} else {
				for (var z = 0; z < this.smpIndices.length; z++) {
					s = 0;
					b = [];
					G.y.smps.push(this.data.y.smps[this.smpIndices[z]]);
					f.push(this.data.y.smps[this.smpIndices[z]]);
					var g = [];
					for (var y = 0; y <= u; y++) {
						g[y] = 0
					}
					for (var y = 0; y < this.varIndices.length; y++) {
						var l = this.data.y.data[this.varIndices[y]][this.smpIndices[z]];
						if (l != null && l != "" && !isNaN(l)) {
							var r = Math.min(Math.floor((l - x) / q), u - 1);
							b.push(parseFloat(this.data.y.data[this.varIndices[y]][this.smpIndices[z]]));
							if (!isNaN(r)) {
								g[r]++;
								G.y.histogram[r][z].push(this.varIndices[y]);
								G.y.all.push(this.varIndices[y])
							}
							s++
						}
					}
					w.push(s);
					for (var y = 0; y <= u; y++) {
						G.y.data[y][z + 1] = g[y]
					}
					if (this.showHistogramDensity) {
						G.y.kde.push(this.kde(this.histogramDensityKernel, false, [x, A], q, b));
						G.y.stats.push([b.length, q])
					}
				}
			}
			for (var z = 0; z < w.length; z++) {
				E.push(z)
			}
			E.sort(function(j, i) {
				return w[i] - w[j]
			});
			if (!this.isDOE) {
				this.dataStndBy = this.data;
				this.configStndBy = this.getConfig();
				this.configStndBy.isCreateHistogram = false;
				this.configStndBy.isHistogram = false
			}
			this.data = {};
			this.graphType = "Scatter2D";
			this.isHistogram = true;
			this.isCreateHistogram = [x, q, c, d, E];
			this.xAxis = C;
			this.yAxis = f;
			this.setMinX = null;
			this.setMaxX = null;
			this.setMinX2 = null;
			this.setMaxX2 = null;
			this.setMinY = null;
			this.setMaxY = null;
			this.setMinZ = null;
			this.setMaxZ = null;
			this.xAxisExact = true;
			this.initializeData(G);
			if (!this.isDOE) {
				this.removeMenus();
				this.draw()
			}
		}
	};
	this.removeHistogram = function() {
		this.functionCaller = "removeHistogram";
		var d = this.isCreateHistogram[2];
		var b = this.isCreateHistogram[3];
		var c = this.histogramDensityKernel;
		var a = this.showHistogramDensity;
		this.removeMenus();
		this.switchData();
		this.histogramDensityKernel = c;
		this.showHistogramDensity = a;
		if (d) {
			this.transpose()
		}
		if (b) {
			this.groupSamples(b)
		} else {
			this.draw()
		}
	};
	this.correlateData = function(d, c) {
		this.functionCaller = "correlateData";
		if (this.graphType.match(/Scatter/i)) {
			this.addRegressionLine()
		} else {
			this.dataStndBy = this.data;
			this.configStndBy = this.getConfig();
			var b = this.groupingFactors;
			if (c) {
				if (d) {
					this.switchAnnotationToVar(c)
				} else {
					this.switchAnnotationToSmp(c)
				}
			}
			var a = d ? this.data.y.vars : this.data.y.smps;
			this.graphType = "Scatter2D";
			this.type2D = "XY";
			if (b) {
				this.ungroupSamples(true)
			}
			if (d) {
				this.transpose(false, true)
			}
			this.xAxis = [a[0]];
			this.xAxisTitle = a[0];
			this.xAxisIndices = [0];
			this.yAxis = [a[1]];
			this.yAxisTitle = a[1];
			this.yAxisIndices = [1];
			this.showAnimation = false;
			this.addRegressionLine(false, true);
			this.isCorrelate = true;
			this.isCorrelateTranspose = d;
			this.isCorrelateGroup = b;
			this.isCorrelateKey = c;
			this.draw(false, false, false, false, true)
		}
		this.removeMenus()
	};
	this.removeCorrelation = function() {
		this.functionCaller = "removeCorrelation";
		this.removeMenus();
		if (this.isCorrelate) {
			if (this.data.d && this.data.d.reg) {
				delete(this.data.d.reg)
			}
			if (this.data.l && this.data.l.reg) {
				delete(this.data.l.reg)
			}
			this.switchData();
			if (this.isCorrelateTranspose) {
				this.transpose()
			}
			if (this.isCorrelateKey) {
				if (this.isCorrelateTranspose) {
					this.switchVarToAnnotation(this.isCorrelateKey)
				} else {
					this.switchSmpToAnnotation(this.isCorrelateKey)
				}
			}
			if (this.isCorrelateGroup) {
				this.groupSamples(this.isCorrelateGroup)
			} else {
				this.draw()
			}
			this.isCorrelate = false;
			this.isCorrelateTranspose = false;
			this.isCorrelateGroup = false;
			this.isCorrelateKey = false
		} else {
			if (this.data.d && this.data.d.reg) {
				delete(this.data.d.reg)
			}
			if (this.data.l && this.data.l.reg) {
				delete(this.data.l.reg)
			}
			this.draw()
		}
	};
	this.updateCorrelation = function() {
		if (this.data.d && this.data.d.reg) {
			delete(this.data.d.reg)
		}
		this.addRegressionLine(false, true)
	};
	this.addRegressionLine = function(e, c) {
		this.functionCaller = "addRegressionLine";
		var j = this;
		var m, d, l, k, a, h, b, g;
		if (!CanvasXpress.cacheImagesReady) {
			setTimeout(function() {
				j.addRegressionLine(e, c)
			}, 100)
		} else {
			if (this.graphType.match(/Scatter/)) {
				if (this.isDOE) {} else {
					if (this.scatterPlotMatrix) {
						this.data.l.reg = [];
						for (var f = 0; f < this.data.l.smps.length; f++) {
							g = this.data.l.smps[f];
							if (g.xAxis && g.yAxis) {
								m = this.getSampleIndices(g.xAxis[0]);
								d = this.getSampleIndices(g.yAxis[0]);
								h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
								l = this.getDataForSmpGrpAtIndex(m);
								k = this.getDataForSmpGrpAtIndex(d);
								a = this.regression(l, k);
								this.data.l.reg[f] = {
									reg: a,
									lab: h,
									col: e ? e : this.colors[0]
								}
							} else {
								this.data.l.reg[f] = false
							}
						}
					} else {
						if (this.type2D == "XYZ") {
							m = this.xAxisIndices[this.xAxisCurrent];
							d = this.yAxisIndices[this.yAxisCurrent];
							h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
							l = this.getDataForSmpGrpAtIndex(m);
							k = this.getDataForSmpGrpAtIndex(d);
							a = this.regression(l, k);
							this.addRegressionDecoration(a, h, this.foreground)
						} else {
							if (this.type2D == "XY") {
								for (var f = 0; f < this.xAxisIndices.length; f++) {
									b = e ? e : this.colors[f % this.colors.length];
									m = this.xAxisIndices[f];
									d = this.yAxisIndices[f];
									h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
									l = this.getDataForSmpGrpAtIndex(m);
									k = this.getDataForSmpGrpAtIndex(d);
									a = this.regression(l, k);
									this.addRegressionDecoration(a, h, b)
								}
							} else {
								if (this.type2D == "X") {
									d = this.yAxisIndices[this.yAxisCurrent];
									k = this.getDataForSmpGrpAtIndex(d);
									for (var f = 0; f < this.xAxisIndices.length; f++) {
										b = e ? e : this.colors[f % this.colors.length];
										m = this.xAxisIndices[f];
										h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
										l = this.getDataForSmpGrpAtIndex(m);
										a = this.regression(l, k);
										this.addRegressionDecoration(a, h, b)
									}
								} else {
									m = this.xAxisIndices[this.xAxisCurrent];
									l = this.getDataForSmpGrpAtIndex(m);
									for (var f = 0; f < this.yAxisIndices.length; f++) {
										b = e ? e : this.colors[f % this.colors.length];
										d = this.yAxisIndices[f];
										k = this.getDataForSmpGrpAtIndex(d);
										h = this.data.y.smps[m] + " vs " + this.data.y.smps[d];
										a = this.regression(l, k);
										this.addRegressionDecoration(a, h, b)
									}
								}
							}
						}
					}
				}
				if (!c) {
					this.draw()
				}
			}
		}
	};
	this.addRegressionDecoration = function(c, b, a) {
		this.showDecorations = true;
		if (!this.data.d) {
			this.data.d = {}
		}
		if (!this.data.d.reg) {
			this.data.d.reg = []
		}
		this.data.d.reg.push({
			slope: c[0],
			intercept: c[1],
			cor: c[2],
			ci: c[3],
			label: b,
			color: a
		})
	};
	this.addNormalDistributionLine = function(c, b) {
		this.functionCaller = "addNormalDistributionLine";
		var k = this;
		var p, g, n, h, j, l, m, f, d, f, a, o;
		if (!CanvasXpress.cacheImagesReady) {
			setTimeout(function() {
				k.addNormalDistributionLine(c)
			}, 100)
		} else {
			if (this.graphType.match(/Scatter/)) {
				if (this.type2D == "XYZ") {
					n = c == "y" ? this.yAxisIndices[this.yAxisCurrent] : this.xAxisIndices[this.xAxisCurrent];
					h = c == "y" ? this.xAxisIndices[this.xAxisCurrent] : this.yAxisIndices[this.yAxisCurrent];
					j = this.getDataForSmpGrpAtIndex(n);
					l = this.getDataForSmpGrpAtIndex(h);
					m = this.max(l);
					f = this.data.y.smps[n];
					d = this.meanStandardDeviationN(j);
					this.addNormalDistributionDecoration(d, m, f, this.foreground, c)
				} else {
					p = c == "y" ? this.yAxisIndices : this.xAxisIndices;
					g = c == "y" ? this.xAxisIndices : this.yAxisIndices;
					o = c == "y" ? this.xAxisCurrent : this.yAxisCurrent;
					for (var e = 0; e < p.length; e++) {
						a = e % this.colors.length;
						n = p[e];
						h = g[e] ? g[e] : g[o];
						j = this.getDataForSmpGrpAtIndex(n);
						l = this.getDataForSmpGrpAtIndex(h);
						m = this.max(l);
						f = this.data.y.smps[n];
						d = this.meanStandardDeviationN(j);
						this.addNormalDistributionDecoration(d, m, f, this.colors[a], c)
					}
				}
				if (!b) {
					this.draw()
				}
			}
		}
	};
	this.addNormalDistributionDecoration = function(e, a, c, b, d) {
		this.showDecorations = true;
		if (!this.data.d) {
			this.data.d = {}
		}
		if (!this.data.d.nor) {
			this.data.d.nor = []
		}
		if (d && d == "y") {
			this.data.d.nor.push({
				mu: e[0],
				sigma: e[1],
				yAxis: true,
				max: a,
				label: c,
				color: b
			})
		} else {
			this.data.d.nor.push({
				mu: e[0],
				sigma: e[1],
				max: a,
				label: c,
				color: b
			})
		}
	};
	this.addKaplanMeierCurve = function(f, B, g, A, w) {
		this.functionCaller = "addKaplanMeierCurve";
		var b = false;
		var F = {
			d: {},
			c: {}
		};
		var a = {};
		var h = 1.95996;
		var k = h * h;
		var s, r, x, D, m, y;
		if (f && B) {
			var e = this.getSampleIndices(f);
			var j = this.getSampleIndices(B);
			if (e != null && j != null) {
				for (var C = 0; C < this.varIndices.length; C++) {
					var o = this.data.y.data[C][e];
					var E = this.data.y.data[C][j];
					if (!isNaN(E)) {
						if (!isNaN(E) && E == 0) {
							F.d[o] = F.d[o] ? F.d[o] + 1 : 1;
							a[o] = true
						} else {
							F.c[o] = F.c[o] ? F.c[o] + 1 : 1;
							a[o] = true
						}
					}
				}
				a = this.getKeys(a);
				a.sort(function(d, c) {
					return d - c
				});
				b = {
					times: a,
					data: []
				};
				for (var C = 0; C < a.length; C++) {
					b.data.push([F.c[a[C]] || 0, F.d[a[C]] || 0])
				}
				b.data[0].push(this.varIndices.length);
				for (var C = 1; C < a.length; C++) {
					b.data[C].push(b.data[C - 1][2] - (b.data[C - 1][0] + b.data[C - 1][1]))
				}
				s = 1;
				for (var C = 0; C < a.length; C++) {
					s = s * (1 - (b.data[C][1] / b.data[C][2]));
					r = 1 - s;
					x = (2 * s * this.varIndices.length) + k + 1 + (h * Math.sqrt(k + 2 - (1 / this.varIndices.length) + 4 * s * ((r * this.varIndices.length) - 1)));
					D = 2 * (this.varIndices.length + k);
					m = x / D;
					if (s == 1) {
						m = 1
					}
					x = (2 * s * this.varIndices.length) + k - 1 - (h * Math.sqrt(k - 2 - (1 / this.varIndices.length) + 4 * s * ((r * this.varIndices.length) + 1)));
					y = x / D;
					if (s == 0) {
						y = 0
					}
					b.data[C].push(s, m, y)
				}
				this.addKaplanMeierDecoration(f, b, g, A)
			}
		}
		if (!w) {
			this.draw()
		}
	};
	this.addKaplanMeierDecoration = function(d, c, b, a) {
		this.showDecorations = true;
		if (!this.data.d) {
			this.data.d = {}
		}
		if (!this.data.d.kaplanMeier) {
			this.data.d.kaplanMeier = []
		}
		this.data.d.kaplanMeier.push({
			time: d,
			data: c,
			label: b || "Kaplan - Meyer " + (this.data.d.kaplanMeier.length + 1),
			color: a || this.colors[this.data.d.kaplanMeier.length % this.colors.length]
		})
	};
	this.addLineDecoration = function(d, e, b, a) {
		if (!this.graphType.match(/Scatter|Network|Genome|Correlation|Venn|Circular/)) {
			if (!this.data.d) {
				this.data.d = {}
			}
			if (!this.data.d.lines) {
				this.data.d.lines = []
			}
			if (d && d == "solid") {
				d = "line"
			}
			this.data.d.lines.push({
				type: d || "line",
				color: e || this.foreground,
				value: b || 0,
				label: a || false
			})
		}
	};
	this.createRandomData = function(f) {
		var h = {};
		if (this.graphType == "Network") {
			h = this.createRandomNetwork();
			if (f) {
				return h
			}
			this.calculateLayout = true;
			this.layoutDone = false
		} else {
			if (this.graphType == "Venn" || this.graphType == "Genome" || this.graphType == "Candlestick") {
				h = this.dataSetExample
			} else {
				h.y = {};
				h.y.data = [];
				h.y.vars = [];
				h.y.smps = [];
				for (var k = 0; k < this.randomDataSamples; k++) {
					if (this.isGraphTime) {
						h.y.smps[k] = new Date(this.meta.start + (k * this.times.day))
					} else {
						h.y.smps[k] = "Sample" + (k + 1)
					}
				}
				var m = this.rnorm(this.randomDataVariables * this.randomDataSamples, this.randomDataMean, this.randomDataSigma);
				var d = 0;
				for (var k = 0; k < this.randomDataVariables; k++) {
					h.y.data[k] = [];
					h.y.vars[k] = "Variable" + (k + 1);
					for (var g = 0; g < this.randomDataSamples; g++) {
						if (this.randomDataUniform) {
							h.y.data[k].push(100)
						} else {
							if (this.randomDataSymmetrical) {
								h.y.data[k].push((k * 10) + ((g + 1) * 5))
							} else {
								h.y.data[k][g] = m[d];
								d++
							}
						}
					}
				}
				h.x = {};
				var b = Math.floor(this.randomDataSamples / this.randomDataSampleAnnotationRatio);
				for (var k = 0; k < this.randomDataSampleAnnotations; k++) {
					var o = this.rnorm(this.randomDataSamples, this.randomDataMean, this.randomDataSigma);
					h.x["Factor" + (k + 1)] = [];
					h.x["SCovar" + (k + 1)] = [];
					for (var g = 0; g < this.randomDataSamples; g++) {
						if (this.randomDataSymmetrical) {
							h.x["Factor" + (k + 1)][g] = "Lev:" + (Math.floor(k / (g + 1)) + 1);
							h.x["SCovar" + (k + 1)][g] = Math.floor(k / (g + 1)) + 1
						} else {
							var e = Math.floor(this.random() * b);
							h.x["Factor" + (k + 1)][g] = "Lev:" + (e + 1);
							h.x["SCovar" + (k + 1)][g] = o[g]
						}
					}
				}
				h.z = {};
				var b = Math.min(10, Math.floor(this.randomDataVariables / this.randomDataVariableAnnotationRatio));
				for (var k = 0; k < this.randomDataVariableAnnotations; k++) {
					var o = this.rnorm(this.randomDataVariables, this.randomDataMean, this.randomDataSigma);
					h.z["Annt" + (k + 1)] = [];
					h.z["VCov" + (k + 1)] = [];
					for (var g = 0; g < this.randomDataVariables; g++) {
						if (this.randomDataSymmetrical) {
							h.z["Annt" + (k + 1)][g] = "Desc:" + (Math.floor(k / (g + 1)) + 1);
							h.z["VCov" + (k + 1)][g] = Math.floor(k / (g + 1)) + 1
						} else {
							var e = Math.floor(this.random() * b);
							h.z["Annt" + (k + 1)][g] = "Desc:" + (e + 1);
							h.z["VCov" + (k + 1)][g] = o[g]
						}
					}
				}
				h.a = {
					xAxis: [],
					xAxis2: []
				};
				for (var k = 0; k < Math.floor(this.randomDataVariables / 2); k++) {
					h.a.xAxis.push("Variable" + (k + 1))
				}
				for (var k = Math.floor(this.randomDataVariables / 2); k < this.randomDataVariables; k++) {
					h.a.xAxis2.push("Variable" + (k + 1))
				}
				if (this.randomMissingDataPercentage > 0 && this.randomMissingDataPercentage < 1) {
					var c = 0;
					var a = this.randomDataVariables * this.randomDataSamples * this.randomMissingDataPercentage;
					while (c < a) {
						var k = Math.floor(this.random() * this.randomDataVariables);
						var g = Math.floor(this.random() * this.randomDataSamples);
						if (h.y.data[k][g]) {
							delete(h.y.data[k][g]);
							c++
						}
					}
				}
			}
		}
		if (f) {
			return h
		}
		this.randomData = true;
		if (this.data && !this.dataStndBy) {
			this.dataStndBy = this.data;
			this.configStndBy = this.getConfig();
			this.data = {}
		}
		this.resetConfig(["graphType", "imageDir"]);
		this.updateData(h, true)
	};
	this.restoreRandomData = function() {
		this.switchData(true)
	};
	this.binDataByPercentile = function(g, f) {
		var d = this.range(this.data.y.data[g]);
		if (!this.data.x) {
			this.data.x = {}
		}
		var a = this.data.y.vars[g] + " Percentile" + (f ? "" : " Category");
		this.data.x[a] = [];
		for (var c = 0; c < this.data.y.data[g].length; c++) {
			var b = this.data.y.data[g][c];
			if (!isNaN(b) && b != "" && b != null) {
				var e = this.parseInt(this.percentile(d[0], d[1], b) / 10);
				if (e == 10) {
					e--
				}
				this.data.x[a][c] = f ? e + 1 : (e * 10) + "-" + ((e + 1) * 10) + "%"
			} else {
				this.data.x[a][c] = ""
			}
		}
		if (this.isGroupedData) {
			this.ungroupSamples(true)
		}
		this.updateData(this.data);
		this.groupSamples([a]);
		this.sortSamplesByCategory([a]);
		this.removeMenus()
	};
	this.binDataByQuantile = function(g, f) {
		var c = this.quants(this.data.y.data[g]);
		if (!this.data.x) {
			this.data.x = {}
		}
		var a = this.data.y.vars[g] + " Quantile" + (f ? "" : " Category");
		this.data.x[a] = [];
		for (var d = 0; d < this.data.y.data[g].length; d++) {
			var b = this.data.y.data[g][d];
			if (!isNaN(b) && b != "" && b != null) {
				var e = this.quantile(c, b);
				if (f) {
					this.data.x[a][d] = e + 1
				} else {
					if (e == 0) {
						this.data.x[a][d] = "1st Quantile"
					} else {
						if (e == 1) {
							this.data.x[a][d] = "2nd Quantile"
						} else {
							if (e == 2) {
								this.data.x[a][d] = "3rd Quantile"
							} else {
								this.data.x[a][d] = "4th Quantile"
							}
						}
					}
				}
			} else {
				this.data.x[a][d] = ""
			}
		}
		if (this.isGroupedData) {
			this.ungroupSamples(true)
		}
		this.updateData(this.data);
		this.groupSamples([a]);
		this.sortSamplesByCategory([a]);
		this.removeMenus()
	};
	this.binDataCustom = function(a, b) {
		this.addBinConfigurator(a, b);
		this.removeMenus()
	};
	this.setMarketTechnicalData = function() {
		if (this.stockIndicators.length > 0) {
			var b = {};
			var g = false;
			var h = {
				Sma5: 5,
				Sma10: 10,
				Sma20: 20,
				Sma25: 25,
				Sma50: 50
			};
			var a = [];
			for (var f = 0; f < this.stockIndicators.length; f++) {
				if (h.hasOwnProperty(this.stockIndicators[f])) {
					a.push(this.stockIndicators[f])
				}
			}
			if (a.length > 0) {
				this.stockIndicators = a;
				var l = {};
				for (var f = 0; f < this.stockIndicators.length; f++) {
					var m = this.stockIndicators[f];
					if (h.hasOwnProperty(m) && !this.data.y.hasOwnProperty(m)) {
						b[m] = true;
						g = true;
						l[m] = [];
						this.data.y[m] = [];
						for (var d = 0; d < this.data.y.vars.length; d++) {
							l[m][d] = [];
							this.data.y[m][d] = []
						}
					}
				}
				if (g) {
					for (var f = 0; f < this.data.y.smps.length; f++) {
						for (var d = 0; d < this.data.y.vars.length; d++) {
							for (var c = 0; c < this.stockIndicators.length; c++) {
								var m = this.stockIndicators[c];
								if (b.hasOwnProperty(m)) {
									if (!isNaN(this.data.y.close[d][f])) {
										l[m][d].push(this.data.y.close[d][f]);
										if (l[m][d].length == h[m]) {
											if (m.match(/Sma/)) {
												this.data.y[m][d][f] = this.mean(l[m][d]);
												l[m][d].shift()
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	};
	this.switchToMarketData = function() {
		var a = this.data.market;
		this.dataStndBy = this.data;
		this.configStndBy = this.getConfig();
		this.data = {};
		this.data.y = a;
		this.initializeDataAttributes();
		if (this.showVolume) {
			this.data.l = {};
			this.data.l.vars = [this.data.y.vars, this.data.y.vars];
			this.data.l.weight = this.graphOrientation == "vertical" ? [
				[1, 0.75],
				[1, 0.25]
			] : [
				[1, 0.25],
				[1, 0.75]
			];
			this.data.l.type = ["Candlestick", "Candlestick"];
			this.data.l.name = this.graphOrientation == "vertical" ? ["Price", "Volume"] : ["Volume", "Price"];
			this.data.l.desc = this.graphOrientation == "vertical" ? ["Price", "Volume"] : ["Volume", "Price"];
			this.segregateSamplesBy = [];
			this.segregateVariablesBy = [];
			this.layoutComb = true;
			this.layout = this.graphOrientation == "vertical" ? "2X1" : "1X2";
			this.isValidLayout()
		}
	};
	this.switchFromMarketData = function() {
		this.switchData(true);
		if (this.showVolume) {
			this.resetLayout();
			this.isValidLayout()
		}
	};
	this.switchData = function(a) {
		if (this.dataStndBy && this.configStndBy) {
			this.data = this.dataStndBy;
			this.resetConfig();
			this.updateConfig(this.configStndBy);
			this.updateData(this.data, a)
		}
	};
	this.updateData = function(a, b) {
		delete(this.data.initialVarIndices);
		delete(this.data.initialSmpIndices);
		delete(this.meta.data);
		this.initializeData(a);
		this.initializeGraph(b)
	}
};
CanvasXpress.prototype.FunctionData = function(a) {
	this.add = function(c, b) {
		return new Number(b) + new Number(c)
	};
	this.sub = function(c, b) {
		return b - c
	};
	this.mul = function(c, b) {
		return b * c
	};
	this.div = function(c, b) {
		return b / c
	};
	this.sin = function(b) {
		return Math.sin(b)
	};
	this.cos = function(b) {
		return Math.cos(b)
	};
	this.tan = function(b) {
		return Math.tan(b)
	};
	this.sec = function(b) {
		return 1 / Math.cos(b)
	};
	this.csc = function(b) {
		return 1 / Math.sin(b)
	};
	this.cot = function(b) {
		return 1 / Math.tan(b)
	};
	this.asin = function(b) {
		return Math.asin(b)
	};
	this.acos = function(b) {
		return Math.acos(b)
	};
	this.atan = function(b) {
		return Math.atan(b)
	};
	this.asec = function(b) {
		return Math.acos(1 / b)
	};
	this.acsc = function(b) {
		return Math.asin(1 / b)
	};
	this.acot = function(b) {
		return Math.atan(1 / b)
	};
	this.sinh = function(b) {
		return (Math.exp(b) - Math.exp(-b)) * 0.5
	};
	this.cosh = function(b) {
		return (Math.exp(b) + Math.exp(-b)) * 0.5
	};
	this.tanh = function(b) {
		return (Math.exp(b) - Math.exp(-b)) / (Math.exp(b) + Math.exp(-b))
	};
	this.sech = function(b) {
		return 1 / cosh(b)
	};
	this.csch = function(b) {
		return 1 / sinh(b)
	};
	this.coth = function(b) {
		return 1 / tanh(b)
	};
	this.asinh = function(b) {
		return Math.log(b + Math.sqrt(b * b + 1))
	};
	this.acosh = function(b) {
		return Math.log(b + Math.sqrt(b * b - 1))
	};
	this.atanh = function(b) {
		return Math.log((1 + b) / (1 - b)) * 0.5
	};
	this.asech = function(b) {
		return acosh(1 / b)
	};
	this.acsch = function(b) {
		return asinh(1 / b)
	};
	this.acoth = function(b) {
		return atanh(1 / b)
	};
	this.exp = function(b) {
		return Math.exp(b)
	};
	this.ln = function(b) {
		return Math.log(b)
	};
	this.log = function(b) {
		return Math.log(b) / Math.LN10
	};
	this.logb = function(c, b) {
		return Math.log(b) / Math.log(c)
	};
	this.pow = function(c, b) {
		return Math.pow(b, c)
	};
	this.pow10 = function(b) {
		return Math.pow(10, b)
	};
	this.sq = function(b) {
		return b * b
	};
	this.sqrt = function(b) {
		return Math.sqrt(b)
	};
	this.abs = function(b) {
		return b >= 0 ? b : -b
	};
	this.sgn = function(b) {
		return b == 0 ? 0 : (b > 0 ? 1 : -1)
	};
	this.chs = function(b) {
		return -b
	};
	this.neg = function(b) {
		return -b
	};
	this.floor = function(b) {
		return Math.floor(b)
	};
	this.ceil = function(b) {
		return Math.ceil(b)
	};
	this.ip = function(b) {
		return parseInt(b)
	};
	this.fp = function(b) {
		return abs(b) - ip(abs(b))
	};
	this.inv = function(b) {
		return 1 / b
	};
	this.idiv = function(c, b) {
		return parseInt(b / c)
	};
	this.mod = function(c, b) {
		return b % c
	};
	this.and = function(c, b) {
		return b & c
	};
	this.or = function(c, b) {
		return b | c
	};
	this.xor = function(c, b) {
		return b ^ c
	};
	this.not = function(b) {
		return ~b
	};
	this.lt = function(c, b) {
		return b < c ? 1 : 0
	};
	this.le = function(c, b) {
		return b <= c ? 1 : 0
	};
	this.eq = function(c, b) {
		return b == c ? 1 : 0
	};
	this.ne = function(c, b) {
		return b != c ? 1 : 0
	};
	this.ge = function(c, b) {
		return b >= c ? 1 : 0
	};
	this.gt = function(c, b) {
		return b > c ? 1 : 0
	};
	this.Min = function(c, b) {
		return Math.min(b, c)
	};
	this.Max = function(c, b) {
		return Math.max(b, c)
	};
	this.pc = function(c, b) {
		return b * c / 100
	};
	this.pcch = function(c, b) {
		return 100 * c / b
	};
	this.gammaLn = function(c) {
		var b = new Array(76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -0.000005395239384953);
		var g = new Number(c);
		var f = new Number(c + 5.5);
		var d = new Number(1.000000000190015);
		f -= (c + 0.5) * Math.log(f);
		for (var e in b) {
			d += b[e] / ++g
		}
		return Math.log(2.5066282746310007 * d / c) - f
	};
	this.gammaLn2 = function(b) {
		var d = 0;
		var g = [76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -0.000005395239384953];
		var c = 1.000000000190015;
		var f, h, e;
		e = (h = f = b) + 5.5;
		e -= (f + 0.5) * Math.log(e);
		for (; d < 6; d++) {
			c += g[d] / ++h
		}
		return Math.log(2.5066282746310007 * c / f) - e
	};
	this.betaCf = function(q, p, o) {
		var i = 1e-30;
		var g = 1;
		var k = p + o;
		var t = p + 1;
		var f = p - 1;
		var n = 1;
		var l = 1 - k * q / t;
		var s, e, r, j;
		if (Math.abs(l) < i) {
			l = i
		}
		l = 1 / l;
		j = l;
		for (; g <= 100; g++) {
			s = 2 * g;
			e = g * (o - g) * q / ((f + s) * (p + s));
			l = 1 + e * l;
			if (Math.abs(l) < i) {
				l = i
			}
			n = 1 + e / n;
			if (Math.abs(n) < i) {
				n = i
			}
			l = 1 / l;
			j *= l * n;
			e = -(p + g) * (k + g) * q / ((p + s) * (t + s));
			l = 1 + e * l;
			if (Math.abs(l) < i) {
				l = i
			}
			n = 1 + e / n;
			if (Math.abs(n) < i) {
				n = i
			}
			l = 1 / l;
			r = l * n;
			j *= r;
			if (Math.abs(r - 1) < 3e-7) {
				break
			}
		}
		return j
	};
	this.beta = function(d, e, c) {
		var f = (d === 0 || d === 1) ? 0 : Math.exp(this.gammaLn2(e + c) - this.gammaLn2(e) - this.gammaLn2(c) + e * Math.log(d) + c * Math.log(1 - d));
		if (d < 0 || d > 1) {
			return false
		}
		if (d < (e + 1) / (e + c + 2)) {
			return f * this.betaCf(d, e, c) / e
		}
		return 1 - f * this.betaCf(1 - d, c, e) / c
	};
	this.betaInv = function(m, z, y) {
		var n = 1e-8;
		var A = z - 1;
		var f = y - 1;
		var q = 0;
		var d, c, r, l, k, e, g, o, v, i, s;
		if (m <= 0) {
			return 0
		}
		if (m >= 1) {
			return 1
		}
		if (z >= 1 && y >= 1) {
			r = (m < 0.5) ? m : 1 - m;
			l = Math.sqrt(-2 * Math.log(r));
			g = (2.30753 + l * 0.27061) / (1 + l * (0.99229 + l * 0.04481)) - l;
			if (m < 0.5) {
				g = -g
			}
			o = (g * g - 3) / 6;
			v = 2 / (1 / (2 * z - 1) + 1 / (2 * y - 1));
			i = (g * Math.sqrt(o + v) / v) - (1 / (2 * y - 1) - 1 / (2 * z - 1)) * (o + 5 / 6 - 2 / (3 * v));
			g = z / (z + y * Math.exp(2 * i))
		} else {
			d = Math.log(z / (z + y));
			c = Math.log(y / (z + y));
			l = Math.exp(z * d) / z;
			k = Math.exp(y * c) / y;
			i = l + k;
			if (m < l / i) {
				g = Math.pow(z * i * m, 1 / z)
			} else {
				g = 1 - Math.pow(y * i * (1 - m), 1 / y)
			}
		}
		s = -this.gammaLn2(z) - this.gammaLn2(y) + this.gammaLn2(z + y);
		for (; q < 10; q++) {
			if (g === 0 || g === 1) {
				return g
			}
			e = this.beta(g, z, y) - m;
			l = Math.exp(A * Math.log(g) + f * Math.log(1 - g) + s);
			k = e / l;
			g -= (l = k / (1 - 0.5 * Math.min(1, k * (A / g - f / (1 - g)))));
			if (g <= 0) {
				g = 0.5 * (g + l)
			}
			if (g >= 1) {
				g = 0.5 * (g + l + 1)
			}
			if (Math.abs(l) < n * g && q > 0) {
				break
			}
		}
		return g
	};
	this.lowRegGamma = function(r, s) {
		var p = this.gammaLn(r);
		var f = r;
		var m = 1 / r;
		var t = m;
		var q = s + 1 - r;
		var o = 1 / 1e-30;
		var n = 1 / q;
		var k = n;
		var g = 1;
		var e = -~(Math.log((r >= 1) ? r : 1 / r) * 8.5 + r * 0.4 + 17);
		var j, l;
		if (s < 0 || r <= 0) {
			return NaN
		} else {
			if (s < r + 1) {
				for (; g <= e; g++) {
					m += t *= s / ++f
				}
				return (m * Math.exp(-s + r * Math.log(s) - (p)))
			}
		}
		for (; g <= e; g++) {
			j = -g * (g - r);
			q += 2;
			n = j * n + q;
			o = q + j / o;
			n = 1 / n;
			k *= n * o
		}
		return (1 - k * Math.exp(-s + r * Math.log(s) - (p)))
	};
	this.gammaPinv = function(c, i) {
		var g = 0;
		var d = i - 1;
		var h = 1e-8;
		var b = this.gammaLn(i);
		var k, f, o, n, e, m, l;
		if (c >= 1) {
			return Math.max(100, i + 100 * Math.sqrt(i))
		}
		if (c <= 0) {
			return 0
		}
		if (i > 1) {
			m = Math.log(d);
			l = Math.exp(d * (m - 1) - b);
			e = (c < 0.5) ? c : 1 - c;
			o = Math.sqrt(-2 * Math.log(e));
			k = (2.30753 + o * 0.27061) / (1 + o * (0.99229 + o * 0.04481)) - o;
			if (c < 0.5) {
				k = -k
			}
			k = Math.max(0.001, i * Math.pow(1 - 1 / (9 * i) - k / (3 * Math.sqrt(i)), 3))
		} else {
			o = 1 - i * (0.253 + i * 0.12);
			if (c < o) {
				k = Math.pow(c / o, 1 / i)
			} else {
				k = 1 - Math.log(1 - (c - o) / (1 - o))
			}
		}
		for (; g < 12; g++) {
			if (k <= 0) {
				return 0
			}
			f = this.lowRegGamma(i, k) - c;
			if (i > 1) {
				o = l * Math.exp(-(k - d) + d * (Math.log(k) - m))
			} else {
				o = Math.exp(-k + d * Math.log(k) - b)
			}
			n = f / o;
			k -= (o = n / (1 - 0.5 * Math.min(1, n * ((i - 1) / k - 1))));
			if (k <= 0) {
				k = 0.5 * (k + o)
			}
			if (Math.abs(o) < h * k) {
				break
			}
		}
		return k
	};
	this.tinv = function(d, e, c) {
		if (c) {
			d /= 2
		}
		var b = this.betaInv(2 * Math.min(d, 1 - d), 0.5 * e, 0.5);
		b = Math.sqrt(e * (1 - b) / b);
		return (d > 0.5) ? b : -b
	};
	this.gamma = function(b) {
		return Math.exp(this.gammaLn(b))
	};
	this.fact = function(c) {
		var b = new Number(c);
		if (c <= 1) {
			return 1
		}
		if (c > 100 || (c % 1)) {
			return Math.exp(this.gammaLn(c + 1))
		}
		while (--c) {
			b *= c
		}
		return b
	};
	this.comb = function(c, b) {
		return Math.floor(0.5 + Math.exp(this.gammaLn(b + 1) - this.gammaLn(c + 1) - this.gammaLn(b - c + 1)))
	};
	this.perm = function(c, b) {
		return Math.floor(0.5 + Math.exp(this.gammaLn(b + 1) - this.gammaLn(b - c + 1)))
	};
	this.gcd = function(d, c) {
		if (d == 0) {
			return (c || 1)
		}
		return (c ? this.gcd(c, d % c) : d)
	};
	this.lcm = function(d, c) {
		return (d / this.gcd(d, c)) * c
	};
	this.prime = function(f) {
		var e = new Number(5);
		var b = new Number(4);
		var c = parseInt(f / e);
		if (f == 2 || f == 3 || f == 5) {
			return 1
		}
		if (f < 5 || (f & 1) == 0 || (f % 3) == 0) {
			return 0
		}
		while (e * c < f && e < c) {
			c = parseInt(f / (e += (b = 6 - b)))
		}
		return (e * c == f ? 0 : 1)
	};
	this.implied = function(b) {
		if (b == "neg") {
			return false
		}
		return /^(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|\w+$/.test(b)
	};
	this.tokenize = function(g) {
		var c;
		var b = [];
		var f = new String("");
		var d = /(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|[xy]|[a-z]+|[-+*\/(),^]|<=?|>=?|==|!=|&&|\|\|/g;
		g = g.toLowerCase();
		g = g.replace(/\s/g, "");
		g = g.replace(/\+\+/g, "+");
		g = g.replace(/\+-/g, "-");
		g = g.replace(/-\+/g, "-");
		g = g.replace(/--/g, "+");
		g = g.replace(/^\+/, "");
		g = g.replace(/([(*\/&\|<>=])\+/g, "$1");
		g = g.replace(/^-/, "neg ");
		g = g.replace(/([(*\/&\|<>=])-/g, "$1neg ");
		g = g.replace(/\)(\(|\w)/g, ")*$1");
		g = g.replace(/(\d)\(/g, "$1*(");
		while (c = d.exec(g)) {
			if (this.implied(f) && this.implied(c[0].toString())) {
				b.push("*")
			}
			b.push(f = c[0])
		}
		return b
	};
	this.isValidEnd = function(b) {
		return /^(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|[)xye]|pi|rand$/.test(b)
	};
	this.toPostFx = function(f) {
		var c = {
			sin: 16,
			cos: 16,
			tan: 16,
			sec: 16,
			csc: 16,
			cot: 16,
			asin: 16,
			acos: 16,
			atan: 16,
			asec: 16,
			acsc: 16,
			acot: 16,
			sinh: 16,
			cosh: 16,
			tanh: 16,
			sech: 16,
			csch: 16,
			coth: 16,
			asinh: 16,
			acosh: 16,
			atanh: 16,
			asech: 16,
			acsch: 16,
			acoth: 16,
			exp: 16,
			ln: 16,
			log: 16,
			logb: 16,
			pow: 16,
			sq: 16,
			sqrt: 16,
			abs: 16,
			sgn: 16,
			chs: 16,
			floor: 16,
			ceil: 16,
			ip: 16,
			fp: 16,
			inv: 16,
			min: 16,
			max: 16,
			gamma: 16,
			fact: 16,
			comb: 16,
			perm: 16,
			rand: 16,
			gcd: 16,
			lcm: 16,
			prime: 16,
			and: 16,
			or: 16,
			xor: 16,
			x: 16,
			y: 16,
			pi: 16,
			e: 16,
			neg: 15,
			not: 15,
			"^": 14,
			"*": 13,
			"/": 13,
			mod: 13,
			div: 13,
			"+": 12,
			"-": 12,
			"<": 10,
			"<=": 10,
			"==": 10,
			"!=": 10,
			">=": 10,
			">": 10,
			"&&": 5,
			"||": 4,
			",": 1
		};
		var d = new String();
		var e = new String("");
		var b = new Array();
		var g = new Array();
		while (d = f.shift()) {
			if (d == "(") {
				b.push(d)
			} else {
				if (c[d]) {
					while (b.length && b[b.length - 1] != "(" && c[b[b.length - 1]] >= c[d]) {
						g.push(b.pop())
					}
					if (d == "," && !this.isValidEnd(e)) {
						g.push("Unexpected: " + e)
					}
					if (d != ",") {
						b.push(d)
					}
				} else {
					if (d == ")") {
						if (!this.isValidEnd(e)) {
							g.push("Unexpected: " + e)
						}
						while (b.length && b[b.length - 1] != "(") {
							g.push(b.pop())
						}
						if (b.length == 0) {
							g.push("Unmatched: )")
						}
						b.pop()
					} else {
						if (/^[-+]?(\d+\.?|\d*\.\d+)(e[-+]?\d+)?$/.test(d)) {
							g.push(d)
						} else {
							g.push("Unknown: " + d)
						}
					}
				}
			}
			e = d
		}
		if (!this.isValidEnd(e)) {
			g.push("Unexpected: " + e)
		}
		while (d = b.pop()) {
			if (d == "(") {
				g.push("Unmatched: (")
			}
			g.push(d)
		}
		return g
	};
	this.syntaxCheck = function(f) {
		var e = {
			sin: 1,
			cos: 1,
			tan: 1,
			sec: 1,
			csc: 1,
			cot: 1,
			asin: 1,
			acos: 1,
			atan: 1,
			asec: 1,
			acsc: 1,
			acot: 1,
			sinh: 1,
			cosh: 1,
			tanh: 1,
			sech: 1,
			csch: 1,
			coth: 1,
			asinh: 1,
			acosh: 1,
			atanh: 1,
			asech: 1,
			acsch: 1,
			acoth: 1,
			exp: 1,
			ln: 1,
			log: 1,
			logb: 2,
			pow: 2,
			sq: 1,
			sqrt: 1,
			abs: 1,
			sgn: 1,
			chs: 1,
			floor: 1,
			ceil: 1,
			ip: 1,
			fp: 1,
			inv: 1,
			min: 2,
			max: 2,
			gamma: 1,
			fact: 1,
			comb: 2,
			perm: 2,
			gcd: 2,
			lcm: 2,
			prime: 1,
			and: 2,
			or: 2,
			xor: 2,
			neg: 1,
			not: 1,
			"^": 2,
			"*": 2,
			"/": 2,
			mod: 2,
			div: 2,
			"+": 2,
			"-": 2,
			"<": 2,
			"<=": 2,
			"==": 2,
			"!=": 2,
			">=": 2,
			">": 2,
			"&&": 2,
			"||": 2
		};
		var b = new Number(0);
		var d = new String();
		for (var c = 0; c < f.length; c++, b++) {
			if (/^Un(matched|known|expected).*/.test(d = f[c])) {
				return d
			}
			if (e[d]) {
				if (b < e[d]) {
					return "Invalid use of: " + d
				}
				b -= e[d]
			}
		}
		return b == 1 ? false : (f.length ? "Unused arguments" : "No function")
	};
	this.evaluate = function(f, c, g) {
		alias = {
			"+": "add",
			"-": "sub",
			"*": "mul",
			"/": "div",
			"!": "fact",
			"x^y": "pow",
			"^": "pow",
			"10^": "pow10",
			div: "idiv",
			"<": "lt",
			"<=": "le",
			"==": "eq",
			"!=": "ne",
			">=": "ge",
			">": "gt",
			"%": "pc",
			"%ch": "pcch"
		};
		var b = new Array();
		var e = new String();
		for (var d = 0; d < f.length; d++) {
			e = f[d];
			if (e == "x") {
				b.push(c)
			} else {
				if (e == "y") {
					b.push(g)
				} else {
					if (e == "pi") {
						b.push(Math.PI)
					} else {
						if (e == "e") {
							b.push(Math.E)
						} else {
							if (e == "rand") {
								b.push(Math.random())
							} else {
								if (this[alias[e] || e]) {
									b.push(this[alias[e] || e](b.pop(), this[alias[e] || e].length > 1 ? b.pop() : 0))
								} else {
									b.push(e)
								}
							}
						}
					}
				}
			}
			if (isNaN(b[b.length - 1])) {
				return Number.NaN
			}
		}
		return parseFloat(b.pop())
	};
	this.set2DPlot = function(k, h) {
		var l = {
			vars: [],
			smps: ["X", "Y"],
			data: []
		};
		var g = this.setMinX ? this.setMinX : (0 - 1);
		var c = this.setMaxX ? this.setMaxX : (1 - 0);
		var f = this.setMinY ? this.setMinY : (0 - 1);
		var b = this.setMaxY ? this.setMaxY : (1 - 0);
		var q = (c - g) / this.functionIntervals;
		var p = (b - f) / this.functionIntervals;
		var e = 1;
		if (h == 1) {
			var o = g;
			for (var j = 0; j < this.functionIntervals; j++) {
				var m = this.evaluate(k, o, 0);
				if (isNaN(m)) {
					m = ""
				}
				o += q;
				l.vars.push("v" + e);
				l.data.push([o, m]);
				e++
			}
		} else {
			var m = f;
			for (var j = 0; j < this.functionIntervals; j++) {
				var o = this.evaluate(k, 0, m);
				if (isNaN(o)) {
					o = ""
				}
				m += p;
				l.vars.push("v" + e);
				l.data.push([o, m]);
				e++
			}
		}
		return l
	};
	this.set3DPlot = function(l) {
		var m = {
			vars: [],
			smps: ["X", "Y", "Z"],
			data: []
		};
		var g = this.setMinX ? this.setMinX : -Math.PI / 2;
		var c = this.setMaxX ? this.setMaxX : Math.PI / 2;
		var f = this.setMinY ? this.setMinY : -Math.PI / 2;
		var b = this.setMaxY ? this.setMaxY : Math.PI / 2;
		var e = 1;
		for (var k = 0; k <= this.functionIntervals; k++) {
			var p = f + (b - f) * k / this.functionIntervals;
			for (var h = 0; h <= this.functionIntervals; h++) {
				var q = g + (c - g) * h / this.functionIntervals;
				var o = this.evaluate(l, q, p);
				if (!isFinite(o)) {
					o = 0
				}
				m.vars.push("v" + e);
				m.data.push([q, o, p]);
				e++
			}
		}
		return m
	};
	this.initializeFunctionData = function() {
		var f = this.toPostFx(this.tokenize(this.data.fx));
		var d = this.syntaxCheck(f);
		if (d) {
			alert(d);
			return
		}
		var b = 0;
		for (var c in f) {
			if (f[c] == "x") {
				b |= 1
			} else {
				if (f[c] == "y") {
					b |= 2
				}
			}
		}
		var e;
		if (b == 0) {
			b = 1
		}
		if (b == 3) {
			this.data.y = this.set3DPlot(f);
			this.graphType = "Scatter3D";
			this.colorBy = "Y"
		} else {
			this.data.y = this.set2DPlot(f, b);
			this.graphType = "Scatter2D";
			this.lineType = "spline"
		}
		this.scatterType = "function"
	};
	if (a) {
		this.initializeFunctionData()
	}
};
CanvasXpress.prototype.initRemote = function() {
	this.ajaxRequest = function(url, params, callback, format, method) {
		var http = false;
		var pars = "";
		for (var p in params) {
			pars += p + "=" + escape(params[p]) + "&"
		}
		pars += "uid=" + new Date().getTime();
		format = format == "json" ? "json" : "text";
		method = method == "POST" ? "POST" : "GET";
		if (window.XMLHttpRequest) {
			try {
				http = new XMLHttpRequest()
			} catch (e) {
				http = false
			}
		} else {
			if (typeof ActiveXObject != "undefined") {
				try {
					http = new ActiveXObject("Msxml2.XMLHTTP")
				} catch (e) {
					try {
						http = new ActiveXObject("Microsoft.XMLHTTP")
					} catch (e) {
						http = false
					}
				}
			}
		}
		if (http && url) {
			if (method == "GET") {
				url += "?" + pars;
				http.open(method, url, true);
				if (http.overrideMimeType) {
					http.overrideMimeType("text/xml")
				}
				pars = null
			} else {
				http.open(method, url, true);
				http.setRequestHeader("Content-type", "application/x-www-form-urlencoded")
			}
			http.onreadystatechange = function() {
				if (http.readyState == 4) {
					if (http.status == 200) {
						var result = "";
						if (http.responseText) {
							result = http.responseText
						}
						if (format == "json") {
							result = result.replace(/[\n\r]/g, "");
							result = eval("(" + result + ")")
						}
						if (callback) {
							callback(result)
						}
					} else {}
				}
			};
			http.send(pars)
		}
	};
	this.setClientIPInfo = function() {
		var setInfo = function(t) {
			return function(r) {
				t.meta.info = JSON.parse(r)
			}
		}(this);
		this.ajaxRequest("http://freegeoip.net/json/", false, setInfo)
	};
	this.requestRemoteData = function(ini) {
		var params = this.cloneObject(this.remoteParams);
		params.index = this.remoteDataIndex;
		params.dir = this.remoteDirection;
		if (ini) {
			params.records = true
		}
		if (this.remoteServiceType == "file") {
			this.ajaxRequest(this.remoteData[this.remoteDataIndex][1], params, this.updateRemoteData, "json", "GET")
		} else {
			this.ajaxRequest(this.remoteService, params, this.updateRemoteData, "json", "GET")
		}
	};
	this.requestRemoteIds = function(d) {
		if (this.remoteService && this.remoteUpdate) {
			var params = this.cloneObject(this.remoteParams);
			params.update = true;
			var that = this;
			var updater = function() {
				this.update = function() {
					clearInterval(cl);
					that.ajaxRequest(that.remoteService, params, that.updateRemoteIds, "json", "GET")
				};
				var cl = setInterval(this.update, d / 5 || 1)
			};
			updater.call()
		}
	};
	this.updateRemoteIds = function(t) {
		return function(res) {
			var that = t;
			var s = t.$(t.remoteParentId + "-canvasXpressRemoteWindowBarSelect");
			if (s) {
				if (res.ids) {
					that.remoteIds = res.ids
				}
				var c = s.selectedIndex;
				var x = s.childNodes[c].text;
				var updater = function() {
					this.update = function() {
						if (s.childNodes.length >= that.remoteIds.length) {
							that.remoteUpdate = false;
							clearInterval(cl)
						} else {
							that.resetSelectOptionsRemoteData(s, x);
							that.requestRemoteIds()
						}
					};
					var cl = setInterval(this.update, that.remoteUpdateDelay)
				};
				updater.call()
			}
		}
	}(this);
	this.saveRemote = function(type, name, object) {
		var that = this;
		var params = this.cloneObject(this.remoteParams);
		params.index = this.remoteDataIndex;
		params.save = type;
		if (name) {
			params.name = JSON.stringify(name)
		}
		var config = object ? object : this.getConfig();
		if (this.graphType == "Network") {
			config.calculateLayout = false
		}
		params.params = JSON.stringify(config);
		params.cxdata = JSON.stringify(this.cloneObject(this.data));
		this.ajaxRequest(this.remoteService, params, function() {
			alert("CanvasXpress data saved " + type + " in the server")
		}, "json", "POST")
	};
	this.clearRemote = function() {
		var that = this;
		params.clear = true;
		this.ajaxRequest(this.remoteService, params, function() {
			alert("CanvasXpress data parameters clear from the server")
		}, "json", "POST")
	};
	this.castRemoteParameters = function(o) {
		o.remoteParentId = this.remoteParentId;
		o.remoteService = this.remoteService;
		o.remoteDirection = this.remoteDirection;
		o.remoteDataIndex = this.remoteDataIndex;
		o.remoteAutoPlay = this.remoteAutoPlay;
		o.remoteAutoPlayDelay = this.remoteAutoPlayDelay;
		o.remoteData = this.remoteData;
		o.remoteIds = this.remoteIds;
		o.remoteServiceType = this.remoteServiceType;
		for (var p in this.remoteParams) {
			o.remoteParams[p] = this.remoteParams[p]
		}
		o.addRemoveNavigationListeners("addEvtListener")
	};
	this.getOriginalDimensions = function() {
		var o = this.$(this.target);
		return [parseInt(o.width) + 18, parseInt(o.height) + 18]
	};
	this.updateRemoteData = function(t) {
		return function(res, callback) {
			if (res && res.data) {
				var d;
				if (t.remoteServiceType == "file") {
					d = res.config ? res : res.data;
					d.renderTo = res.renderTo || t.remoteData[t.remoteDataIndex][0];
					var trt = d.renderTo;
					var cnt = 1;
					var nrt = t.$(d.renderTo);
					while (nrt) {
						d.renderTo = trt + "-" + cnt;
						nrt = t.$(d.renderTo);
						cnt++
					}
				} else {
					d = t.appendUserConfig(res.data)
				}
				var a = t.remoteDirection == "next" ? true : false;
				var w = t.$("container-" + t.target);
				if (w) {
					var p = w.parentNode;
					var r = w.getClientRects();
					var o = t.getOriginalDimensions();
					var l = t.target;
					t.insertTarget(d.renderTo, w, d.config.width || o[0], d.config.height || o[1], a);
					d.hidden = d.uploadFile ? false : true;
					var n = new CanvasXpress(d);
					n.target0 = t.target0 ? t.target0 : t.target;
					t.castRemoteParameters(n);
					t.addSelectOptionsRemoteData(res.ids);
					t.resetInfoSpan(false, true);
					t.animateTransition(p, r[0], l, d.uploadFile);
					t.requestRemoteIds(t.remoteUpdateDelay);
					if (t.Ext) {
						if (!n.Ext) {
							n.Ext = {
								canvasId: d.renderTo,
								canvas: n,
								extId: t.Ext.id || t.Ext.extId
							}
						}
					}
					if (res.postprocess) {
						for (var i = 0; i < res.postprocess.length; i++) {
							var fn = res.postprocess[i].func;
							var pr = res.postprocess[i].param;
							if (fn) {
								if (fn == "groupSamples" && n.isGroupedData) {
									continue
								}
								if (pr) {
									n[fn].apply(n, pr)
								} else {
									n[fn]()
								}
							}
						}
					}
					if (!n.userEvents.remoteupdate && t.userEvents.remoteupdate) {
						n.userEvents.remoteupdate = t.userEvents.remoteupdate
					}
					if (n.userEvents.remoteupdate) {
						n.userEvents.remoteupdate.call(this, n)
					}
					if (res.info) {
						n.updateInfoDiv(res.info)
					}
					if (t.showCode) {
						n.updateCodeDiv()
					}
					if (callback) {
						callback()
					}
				}
			} else {
				t.remoteDataIndex = t.remoteDirection == "next" ? Math.max(0, t.remoteDataIndex - 1) : t.remoteDataIndex + 1;
				t.remoteUpdating = false
			}
		}
	}(this);
	this.appendUserConfig = function(d) {
		if (d.config) {
			for (var i in this.meta.config.user) {
				if (!i.match(/decrease|remote|^calculateLayout$|layoutComb/)) {
					if (!d.config[i]) {
						d.config[i] = this.meta.config.user[i]
					}
				}
			}
		}
		return d
	};
	this.updateCurrentRemoteData = function(s, c) {
		if (!s) {
			s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect")
		}
		if (!c) {
			c = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarCurrent")
		}
		if (s && c) {
			s.selectedIndex = this.remoteDataIndex;
			if (this.remoteIds.length == 0) {
				for (var i = 0; i < s.childNodes.length; i++) {
					this.remoteIds.push(s.childNodes[i].text)
				}
			}
			if (s.childNodes[s.selectedIndex]) {
				var v = s.childNodes[s.selectedIndex].text;
				c.value = v.length > 40 ? v.substring(0, 37) + "..." : v
			} else {
				this.resetSelectOptionsRemoteData(s)
			}
		}
	};
	this.resetSelectOptionsRemoteData = function(s, t) {
		if (!s) {
			s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect")
		}
		if (s) {
			if (this.remoteIds.length == 0) {
				for (var i = 0; i < s.childNodes.length; i++) {
					this.remoteIds.push(s.childNodes[i].text)
				}
			}
			this.clearSelectOptionsRemoteData(s);
			this.addSelectOptionsRemoteData(this.remoteIds, s, t)
		}
	};
	this.clearSelectOptionsRemoteData = function(s) {
		if (!s) {
			s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect")
		}
		if (s && s.hasChildNodes()) {
			while (s.childNodes.length >= 1) {
				s.removeChild(s.firstChild)
			}
		}
	};
	this.addSelectOptionsRemoteData = function(ids, s, t) {
		if (ids && ids.length > 0) {
			this.remoteIds = ids;
			if (!s) {
				s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect")
			}
			if (s) {
				this.clearSelectOptionsRemoteData(s);
				for (var i = 0; i < this.remoteIds.length; i++) {
					var opt = this.$cX("option", {
						text: this.remoteIds[i],
						value: i
					}, {
						width: (this.meta.canvas.ctx.canvas.width - 134) + "px"
					});
					if (t) {
						if (this.remoteIds[i] == t) {
							opt.selected = "selected";
							this.remoteDataIndex = i;
							s.selectedIndex = this.remoteDataIndex
						}
					} else {
						if (this.remoteDataIndex == i) {
							opt.selected = "selected";
							s.selectedIndex = this.remoteDataIndex
						}
					}
					try {
						s.add(opt, null)
					} catch (ex) {
						s.add(opt)
					}
				}
				if (this.remoteIds.length == 1) {
					this.hideNavigation()
				} else {
					this.showNavigation()
				}
			}
		}
	};
	this.animateTransition = function(b, r, o, n) {
		if (b) {
			var w, h, c1, c2;
			var that = this;
			var step = 15;
			var s = 0;
			var cn = b.childNodes;
			for (var i = 0; i < cn.length; i++) {
				if (cn[i].nodeName.toUpperCase() == "DIV") {
					c1 = cn[i];
					break
				}
			}
			for (var i = cn.length - 1; i >= 0; i--) {
				if (cn[i].nodeName.toUpperCase() == "DIV") {
					c2 = cn[i];
					break
				}
			}
			if (!r) {
				var cont = this.$("container-" + this.target);
				w = cont.style.width;
				h = cont.style.height
			} else {
				w = r.width;
				h = r.height
			}
			b.parentNode.style.overflow = "hidden";
			if (this.meta.system.isIE || n) {
				if (this.remoteDirection == "next" || n) {
					b.removeChild(c1)
				} else {
					b.removeChild(c2)
				}
				b.parentNode.style.overflow = "visible";
				this.remoteUpdating = false
			} else {
				var updater = function() {
					this.update = function() {
						var n = Math.atan((s / step) * 10 - 5) * 0.5 / Math.atan(5) + 0.5;
						var l = w * n;
						if (s >= step) {
							clearInterval(clearUpdateInt);
							that.destroy(o);
							if (that.remoteDirection == "next") {
								c2.style.left = 0 + "px"
							} else {
								c1.style.left = 0 + "px"
							}
							b.parentNode.style.overflow = "visible";
							that.remoteUpdating = false;
							that.updateCurrentRemoteData()
						} else {
							if (that.remoteDirection == "next") {
								c1.style.left = (l * -1) + "px";
								c2.style.left = (l * -1) + "px"
							} else {
								c1.style.left = (-w + l) + "px";
								c2.style.left = (-w + l) + "px"
							}
							c1.style.display = "block";
							c2.style.display = "block"
						}
						s++
					};
					var clearUpdateInt = setInterval(this.update, 100)
				};
				updater.call()
			}
		}
	};
	this.handleRemoteSelect = function(t) {
		return function(e) {
			var s = t.getTargetEvent(e);
			var i = s.children[s.selectedIndex].value;
			var c = t.$(t.remoteParentId + "-canvasXpressRemoteWindowBarCurrent");
			t.remoteDirection = i > t.remoteDataIndex ? "next" : "previous";
			t.remoteDataIndex = i;
			var v = s.children[s.selectedIndex].text;
			if (c && s) {
				s.style.display = "none";
				t.resetSelectOptionsRemoteData(s);
				c.value = v.length > 40 ? v.substring(0, 37) + "..." : v
			}
			t.requestRemoteData()
		}
	}(this);
	this.handleRemoteClickStop = function(t) {
		return function(e) {
			t.remoteStop = true
		}
	}(this);
	this.handleRemoteClickPlay = function(t) {
		return function(e) {
			var r = t.getTargetEvent(e);
			t.remoteDirection = "next";
			t.remoteStop = false;
			t.playRemoteData(r.parentNode.lastChild)
		}
	}(this);
	this.playRemoteData = function(s) {
		var getRef = function(trg) {
			for (var i = 0; i < CanvasXpress.instances.length; i++) {
				if (trg == CanvasXpress.instances[i].target0) {
					return CanvasXpress.instances[i];
					break
				}
			}
			for (var i = 0; i < CanvasXpress.instances.length; i++) {
				if (trg == CanvasXpress.instances[i].target) {
					return CanvasXpress.instances[i];
					break
				}
			}
			return CanvasXpress.instances[0]
		};
		var id = this.target0 || this.target;
		var updater = function() {
			var that = getRef(id);
			if (that) {
				if (!that.remoteUpdating && !that.remoteStop) {
					that.remoteUpdating = true;
					that.showInfoSpan(false, "Updating ...", true);
					if (s && s.tagName.match(/select/i) && that.remoteDataIndex >= s.length - 1) {
						that.remoteDataIndex = 0
					} else {
						that.remoteDataIndex++
					}
					that.requestRemoteData()
				}
			}
			this.update = function() {
				var that = getRef(id);
				if (that) {
					if (!that.remoteUpdating && !that.remoteStop) {
						that.remoteUpdating = true;
						that.showInfoSpan(false, "Updating ...", true);
						if (s && s.tagName.match(/select/i) && that.remoteDataIndex >= s.length - 1) {
							that.remoteDataIndex = 0
						} else {
							that.remoteDataIndex++
						}
						that.requestRemoteData()
					}
					if (that.remoteStop) {
						clearInterval(cl)
					}
				} else {
					clearInterval(cl)
				}
			};
			var cl = setInterval(this.update, that.remoteAutoPlayDelay)
		};
		updater.call()
	};
	this.handleRemoteClickPrev = function(t) {
		return function(e) {
			if (!t.remoteUpdating) {
				var r = t.getTargetEvent(e);
				var s = r.parentNode.lastChild;
				t.remoteUpdating = true;
				t.showInfoSpan(false, "Updating ...", true);
				t.remoteDirection = "previous";
				if (s && s.tagName.match(/select/i) && t.remoteDataIndex <= 0) {
					t.remoteDataIndex = s.length - 1
				} else {
					t.remoteDataIndex = Math.max(0, t.remoteDataIndex - 1)
				}
				t.requestRemoteData()
			}
		}
	}(this);
	this.handleRemoteClickNext = function(t) {
		return function(e) {
			if (!t.remoteUpdating) {
				var r = t.getTargetEvent(e);
				var s = r.parentNode.lastChild;
				t.remoteUpdating = true;
				t.showInfoSpan(false, "Updating ...", true);
				t.remoteDirection = "next";
				if (s && s.tagName.match(/select/i) && t.remoteDataIndex >= s.length - 1) {
					t.remoteDataIndex = 0
				} else {
					t.remoteDataIndex++
				}
				t.requestRemoteData()
			}
		}
	}(this);
	this.handleRemoteClickDown = function(t) {
		return function(e) {
			if (!t.remoteUpdating) {
				var s = t.$(t.remoteParentId + "-canvasXpressRemoteWindowBarSelect");
				if (s) {
					if (s.style.display == "none") {
						s.style.display = "block";
						s.options[s.selectedIndex].selected = true
					} else {
						s.style.display = "none"
					}
				}
			}
		}
	}(this);
	this.addRemoteNavigation = function(w) {
		var m = "5px";
		var n = this.$cX("div", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBar"
		}, {
			padding: "2px",
			color: "rgb(34,34,34)",
			border: "1px solid rgb(51,122,183)",
			backgroundColor: "rgb(245,245,245)",
			boxShadow: "2px 2px 2px rgba(154,154,154,0.2)",
			MozBoxShadow: "2px 2px 2px rgba(154,154,154,0.2)",
			borderRadius: "4px",
			width: (this.meta.canvas.ctx.canvas.width - 5) + "px",
			position: "absolute",
			marginLeft: w + "px",
			display: "none"
		});
		var r = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarPrev",
			src: CanvasXpress.images.controlRewindBlue,
			alt: "Previous graph",
			title: "Previous graph"
		}, {
			margin: m
		});
		n.appendChild(r);
		var p = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarPlay",
			src: CanvasXpress.images.controlPlayBlue,
			alt: "Iterate over graphs",
			title: "Iterate over graphs"
		}, {
			margin: m
		});
		n.appendChild(p);
		var e = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarStop",
			src: CanvasXpress.images.controlStopBlue,
			alt: "Stop iteration",
			title: "Stop iteration"
		}, {
			margin: m
		});
		n.appendChild(e);
		var f = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarNext",
			src: CanvasXpress.images.controlForwardBlue,
			alt: "Next graph",
			title: "Next graph"
		}, {
			margin: m
		});
		n.appendChild(f);
		var c = this.$cX("input", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarCurrent",
			type: "text"
		}, {
			padding: "1px 1px 2px 1px",
			position: "absolute",
			cursor: "default",
			display: "block",
			left: "102px",
			top: "0px",
			margin: "5px",
			width: (this.meta.canvas.ctx.canvas.width - 118) + "px",
			borderRadius: "4px",
			MozBorderRadius: "4px",
			lineHeight: "normal"
		});
		n.appendChild(c);
		var d = this.$cX("img", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarDown",
			src: CanvasXpress.images.menuDropdown,
			alt: "Select graph",
			title: "Select graph"
		}, {
			margin: m,
			position: "absolute",
			top: "3px",
			right: "10px"
		});
		n.appendChild(d);
		var s = this.$cX("select", {
			id: this.remoteParentId + "-canvasXpressRemoteWindowBarSelect",
			size: 4
		}, {
			position: "absolute",
			margin: "5px",
			color: "rgb(34,34,34)",
			border: "1px solid rgb(51,122,183)",
			marginTop: "1px",
			left: "102px",
			top: "26px",
			maxWidth: "800px",
			display: "none",
			zIndex: 9500
		});
		n.appendChild(s);
		return n
	};
	this.addRemoveNavigationListeners = function(t) {
		var r = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarPrev");
		var p = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarPlay");
		var e = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarStop");
		var f = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarNext");
		var d = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarDown");
		var s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect");
		if (r) {
			this[t](r, "click", this.handleRemoteClickPrev, false)
		}
		if (p) {
			this[t](p, "click", this.handleRemoteClickPlay, false)
		}
		if (e) {
			this[t](e, "click", this.handleRemoteClickStop, false)
		}
		if (f) {
			this[t](f, "click", this.handleRemoteClickNext, false)
		}
		if (d) {
			this[t](d, "click", this.handleRemoteClickDown, false)
		}
		if (s) {
			this[t](s, "change", this.handleRemoteSelect, false)
		}
	};
	this.selectDataSet = function(e) {
		var t = document.activeElement;
		if (t.id == this.remoteParentId + "-canvasXpressRemoteWindowBarCurrent") {
			var s = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBarSelect");
			var p = [];
			if (s && t.value.length > 0) {
				if (this.remoteIds.length == 0) {
					for (var i = 0; i < s.childNodes.length; i++) {
						this.remoteIds.push(s.childNodes[i].text)
					}
				}
				this.clearSelectOptionsRemoteData(s);
				for (var i = 0; i < this.remoteIds.length; i++) {
					if (this.remoteIds[i].toLowerCase().indexOf(t.value.toLowerCase()) >= 0) {
						p.push(i)
					}
				}
				for (var i = 0; i < p.length; i++) {
					var o = this.$cX("option", {
						text: this.remoteIds[p[i]],
						value: p[i]
					}, {
						width: (this.meta.canvas.ctx.canvas.width - 134) + "px"
					});
					try {
						s.add(o, null)
					} catch (ex) {
						s.add(o)
					}
				}
				s.style.display = "block"
			}
		}
	};
	this.updateRemoteNavigationWindow = function() {
		var c = this.$(this.target);
		var x = 0;
		var y = 36;
		var w = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
		var b = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBuffer");
		if (c && w && b) {
			w.style.height = ((y * 2) + c.height) + "px";
			w.style.width = ((x * 2) + c.width) + "px";
			b.style.width = (parseInt(c.parentNode.parentNode.clientWidth) * 2) + "px";
			b.style.left = x + "px";
			b.style.top = y + "px";
			this.resizeExtContainer()
		}
	};
	this.addRemoteWindow = function() {
		var w = this.$("container-" + this.target);
		var c = this.$(this.target);
		var p = w.parentNode;
		var y = 36;
		if (p.id && !p.id.match(/canvasXpressRemoteWindow/)) {
			this.remoteParentId = p.id;
			var d = this.$cX("div", {
				id: this.remoteParentId + "-canvasXpressRemoteWindow"
			}, {
				marginTop: "3px",
				height: (y + c.height) + "px",
				width: c.width + "px",
				position: "relative"
			});
			var t = this.addRemoteNavigation();
			var v = this.$cX("div", {
				id: this.remoteParentId + "-canvasXpressRemoteWindowBuffer"
			}, {
				width: (parseInt(c.parentNode.parentNode.clientWidth) * 2) + "px",
				position: "absolute",
				left: "0px",
				top: y + "px",
				height: "1000px"
			});
			d.appendChild(t);
			d.appendChild(v);
			p.insertBefore(d, w);
			v.appendChild(w.parentNode.appendChild(w));
			this.addRemoveNavigationListeners("addEvtListener");
			this.requestRemoteData(true);
			this.initialRemoteDataRequest = true;
			if (this.remoteAutoPlay) {
				this.remoteUpdating = true;
				this.remoteDirection = "next";
				this.remoteStop = false;
				this.playRemoteData(t.lastChild)
			}
		} else {
			this.initialRemoteDataRequest = false
		}
	};
	this.resizeExtContainer = function(over) {
		if (this.Ext && this.Ext.extId && Ext) {
			var cnt = Ext.getCmp(this.Ext.extId);
			if (cnt) {
				var par = cnt.ownerCt;
				if (par) {
					var grp = par.ownerCt;
					if (grp) {
						grp.doLayout()
					} else {
						par.doLayout()
					}
				} else {
					con.doLayout()
				}
			}
		}
	};
	this.hideNavigation = function() {
		var t = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBar");
		if (t) {
			t.style.display = "none"
		}
	};
	this.showNavigation = function() {
		var t = this.$(this.remoteParentId + "-canvasXpressRemoteWindowBar");
		if (t) {
			t.style.display = "block"
		}
	};
	this.initializeRemote = function() {
		if (this.remoteService || this.dataURL) {
			this.addRemoteWindow();
			this.setClientIPInfo()
		}
	};
	this.initializeRemote()
};
CanvasXpress.prototype.initGraph = function() {
	this.draw = function(b, f, a, e, d) {
		var c = this;
		this.setUserEvents();
		this.validateUserColors();
		this.stack();
		this.initializeGraph(true, b, f, a, e, d);
		this.resetGradientTransparencyShadow();
		if (this.userEvents.enddraw) {
			this.userEvents.enddraw.call(this)
		}
	};
	this.isValidGraphType = function(a) {
		switch (a) {
			case "Bar":
			case "Line":
			case "Area":
			case "AreaLine":
			case "Dotplot":
			case "Heatmap":
			case "Stacked":
			case "StackedPercent":
			case "Boxplot":
			case "Correlation":
			case "Treemap":
			case "TagCloud":
			case "Pie":
			case "Circular":
				if (this.data.y) {
					return true
				} else {
					return false
				}
			case "BarLine":
			case "DotLine":
			case "StackedLine":
			case "StackedPercentLine":
				if (this.data.y && this.data.a && this.data.a.xAxis && this.data.a.xAxis2) {
					return true
				} else {
					return false
				}
			case "Scatter2D":
				if (this.data.y && this.data.y.smps && this.data.y.smps.length > 1) {
					return true
				} else {
					return false
				}
			case "ScatterBubble2D":
			case "Scatter3D":
				if (this.data.y && this.data.y.smps && this.data.y.smps.length > 2) {
					return true
				} else {
					return false
				}
			case "Candlestick":
				if (this.data.market) {
					return true
				} else {
					return false
				}
			case "Venn":
				if (this.data.venn) {
					return true
				} else {
					return false
				}
			case "Network":
				if (this.data.nodes) {
					return true
				} else {
					return false
				}
			case "Genome":
				if (this.data.tracks) {
					return true
				} else {
					return false
				}
			case "Video":
				if (this.data.video) {
					return true
				} else {
					return false
				}
		}
		return false
	};
	this.setColorScheme = function() {
		if (this.colorScheme == "User") {
			return
		} else {
			if (this.colorScheme == "ColorSpectrum") {
				var a = this.colorSpectrumNumber;
				this.colorSpectrumNumber = this.data.y.vars.length;
				var b = this.getColorBrew(this.colorSpectrum, 0, this.data.y.vars.length);
				this.colors = b.colors;
				this.colorSpectrumNumber = a
			} else {
				if (this.colorSchemes[this.colorScheme]) {
					var d;
					var c = this.getKeys(this.colorSchemes[this.colorScheme]);
					c.sort(function(f, e) {
						return f - e
					});
					if (this.graphType == "Video") {
						d = c[c.length - 1]
					} else {
						if (this.graphType.match(/Scatter|Treemap|TagCloud/)) {
							d = this.data.y.smps.length
						} else {
							if (this.graphType.match(/Venn/)) {
								d = this.vennGroups
							} else {
								if (this.graphType.match(/Pie/)) {
									d = this.data.y.vars.length
								} else {
									if (this.graphType.match(/Network|Genome|Correlation/)) {
										d = c[c.length - 1]
									} else {
										if (this.graphType == "Line") {
											d = this.data.y.vars.length
										} else {
											if (this.graphType.match(/BarLine|DotLine/) && this.coordinateLineColor) {
												d = Math.max(this.data.a.xAxis.length, this.data.a.xAxis2.length)
											} else {
												d = this.data.y.vars.length
											}
										}
									}
								}
							}
						}
					}
					if (this.colorSchemes[this.colorScheme][d]) {
						this.colors = this.colorSchemes[this.colorScheme][d]
					} else {
						if (d > c[c.length - 1]) {
							d--;
							while (!this.colorSchemes[this.colorScheme][d]) {
								d--
							}
						} else {
							d++;
							while (!this.colorSchemes[this.colorScheme][d]) {
								d++
							}
						}
						this.colors = this.colorSchemes[this.colorScheme][d]
					}
				} else {
					this.colors = this.colorSchemes.Balanced[20]
				}
			}
		}
	};
	this.reinitializeGraph = function() {
		if (this.graphType == "Candlestick") {
			this.isGraphTime = true;
			if (!this.isMarketSwitched) {
				this.switchToMarketData();
				this.initAxes();
				this.summaryType = "candle";
				this.initializeDataAttributes();
				this.isMarketSwitched = true
			}
			this.setMarketTechnicalData()
		} else {
			if (this.isExample && this.isMarketSwitched) {
				this.switchFromMarketData();
				this.isMarketSwitched = false;
				this.summaryType = this.data.y.data ? "raw" : "mean";
				this.initializeDataAttributes();
				this.isGraphTime = false;
				if (this.showVolume) {
					this.layoutComb = false
				}
			} else {
				if (this.graphType.match(/Scatter/) && this.scatterPlotMatrix && !this.isDOE) {
					if (!this.data.l) {
						this.setScatterPlotMatrix()
					}
				} else {
					if (this.graphType.match(/Pie/) && this.xAxis.length > 1 && !this.isDOE) {
						this.setMultiplePies()
					}
				}
			}
		}
	};
	this.getNetworkImages = function() {
		var a = [];
		if (this.graphType == "Network") {
			for (var b = 0; b < this.data.nodes.length; b++) {
				var c = this.data.nodes[b];
				if (c.imagePath) {
					if (!c.imagePath.match(/^(http|file):\/\//)) {
						c.imagePath = this.imageDir + c.imagePath
					}
					a.push(c.imagePath)
				}
			}
		}
		return a
	};
	this.initializeGraph = function(o, a, n, k, c, d) {
		var f = this;
		var b = 0;
		var h = [];
		var l = [];
		var g = function(i) {
			var p = f.getFileName(i);
			return CanvasXpress.images[p] ? true : CanvasXpress.cacheImages.hasOwnProperty(p) && typeof(CanvasXpress.cacheImages[p]) == "object"
		};
		var m = function() {
			for (var p = 0; p < h.length; p++) {
				if (CanvasXpress.images[h[p]]) {
					continue
				}
				if (!g(h[p])) {
					return false
				}
			}
			return true
		};
		this.createPatterns();
		if (this.graphType == "Network") {
			h = this.getNetworkImages()
		}
		if (this.graphType.match(/scatter/i)) {
			for (var e = 0; e < this.images.length; e++) {
				if (!this.images[e].match(/^(http|file):\/\//)) {
					this.images[e] = this.imageDir + this.images[e]
				}
				h.push(this.images[e])
			}
		}
		if (this.backgroundImage) {
			if (!this.backgroundImage.match(/^(http|file):\/\//)) {
				this.backgroundImage = this.imageDir + this.backgroundImage
			}
			h.push(this.backgroundImage)
		}
		if (h.length > 0) {
			if (this.graphType == "Network") {
				this.Network(true)
			} else {
				if (this.graphType == "Scatter3D") {
					this.Scatter3D(true)
				} else {
					if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
						this.Scatter2D(true)
					}
				}
			}
		} else {
			CanvasXpress.cacheImagesReady = true
		}
		if (h.length > 0 && !m() && !d) {
			for (var e = 0; e < h.length; e++) {
				if (!g(h[e])) {
					l.push(h[e])
				}
			}
			for (var e = 0; e < h.length; e++) {
				if (!g(h[e])) {
					var j = new Image;
					j.onload = function() {
						CanvasXpress.cacheImages[f.getFileName(this.src)] = this;
						b++;
						CanvasXpress.cacheImagesReady = b == l.length;
						if (CanvasXpress.cacheImagesReady) {
							f.renderGraph(o, a, n, k, c)
						}
					};
					j.src = h[e]
				}
			}
		} else {
			this.renderGraph(o, a, n, k, c)
		}
	};
	this.renderGraph = function(h, d, a, c, f) {
		var g = this.meta.def;
		if (this.initialRemoteDataRequest) {
			return
		}
		this.setColorScheme();
		this.reinitializeGraph();
		if (!c) {
			if (this.graphType != "Candlestick" || (this.graphType == "Candlestick" && !this.showVolume)) {
				if (!this.motionOn) {
					this.initAxes()
				}
				this.setColorBrew(true)
			}
		}
		if (h) {
			this.resizeCanvas(true, d, a)
		} else {
			this.resizeCanvas(false, d, a)
		}
		this.setAspectRatioProperties();
		if (this.isValidAnimation() && this.showAnimation && !this.isAnimation) {
			this.createAnimation(this.animationType)
		} else {
			var e = this.layoutComb ? true : false;
			switch (this.graphType) {
				case "Bar":
				case "Dotplot":
					if (this.isBoxPlotCalc && this.isGroupedData) {
						this.groupSamples(this.getGroupingFactors(true), false, false, false, true)
					}
					if (this.is3DPlot) {
						this.Scatter3D()
					} else {
						this.oneDPlot()
					}
					break;
				case "Line":
				case "Area":
				case "AreaLine":
				case "BarLine":
				case "DotLine":
				case "Heatmap":
				case "Treemap":
				case "TagCloud":
				case "Stacked":
				case "StackedLine":
				case "StackedPercent":
				case "StackedPercentLine":
				case "Candlestick":
					if (this.isBoxPlotCalc && this.isGroupedData) {
						this.groupSamples(this.getGroupingFactors(true), false, false, false, true)
					}
					this.oneDPlot();
					break;
				case "Boxplot":
					if (!this.isBoxPlotCalc && this.isGroupedData) {
						this.groupSamples(this.getGroupingFactors(true), false, false, false, true)
					}
					this.oneDPlot();
					break;
				case "Scatter2D":
				case "ScatterBubble2D":
					this.Scatter2D();
					break;
				case "Scatter3D":
					this.Scatter3D();
					break;
				case "Correlation":
					this.Correlation();
					break;
				case "Venn":
					this.Venn();
					break;
				case "Pie":
					this.Pie();
					break;
				case "Circular":
					this.Circular();
					break;
				case "Network":
					if (f) {
						var b = this.calculateLayout;
						var e = this.randomNetwork;
						this.calculateLayout = false;
						this.randomNetwork = false;
						this.Network();
						this.calculateLayout = b;
						this.randomNetwork = e
					} else {
						this.Network()
					}
					break;
				case "Genome":
					this.Genome();
					break;
				case "Video":
					this.Video();
					break
			}
			this.drawCanvasBox();
			if (this.showCode) {
				this.updateCodeDiv()
			}
			if (this.showDataTable) {
				this.updateDataTable()
			} else {
				if (this.dataTableLastState && this.dataTableLastState != "docked") {
					this.hideUnhideDataTable(true)
				}
			}
			this.setAcknowledgmentVisibility();
			if (this.graphType != "Network") {
				this.drawCitation()
			}
			this.setVideoControls();
			if (navigator.onLine) {
				if (!this.Rdatasets && this.loadRDatasets) {
					this.getRDatasets()
				}
			}
			this.resetAspectRatioProperties();
			this.hideMask()
		}
	};
	this.initializeGraph()
};
CanvasXpress.prototype.initAxes = function(a) {
	this.getValidAxes = function(b) {
		var c = [];
		if (this.graphType == "Scatter2D") {
			c.push("xAxis");
			c.push("yAxis")
		} else {
			if (this.graphType == "ScatterBubble2D" || this.graphType == "Scatter3D") {
				c.push("xAxis");
				c.push("yAxis");
				c.push("zAxis")
			} else {
				if (this.graphType.match(/Network|Genome|Correlation|Venn|Heatmap|Pie|Video/)) {
					if (b) {
						c.push("xAxis")
					} else {
						return false
					}
				} else {
					if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) || (this.graphType == "Candlestick" && this.showVolume)) {
						c.push("xAxis");
						c.push("xAxis2")
					} else {
						if (this.graphType == "Circular") {
							c.push("xAxis");
							c.push("rAxis")
						} else {
							c.push("xAxis")
						}
					}
				}
			}
		}
		return c
	};
	this.addRemoveSamplesInAxis = function(d, c, b) {
		if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
			if (b) {
				return this.removeSamplesFromAxis(d, c)
			} else {
				return this.addSamplesToAxis(d, c)
			}
		} else {
			if (this.graphType == "Scatter3D" || this.graphType == "Pie") {
				return this.switchSampleInAxis(d, c)
			}
		}
	};
	this.addSamplesToAxis = function(e, d) {
		if (this[d]) {
			if (this.isArray(e)) {
				var c = this.getObjectArray(this[d]);
				for (var b = 0; b < e.length; b++) {
					if (!c.hasOwnProperty(e[b])) {
						this[d].push(e[b])
					}
				}
			} else {
				this[d].push(e)
			}
			return false
		} else {
			return "Not a valid axis"
		}
	};
	this.removeSamplesFromAxis = function(f, e) {
		if (this[e]) {
			if (this[e].length > 1) {
				var c = {};
				var b = [];
				if (this.isArray(f)) {
					for (var d = 0; d < f.length; d++) {
						c[f[d]] = 1
					}
				} else {
					c[f] = 1
				}
				for (var d = 0; d < this[e].length; d++) {
					if (!c.hasOwnProperty(this[e][d])) {
						b.push(this[e][d])
					}
				}
				this[e] = b;
				return false
			} else {
				return e + " cannot be null"
			}
		} else {
			return "Not a valid axis"
		}
	};
	this.switchSampleInAxis = function(c, b) {
		if (this[b]) {
			this[b][0] = this.isArray(c) ? c[0] : c;
			return false
		} else {
			return "Not a valid axis"
		}
	};
	this.addRemoveVariablesInAxis = function(d, c, b) {
		if (b) {
			return this.removeVariablesFromAxis(d, c)
		} else {
			return this.addVariablesToAxis(d, c)
		}
	};
	this.addVariablesToAxis = function(d, c) {
		if (!this.data.a) {
			this.data.a = {}
		}
		if (!this.data.a[c]) {
			this.data.a[c] = []
		}
		if (this.isArray(d)) {
			for (var b = 0; b < d.length; b++) {
				this.data.a[c].push(d[b])
			}
		} else {
			this.data.a[c].push(d)
		}
		this.resetVariablesVisibleByAxis(c);
		return false
	};
	this.removeVariablesFromAxis = function(f, e) {
		if (this.data.a && this.data.a[e]) {
			var c = {};
			var b = [];
			if (this.isArray(f)) {
				for (var d = 0; d < f.length; d++) {
					c[f[d]] = 1
				}
			} else {
				c[f] = 1
			}
			for (var d = 0; d < this.data.a[e].length; d++) {
				if (!c.hasOwnProperty(this.data.a[e][d])) {
					b.push(this.data.a[e][d])
				}
			}
			this.data.a[e] = b
		}
		this.resetVariablesVisibleByAxis(e);
		return false
	};
	this.formatAxisValue = function(f, c) {
		if (this[c + "TickFormat"]) {
			if (this.graphType == "Candlestick" && this.summaryType == "volume") {
				if (this.xAxis2TickFormat) {
					return sprintf(this.xAxis2TickFormat, f)
				} else {
					return sprintf(this[c + "TickFormat"], f)
				}
			} else {
				return sprintf(this[c + "TickFormat"], f)
			}
		} else {
			if (this.graphType == "Candlestick" && this.summaryType == "volume") {
				return sprintf("%." + this.xAxis2Decs + "f", f)
			} else {
				if (f % 1 === 0) {
					if (f.toString().match("e")) {
						return f.toString()
					} else {
						return parseInt(f).toString()
					}
				} else {
					var e = Math.min(this[c + "Decs"], 20);
					var b = sprintf("%." + e + "f", f);
					var g = b.length;
					if (g > 8) {
						b = sprintf("%.3e", f)
					}
					while (b.substring(g - 1, g) == "0") {
						b = b.substring(0, g - 1);
						g = b.length
					}
					return b
				}
			}
		}
	};
	this.getAxisDataBySample = function(b) {
		var f = [];
		if (this.isArray(b)) {
			for (var d = 0; d < this.varIndices.length; d++) {
				var e = this.varIndices[d];
				for (var c = 0; c < b.length; c++) {
					f.push(this.getDataAtPos(e, b[c]))
				}
			}
		} else {
			for (var d = 0; d < this.varIndices.length; d++) {
				var e = this.varIndices[d];
				f.push(this.getDataAtPos(e, b))
			}
		}
		return f
	};
	this.getAxisRangeBySample = function(b) {
		return this.range(this.getAxisDataBySample(b))
	};
	this.getAxisIncrements = function(f, n, o, j, p) {
		var l, c;
		var h = 0;
		if (f == n) {
			return 0.1
		}
		if (j) {
			l = parseFloat(this.formatNumber((n - f) / o, h));
			while (l == 0) {
				h++;
				l = parseFloat(this.formatNumber((n - f) / o, h))
			}
			return l
		} else {
			if (n - f <= Number.MIN_VALUE) {
				return 0.1
			}
			var m = ((p || n) - f) * this.axisExtension;
			var d = f - m;
			var g = (p || n) + m;
			var i = g - d;
			var k = -Math.floor(Math.log(i / o) / Math.LN10);
			var e = Math.pow(10, -k);
			var h = this.getAxisDecimals(e);
			var b = ((i / o) / e);
			if (b < 1.5) {
				l = e
			} else {
				if (b < 2) {
					l = e * 2
				} else {
					if (b < 2.5) {
						l = e * 2.5
					} else {
						if (b < 5) {
							l = e * 5;
							c = e * 2.5
						} else {
							if (b < 7.5) {
								l = e * 7.5
							} else {
								l = e * 10;
								c = e * 5
							}
						}
					}
				}
			}
			if (this.getAxisMin(f, l) + (l * o) < n) {
				return this.getAxisIncrements(f, n, o, j, (p || n) + l)
			} else {
				if (c && this.getAxisMin(f, c) + (c * o) >= n) {
					return c
				} else {
					return l
				}
			}
		}
	};
	this.getAxisMin = function(b, c) {
		var d = c * Math.floor(b / c);
		return isNaN(d) ? 0 : d < 0 && this.minData >= 0 ? 0 : d
	};
	this.setAxis = function(c) {
		var d = this.isGroupedData ? this.data.w : this.data.y;
		var b = this.getSampleIndices(this[c]);
		if ((this.isArray(b) && b.length == 0) || (!this.isArray(b) && b == -1)) {
			this[c] = []
		}
		if (this[c].length == 0) {
			if (c == "xAxis") {
				this[c].push(d.smps[this.smpIndices[0]])
			} else {
				if (c == "yAxis") {
					if (d.smps.length > 1) {
						this[c].push(d.smps[this.smpIndices[1]])
					} else {
						this[c].push(d.smps[this.smpIndices[0]])
					}
				} else {
					if (c == "zAxis") {
						if (d.smps.length > 2) {
							this[c].push(d.smps[this.smpIndices[2]])
						} else {
							if (d.smps.length > 1) {
								this[c].push(d.smps[this.smpIndices[1]])
							} else {
								this[c].push(d.smps[this.smpIndices[0]])
							}
						}
					}
				}
			}
		} else {
			if (this.graphType == "Scatter3D" && this[c].length > 1) {
				this[c] = [this[c][0]]
			}
		}
	};
	this.setAxisValues = function(d) {
		var A, q, n, o, p, y, l, e, f;
		var c = {};
		var k = d + "MinorValues";
		var m = d + "Values";
		var w = d + "Ticks";
		var x = d + "TickFormat";
		var v = d + "Incr";
		var b = d + "Decs";
		var r = d + "Min";
		var u = d + "Max";
		var h = d + "Transform";
		var g = d + "MaxStrLength";
		if (this[h] == "percentile") {
			this[b] = 0;
			this[m] = [];
			this[k] = [];
			var z = [0, 25, 50, 75, 100];
			for (var t = 0; t < z.length; t++) {
				this[m].push(z[t])
			}
			for (var t = 5; t < 100; t += 5) {
				this[k].push(t)
			}
		} else {
			this[m] = [];
			this[k] = [];
			A = this[r];
console.log(A);
			p = this[v] / this[w];
			for (var t = 0; t <= this[w] + 1; t++) {
				for (var s = 0; s < this[w]; s++) {
					f = A + (p * s);
					this[k].push(f)
				}
				if (this[b] == 0 && A.toString().match(/\.5$/)) {
					this[b] = 1
				}
				if (this[x]) {
					q = sprintf(this[x], A)
				} else {
					q = this.formatNumber(sprintf("%." + this[b] + "f", A), this[b])
				}
				if (c.hasOwnProperty(q) && !this[x]) {
					l = true
				} else {
					c[q] = 1
				}
				this[m].push(q);
				A += this[v]
			}
		}
		if (l && this[b] < 20) {
			this[b]++;
			this[m] = [];
			this[k] = [];
			this.setAxisValues(d)
		} else {
			e = this.getMaxText(this[m]);
			if (this[x]) {
				this[g] = e
			} else {
				this[g] = this.formatNumber(e, this[b])
			}
		}
	};
	this.setAxisAttributes = function(d, f, h, k, s) {
		var b = k && k.match(/log/) ? true : false;
		var r = d + "Ticks";
		var q = d + "Incr";
		var m = d + "Exact";
		var e = d + "AbsMin";
		var g = d + "AbsMax";
		var n = d + "Min";
		var p = d + "Max";
		var u = d + "Range";
		var c = d + "Decs";
		var i = d + "Transform";
		this.setRangeData(f, h, b, s);
		if (this.minData == this.maxData) {
			this.maxData += 0.5
		}
		if (k) {
			if (k == "log2") {
				this.minData = Math.log(this.minData) / Math.LN2;
				this.maxData = Math.log(this.maxData) / Math.LN2
			} else {
				if (k == "log10") {
					this.minData = Math.log(this.minData) / Math.LN10;
					this.maxData = Math.log(this.maxData) / Math.LN10
				} else {
					if (k == "exp2") {
						this.minData = Math.pow(2, this.minData);
						this.maxData = Math.pow(2, this.maxData)
					} else {
						if (k == "exp10") {
							this.minData = Math.pow(10, this.minData);
							this.maxData = Math.pow(10, this.maxData)
						} else {
							if (k == "percentile") {
								this.minData = 0;
								this.maxData = 100
							}
						}
					}
				}
			}
		}
		this[e] = this.setMin == null ? this.minData : this[e];
		this[g] = this.setMax == null ? this.maxData : this[g];
		var o = this.isHistogram || this.graphType.match(/Stacked|Bar|Area/) || (k && k == "percentile");
		var l = this[this.axisAlgorithm](this.minData, this.maxData, this[r], this.axisWilkinsonLoose);
		var j = (this.maxData - this.minData) * this.axisExtension / 2;
		var t = this[r];
		this[q] = l[1] - l[0];
		this[c] = this.getAxisDecimals(this[q]);
		this[n] = l[0];
		this[p] = l[l.length - 1];
		this[r] = l.length;
		this.setAxisValues(d);
		if (l[0] < this.minData || o) {
			this[n] = l[0]
		} else {
			this[n] = this.minData - j
		}
		if (l[l.length - 1] > this.maxData || o) {
			this[p] = l[l.length - 1]
		} else {
			this[p] = this.maxData + j
		}
		this[u] = this[p] - this[n];
		this[r] = t
	};
	this.setAxes = function(c) {
		if (this.smpIndices && this.smpIndices.length < 1) {
			return
		}
		if (this.graphType.match(/Correlation/)) {
			var e = this.isGroupedData ? this.data.w : this.data.y;
			this.setMin = null;
			this.setMax = null;
			if (this.correlationAnchorLegend) {
				this.setAxisAttributes("xAxis")
			}
			if (!e.cor || e.cor.length == 0) {
				this.summarize("cor");
				this.setRangeData("cor")
			}
			if (!this.yAxisTitle) {
				this.yAxisTitle = "Correlation"
			}
		} else {
			if (this.graphType.match(/Scatter|Pie/)) {
				var s = this.smpIndices;
				var o = ["xAxis"];
				var b = ["X"];
				if (this.graphType.match(/Scatter/)) {
					o.push("yAxis");
					b.push("Y")
				}
				if (this.graphType.match(/ScatterBubble2D|Scatter3D/)) {
					o.push("zAxis");
					b.push("Z")
				}
				if (this.graphType == "Scatter3D") {
					this.xAxisTicks = 10;
					this.yAxisTicks = 10;
					this.zAxisTicks = 10
				}
				for (var j = 0; j < o.length; j++) {
					var k = o[j] + "Indices";
					var h = "setMin" + b[j];
					var q = "setMax" + b[j];
					this.setMin = null;
					this.setMax = null;
					this.setAxis(o[j]);
					this[k] = this.getSampleIndices(this[o[j]]);
					if (this.scatterAxesEqual) {
						this.setSamplesVisible(s)
					} else {
						this.setSamplesVisible(this[k])
					}
					if (this[h] != null) {
						this.setMin = this[h]
					}
					if (this[q] != null) {
						this.setMax = this[q]
					}
					this.setAxisAttributes(o[j], j > 0 ? c : false, false, this[o[j] + "Transform"]);
					this.setSamplesVisible(s)
				}
				if (!this.scatterPlotMatrix) {
					if (!this.xAxisTitle || this.xAxisTitleDynamic) {
						this.xAxisTitleDynamic = true;
						this.xAxisTitle = this.xAxis.length == 1 ? this.xAxis[0] : " "
					}
					if (this.graphType.match(/Scatter/)) {
						if (!this.yAxisTitle || this.yAxisTitleDynamic) {
							this.yAxisTitleDynamic = true;
							this.yAxisTitle = this.yAxis.length == 1 ? this.yAxis[0] : " "
						}
						if (this.graphType.match(/ScatterBubble2D|Scatter3D/)) {
							if (!this.zAxisTitle || this.zAxisTitleDynamic) {
								this.zAxisTitleDynamic = true;
								this.zAxisTitle = this.zAxis.length == 1 ? this.zAxis[0] : " "
							}
						}
					}
				}
			} else {
				if (this.graphType.match(/Genome/)) {
					this.setMax = this.setMaxX != null ? this.setMaxX : null;
					this.setMin = this.setMinX != null ? this.setMinX : null;
					this.setRangeData("genome");
					this.xAxisExact = true;
					this.xAxisTransform = false;
					this.xAxisAbsMin = this.minData;
					this.xAxisAbsMax = this.maxData;
					this.xAxisMin = this.minData - 1;
					this.xAxisMax = this.maxData + 1;
					this.xAxisDecs = 0;
					this.xAxisRange = this.xAxisMax - this.xAxisMin;
					this.xAxisTicks = this.genomeTicks;
					this.xAxisIncr = this.xAxisRange / this.xAxisTicks;
					this.setAxisValues("xAxis")
				} else {
					var n = this.smpIndices;
					var d = this.varIndices;
					var g = this.grpIndices;
					var l = this.varIndices;
					var r = (this.graphType == "Dotplot" || this.graphType == "DotLine") && this.isGroupedData ? true : false;
					var f = this.graphType.match(/Percent/) || (this.graphType.match(/Area/) && this.areaType.match(/percent/)) ? "percentile" : this.xAxisTransform;
					var m = this.graphType.match(/Stacked/) || (this.graphType.match(/Area/) && this.areaType.match(/stacked/)) ? true : false;
					var p = this.graphType == "Candlestick" ? "candle" : f ? f : false;
					if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && !this.data.a) {
						this.data.a = {
							xAxis: [],
							xAxis2: []
						};
						this.xAxisVarIndices = [];
						this.xAxis2VarIndices = [];
						for (var j = 0; j < this.varIndices.length - 1; j++) {
							this.data.a.xAxis.push(this.data.y.vars[this.varIndices[j]]);
							this.xAxisVarIndices.push(this.varIndices[j])
						}
						this.data.a.xAxis2.push(this.data.y.vars[this.varIndices.length - 1]);
						this.xAxis2VarIndices.push(this.varIndices[this.varIndices.length - 1])
					}
					if (this.varIndicesStart > -1 || this.smpIndicesStart > -1) {
						if (this.graphType == "Heatmap") {
							this.graphOrientation = "horizontal"
						}
					} else {
						if (this.graphType == "StackedPercent" || this.graphType == "StackedPercentLine" || (this.graphType.match(/Area/) && this.areaType.match(/percent/))) {
							this.setMinX = null;
							this.setMaxX = null;
							this.xAxisExact = true
						} else {
							if ((this.graphType == "Boxplot" && !this.isGroupedData && this.groupingFactors.length == 0) || this.summarizeBoxplot) {
								this.summarize("iqr");
								delete(this.summarizeBoxplot)
							}
						}
					}
					this.xAxis2Ticks = this.xAxisTicks;
					if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a) {
						this.setVariablesVisible(this.getVariablesVisibleByAxis("xAxis"))
					}
					this.setMax = this.setMaxX != null ? this.setMaxX : null;
					this.setMin = this.setMinX != null ? this.setMinX : null;
					this.setAxisAttributes("xAxis", p, r, f, m);
					this.xAxisTitle = this.xAxisTitle ? this.xAxisTitle : this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "";
					if ((this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a) || (this.graphType == "Candlestick" && this.showVolume)) {
						p = this.graphType == "Candlestick" ? "volume" : false;
						if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/)) {
							this.setVariablesVisible(l);
							this.setVariablesVisible(this.getVariablesVisibleByAxis("xAxis2"))
						}
						this.setMax = this.setMaxX2 != null ? this.setMaxX2 : null;
						this.setMin = this.setMinX2 != null ? this.setMinX2 : null;
						this.setAxisAttributes("xAxis2", p, r, f, m);
						this.xAxis2Title = this.xAxis2Title ? this.xAxis2Title : this.data.y.desc && this.data.y.desc[1] ? this.data.y.desc[1] : ""
					}
					this.setMax = this.setMaxR != null ? this.setMaxR : this.setMax;
					this.setMin = this.setMinR != null ? this.setMinR : this.setMin;
					if (this.graphType == "Circular" && this.rAxis) {
						this.setAxisAttributes("rAxis", "circular", r, f, false, true)
					}
					this.setVariablesVisible(l);
					this.smpIndices = n;
					this.varIndices = d;
					this.grpIndices = g
				}
			}
		}
	};
	this.setScatterPointSize = function() {
		this.scatterPointSize = this.varIndices.length > 50 ? this.sizes[1] : this.varIndices.length > 20 ? this.sizes[2] : this.sizes[3];
		if (this.layoutComb) {
			this.scatterPointSize = Math.ceil(this.scatterPointSize / this.layoutRows)
		}
	};
	this.setAxisUnits = function(d, f) {
		var e = d + "Unit";
		var c = d + "Range";
		var b = f ? f : d.substring(0, 1);
		this[e] = this[b] / this[c]
	};
	this.setAxisFont = function(f, e) {
		if (this.autoScaleFont) {
			var b = this.setPropertyFontSize(e, "decorationFont");
			var d = this.setPropertyFontSize(e, "axisTickFont");
			var c = this.setPropertyFontSize(e, "axisTitleFont");
			this.adjustFont(f, "axisTitleFont", e)
		} else {
			this.decorationFont = this.decorationFontStyle + " " + parseInt(this.decorationFontSize) + "px " + this.fontName;
			this.axisTickFont = this.axisTickFontStyle + " " + parseInt(this.axisTickFontSize) + "px " + this.fontName;
			this.axisTitleFont = this.axisTitleFontStyle + " " + parseInt(this.axisTitleFontSize) + "px " + this.fontName
		}
	};
	this.getAxisFont = function(b) {
		if (b >= 600) {
			return 12
		} else {
			if (b >= 400) {
				return 10
			} else {
				if (b >= 200) {
					return 8
				} else {
					return 6
				}
			}
		}
	};
	this.initializeAxis = function() {
		if (!this.graphType.match(/Venn|Network|Video/)) {
			if (!a) {
				this.setAxes();
				this.setColorBrew()
			}
		}
	};
	this.initializeAxis()
};
CanvasXpress.prototype.Pie = function(a) {
	this.setVarPie = function() {
		var g = [];
		var b = this.smpIndices[0];
		if (this.varIndices.length >= this.maxPieSectors - 1) {
			var f = this;
			this.varIndices.sort(function(h, d) {
				return f.data.y.data[d][b] - f.data.y.data[h][b]
			})
		}
		for (var c = 0; c < this.varIndices.length; c++) {
			var e = this.varIndices[c];
			g.push(this.getDataAtPos(e, b))
		}
		this.varPie = this.setPieData(g, true)
	};
	this.setPieFont = function() {
		if (this.autoScaleFont) {
			var b = Math.min(this.width, this.height) * (1 - this.percentAspectRatioPlotArea);
			this.setAxisFont("Pie", b)
		}
	};
	this.setPieXYDimensions = function() {
		if (this.showLegend) {
			if (this.legendPosition == "right") {
				this.right = this.layoutComb && !this.isDOE ? this.layoutRight : this.layoutComb ? Math.min(this.layoutWidth / 3, this.legendVariableWidth) : Math.min(this.width / 3, this.legendVariableWidth)
			} else {
				this.bottom = this.layoutComb && !this.isDOE ? this.layoutBottom : this.layoutComb ? Math.min(this.layoutHeight / 3, this.legendVariableHeight) : Math.min(this.height / 3, this.legendVariableHeight)
			}
		}
		this.x = this.layoutComb && !this.isDOE ? this.layoutWidth : this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
		this.y = this.layoutComb && !this.isDOE ? this.layoutHeight : this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
	};
	this.drawPieDataPoints = function() {
		var c = Math.min(this.x, this.y);
		var d = (c - (c / 5)) / 2;
		var b = this.marginLeft + this.offsetX + this.left + (this.x / 2);
		var e = this.marginTop + this.offsetY + this.top + (this.y / 2);
		this.setVarPie();
		this.drawPie(this.varPie, b, e, d, true)
	};
	this.drawPiePlot = function() {
		this.setPieFont();
		this.setLegends();
		this.setPieXYDimensions();
		this.drawPieDataPoints();
		this.drawLegend();
		this.drawTitle()
	};
	this.initializePiePlot = function() {
		if (this.xAxisMin < 0) {
			alert("Dude you can't draw a pie chart with negative numbers!");
			return
		}
		this.setPropertyFontSize(Math.min(this.width, this.height), "smpLabelFont");
		if (this.layoutValid) {
			this.drawLayoutCompartments(this.drawPiePlot)
		} else {
			this.drawPiePlot()
		}
	};
	if (!a) {
		this.initializePiePlot()
	}
};
CanvasXpress.prototype.Venn = function() {
	this.setVennXYDimensions = function() {
		var a;
		this.vennMarginLeft = 0;
		this.vennMarginTop = 0;
		this.setAxisFont("Venn", this.width);
		if (this.showLegend) {
			this.bottom = this.legendHeight
		}
		if (this.width <= this.height) {
			this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
		} else {
			this.x = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
		}
		this.y = this.vennGroups == 4 ? this.x * 0.8 : this.vennGroups == 3 ? this.x * 0.95 : this.vennGroups == 2 ? this.x * 0.65 : this.x;
		this.vennMarginTop = (this.height - (this.marginTop + this.top + this.y + this.bottom + this.marginBottom)) / 2;
		this.vennMarginLeft = (this.width - (this.marginLeft + this.left + this.x + this.right + this.marginRight)) / 2;
		if (this.x < 400) {
			var b = this.getFontPt(this.axisTickFont) - 2;
			if (this.x < 200) {
				b -= 1
			}
			this.axisTickFont = b + "px " + this.fontName
		}
		this.resizeCanvas()
	};
	this.drawVennBubble = function(d, e, f, b, c, a) {
		this.drawShape(f, d, e, b, b, c, this.foreground, "closed", a)
	};
	this.drawVennLayout = function() {
		var g, h, b, e;
		var a = [];
		for (var d in this.data.venn.legend) {
			a.push(d)
		}
		this.rectangleClear(0, 0, this.width, this.height);
		this.setGlobalCompositionOperation("lighter");
		if (this.vennGroups == 4) {
			g = this.vennMarginLeft + this.marginLeft + this.margin;
			h = this.vennMarginTop + this.marginTop + this.top;
			this.drawVennBubble(g + (this.x / 4.94), h + (this.x / 13), "ellipse2", this.x / 1.4, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)", Math.PI / 4);
			this.drawVennBubble(g + (this.x / 2.72), h + (this.x / -40.31), "ellipse2", this.x / 1.4, this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,153,51)", Math.PI / 4);
			this.drawVennBubble(g + (this.x / 3.43), h + (this.x / 1.72), "ellipse2", this.x / 1.4, this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)", -Math.PI / 4);
			this.drawVennBubble(g + (this.x / 7.96), h + (this.x / 2.07), "ellipse2", this.x / 1.4, this.vennColors.length > 3 && this.validateColor(this.vennColors[3]) ? this.validateColor(this.vennColors[3]) : "rgb(153,204,0)", -Math.PI / 4);
			b = [11.2, 3.05, 1.46, 1.08];
			e = [7, 42, 42, 7]
		} else {
			if (this.vennGroups == 3) {
				g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 2);
				h = this.vennMarginTop + this.marginTop + this.top + (this.x / 2.86);
				this.drawVennBubble(g, h, "circle", this.x / 2, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)");
				h += (this.x / 3.33);
				g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 3);
				this.drawVennBubble(g, h, "circle", this.x / 2, this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(0,255,0)");
				g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 1.5);
				this.drawVennBubble(g, h, "circle", this.x / 2, this.vennColors.length > 2 && this.validateColor(this.vennColors[2]) ? this.validateColor(this.vennColors[2]) : "rgb(0,0,255)");
				b = [2, 8.66, 1.13];
				e = [20, 2.3, 2.3]
			} else {
				if (this.vennGroups == 2) {
					g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 3);
					h = this.vennMarginTop + this.marginTop + this.top + (this.x / 2.67);
					this.drawVennBubble(g, h, "circle", this.x / 2, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(0,0,255)");
					g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 1.5);
					h = this.vennMarginTop + this.marginTop + this.top + (this.x / 2.67);
					this.drawVennBubble(g, h, "circle", this.x / 2, this.vennColors.length > 1 && this.validateColor(this.vennColors[1]) ? this.validateColor(this.vennColors[1]) : "rgb(255,0,0)");
					b = [3, 1.5];
					e = [16, 16]
				} else {
					if (this.vennGroups == 1) {
						g = this.vennMarginLeft + this.marginLeft + this.left + (this.x / 2);
						h = this.vennMarginTop + this.marginTop + this.top + (this.x / 2);
						this.drawShape("circle", g, h, this.x, this.x, this.vennColors.length > 0 && this.validateColor(this.vennColors[0]) ? this.validateColor(this.vennColors[0]) : "rgb(255,0,0)", this.foreground, "closed");
						b = [100];
						e = [100]
					}
				}
			}
		}
		this.setGlobalCompositionOperation("source-over");
		if (!this.vennLegendColors) {
			for (var d = 0; d < this.vennGroups; d++) {
				var c = this.vennMarginLeft + this.marginLeft + this.left + (this.x / b[d]);
				var f = this.vennMarginTop + this.marginTop + this.top + (this.x / e[d]);
				this.drawText(a[d], c, f, this.axisTickFont, this.axisTickColor, "center", "middle")
			}
		}
	};
	this.drawVennDataPoints = function() {
		var a, e, g;
		this.vennCompartments = this.vennCompartments.sort();
		if (this.vennGroups == 4) {
			g = [0, 8, 1, 12, 5, 9, 2, 14, 7, 11, 13, 4, 6, 10, 3];
			a = [5.6, 2.94, 3.5, 1.54, 3.29, 2, 2.59, 1.212, 2, 1.442, 1.4, 1.757, 2.31, 1.624, 2];
			e = [2.94, 7, 3.92, 7, 1.89, 4.06, 2.66, 2.94, 1.54, 1.89, 3.92, 1.729, 1.729, 2.66, 2.03];
			this.y = (this.x * 1.1) / 1.4
		} else {
			if (this.vennGroups == 3) {
				g = [0, 4, 1, 6, 3, 5, 2];
				a = [2, 3.5, 2.55, 1.4, 1.6, 2, 2];
				e = [3.6, 1.54, 2.07, 1.54, 2.07, 1.54, 1.83];
				this.y = this.x * 0.95
			} else {
				if (this.vennGroups == 2) {
					g = [0, 2, 1];
					a = [3.5, 1.4, 2];
					e = [2.66, 2.66, 2.66];
					this.y = this.x * 0.65
				} else {
					if (this.vennGroups == 1) {
						g = [0];
						a = [2];
						e = [2]
					}
				}
			}
		}
		for (var d = 0; d < g.length; d++) {
			var c = this.vennMarginLeft + this.marginLeft + this.left + (this.x / a[d]);
			var f = this.vennMarginTop + this.marginTop + this.top + (this.x / e[d]);
			var b = this.getFontPt(this.axisTickFont);
			var h = this.data.venn.data[this.vennCompartments[g[d]]] ? this.data.venn.data[this.vennCompartments[g[d]]] : 0;
			if (this.isArray(h)) {
				h = h[0]
			}
			this.drawText(h, c, f, this.axisTickFont, this.axisTickColor, "center", "middle");
			this.addArea(["circle", c, f, b], [g[d]])
		}
	};
	this.validateVennCompartments = function() {
		var b = "";
		if (this.vennGroups == 4 && this.vennCompartments.length != 15) {
			this.vennCompartments = ["A", "B", "AB", "C", "AC", "BC", "ABC", "D", "AD", "BD", "CD", "ABD", "ACD", "BCD", "ABCD"];
			b = "Unless there are exactly 15 vennCompartments the Venn data should be mapped to 'A', 'B', 'AB', 'C', 'AC', 'BC', 'ABC', 'D', 'AD', 'BD', 'CD', 'ABD', 'ACD', 'BCD', 'ABCD'"
		} else {
			if (this.vennGroups == 3 && this.vennCompartments.length != 7) {
				this.vennCompartments = ["A", "B", "AB", "C", "AC", "BC", "ABC"];
				b = "Unless there are exactly 7 vennCompartments the Venn data should be mapped to 'A', 'B', 'AB', 'C', 'AC', 'BC', 'ABC'"
			} else {
				if (this.vennGroups == 2 && this.vennCompartments.length != 3) {
					this.vennCompartments = ["A", "B", "AB"];
					b = "Unless there are exactly 3 vennCompartments the Venn data should be mapped to 'A', 'B', 'AB'"
				} else {
					if (this.vennGroups == 1 && this.vennCompartments.length != 1) {
						this.vennCompartments = ["A"];
						b = "Unless there are exactly 1 vennCompartments the Venn data should be mapped to 'A'  "
					}
				}
			}
		}
		for (var a = 0; a < this.vennCompartments.length; a++) {
			if (!this.data.venn.data.hasOwnProperty(this.vennCompartments[a])) {
				alert("Data for Venn diagram do not conform to specifications. " + b);
				break
			}
		}
	};
	this.drawVennPlot = function() {
		this.validateVennCompartments();
		this.setLegends();
		this.setVennXYDimensions();
		this.showShadow = false;
		this.drawVennLayout();
		this.showShadow = this.tmpshowShadow;
		this.drawVennDataPoints();
		this.drawLegend();
		this.drawTitle()
	};
	this.initializeVennPlot = function() {
		this.transparency = null;
		this.tmpshowShadow = this.showShadow;
		this.background = "rgb(255,255,255)";
		this.foreground = "rgb(0,0,0)";
		this.drawVennPlot()
	};
	this.initializeVennPlot()
};
CanvasXpress.prototype.Correlation = function() {
	this.setCorrelationVarSmpLabelFont = function(a) {
		this.setPropertyFontSize(Math.min(this.width, this.height), "varLabelFont");
		this.setPropertyFontSize(Math.min(this.width, this.height), "smpLabelFont")
	};
	this.getCorrelationLabelsHeight = function() {
		var a = 0;
		if (this.correlationAxis == "samples") {
			if (this.meta.data.y.maxSmpChr > this.maxSmpStringLen) {
				a += this.measureText(this.meta.data.y.maxSmpStr.substring(0, this.maxSmpStringLen), this.smpLabelFont)
			} else {
				a += this.measureText(this.meta.data.y.maxSmpStr, this.smpLabelFont)
			}
		} else {
			if (this.meta.data.y.maxVarChr > this.maxVarStringLen) {
				a += this.measureText(this.meta.data.y.maxVarStr.substring(0, this.maxVarStringLen), this.varLabelFont)
			} else {
				a += this.measureText(this.meta.data.y.maxVarStr, this.varLabelFont)
			}
		}
		if (this.correlationAnchorLegend) {
			a += this.correlationAnchorLegendAlignWidth + this.margin
		}
		return a
	};
	this.setCorrelationXYDimensions = function() {
		this.corMarginLeft = 0;
		this.corMarginTop = 0;
		if (this.yAxisShow) {
			this.setAxisFont(this.yAxisTitle, Math.min(this.width, this.height));
			this.left = this.margin + this.getFontPt(this.axisTitleFont) + this.margin
		}
		if (this.width <= this.height) {
			this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
		} else {
			this.x = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
		}
		var a = this.correlationAxis == "variables" ? this.varIndices.length : this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
		this.diamondSize = this.x / a;
		this.setCorrelationVarSmpLabelFont(a);
		this.setLegendFont();
		this.y = this.x / 2 + (this.diamondSize / 2);
		if (this.xAxisShow) {
			this.top += this.margin + this.getCorrelationLabelsHeight() + this.margin
		}
		if (this.autoAdjust) {
			this.height = this.marginTop + this.top + this.y + this.bottom + this.marginBottom;
			this.width = this.marginLeft + this.left + this.x + this.right + this.marginRight
		} else {
			this.corMarginTop = (this.height - (this.marginTop + this.top + this.y + this.bottom + this.marginBottom)) / 2;
			this.corMarginLeft = (this.width - (this.marginLeft + this.left + this.x + this.right + this.marginRight)) / 2
		}
		this.resizeCanvas()
	};
	this.drawCorrelationLayout = function() {
		if (this.yAxisShow) {
			this.drawText(this.yAxisTitle, this.corMarginLeft + this.marginLeft + this.left / 2, this.marginTop + this.top + (this.y / 2), this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2)
		}
		if (this.xAxisShow) {
			var c = this.corMarginLeft + this.marginLeft + this.left + (this.diamondSize / 2);
			var p = (this.corMarginTop + this.marginTop + this.top) - this.margin;
			var o = (this.corMarginTop + this.marginTop + this.top) - (this.getCorrelationLabelsHeight() + this.margin);
			var n = o + this.correlationAnchorLegendAlignWidth;
			var k, f, h;
			var a = this.isGroupedData ? this.data.w : this.data.y;
			var r = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
			var m = this.correlationAxis == "samples" ? this.maxSmpStringLen : this.maxVarStringLen;
			if (this.correlationAnchorLegend) {
				h = this.correlationAxis == "samples" ? a.data[0] : this.getDataForSmpGrpAtIndex(0);
				if ((this.smpIndicesStart < 0 && this.correlationAxis == "samples") || (this.varIndicesStart < 0 && this.correlationAxis == "variables")) {
					r.sort(function(s, i) {
						return h[s] - h[i]
					})
				}
				this.setAxisUnits("xAxis")
			}
			if (this.correlationAxis == "samples") {
				k = a.smps;
				f = this.smpLabelFont
			} else {
				k = a.vars;
				f = this.varLabelFont
			}
			for (var g = 0; g < r.length; g++) {
				var q = r[g];
				var j = this.shortenText(k[q], m);
				var e = this.correlationAxis == "samples" ? this.getSmpColor(k[q]) : this.getVarColor(k[q]);
				var l = g / this.correlationLabelInterval;
				if (parseInt(l) == parseFloat(l)) {
					this.drawText(j, c, p, f, e, "left", "middle", -Math.PI / 2)
				}
				if (this.correlationAnchorLegend) {
					var d;
					if ((this.smpIndicesStart < 0 && this.correlationAxis == "samples") || (this.varIndicesStart < 0 && this.correlationAxis == "variables")) {
						d = h[q]
					} else {
						d = h[g]
					}
					var b = this.corMarginLeft + this.marginLeft + this.left + ((d - this.xAxisMin) * this.xAxisUnit);
					this.drawLine("line", b, o - this.margin, b, o, e);
					this.drawLine("line", b, o, c, n, e)
				}
				c += this.diamondSize
			}
		}
		c = (this.corMarginLeft + this.marginLeft + this.left + (this.x / 3)) - this.heatmapIndicatorWidth;
		p = this.width - (this.marginBottom + this.bottom + this.heatmapIndicatorHeight + (this.margin * 8));
		if (this.correlationAnchorLegend) {
			this.setRangeData("cor")
		}
		if (this.minData == null || this.maxData == null) {
			this.setRangeData("cor")
		}
		this.drawColorIndicator(c, p, this.getDefaultMetaDataObject(), "Correlation", true)
	};
	this.drawCorrelationDataPoints = function() {
		var c, o, b, n;
		var r = this.diamondSize / 2;
		var h = this.isGroupedData ? this.data.w.cor : this.data.y.cor;
		var q = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
		c = this.corMarginLeft + this.marginLeft + this.left + r;
		o = this.corMarginTop + this.marginTop + this.top + r;
		for (var l = 0; l < Math.ceil(q.length / 2); l++) {
			var p = q[l];
			b = c + (this.diamondSize * l);
			n = o;
			for (var g = l; g < q.length - l; g++) {
				var m = q[g];
				var e = h[p][m];
				var d = this.getColorForValue(false, e);
				if (isNaN(e)) {
					this.addArea(this.drawShape("diamond", b, n, this.diamondSize, this.diamondSize, this.missingDataColor, this.missingDataColor, "closed"), [p, m])
				} else {
					this.addArea(this.drawShape("diamond", b, n, this.diamondSize, this.diamondSize, d, d, "closed"), [p, m])
				}
				b += r;
				n += r
			}
			n -= this.diamondSize;
			for (var f = g - 2; f >= l; f--) {
				var a = q[(q.length - f) - 1];
				var e = h[a][m];
				var d = this.getColorForValue(false, e);
				if (isNaN(e)) {
					this.addArea(this.drawShape("diamond", b, n, this.diamondSize, this.diamondSize, this.missingDataColor, this.missingDataColor, "closed"), [a, m])
				} else {
					this.addArea(this.drawShape("diamond", b, n, this.diamondSize, this.diamondSize, d, d, "closed"), [a, m])
				}
				b += r;
				n -= r
			}
		}
		this.drawLine("line", this.corMarginLeft + this.marginLeft + this.left, this.corMarginTop + this.marginTop + this.top + r, this.corMarginLeft + this.marginLeft + this.left + (this.x / 2), this.corMarginTop + this.marginTop + this.top + this.y, this.foreground, false, "butt");
		this.drawLine("line", this.corMarginLeft + this.marginLeft + this.left + this.x, this.corMarginTop + this.marginTop + this.top + r, this.corMarginLeft + this.marginLeft + this.left + (this.x / 2), this.corMarginTop + this.marginTop + this.top + this.y, this.foreground, false, "butt");
		c = this.corMarginLeft + this.marginLeft + this.left + r;
		o = this.corMarginTop + this.marginTop + this.top;
		b = c + (this.x / 2);
		n = (this.corMarginTop + this.marginTop + this.top + this.y) - r;
		for (var l = 0; l < q.length; l++) {
			this.drawLine("line", c, o, b, n, this.foreground, false, "butt");
			c += this.diamondSize;
			b += r;
			n -= r
		}
		c = (this.corMarginLeft + this.marginLeft + this.left + this.x) - r;
		o = this.corMarginTop + this.marginTop + this.top;
		b = (this.corMarginLeft + this.marginLeft + this.left + (this.x / 2)) - r;
		n = (this.corMarginTop + this.marginTop + this.top + this.y) - r;
		for (var l = 0; l < q.length; l++) {
			this.drawLine("line", c, o, b, n, this.foreground, false, "butt");
			c -= this.diamondSize;
			b -= r;
			n -= r
		}
	};
	this.drawCorrelationPlot = function() {
		this.setCorrelationXYDimensions();
		this.drawCorrelationLayout();
		this.drawTitle();
		this.drawCorrelationDataPoints()
	};
	this.initializeCorrelationPlot = function() {
		this.drawCorrelationPlot()
	};
	this.initializeCorrelationPlot()
};
CanvasXpress.prototype.Scatter2D = function(a) {
	this.get2DYAxisWidth = function(b) {
		if (this.scatterPlotMatrix && !this.layoutAdjust) {
			return this.yAxisShow || b ? this.measureText(this.yAxisMaxStrLength, this.axisTickFont) + (this.margin * 3) : this.margin
		} else {
			var c = this.isGraphTime == "y" ? dateFormat(new Date(this.yAxisMax), this.timeFormat) : this.yAxisMaxStrLength;
			c = this.formatAxisValue(parseFloat(c), "yAxis");
			if (this.yAxisTitle && this.yAxisTitle != " ") {
				return this.yAxisShow ? this.getFontPt(this.axisTitleFont) + this.measureText(c, this.axisTickFont) + (this.margin * 5) : this.margin
			} else {
				return this.yAxisShow ? this.measureText(c, this.axisTickFont) + (this.margin * 3) : this.margin
			}
		}
	};
	this.get2DXAxisHeight = function(b) {
		if (this.scatterPlotMatrix && !this.layoutAdjust) {
			return this.xAxisShow || b ? this.getFontPt(this.axisTickFont) + (this.margin * 3) : this.margin
		} else {
			if (this.xAxisTitle && this.xAxisTitle != " ") {
				return this.xAxisShow ? this.getFontPt(this.axisTickFont) + this.getFontPt(this.axisTitleFont) + (this.margin * 5) : this.margin
			} else {
				return this.xAxisShow ? this.getFontPt(this.axisTickFont) + (this.margin * 3) : this.margin
			}
		}
	};
	this.set2DType = function() {
		if (this.isValidKaplanMeier()) {
			this.type2D = "KM"
		} else {
			if (this.graphType == "ScatterBubble2D" && this.xAxisIndices.length > 1 && this.xAxisIndices.length == this.yAxisIndices.length && this.xAxisIndices.length == this.zAxisIndices.length) {
				this.type2D = "XYZ"
			} else {
				if (this.xAxisIndices.length > 1 && this.xAxisIndices.length == this.yAxisIndices.length) {
					this.type2D = "XY"
				} else {
					if (this.xAxisIndices.length > this.yAxisIndices.length) {
						this.type2D = "X"
					} else {
						this.type2D = "Y"
					}
				}
			}
		}
	};
	this.set2DFont = function() {
		var b = this.xAxisTitle.length > this.yAxisTitle.length ? this.xAxisTitle : this.yAxisTitle;
		var c = Math.min(this.width, this.height) * (1 - this.percentAspectRatioPlotArea);
		this.setAxisFont(b, c)
	};
	this.reRangeData = function() {
		this.xAxis = [];
		for (var b = 0; b < this.data.d.kaplanMeier.length; b++) {
			this.xAxis.push(this.data.d.kaplanMeier[b].time);
			this.xAxisTitle = this.data.d.kaplanMeier[b].time
		}
		this.yAxisTitle = "Probability of Survival";
		this.setAxes("km")
	};
	this.set2DXYDimensions = function() {
		this.setLegends();
		this.right = this.isDOE ? this.margin * 5 : this.layoutComb ? 0 : this.margin;
		if (!this.layoutComb) {
			if (!this.legendInside) {
				if (this.showLegend && this.legendPosition == "right") {
					this.right += this.legendWidth + this.margin
				}
				if (this.showDecorations && this.showDecorationsLegend && this.decorationsPosition == "right") {
					this.right += this.legendDecorationWidth + this.margin
				}
			}
			if (this.yAxisHistogramShow) {
				this.right += this.yAxisHistogramHeight + (this.margin * 3)
			}
			if (this.graphType == "ScatterBubble2D" && this.zAxisShow) {
				this.right += this.getFontPt(this.axisTitleFont) + this.margin
			} else {
				this.right += this.margin
			}
		}
		this.left = this.isDOE ? this.get2DYAxisWidth() + (this.margin * 5) : this.layoutComb && !this.layoutAdjust ? this.margin : this.get2DYAxisWidth();
		this.top = this.isDOE ? this.margin * 10 : this.layoutComb ? this.margin : this.marginTop + this.margin;
		if (!this.layoutComb) {
			this.top += this.getTitleSubtitleHeight();
			if (this.xAxisHistogramShow) {
				this.top += this.xAxisHistogramHeight + (this.margin * 2)
			}
		} else {
			if (!this.scatterPlotMatrixType.match(/complete/)) {
				this.top += this.getFontPt(this.axisTitleFont) + this.margin + this.margin
			}
		}
		this.bottom = this.isDOE ? this.get2DXAxisHeight() + (this.margin * 3) : this.layoutComb && !this.layoutAdjust ? 0 : this.get2DXAxisHeight() + this.margin;
		if (!this.legendInside && !this.layoutComb) {
			if (this.showLegend && this.legendPosition == "bottom") {
				this.bottom += this.legendHeight + this.margin
			}
			if (this.showDecorations && this.showDecorationsLegend && this.decorationsPosition == "bottom") {
				this.bottom += this.legendDecorationHeight + this.margin
			}
		}
		var b = this.motionBy ? this.width - 40 : this.width;
		var c = this.motionBy ? this.height - 40 : this.height;
		this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : b - (this.marginLeft + this.left + this.right + this.marginRight);
		this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : c - (this.marginTop + this.top + this.bottom + this.marginBottom);
		this.setScatterPointSize();
		if (this.isValidKaplanMeier()) {
			this.reRangeData()
		}
		this.setAxisUnits("xAxis");
		this.setAxisUnits("yAxis");
		if (this.motionBy) {
			this.addMotionDiv()
		}
	};
	this.set2DWireFrame = function() {
		var c = this.marginLeft + this.offsetX + this.left;
		var b = c + this.x;
		var e = this.marginTop + this.offsetY + this.top;
		var d = e + this.y;
		this.set2DWireFrameY(c, b);
		this.set2DWireFrameX(e, d)
	};
	this.set2DWireFrameY = function(e, c) {
		this.disableGradientTransparencyShadow();
		var b = this.yAxisTickStyle == "dotted" ? "dottedLine" : "line";
		if (this.yAxisMinorTicks) {
			for (var d = 0; d < this.yAxisMinorValues.length; d++) {
				var g = parseFloat(this.yAxisMinorValues[d]);
				if (g >= this.yAxisMin && g <= this.yAxisMax) {
					var f = (this.marginTop + this.offsetY + this.top + this.y) - ((g - this.yAxisMin) * this.yAxisUnit);
					this.drawLine(b, e, f, c, f, this.yAxisTickColor, this.outlineWidth / 3, "butt")
				}
			}
		}
		for (var d = 0; d < this.yAxisValues.length; d++) {
			var g = parseFloat(this.yAxisValues[d]);
			if (g >= this.yAxisMin && g <= this.yAxisMax) {
				var f = (this.marginTop + this.offsetY + this.top + this.y) - ((g - this.yAxisMin) * this.yAxisUnit);
				if (this.yAxisMajorTicks) {
					if (this.yAxisShow) {
						this.drawLine(b, e - this.margin, f, c, f, this.yAxisTickColor, false, "butt")
					} else {
						if (this.yAxisS2Show) {
							this.drawLine(b, e, f, c + this.margin, f, this.yAxisTickColor, false, "butt")
						} else {
							this.drawLine(b, e, f, c, f, this.yAxisTickColor, false, "butt")
						}
					}
				} else {
					this.drawLine(b, e - this.margin, f, e, f, this.yAxisTickColor, false, "butt")
				}
			}
		}
		this.enableGradientTransparencyShadow()
	};
	this.set2DWireFrameX = function(g, f) {
		this.disableGradientTransparencyShadow();
		var b = this.xAxisTickStyle == "dotted" ? "dottedLine" : "line";
		if (this.xAxisMinorTicks) {
			for (var e = 0; e < this.xAxisMinorValues.length; e++) {
				var h = parseFloat(this.xAxisMinorValues[e]);
				if (h >= this.xAxisMin && h <= this.xAxisMax) {
					var d = (this.marginLeft + this.offsetX + this.left) + ((h - this.xAxisMin) * this.xAxisUnit);
					this.drawLine(b, d, g, d, f, this.xAxisTickColor, this.outlineWidth / 3, "butt")
				}
			}
		}
		for (var e = 0; e < this.xAxisValues.length; e++) {
			var h = parseFloat(this.xAxisValues[e]);
			if (h >= this.xAxisMin && h <= this.xAxisMax) {
				var d = (this.marginLeft + this.offsetX + this.left) + ((h - this.xAxisMin) * this.xAxisUnit);
				if (this.xAxisMajorTicks) {
					if (this.xAxisShow) {
						this.drawLine(b, d, g, d, f + this.margin, this.xAxisTickColor, false, "butt")
					} else {
						if (this.xAxisS2Show) {
							if (!this.scatterPlotMatrixType.match(/complete/)) {
								var c = this.getFontPt(this.axisTitleFont) + this.margin + this.margin;
								this.drawLine(b, d, g - (c + this.margin), d, g - c, this.xAxisTickColor, false, "butt");
								this.drawLine(b, d, g, d, f, this.xAxisTickColor, false, "butt")
							} else {
								this.drawLine(b, d, g - this.margin, d, f, this.xAxisTickColor, false, "butt")
							}
						} else {
							this.drawLine(b, d, g, d, f, this.xAxisTickColor, false, "butt")
						}
					}
				} else {
					this.drawLine(b, d, f, d, f + this.margin, this.xAxisTickColor, false, "butt")
				}
			}
		}
		this.enableGradientTransparencyShadow()
	};
	this.set2DLayout = function() {
		var d = this.marginLeft + this.offsetX + this.margin + (this.getFontPt(this.axisTitleFont) / 2);
		var f = this.marginTop + this.offsetY + this.top + (this.y / 2);
		if (this.yAxisShow && !this.scatterPlotMatrix) {
			this.drawText(this.yAxisTitle, d, f, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2)
		}
		d = this.marginLeft + this.offsetX + this.left - (this.margin * 2);
		var b = this.marginLeft + this.offsetX + this.left + this.x + this.margin + this.margin;
		if (this.yAxisTransform && this.yAxisTransform.match(/log/) && !this.yAxisTransformTicks) {
			this.yAxisDecs = parseInt(Math.abs(this.yAxisMin))
		}
		var j = this.yAxisTransform && this.yAxisTransform == "percentile" ? this.yAxisValues.length : this.yAxisValues.length - 1;
		for (var c = 0; c < j; c++) {
			var h = parseFloat(this.yAxisValues[c]);
			if (h >= this.yAxisMin && h <= this.yAxisMax) {
				var g = this.yAxisTransform && !this.yAxisTransformTicks ? this.formatAxisValue(this.transformValue(this.yAxisTransform, h, true), "yAxis") : this.isGraphTime == "y" ? dateFormat(new Date(this.yAxisMin + h), this.timeFormat) : this.formatAxisValue(h, "yAxis");
				f = (this.marginTop + this.offsetY + this.top + this.y) - ((h - this.yAxisMin) * this.yAxisUnit);
				if (this.yAxisShow) {
					this.drawText(g, d, f, this.axisTickFont, this.axisTickColor, "right", "middle")
				}
				if (this.yAxisS2Show) {
					this.drawText(g, b, f, this.axisTickFont, this.axisTickColor, "left", "middle")
				}
			}
		}
		d = this.marginLeft + this.offsetX + this.left + (this.x / 2);
		f = this.marginTop + this.offsetY + this.top + this.y + this.margin + this.margin + this.getFontPt(this.axisTickFont) + this.margin + this.margin + (this.getFontPt(this.axisTitleFont) / 2);
		if (this.xAxisShow && !this.scatterPlotMatrix) {
			this.drawText(this.xAxisTitle, d, f, this.axisTitleFont, this.axisTitleColor, "center", "middle")
		}
		f = this.marginTop + this.offsetY + this.top + this.y + this.margin + this.margin + (this.getFontPt(this.axisTickFont) / 2);
		var e = this.marginTop + this.offsetY + this.top - (this.margin + this.margin + (this.getFontPt(this.axisTickFont) / 2));
		if (!this.scatterPlotMatrixType.match(/complete/)) {
			e -= this.getFontPt(this.axisTitleFont) + this.margin + this.margin
		}
		if (this.xAxisTransform && this.xAxisTransform.match(/log/) && !this.xAxisTransformTicks) {
			this.xAxisDecs = parseInt(Math.abs(this.xAxisMin))
		}
		var j = this.xAxisTransform && this.xAxisTransform == "percentile" ? this.xAxisValues.length : this.xAxisValues.length - 1;
		for (var c = 0; c < j; c++) {
			var h = parseFloat(this.xAxisValues[c]);
			if (h >= this.xAxisMin && h <= this.xAxisMax) {
				var g;
				if (this.isCreateHistogram) {
					g = this.formatAxisValue((h - this.xAxisMin) + this.isCreateHistogram[0], "xAxis")
				} else {
					g = this.xAxisTransform && !this.xAxisTransformTicks ? this.formatAxisValue(this.transformValue(this.xAxisTransform, h, true), "xAxis") : this.isGraphTime == "x" ? dateFormat(new Date(this.xAxisMin + h), this.timeFormat) : this.formatAxisValue(h, "xAxis")
				}
				d = (this.marginLeft + this.offsetX + this.left) + ((h - this.xAxisMin) * this.xAxisUnit);
				if (this.xAxisShow) {
					this.drawText(g, d, f, this.axisTickFont, this.axisTickColor, "center", "middle")
				}
				if (this.xAxisS2Show) {
					this.drawText(g, d, e, this.axisTickFont, this.axisTickColor, "center", "middle")
				}
			}
		}
		if (this.graphType == "ScatterBubble2D") {
			if (this.zAxisShow) {
				d = this.marginLeft + this.offsetX + this.left + this.x + this.margin;
				f = this.marginTop + this.offsetY + this.top + (this.y / 2);
				this.drawText(this.zAxisTitle, d, f, this.axisTitleFont, this.axisTitleColor, "center", "bottom", Math.PI / 2)
			}
		}
		if (this.plotBox) {
			this.disableGradientTransparencyShadow();
			this.rectangle(this.marginLeft + this.offsetX + this.left, this.marginTop + this.offsetY + this.top, this.x, this.y, this.plotBoxColor, this.plotBoxColor, "open", false, this.outlineWidth);
			this.enableGradientTransparencyShadow()
		}
	};
	this.draw2DDataPoints = function() {
		if (this.motionBy && this.motionTrails) {
			this.draw2DDataPointsTrail()
		} else {
			this.draw2DDataPointsNotrail()
		}
	};
	this.draw2DDataPointsTrail = function() {
		var f = this.motionObject.varIndicesMotion.length;
		var d = f == 1 ? [0.5] : f == 2 ? [0.25, 0.5] : [0.1, 0.25, 0.5];
		var e = this.cloneObject(this.varIndices);
		var b = this.cloneObject(this.smpIndices);
		for (var c = 0; c < f; c++) {
			this.transparency = d[c];
			this.varIndices = this.motionObject.varIndicesMotion[c];
			this.smpIndices = this.motionObject.smpIndicesMotion[c];
			this.draw2DDataPointsNotrail()
		}
		this.transparency = null;
		this.varIndices = e;
		this.smpIndices = b;
		this.draw2DDataPointsNotrail()
	};
	this.setHistogram = function(p, o, c, q, e) {
		if (!this[p + "AxisHistogram"]) {
			this[p + "AxisHistogram"] = {
				data: [],
				vars: [],
				smps: [],
				cntx: [],
				hist: [],
				kde: [],
				stats: []
			};
			var k = this.getAxisDecimals(q);
			for (var g = 0; g <= o; g++) {
				var n = (c + (q * g)).toFixed(k);
				var h = (c + (q * (g + 1))).toFixed(k);
				this[p + "AxisHistogram"].vars.push("Bin" + (g + 1) + " (" + n + " to " + h + ")");
				this[p + "AxisHistogram"].data[g] = [];
				this[p + "AxisHistogram"].data[g][0] = q * (g + 1);
				this[p + "AxisHistogram"].hist[g] = [];
				for (var f = 0; f < e; f++) {
					this[p + "AxisHistogram"].hist[g][f] = []
				}
			}
			this[p + "AxisHistogram"].smps.push("Bin");
			this[p + "AxisHistogram"].min = c;
			this[p + "AxisHistogram"].size = q;
			this[p + "AxisHistogram"].decs = k;
			this[p + "AxisHistogram"].len = e
		}
	};
	this.setKde = function(b) {
		var e = this.marginLeft + this.offsetX + this.left;
		var o = this.marginTop + this.offsetY + this.top + this.y;
		var h = this.data;
		if (h.y.kde && h.y.stats && this.showHistogramDensity) {
			var f = h.y.kde[0];
			var p = h.y.stats[0];
			var c = [];
			var n = [];
			for (var g = 0; g < f.length; g++) {
				var m = f[g][0];
				var i = f[g][1] * p[0];
				c.push(e + ((m - f[0][0]) * this.xAxisUnit));
				n.push(o - ((i - this.yAxisMin) * this.yAxisUnit))
			}
			this.drawLine("spline", c, n, false, false, this.foreground, 1, false, false, false, true)
		}
	};
	this.draw2DDataPointsNotrail = function() {
		var D, c, C, aE;
		var aC, au, M, aw, s, aD, N, az;
		var X, J, am, E, ay, aa, N, az;
		var L, ax, v, ag;
		var G = [];
		var A = [];
		var Y = this;
		var ao = this.marginLeft + this.offsetX + this.left;
		var ai = this.marginTop + this.offsetY + this.top + this.y;
		if (this.type2D == "KM") {
			return
		} else {
			if (this.isHistogram) {
				this.histogramBarWidth = (this.isCreateHistogram[1] * this.xAxisUnit) - 1;
				var af = this.histogramStagger ? this.histogramBarWidth : this.histogramBarWidth / (this.isCreateHistogram[4].length);
				for (var V = 0; V < this.isCreateHistogram[4].length; V++) {
					var at = this.isCreateHistogram[4][V];
					var n = this.varIndices.length == 1 || !this.histogramStagger ? this.colors[at % this.colors.length] : this.addColorTransparency(this.colors[at % this.colors.length], 0.7);
					for (var ar = 0; ar < this.varIndices.length; ar++) {
						var B = this.varIndices[ar];
						var ad = this.getDataAtPos(B, 0);
						var ab = this.getDataAtPos(B, at + 1);
						if (this.histogramStagger) {
							D = (this.marginLeft + this.offsetX + this.left) + (ad * this.xAxisUnit) - this.histogramBarWidth
						} else {
							D = (this.marginLeft + this.offsetX + this.left) + (ad * this.xAxisUnit) + (af * at) - this.histogramBarWidth
						}
						C = D + af;
						c = ai - ((ab - this.yAxisMin) * this.yAxisUnit);
						aE = ai - c;
						if (this.isVisibleSelectedDataPoint(B, at + 1) && ab > 0 && aE > 0.5) {
							if (this.selectDataMode == "area" && this.isInSelectedDataPoints(B, at)) {
								this.drawSelectedBackground(B, at, "rectangle", C - (af / 2), c + (aE / 2), af - 5, aE - 5, false, true);
								if (af > 6 && aE > 6) {
									this.addArea(this.rectangle(D + 3, c + 3, af - 6, aE - 6, n, false, f, false, false, true), [B, at + 1])
								}
							} else {
								this.addArea(this.rectangle(D, c, af, aE, n, false, false, false, false, true), [B, at + 1])
							}
							this.drawSelectedBackgroundLabel(B, at + 1, D, c)
						}
					}
					this.setKde(n)
				}
			} else {
				var Q = this.type2D == "XYZ" ? 1 : Math.max(this.xAxisIndices.length, this.yAxisIndices.length);
				var af = this.histogramBarWidth;
				var m = this.meta;
				if (!m.histograms) {
					m.histograms = {}
				}
				for (var at = 0; at < Q; at++) {
					this.resetStagingDrawingBuffer();
					var ac = this.type2D == "Y" || this.type2D == "XYZ" ? this.xAxisIndices[this.xAxisCurrent] : this.xAxisIndices[at];
					var I = this.type2D == "X" || this.type2D == "XYZ" ? this.yAxisIndices[this.yAxisCurrent] : this.yAxisIndices[at];
					var d = (this.graphType == "ScatterBubble2D" && !this.sizeBy && this.zAxisIndices.length > 0) || this.type2D == "XYZ" ? this.zAxisIndices[this.zAxisCurrent] : false;
					var F = this.isHistogram ? ac : ac + ":" + I;
					var u = [];
					var r = [];
					var g = [];
					var e = [];
					var K = [];
					var H = [];
					var P = {};
					for (var ar = 0; ar < this.varIndices.length; ar++) {
						if ((this.xAxisTransform == "percentile" && ((this.type2D.match(/Y|Z/) && ar == 0) || (this.type2D == "X"))) || (this.xAxisHistogramShow && !m.histograms.xAxisHistogram)) {
							aC = this.type2D == "XYZ" || this.xAxisTransform != "percentile" ? this.getAxisDataBySample(this.xAxisIndices) : this.getAxisDataBySample(ac);
							au = this.range(aC);
							aw = au[0];
							M = au[1];
							if (this.xAxisHistogramShow && ar == 0) {
								if ((this.type2D == "X" || this.type2D == "XY") && this.xAxisTransform == "percentile") {
									aC = this.getAxisDataBySample(this.xAxisIndices);
									au = this.range(aC)
								}
								s = this.histogramBins ? this.pretty((au[1] - au[0]) / this.histogramBins) : this.freedmanDiaconis(aC);
								N = this.getHistogramBin(au[0], s);
								az = this.getHistogramBin(s + au[1], s);
								aD = this.histogramBins ? this.histogramBins : (az - N) / s;
								this.setHistogram("x", aD, N, s, this.xAxisIndices.length);
								for (var ap = 0; ap <= aD; ap++) {
									u[ap] = 0
								}
								this.xAxisHistogram.smps.push(ac);
								this.xAxisHistogram.cntx.push([ac, I])
							}
						}
						if ((this.yAxisTransform == "percentile" && ((this.type2D.match(/X|Z/) && ar == 0) || (this.type2D == "Y"))) || (this.yAxisHistogramShow && !m.histograms.yAxisHistogram)) {
							X = this.type2D == "XYZ" || this.yAxisTransform != "percentile" ? this.getAxisDataBySample(this.yAxisIndices) : this.getAxisDataBySample(I);
							J = this.range(X);
							E = J[0];
							am = J[1];
							if (this.yAxisHistogramShow && ar == 0) {
								if ((this.type2D == "Y" || this.type2D == "XY") || this.yAxisTransform == "percentile") {
									X = this.getAxisDataBySample(this.yAxisIndices);
									J = this.range(X)
								}
								ay = this.histogramBins ? this.pretty((J[1] - J[0]) / this.histogramBins) : this.freedmanDiaconis(X);
								yBinMin = this.getHistogramBin(J[0], ay);
								yBinMax = this.getHistogramBin(ay + J[1], ay);
								aa = this.histogramBins ? this.histogramBins : (yBinMax - yBinMin) / ay;
								this.setHistogram("y", aa, yBinMin, ay, this.yAxisIndices.length);
								for (var ap = 0; ap <= aa; ap++) {
									r[ap] = 0
								}
								this.yAxisHistogram.smps.push(I);
								this.yAxisHistogram.cntx.push([ac, I])
							}
						}
						if (d !== false && ar == 0) {
							L = this.type2D == "XYZ" ? this.getAxisDataBySample(this.zAxisIndices) : this.getAxisDataBySample(d);
							ax = this.range(L);
							ag = ax[0];
							v = ax[1]
						}
						var B = this.varIndices[ar];
						var ad = this.xAxisTransform && this.xAxisTransform.match(/ceil|floor/) ? this.getDataAtPos(B, ac, false, this.xAxisTransform, this.xAxisTransformFloorValue, this.xAxisTransformCeilValue) : this.getDataAtPos(B, ac, false, this.xAxisTransform, aw, M);
						var ab = this.yAxisTransform && this.yAxisTransform.match(/ceil|floor/) ? this.getDataAtPos(B, I, false, this.yAxisTransform, this.yAxisTransformFloorValue, this.yAxisTransformCeilValue) : this.getDataAtPos(B, I, false, this.yAxisTransform, E, am);
						var Z = d !== false ? this.getDataAtPos(B, d, false, "percentile", ag, v) : false;
						var ah = this.getDataAtPos(B, ac, "stdev");
						var O = this.getDataAtPos(B, I, "stdev");
						var n = this.colorBy ? this.getPropertyValue(B, ac, "colorBy") : this.colors[at % this.colors.length];
						var ae = n;
						var S = this.shapeBy ? this.getPropertyValue(B, ac, "shapeBy") : this.shapes[0];
						var h = this.sizeBy ? parseInt(this.getPropertyValue(B, ac, "sizeBy")) : d !== false ? this.sizes[Math.floor(Z / 10) + 1] : this.scatterPointSize;
						var f = this.patternBy ? this.getPropertyValue(B, ac, "patternBy") : "closed";
						var p = this.scatterType && this.scatterType.match(/image/i) ? this.images[ar] : false;
						var W = p ? "image" : S;
						var an = this.isVisibleSelectedDataPoint(B, F);
						var U = this.isInSelectedDataPoints(B, F);
						var o = this.selectDataMode == "transparency" && this.isSelectDataPoints && !U;
						var av = this.ellipseBy && this.data.z && this.data.z.hasOwnProperty(this.ellipseBy) ? this.data.z[this.ellipseBy][B] : this.ellipseBy && this.ellipseBy == "variable" ? "variable" : false;
						if (this.varIndices.length < this.scatterOutlineThreshold) {
							var R = this.isColorTransparency(n);
							if (R != null) {
								ae = this.addColorTransparency(this.foreground, R, true)
							} else {
								ae = this.transparency ? this.addColorTransparency(this.foreground, this.transparency) : this.foreground
							}
						}
						if (this.xAxisHistogramShow && (this.type2D != "Y" || (this.type2D == "Y" && at == 0)) && !m.histograms.xAxisHistogram) {
							if (ad != null && ad != "" && !isNaN(ad)) {
								var aB = Math.max(Math.min(Math.floor((ad - N) / s), aD), 0);
								g.push(ad);
								if (!isNaN(aB)) {
									u[aB]++;
									this.xAxisHistogram.hist[aB][at].push(B)
								}
							}
						}
						if (this.yAxisHistogramShow && (this.type2D != "X" || (this.type2D == "X" && at == 0)) && !m.histograms.yAxisHistogram) {
							if (ab != null && ab != "" && !isNaN(ab)) {
								var aB = Math.max(Math.min(Math.floor((ab - yBinMin) / ay), aa), 0);
								e.push(ab);
								if (!isNaN(aB)) {
									r[aB]++;
									this.yAxisHistogram.hist[aB][at].push(B)
								}
							}
						}
						D = ao + ((ad - this.xAxisMin) * this.xAxisUnit);
						c = ai - ((ab - this.yAxisMin) * this.yAxisUnit);
						n = o ? this.addColorTransparency(n, 0.1) : n;
						ae = o ? this.addColorTransparency(ae, 0.1) : ae;
						if (this.ellipseBy && av) {
							if (!P.hasOwnProperty(av)) {
								P[av] = [
									[],
									[]
								]
							}
							P[av][0].push(ad);
							P[av][1].push(ab)
						}
						if (this.scatterType && this.scatterType == "bar" && this.type2D != "XYZ") {
							aE = (this.marginTop + this.offsetY + this.top + this.y) - c;
							if (an && ab > 0) {
								if (this.selectDataMode == "area" && U) {
									this.drawSelectedBackground(B, F, "rectangle", D, c + (aE / 2), (af * 2) - 5, aE - 5, false, true);
									this.addArea(this.rectangle(D + 2.5 - af, c + 2.5, (af * 2) - 5, aE - 5, n, false, f, false, false, true), [B, ac, I])
								} else {
									this.addArea(this.rectangle(D - af, c, af * 2, aE, n, false, pa3t, false, false, true), [B, ac, I])
								}
								this.drawSelectedBackgroundLabel(B, F, D, c)
							}
						} else {
							if (an) {
								if (!this.scatterType || !this.scatterType.match(/functio|lineStep/)) {
									this.addKeyStagingDrawingBuffer(ar, D, c, h, h);
									this.addDataStagingDrawingBuffer(ar, "drawSelectedBackground", [B, F, S, D, c, h, h, false, true]);
									if (ah && !isNaN(ah)) {
										C = (ah / 2) * this.xAxisUnit;
										this.addDataStagingDrawingBuffer(ar, "errorBar", [D, c, D + C, c, this.margin, n]);
										this.addDataStagingDrawingBuffer(ar, "errorBar", [D, c, D - C, c, this.margin, n])
									}
									if (O && !isNaN(O)) {
										aE = (O / 2) * this.yAxisUnit;
										this.addDataStagingDrawingBuffer(ar, "errorBar", [D, c, D, c + aE, -this.margin, n]);
										this.addDataStagingDrawingBuffer(ar, "errorBar", [D, c, D, c - aE, -this.margin, n])
									}
									this.addDataStagingDrawingBuffer(ar, "drawShape", [W, D, c, h, h, n, ae, f, false, false, true, false, false, false, p], [B, ac, I, d]);
									this.addDataStagingDrawingBuffer(ar, "drawSelectedBackgroundLabel", [B, F, D, c])
								}
								if (this.scatterType && this.scatterType.match(/line|functio/i) && ar < this.varIndices.length - 1 && this.isVisibleSelectedDataPoint(this.varIndices[ar + 1], F)) {
									B = this.varIndices[ar + 1];
									ad = this.xAxisTransform && this.xAxisTransform.match(/ceil|floor/) ? this.getDataAtPos(B, ac, false, this.xAxisTransform, this.xAxisTransformFloorValue, this.xAxisTransformCeilValue) : this.getDataAtPos(B, ac, false, this.xAxisTransform, aw, M);
									ab = this.yAxisTransform && this.yAxisTransform.match(/ceil|floor/) ? this.getDataAtPos(B, I, false, this.yAxisTransform, this.yAxisTransformFloorValue, this.yAxisTransformCeilValue) : this.getDataAtPos(B, I, false, this.yAxisTransform, E, am);
									C = ao + ((ad - this.xAxisMin) * this.xAxisUnit);
									aE = ai - ((ab - this.yAxisMin) * this.yAxisUnit);
									if (this.scatterType == "lineStep") {
										this.drawLine("line", D, c, C, c, n, false, false, false, false, true);
										this.drawLine("line", C, c, C, aE, n, false, false, false, false, true)
									} else {
										if (this.lineType == "spline") {
											G.push(D);
											A.push(c)
										} else {
											this.drawLine("line", D, c, C, aE, n, false, false, false, false, true)
										}
									}
								}
							}
						}
					}
					this.drawDataStagingDrawingBuffer();
					if (this.scatterType && this.scatterType.match(/line|functio/i) && this.lineType == "spline") {
						G.push(C);
						A.push(aE);
						this.drawLine("spline", G, A, false, false, n, false, false, false, false, true);
						G = [];
						A = []
					}
					if (this.xAxisHistogramShow && !m.histograms.xAxisHistogram) {
						for (var ar = 0; ar <= aD; ar++) {
							K.push(u[ar]);
							this.xAxisHistogram.data[ar][at + 1] = u[ar]
						}
					}
					if (this.yAxisHistogramShow && !m.histograms.yAxisHistogram) {
						for (var ar = 0; ar <= aa; ar++) {
							H.push(r[ar]);
							this.yAxisHistogram.data[ar][at + 1] = r[ar]
						}
					}
					if (this.showLoessFit) {
						var ad = this.getAxisDataBySample(ac);
						var ab = this.getAxisDataBySample(I);
						var T = this.loess([ad, ab], false, [ac, I]);
						var G = [];
						var A = [];
						if (ao) {
							for (var ar = 0; ar < this.loessDrawOptimizer; ar++) {
								G.push(ao + ((T[0][ar] - this.xAxisMin) * this.xAxisUnit));
								A.push(ai - ((T[1][ar] - this.yAxisMin) * this.yAxisUnit))
							}
							for (var ar = this.loessDrawOptimizer; ar < T[0].length - 1; ar++) {
								if (this.parseInt(T[0][ar]) == this.parseInt(T[0][ar - this.loessDrawOptimizer]) && this.parseInt(T[1][ar]) == this.parseInt(T[1][ar - this.loessDrawOptimizer])) {
									continue
								} else {
									G.push(ao + ((T[0][ar] - this.xAxisMin) * this.xAxisUnit));
									A.push(ai - ((T[1][ar] - this.yAxisMin) * this.yAxisUnit))
								}
							}
							G.push(ao + ((T[0][T[0].length - 1] - this.xAxisMin) * this.xAxisUnit));
							A.push(ai - ((T[1][T[0].length - 1] - this.yAxisMin) * this.yAxisUnit));
							this.drawLine("spline", G, A, false, false, this.loessColor, 2)
						}
					}
					if (this.ellipseBy) {
						var q = this.ellipseBy && this.data.z && this.data.z.hasOwnProperty(this.ellipseBy) ? this.meta.data.z[this.ellipseBy] : false;
						for (var av in P) {
							var aq = this.errorEllipse(P[av][0], P[av][1]);
							var n = q ? q.colors[q.order[av]] : this.colors[at % this.colors.length];
							var ak = ao + ((aq.cx - this.xAxisMin) * this.xAxisUnit);
							var aj = ai - ((aq.cy - this.yAxisMin) * this.yAxisUnit);
							var al = 2 * aq.rx * this.xAxisUnit;
							var aA = 2 * aq.ry * this.yAxisUnit;
							this.drawShape("oval", ak, aj, al, aA, false, n, "open", aq.rot)
						}
					}
				}
				if (this.xAxisHistogramShow && !m.histograms.xAxisHistogram) {
					au = this.range(K);
					this.xAxisHistogram.axis = this[this.axisAlgorithm](au[0], au[1], 3, this.axisWilkinsonLoose);
					this.xAxisHistogram.axisMin = Math.min(au[0], this.xAxisHistogram.axis[0]);
					this.xAxisHistogram.axisMax = Math.max(au[1], this.xAxisHistogram.axis[this.xAxisHistogram.axis.length - 1]);
					this.xAxisHistogram.axisUnit = this.xAxisHistogramHeight / (this.xAxisHistogram.axisMax - this.xAxisHistogram.axisMin);
					if (!m.histograms.xAxisHistogram) {
						m.histograms.xAxisHistogram = this.xAxisHistogram
					}
				}
				if (this.yAxisHistogramShow && !m.histograms.yAxisHistogram) {
					J = this.range(H);
					this.yAxisHistogram.axis = this[this.axisAlgorithm](J[0], J[1], 3, this.axisWilkinsonLoose);
					this.yAxisHistogram.axisMin = Math.min(J[0], this.yAxisHistogram.axis[0]);
					this.yAxisHistogram.axisMax = Math.max(J[1], this.yAxisHistogram.axis[this.yAxisHistogram.axis.length - 1]);
					this.yAxisHistogram.axisUnit = this.yAxisHistogramHeight / (this.yAxisHistogram.axisMax - this.yAxisHistogram.axisMin);
					if (!m.histograms.yAxisHistogram) {
						m.histograms.yAxisHistogram = this.yAxisHistogram
					}
				}
			}
		}
	};
	this.draw2DContour = function() {
		var d, q, c, p;
		var g = this.marginLeft + this.offsetX + this.left;
		var r = this.marginTop + this.offsetY + this.top + this.y;
		if (this.isContour) {
			var o = this.data.y.contour.list;
			var s = this.getColorBrew(this.colorSpectrum, 0, o[0].level, this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			var b = this.data.y.contour.xs;
			var h = this.data.y.contour.ys;
			if (this.contourType == "overlay") {
				for (var n = 0; n < o.length; n++) {
					d = g + (o[n][0].x * this.xAxisRange / b * this.xAxisUnit);
					q = r - (o[n][0].y * this.yAxisRange / h * this.yAxisUnit);
					for (var k = 1; k < o[n].length; k++) {
						c = g + (o[n][k].x * this.xAxisRange / b * this.xAxisUnit);
						p = r - (o[n][k].y * this.yAxisRange / h * this.yAxisUnit);
						this.drawLine("line", d, q, c, p, this.foreground, false, false, false, false, true);
						d = c;
						q = p
					}
				}
			} else {
				if (this.contourType == "color") {
					this.rectangle(g, r - this.y, this.x, this.y, this.getColorForValue(s, 0));
					for (var n = o.length - 1; n >= 0; n--) {
						var f = [];
						var m = [];
						var e = this.getColorForValue(s, o[n].level);
						for (var k = 0; k < o[n].length; k++) {
							f.push(g + (o[n][k].x * this.xAxisRange / b * this.xAxisUnit));
							m.push(r - (o[n][k].y * this.yAxisRange / h * this.yAxisUnit))
						}
						if (o[n][0].x != o[n][o[n].length - 1].x || o[n][0].y != o[n][o[n].length - 1].y) {
							if (o[n][0].x == 0 || o[n][0].x == b) {
								f.push(g + (o[n][0].x * this.xAxisRange / b * this.xAxisUnit));
								m.push(r - (o[n][o[n].length - 1].y * this.yAxisRange / h * this.yAxisUnit))
							} else {
								if (o[n][o[n].length - 1].x == 0 || o[n][o[n].length - 1].x == b) {
									f.push(g + (o[n][o[n].length - 1].x * this.xAxisRange / b * this.xAxisUnit));
									m.push(r - (o[n][0].y * this.yAxisRange / h * this.yAxisUnit))
								}
							}
						}
						this.drawShape("path", f, m, false, false, e, e, "closed", false, false, true)
					}
				}
			}
		}
	};
	this.draw2DHistograms = function() {
		var H, f;
		var v = ["x", "y"];
		this.resetClipArea();
		this.disableGradientTransparencyShadow();
		for (var E = 0; E < v.length; E++) {
			if (this[v[E] + "AxisHistogramShow"]) {
				var B = v[E] == "x" ? this.marginLeft + this.offsetX + this.left : this.marginLeft + this.offsetX + this.left + this.x + (this.margin * 2);
				var u = v[E] == "x" ? (this.marginTop + this.offsetY + this.top) - (this.margin * 2) : this.marginTop + this.offsetY + this.top + this.y;
				var z = v[E] == "x" ? [B, u - this.xAxisHistogramHeight, this.x, this.xAxisHistogramHeight] : [B, u - this.y, this.yAxisHistogramHeight, this.y];
				if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
					this.drawImage(CanvasXpress.cacheImages[this.getFileName(this.backgroundImage)], z[0], z[1], z[2], z[3])
				} else {
					if (this.backgroundType == "solid") {} else {
						if (this.backgroundType == "window" || this.backgroundType == "windowSolidGradient") {} else {
							var G = this.getLinearGradient(z[0], z[1], z[2], z[3], this.backgroundGradient1Color, this.backgroundGradient2Color);
							this.rectangle(z[0], z[1], z[2], z[3], G, this.foreground)
						}
					}
				}
				if (v[E] == "x") {
					this.set2DWireFrameX(u - this.xAxisHistogramHeight, u);
					for (var D = 0; D < this.xAxisHistogram.axis.length; D++) {
						f = u - (this.xAxisHistogram.axis[D] * this.xAxisHistogram.axisUnit);
						this.drawLine("line", B, f, B + this.x + this.margin, f, this.xAxisTickColor, false, "butt");
						this.drawText(this.xAxisHistogram.axis[D], B + this.x + this.margin + 1, f, this.axisTickFont, this.axisTickColor, "left", "middle")
					}
				} else {
					this.set2DWireFrameY(B, B + this.xAxisHistogramHeight);
					for (var D = 0; D < this.yAxisHistogram.axis.length; D++) {
						H = B + (this.yAxisHistogram.axis[D] * this.yAxisHistogram.axisUnit);
						this.drawLine("line", H, u - this.y, H, u + this.margin, this.xAxisTickColor, false, "butt");
						this.drawText(this.xAxisHistogram.axis[D], H, u + this.margin + 1, this.axisTickFont, this.axisTickColor, "left", "middle", Math.PI / 2)
					}
				}
				if (this.plotBox) {
					this.rectangle(z[0], z[1], z[2], z[3], false, this.plotBoxColor, "open")
				}
			}
		}
		this.enableGradientTransparencyShadow();
		for (var E = 0; E < v.length; E++) {
			if (this[v[E] + "AxisHistogramShow"]) {
				var F = v[E] == "x" ? this.meta.histograms.xAxisHistogram : this.meta.histograms.yAxisHistogram;
				var B = v[E] == "x" ? this.marginLeft + this.offsetX + this.left : this.marginLeft + this.offsetX + this.left + this.x + (this.margin * 2);
				var u = v[E] == "x" ? (this.marginTop + this.offsetY + this.top) - (this.margin * 2) : this.marginTop + this.offsetY + this.top + this.y;
				var J = v[E] == "x" ? (F.size * this.xAxisUnit) - 1 : (F.size * this.yAxisUnit) - 1;
				var s = v[E] == "x" ? this.histogramStagger ? J : J / F.len : this.histogramStagger ? J : J / F.len;
				var I = v[E] == "x" ? [B, u - this.xAxisHistogramHeight, this.x + 1, this.xAxisHistogramHeight + 1] : [B, u - this.y, this.yAxisHistogramHeight + 1, this.y + 1];
				var z = v[E] == "x" ? [B, u - this.xAxisHistogramHeight, this.x, this.xAxisHistogramHeight] : [B, u - this.y, this.yAxisHistogramHeight, this.y];
				this.setClipArea(I);
				for (var D = 0; D < F.vars.length; D++) {
					if (this.histogramStagger) {
						var d = [];
						var m = [];
						for (var C = 0; C < F.len; C++) {
							d.push(F.data[D][C + 1]);
							m.push(C)
						}
						m.sort(function(g, c) {
							return d[c] - d[g]
						})
					}
					for (var C = 0; C < F.len; C++) {
						var e = this.histogramStagger ? m[C] : C;
						var n = F.len == 1 || !this.histogramStagger ? this.colors[e % this.colors.length] : this.addColorTransparency(this.colors[e % this.colors.length], 0.7);
						var q = F.data[D][0];
						var p = F.data[D][e + 1];
						var A = this[v[E] + "AxisMin"] - F.min;
						if (!p) {
							continue
						}
						if (v[E] == "x") {
							H = this.histogramStagger ? B + ((q - A) * this.xAxisUnit) - J : B + ((q - A) * this.xAxisUnit) + (s * e) - J;
							f = p * this.xAxisHistogram.axisUnit;
							this.addArea(this.rectangle(H + 1, u - f, s - 2, f, n), [v[E] + "AxisHistogram-" + D + "-" + (e + 1) + "-" + C])
						} else {
							H = p * this.yAxisHistogram.axisUnit;
							f = this.histogramStagger ? u - ((q - A) * this.yAxisUnit) : u - ((q - A) * this.yAxisUnit) + (s * e);
							this.addArea(this.rectangle(B, f + 1, H, s - 2, n), [v[E] + "AxisHistogram-" + D + "-" + (e + 1) + "-" + C])
						}
					}
				}
				this.resetClipArea()
			}
		}
	};
	this.set2DprivateParams = function() {
		this.set2DType();
		this.set2DFont()
	};
	this.isValidKaplanMeier = function() {
		if (this.data.d && this.data.d.kaplanMeier) {
			return true
		} else {
			return false
		}
	};
	this.draw2DXYPlot = function() {
		this.setClipArea();
		this.drawDecorationData();
		this.draw2DContour();
		this.draw2DDataPoints();
		this.draw2DHistograms();
		this.resetClipArea()
	};
	this.draw2DPlot = function() {
		if (this.xAxis && this.yAxis) {
			this.validatePropertyValues()
		}
		this.set2DprivateParams();
		this.set2DXYDimensions();
		if (this.xAxis && this.yAxis) {
			this.drawPlotWindow();
			this.set2DWireFrame();
			this.set2DLayout();
			this.draw2DXYPlot();
			this.drawLegend();
			this.drawTitle()
		}
	};
	this.initializeScatter2D = function() {
		if (this.layoutValid && (this.scatterPlotMatrix || this.isDOE)) {
			this.drawLayoutCompartments(this.draw2DPlot)
		} else {
			if (!this.scatterPlotMatrix) {
				this.unsetScatterPlotMatrix()
			}
			this.draw2DPlot()
		}
	};
	if (!a) {
		this.initializeScatter2D()
	}
};
CanvasXpress.prototype.Scatter3D = function(a) {
	this.set3DText = function() {
		this.setAxisFont(false, this.x)
	};
	this.set3DXYDimensions = function() {
		var e = this.width - (this.marginLeft + this.marginRight);
		var c = this.height - (this.marginTop + this.marginBottom);
		if (this.showLegend) {
			this.setLegends();
			if (!this.legendInside && this.legendLayout.length > 0) {
				if (this.legendPosition == "right") {
					e -= this.legendWidth
				}
				if (this.legendPosition == "bottom") {
					c -= this.legendHeight
				}
			}
		}
		var b = Math.min(e, c);
		var d = 0;
		if (e > c) {
			d = e - c;
			this.left = d / 2;
			this.right = d / 2;
			this.top = 0;
			this.bottom = 0;
			this.funcX = d / 2;
			this.funcY = 0
		} else {
			d = c - e;
			this.left = 0;
			this.right = 0;
			this.top = d / 2;
			this.bottom = d / 2;
			this.funcX = 0;
			this.funcY = d / 2
		}
		this.x = b;
		this.y = b;
		this.setScatterPointSize()
	};
	this.draw3DLayout = function(j, b, o, k, c, p, g, d) {
		var f, r, e, q, n;
		var h = this.marginLeft + this.left + this.offsetX;
		var s = this.marginTop + this.top + this.offsetY;
		this.disableGradientTransparencyShadow();
		for (var m = 0; m < j.length; m++) {
			n = this.get3DTransfrom(j[m], b[m], o[m]);
			f = n[0] + h;
			r = n[1] + s;
			n = this.get3DTransfrom(k[m], c[m], p[m]);
			e = n[0] + h;
			q = n[1] + s;
			if (d == "dotted") {
				this.drawLine("dottedLine", f, r, e, q, g[m], false, "butt")
			} else {
				this.drawLine("line", f, r, e, q, g[m], false, "butt")
			}
		}
		this.enableGradientTransparencyShadow()
	};
	this.draw3DBar = function(q, o, n, v, Q, S) {
		var I = this.marginLeft + this.left + this.offsetX;
		var E = this.marginTop + this.top + this.offsetY;
		var k = I + (this.x / 2);
		var g = E + (this.y / 2);
		var M = v / 2;
		var N = [
			[
				[q - v, o, n - v],
				[q + v, o, n - v],
				[q + v, M, n - v],
				[q - v, M, n - v]
			],
			[
				[q + v, o, n - v],
				[q + v, o, n + v],
				[q + v, M, n + v],
				[q + v, M, n - v]
			],
			[
				[q - v, o, n + v],
				[q + v, o, n + v],
				[q + v, M, n + v],
				[q - v, M, n + v]
			],
			[
				[q - v, o, n - v],
				[q - v, o, n + v],
				[q - v, M, n + v],
				[q - v, M, n - v]
			],
			[
				[q - v, o, n - v],
				[q + v, o, n - v],
				[q + v, o, n + v],
				[q - v, o, n + v]
			]
		];
		var P = [];
		var R = [];
		var O = [];
		var H = [];
		for (var L = 0; L < N.length; L++) {
			P[L] = [];
			for (var K = 0; K < N[L].length; K++) {
				var G = this.xAxisMin < 0 ? 0 : this.xAxisMin;
				var D = this.yAxisMin < 0 ? 0 : this.yAxisMin;
				var C = this.zAxisMin < 0 ? 0 : this.zAxisMin;
				var A = ((N[L][K][0] - G) * this.xAxisUnit) - this.xAxisOffset;
				var u = this.yAxisOffset - ((N[L][K][1] - D) * this.yAxisUnit);
				var p = ((N[L][K][2] - C) * this.zAxisUnit) - this.zAxisOffset;
				P[L].push(this.get3DTransfrom(A, u, p))
			}
			H.push(L);
			O.push(this.euclidianDistance([(P[L][0][0] + P[L][2][0]) / 2, (P[L][0][1] + P[L][2][1]) / 2, (P[L][0][2] + P[L][2][2]) / 2], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]))
		}
		H.sort(function(d, c) {
			return O[c] - O[d]
		});
		for (var B = 1; B < P.length; B++) {
			var L = H[B];
			var F = B < 3 ? this.darkenLightenColor(Q, -B * 15) : Q;
			var m = [];
			var J = [];
			for (var K = 0; K < P[L].length; K++) {
				m.push(P[L][K][0] + I);
				J.push(P[L][K][1] + E)
			}
			this.addArea(this.drawShape("polygon", m, J, false, false, F, this.foreground, "closed"), S)
		}
	};
	this.set3DXLayout = function() {
		var z = [],
			d = [],
			n = [],
			w = [],
			c = [],
			k = [],
			e = [];
		var v, m, p, b, A, r, j, h;
		var f = this.lenX / 15;
		var q = (15 * -f) + f;
		var g = this.xAxisTitle ? this.xAxisTitle : this.is3DPlot && this.xAxis.length == 0 ? "Samples" : this.xAxisIndex ? this.data.y.smps[this.xAxisIndex] : this.xAxis[0];
		var u = this.marginLeft + this.left + this.offsetX;
		var o = this.marginTop + this.top + this.offsetY;
		if (this.show3DGrid) {
			p = q;
			v = 0;
			m = 0;
			while (p < this.lenX) {
				if ((v + 1) % 3) {
					if (this.xAxisType == "continuous") {
						z[m] = p;
						d[m] = -this.lenY;
						n[m] = this.lenZ;
						w[m] = p;
						c[m] = this.lenY;
						k[m] = this.lenZ;
						e.push(this.xAxisTickColor);
						m++
					}
					z[m] = -this.lenX;
					d[m] = p * this.lenY / this.lenX;
					n[m] = this.lenZ;
					w[m] = this.lenX;
					c[m] = p * this.lenY / this.lenX;
					k[m] = this.lenZ;
					e.push(this.xAxisTickColor);
					m++
				}
				p += f;
				v++
			}
			this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle);
			z = [], d = [], n = [], w = [], c = [], k = [], e = [];
			p = q;
			v = 0;
			m = 0;
			A = this.xAxisIncr;
			while (p < this.lenX) {
				if (!((v + 1) % 3)) {
					if (this.xAxisType == "continuous") {
						z[m] = p;
						d[m] = -this.lenY;
						n[m] = this.lenZ;
						w[m] = p;
						c[m] = this.lenY;
						k[m] = this.lenZ;
						e.push(this.foreground);
						m++
					}
					z[m] = -this.lenX;
					d[m] = p * this.lenY / this.lenX;
					n[m] = this.lenZ;
					w[m] = this.lenX;
					c[m] = p * this.lenY / this.lenX;
					k[m] = this.lenZ;
					e.push(this.foreground);
					b = this.get3DTransfrom(p, this.lenY, -this.lenZ);
					j = b[0] + u;
					h = b[1] + o;
					r = this.xAxisTime ? dateFormat(new Date(this.xAxisMin + A), this.timeFormat) : this.formatAxisValue(this.xAxisMin + A, "xAxis");
					A += this.xAxisIncr;
					if (this.xAxisShow && this.xAxisType == "continuous") {
						this.drawText(r, j, h + 5, this.axisTickFont, this.axisTickColor, "right", false, -Math.PI / 2)
					}
					m++
				}
				p += f;
				v++
			}
			this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle)
		}
		if (this.xAxisShow && !this.is3DPlot) {
			this.draw3DAxisTitle(q - (f * 2), this.lenX + f, this.lenY + (f * 4), this.lenY + (f * 4), -this.lenZ - (f * 4), -this.lenZ - (f * 4), g, "x")
		}
		z = [-this.lenX, -this.lenX, this.lenX, -this.lenX];
		d = [-this.lenY, -this.lenY, -this.lenY, this.lenY];
		n = [this.lenZ, this.lenZ, this.lenZ, this.lenZ];
		w = [-this.lenX, this.lenX, this.lenX, this.lenX];
		c = [this.lenY, -this.lenY, this.lenY, this.lenY];
		k = [this.lenZ, this.lenZ, this.lenZ, this.lenZ];
		e = [this.foreground, this.foreground, this.foreground, this.foreground];
		this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle)
	};
	this.set3DYLayout = function() {
		var A = [],
			d = [],
			n = [],
			z = [],
			c = [],
			k = [],
			e = [];
		var w, m, q, b, B, u, j, h;
		var f = this.lenY / 15;
		var r = (15 * -f) + f;
		var g = this.yAxisTitle ? this.yAxisTitle : this.is3DPlot && this.yAxis.length == 0 ? "Value" : this.yAxisIndex ? this.data.y.smps[this.yAxisIndex] : this.yAxis[0];
		var v = this.marginLeft + this.left + this.offsetX;
		var o = this.marginTop + this.top + this.offsetY;
		var p = [];
		if (this.show3DGrid) {
			q = r;
			w = 0;
			m = 0;
			while (q < this.lenY) {
				if ((w + 1) % 3) {
					if (this.zAxisType == "continuous") {
						A[m] = -this.lenX;
						d[m] = -this.lenY;
						n[m] = q * this.lenZ / this.lenY;
						z[m] = -this.lenX;
						c[m] = this.lenY;
						k[m] = q * this.lenZ / this.lenY;
						e.push(this.yAxisTickColor);
						m++
					}
					A[m] = -this.lenX;
					d[m] = q;
					n[m] = -this.lenZ;
					z[m] = -this.lenX;
					c[m] = q;
					k[m] = this.lenZ;
					e.push(this.yAxisTickColor);
					m++
				}
				q += f;
				w++
			}
			this.draw3DLayout(A, d, n, z, c, k, e, this.yAxisTickStyle);
			A = [], d = [], n = [], z = [], c = [], k = [], e = [];
			q = r;
			w = 0;
			m = 0;
			B = this.is3DPlot && this.yAxis.length == 0 ? this.yAxisIncr * this.xAxisTicks * 9 / 10 : this.yAxisIncr * 9;
			while (q < this.lenY) {
				if (!((w + 1) % 3)) {
					if (this.zAxisType == "continuous") {
						A[m] = -this.lenX;
						d[m] = -this.lenY;
						n[m] = q * this.lenZ / this.lenY;
						z[m] = -this.lenX;
						c[m] = this.lenY;
						k[m] = q * this.lenZ / this.lenY;
						e.push(this.foreground);
						m++
					}
					A[m] = -this.lenX;
					d[m] = q;
					n[m] = -this.lenZ;
					z[m] = -this.lenX;
					c[m] = q;
					k[m] = this.lenZ;
					e.push(this.foreground);
					b = this.get3DTransfrom(-this.lenX, q, -this.lenZ);
					j = b[0] + v;
					h = b[1] + o;
					u = this.formatAxisValue(this.yAxisMin + B, "yAxis");
					B -= this.is3DPlot && this.yAxis.length == 0 ? this.yAxisIncr * this.xAxisTicks / 10 : this.yAxisIncr;
					if (this.yAxisShow) {
						if (this.yRotate >= 45 && this.xRotate >= 45) {
							this.drawText(u, j, h + 5, this.axisTickFont, this.axisTickColor, "right", false, -Math.PI / 2)
						} else {
							this.drawText(u, j - 5, h, this.axisTickFont, this.axisTickColor, "right")
						}
					}
					m++
				}
				q += f;
				w++
			}
			this.draw3DLayout(A, d, n, z, c, k, e, this.yAxisTickStyle)
		}
		if (this.yAxisShow) {
			this.draw3DAxisTitle(-this.lenX - (f * 4), -this.lenX - (f * 4), r - (f * 2), this.lenY + f, -this.lenZ - (f * 4), -this.lenZ - (f * 4), g, "y")
		}
		A = [-this.lenX, -this.lenX, -this.lenX, -this.lenX];
		d = [-this.lenY, -this.lenY, -this.lenY, this.lenY];
		n = [-this.lenZ, this.lenZ, this.lenZ, this.lenZ];
		z = [-this.lenX, -this.lenX, -this.lenX, -this.lenX];
		c = [this.lenY, -this.lenY, this.lenY, this.lenY];
		k = [-this.lenZ, -this.lenZ, this.lenZ, -this.lenZ];
		e = [this.foreground, this.foreground, this.foreground, this.foreground];
		this.draw3DLayout(A, d, n, z, c, k, e, this.yAxisTickStyle)
	};
	this.set3DZLayout = function() {
		var n = this;
		var J = [],
			d = [],
			w = [],
			I = [],
			c = [],
			q = [],
			h = [];
		var G, r, A, v, b, L, E, p, o;
		var k, f, g, e, C, B, D, j;
		var m = this.zAxisTitle ? this.zAxisTitle : this.is3DPlot && this.zAxis.length == 0 ? "Variables" : this.zAxisIndex ? this.data.y.smps[this.zAxisIndex] : this.zAxis[0];
		var F = this.marginLeft + this.left + this.offsetX;
		var z = this.marginTop + this.top + this.offsetY;
		var H = function(u) {
			var t = u / n.varLabelInterval;
			if (parseInt(t) == parseFloat(t)) {
				var s = n.get3DTransfrom(n.lenX, n.lenY, A - (k / 2));
				var l = s[0] + F;
				var N = s[1] + z;
				var M = n.zAxis.length == 0 ? n.data.y.vars[n.varIndices[u]] : e[u];
				if (n.xRotate >= 45) {
					if (n.yRotate >= 45) {
						n.drawText(M, l + 5, N, n.axisTickFont, n.axisTickColor, "left")
					} else {
						n.drawText(M, l, N + 5, n.axisTickFont, n.axisTickColor, "right", false, -Math.PI / 2)
					}
				} else {
					n.drawText(M, l + 5, N, n.axisTickFont, n.axisTickColor, "left")
				}
			}
		};
		var K = function(N, t) {
			var M = N / n.smpLabelInterval;
			if (parseInt(M) == parseFloat(M)) {
				var s = n.get3DTransfrom((t * n.lenX / n.lenZ) - ((f / 2) * n.x3DRatio), n.lenY, -n.lenZ);
				var l = s[0] + F;
				var P = s[1] + z;
				var O = n.xAxis.length == 0 ? n.isGroupedData && n.scatterType == "dot" ? n.data.w.smps[n.grpIndices[N]] : n.data.y.smps[n.smpIndices[N]] : g[N];
				n.drawText(O, l, P + 5, n.axisTickFont, n.axisTickColor, "right", false, -Math.PI / 2)
			}
		};
		if (this.is3DPlot) {
			if (this.zAxis.length > 0) {
				if (this.zAxisType == "continuous") {
					k = this.lenZ / 15;
					C = (15 * -k) + k
				} else {
					e = this.getVariableLevelsByAnnotation(this.zAxis[0]);
					k = this.lenZ / (e.length * 0.5);
					C = ((e.length * 0.5) * -k) + k
				}
			} else {
				k = this.lenZ / (this.varIndices.length * 0.5);
				C = ((this.varIndices.length * 0.5) * -k) + k
			}
			if (this.xAxis.length > 0) {
				if (this.xAxisType == "continuous") {
					f = this.lenX / 15;
					B = (15 * -f) + f
				} else {
					g = this.getVariableLevelsByAnnotation(this.xAxis[0]);
					f = this.lenX / (g.length * 0.5);
					B = ((g.length * 0.5) * -f) + f
				}
			} else {
				if (this.isGroupedData && this.scatterType == "dot") {
					f = this.lenZ / (this.grpIndices.length * 0.5);
					B = ((this.grpIndices.length * 0.5) * -f) + f
				} else {
					f = this.lenZ / (this.smpIndices.length * 0.5);
					B = ((this.smpIndices.length * 0.5) * -f) + f
				}
			}
		} else {
			k = this.lenZ / 15;
			f = false;
			C = (15 * -k) + k;
			B = false
		}
		if (this.zAxisType == "continuous") {
			J = [], d = [], w = [], I = [], c = [], q = [], h = [];
			A = C;
			G = 0;
			r = 0;
			while (A < this.lenZ) {
				if ((G + 1) % 3) {
					J[r] = -this.lenX;
					d[r] = this.lenY;
					w[r] = A;
					I[r] = this.lenX;
					c[r] = this.lenY;
					q[r] = A;
					h.push(this.zAxisTickColor);
					r++
				}
				A += k;
				G++
			}
			this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
		}
		if (this.xAxisType == "continuous") {
			J = [], d = [], w = [], I = [], c = [], q = [], h = [];
			A = B || C;
			G = 0;
			r = 0;
			while (A < this.lenZ) {
				if ((G + 1) % 3) {
					J[r] = A * this.lenX / this.lenZ;
					d[r] = this.lenY;
					w[r] = -this.lenZ;
					I[r] = A * this.lenX / this.lenZ;
					c[r] = this.lenY;
					q[r] = this.lenZ;
					h.push(this.zAxisTickColor);
					r++
				}
				A += f || k;
				G++
			}
			this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
		}
		if (this.zAxisType == "continuous") {
			J = [], d = [], w = [], I = [], c = [], q = [], h = [];
			A = C;
			G = 0;
			r = 0;
			L = this.zAxisIncr;
			while (A < this.lenZ) {
				if (!((G + 1) % 3)) {
					J[r] = -this.lenX;
					d[r] = this.lenY;
					w[r] = A;
					I[r] = this.lenX;
					c[r] = this.lenY;
					q[r] = A;
					h.push(this.foreground);
					r++
				}
				A += k;
				G++
			}
			this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
		}
		if (this.xAxisType == "continuous" || this.zAxisType == "continuous") {
			J = [], d = [], w = [], I = [], c = [], q = [], h = [];
			if (this.xAxisType == "continuous") {
				A = B || C
			} else {
				A = C
			}
			G = 0;
			r = 0;
			L = this.zAxisIncr;
			while (A < this.lenZ) {
				if (!((G + 1) % 3)) {
					J[r] = A * this.lenX / this.lenZ;
					d[r] = this.lenY;
					w[r] = -this.lenZ;
					I[r] = A * this.lenX / this.lenZ;
					c[r] = this.lenY;
					q[r] = this.lenZ;
					h.push(this.foreground);
					r++;
					b = this.get3DTransfrom(this.lenX, this.lenY, A);
					p = b[0] + F;
					o = b[1] + z;
					E = this.zAxisTime ? dateFormat(new Date(this.zAxisMin + L), this.timeFormat) : this.formatAxisValue(this.zAxisMin + L, "zAxis");
					L += this.zAxisIncr;
					if (this.zAxisShow && this.zAxisType == "continuous") {
						if (this.xRotate >= 45) {
							if (this.yRotate >= 45) {
								this.drawText(E, p + 5, o, this.axisTickFont, this.axisTickColor, "left")
							} else {
								this.drawText(E, p, o + 5, this.axisTickFont, this.axisTickColor, "right", false, -Math.PI / 2)
							}
						} else {
							this.drawText(E, p + 5, o, this.axisTickFont, this.axisTickColor, "left")
						}
					}
				}
				if (this.xAxisType == "continuous") {
					A += f || k
				} else {
					A += k
				}
				G++
			}
			if (this.xAxisType == "continuous") {
				this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
			}
		}
		if (this.zAxisType == "categorical") {
			A = C;
			G = 0;
			r = 0;
			while (A < this.lenZ) {
				J[r] = -this.lenX;
				d[r] = this.lenY;
				w[r] = A;
				I[r] = this.lenX;
				c[r] = this.lenY;
				q[r] = A;
				h.push(this.zAxisTickColor);
				H(G);
				r++;
				G++;
				A += k
			}
			this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle);
			H(G)
		}
		if (this.xAxisType == "categorical") {
			G = 0;
			v = B;
			while (v < this.lenZ) {
				J[r] = v * this.lenX / this.lenZ;
				d[r] = this.lenY;
				w[r] = -this.lenZ;
				I[r] = v * this.lenX / this.lenZ;
				c[r] = this.lenY;
				q[r] = this.lenZ;
				h.push(this.zAxisTickColor);
				K(G, v);
				r++;
				G++;
				v += f
			}
			this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle);
			K(G, v)
		}
		if (this.zAxisShow && !this.is3DPlot) {
			this.draw3DAxisTitle(this.lenX + (k * 6), this.lenX + (k * 6), this.lenY + (k * 6), this.lenY + (k * 6), C - (k * 2), this.lenZ + k, m, "z")
		}
		J = [-this.lenX, -this.lenX, this.lenX, -this.lenX];
		d = [this.lenY, this.lenY, this.lenY, this.lenY];
		w = [-this.lenZ, this.lenZ, -this.lenZ, -this.lenZ];
		I = [-this.lenX, this.lenX, this.lenX, this.lenX];
		c = [this.lenY, this.lenY, this.lenY, this.lenY];
		q = [this.lenZ, this.lenZ, this.lenZ, -this.lenZ];
		h = [this.foreground, this.foreground, this.foreground, this.foreground];
		this.draw3DLayout(J, d, w, I, c, q, h, this.zAxisTickStyle)
	};
	this.draw3DAxisTitle = function(v, u, e, d, k, j, n, c) {
		var p = this.measureText(n);
		var r = p / 2;
		var w = n.split("");
		var h = (v + u) / 2;
		var g = (e + d) / 2;
		var f = (k + j) / 2;
		var q = this.marginLeft + this.left + this.offsetX;
		var m = this.marginTop + this.top + this.offsetY;
		var o = this.xRotate >= 45 || this.yRotate >= 45 ? 4 : 0;
		if (this.xRotate >= 45 || this.yRotate >= 45) {
			p += w.length * 4;
			r = p / 2
		}
		if (c == "x") {
			h -= r;
			for (var s = 0; s < w.length; s++) {
				var b = this.get3DTransfrom(h, g, f);
				this.drawText(w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "top");
				h += this.measureText(w[s]) + o
			}
		} else {
			if (c == "y") {
				g += r;
				for (var s = 0; s < w.length; s++) {
					var b = this.get3DTransfrom(h, g, f);
					this.drawText(w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "bottom", -Math.PI / 2);
					g -= this.measureText(w[s]) + o
				}
			} else {
				if (c == "z") {
					f -= r;
					for (var s = 0; s < w.length; s++) {
						var b = this.get3DTransfrom(h, g, f);
						this.drawText(w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "bottom");
						f += this.measureText(w[s]) + o
					}
				}
			}
		}
	};
	this.set3DLayout = function(c) {
		if (c) {
			this.layoutSet = {
				x: false,
				y: false,
				z: false
			}
		}
		for (var g = 0; g < this.layoutOrder.ord.length; g++) {
			var d = this.layoutOrder.ord[g];
			var h = c && this.layoutOrder[d];
			var f = !c && !this.layoutOrder[d];
			var e = c && this.layoutOrder[d + "1"];
			if (!this.layoutSet[d]) {
				if (h || f || (!h && !f && e)) {
					this["set3D" + d.toUpperCase() + "Layout"]();
					this.layoutSet[d] = true
				}
			}
		}
		if (!c) {
			delete(this.layoutSet)
		}
	};
	this.set3DAxes = function() {
		var f = ["x", "y", "z"];
		this.setMin = null;
		this.setMax = null;
		if (this.is3DPlot) {
			if (this.yAxis.length == 0) {
				if (this.xAxisTitle) {
					var c = this.yAxisTitle;
					this.yAxisTitle = this.xAxisTitle;
					this.xAxisTitle = c
				}
				this.yAxisMin = this.xAxisMin;
				this.yAxisMax = this.xAxisMax;
				this.yAxisIncr = this.xAxisIncr;
				this.yAxisDecs = this.xAxisDecs;
				this.yAxisRange = this.xAxisRange
			} else {
				var g = this.smpIndices;
				this.yAxisIndex = this.getSampleIndices([this.yAxis[0]]);
				this.setSamplesVisible([this.yAxisIndex]);
				this.setRangeData();
				this.yAxisMin = this.setMinY != null ? this.setMinY : this.minData;
				this.yAxisMax = this.setMaxY != null ? this.setMaxY : this.maxData;
				this.yAxisIncr = this.getAxisIncrements(this.yAxisMin, this.yAxisMax, 10, this.yAxisExact);
				this.yAxisDecs = this.getAxisDecimals(this.yAxisIncr);
				if (!this.yAxisExact) {
					this.yAxisMin = this.getAxisMin(this.yAxisMin, this.yAxisIncr);
					this.yAxisMax = this.yAxisMin + (this.yAxisIncr * 10)
				}
				this.yAxisRange = this.yAxisMax - this.yAxisMin;
				this.yAxisUnit = this.lenY * 2 / this.yAxisRange;
				this.yAxisOffset = Math.min(this.lenY, (this.yAxisMin + (this.yAxisRange / 2)) * this.yAxisUnit);
				this.AxisType = "continuous";
				this.setSamplesVisible(g)
			}
			this.yAxisUnit = this.lenY * 2 / this.yAxisRange;
			this.yAxisOffset = Math.min(this.lenY, (this.yAxisMin + (this.yAxisRange / 2)) * this.yAxisUnit);
			this.yAxisType = "continuous";
			if (this.xAxis.length > 0) {
				if (this.data.z && this.data.z.hasOwnProperty(this.xAxis[0]) && !this.isNumeric(this.data.z[this.xAxis[0]])) {
					var e = this.getVariableLevelsByAnnotation(this.xAxis[0]);
					this.xAxisMin = 0;
					this.xAxisMax = 10;
					this.xAxisIncr = 10 / e.length;
					this.xAxisDecs = 0;
					this.xAxisRange = this.xAxisMax - this.xAxisMin;
					this.xAxisUnit = this.lenX * 2 / this.xAxisRange;
					this.xAxisOffset = Math.min(this.lenX, (this.xAxisMin + (this.xAxisRange / 2)) * this.xAxisUnit);
					this.xAxisType = "categorical"
				} else {
					if (this.getSampleIndices(this.xAxis[0]) >= 0) {
						var g = this.smpIndices;
						this.xAxisIndex = this.getSampleIndices([this.xAxis[0]]);
						this.setSamplesVisible([this.xAxisIndex]);
						this.setRangeData();
						this.xAxisMin = this.setMinX != null ? this.setMinX : this.minData;
						this.xAxisMax = this.setMaxX != null ? this.setMaxX : this.maxData;
						this.xAxisIncr = this.getAxisIncrements(this.xAxisMin, this.xAxisMax, 10, this.xAxisExact);
						this.xAxisDecs = this.getAxisDecimals(this.xAxisIncr);
						if (!this.xAxisExact) {
							this.xAxisMin = this.getAxisMin(this.xAxisMin, this.xAxisIncr);
							this.xAxisMax = this.xAxisMin + (this.xAxisIncr * 10)
						}
						this.xAxisRange = this.xAxisMax - this.xAxisMin;
						this.xAxisUnit = this.lenX * 2 / this.xAxisRange;
						this.xAxisOffset = Math.min(this.lenX, (this.xAxisMin + (this.xAxisRange / 2)) * this.xAxisUnit);
						this.xAxisType = "continuous";
						this.setSamplesVisible(g)
					}
				}
			} else {
				this.xAxisMin = 0;
				this.xAxisMax = 10;
				this.xAxisIncr = this.isGroupedData ? 10 / this.grpIndices.length : 10 / this.smpIndices.length;
				this.xAxisDecs = 0;
				this.xAxisRange = this.xAxisMax - this.xAxisMin;
				this.xAxisUnit = this.lenX * 2 / this.xAxisRange;
				this.xAxisOffset = Math.min(this.lenX, (this.xAxisMin + (this.xAxisRange / 2)) * this.xAxisUnit);
				this.xAxisType = "categorical"
			}
			if (this.zAxis.length > 0) {
				if (this.data.z && this.data.z.hasOwnProperty(this.zAxis[0]) && !this.isNumeric(this.data.z[this.zAxis[0]])) {
					var e = this.getVariableLevelsByAnnotation(this.zAxis[0]);
					this.zAxisMin = 0;
					this.zAxisMax = 10;
					this.zAxisIncr = 10 / e.length;
					this.zAxisDecs = 0;
					this.zAxisRange = this.zAxisMax - this.zAxisMin;
					this.zAxisUnit = this.lenZ * 2 / this.zAxisRange;
					this.zAxisOffset = Math.min(this.lenZ, (this.zAxisMin + (this.zAxisRange / 2)) * this.zAxisUnit);
					this.zAxisType = "categorical"
				} else {
					if (this.getSampleIndices(this.zAxis[0]) >= 0) {
						var g = this.smpIndices;
						this.zAxisIndex = this.getSampleIndices([this.zAxis[0]]);
						this.setSamplesVisible([this.zAxisIndex]);
						this.setRangeData();
						this.zAxisMin = this.setMinZ != null ? this.setMinZ : this.minData;
						this.zAxisMax = this.setMaxZ != null ? this.setMaxZ : this.maxData;
						this.zAxisIncr = this.getAxisIncrements(this.zAxisMin, this.zAxisMax, 10, this.zAxisExact);
						this.zAxisDecs = this.getAxisDecimals(this.zAxisIncr);
						if (!this.zAxisExact) {
							this.zAxisMin = this.getAxisMin(this.zAxisMin, this.zAxisIncr);
							this.zAxisMax = this.zAxisMin + (this.zAxisIncr * 10)
						}
						this.zAxisRange = this.zAxisMax - this.zAxisMin;
						this.zAxisUnit = this.lenZ * 2 / this.zAxisRange;
						this.zAxisOffset = Math.min(this.lenZ, (this.zAxisMin + (this.zAxisRange / 2)) * this.zAxisUnit);
						this.zAxisType = "continuous";
						this.setSamplesVisible(g)
					}
				}
			} else {
				this.zAxisMin = 0;
				this.zAxisMax = 10;
				this.zAxisIncr = 10 / this.varIndices.length;
				this.zAxisDecs = 0;
				this.zAxisRange = this.zAxisMax - this.zAxisMin;
				this.zAxisUnit = this.lenZ * 2 / this.zAxisRange;
				this.zAxisOffset = Math.min(this.lenZ, (this.zAxisMin + (this.zAxisRange / 2)) * this.zAxisUnit);
				this.zAxisType = "categorical"
			}
		} else {
			for (var b = 0; b < f.length; b++) {
				var g = this.smpIndices;
				var d = f[b].toUpperCase();
				this[f[b] + "AxisIndex"] = this.getSampleIndices(this[f[b] + "Axis"])[0];
				this.setSamplesVisible([this[f[b] + "AxisIndex"]]);
				this.setRangeData();
				if (this.minData == this.maxData) {
					this.maxData += 0.5
				}
				this[f[b] + "AxisMin"] = this["setMin" + d] != null ? this["setMin" + d] : this.minData;
				this[f[b] + "AxisMax"] = this["setMax" + d] != null ? this["setMax" + d] : this.maxData;
				this[f[b] + "AxisIncr"] = this.getAxisIncrements(this[f[b] + "AxisMin"], this[f[b] + "AxisMax"], 10, this[f[b] + "AxisExact"]);
				this[f[b] + "AxisDecs"] = this.getAxisDecimals(this[f[b] + "AxisIncr"]);
				if (!this[f[b] + "AxisExact"]) {
					this[f[b] + "AxisMin"] = this.getAxisMin(this[f[b] + "AxisMin"], this[f[b] + "AxisIncr"]);
					this[f[b] + "AxisMax"] = this[f[b] + "AxisMin"] + (this[f[b] + "AxisIncr"] * 10)
				}
				this[f[b] + "AxisRange"] = this[f[b] + "AxisMax"] - this[f[b] + "AxisMin"];
				this[f[b] + "AxisUnit"] = this["len" + d] * 2 / this[f[b] + "AxisRange"];
				this[f[b] + "AxisOffset"] = Math.min(this["len" + d], (this[f[b] + "AxisMin"] + (this[f[b] + "AxisRange"] / 2)) * this[f[b] + "AxisUnit"]);
				this[f[b] + "AxisType"] = "continuous";
				this[f[b] + "AxisTime"] = this.isGraphTime == f[b] ? true : false;
				this.setSamplesVisible(g)
			}
		}
		this.set3DCenter()
	};
	this.set3DCenter = function() {
		var r = this.xAxisMin < 0 ? 0 : this.xAxisMin;
		var q = this.yAxisMin < 0 ? 0 : this.yAxisMin;
		var o = this.zAxisMin < 0 ? 0 : this.zAxisMin;
		var m = ((((this.xAxisMin + this.xAxisMax) / 2) - r) * this.xAxisUnit) - this.xAxisOffset;
		var l = this.yAxisOffset - ((((this.yAxisMin + this.yAxisMax) / 2) - q) * this.yAxisUnit);
		var k = ((((this.zAxisMin + this.zAxisMax) / 2) - o) * this.zAxisUnit) - this.zAxisOffset;
		this.zero3DPoint = this.get3DTransfrom(m, l, k);
		var A = this.get3DTransfrom(((this.xAxisMin - r) * this.xAxisUnit) - this.xAxisOffset, l, k);
		var w = this.get3DTransfrom(((this.xAxisMax - r) * this.xAxisUnit) - this.xAxisOffset, l, k);
		var f = this.get3DTransfrom(m, this.yAxisOffset - ((this.yAxisMin - q) * this.yAxisUnit), k);
		var e = this.get3DTransfrom(m, this.yAxisOffset - ((this.yAxisMax - q) * this.yAxisUnit), k);
		var p = this.get3DTransfrom(m, l, ((this.zAxisMax - o) * this.zAxisUnit) - this.zAxisOffset);
		var n = this.get3DTransfrom(m, l, ((this.zAxisMin - o) * this.zAxisUnit) - this.zAxisOffset);
		var u = this.euclidianDistance([A[0], A[1], A[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var t = this.euclidianDistance([w[0], w[1], w[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var c = this.euclidianDistance([f[0], f[1], f[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var b = this.euclidianDistance([e[0], e[1], e[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var j = this.euclidianDistance([p[0], p[1], p[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var h = this.euclidianDistance([n[0], n[1], n[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var s = this.euclidianDistance([this.zero3DPoint[0], this.zero3DPoint[1], this.zero3DPoint[2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]);
		var B = [Math.min(u, t), Math.min(c, b), Math.min(j, h)];
		var C = {
			0: "x",
			1: "y",
			2: "z"
		};
		var g = [0, 1, 2];
		g = g.sort(function(x, i) {
			return B[x] - B[i]
		});
		var d = [];
		for (var v = 0; v < g.length; v++) {
			d.push(C[g[v]])
		}
		this.layoutOrder = {
			x0: j,
			x1: h,
			y0: u,
			y1: t,
			z0: c,
			z1: b,
			md: s,
			x: j >= h,
			y: u >= t,
			z: c >= b,
			x1: Math.min(j, h) > s,
			y1: Math.min(u, t) > s,
			z1: Math.min(c, b) > s,
			ord: d
		}
	};
	this.is3DVisibleDataPoint = function(b, d, c) {
		if (b >= this.xAxisMin && b <= this.xAxisMax) {
			if (d >= this.yAxisMin && d <= this.yAxisMax) {
				if (c >= this.zAxisMin && c <= this.zAxisMax) {
					return true
				}
			}
		}
		return false
	};
	this.draw3DDataPoints = function() {
		var Z = this.marginLeft + this.left + this.offsetX;
		var Q = this.marginTop + this.top + this.offsetY;
		var aq = this.xAxisIndex + ":" + this.yAxisIndex + ":" + this.zAxisIndex;
		var aN = {
			data: {},
			ellp: {},
			sphr: {}
		};
		var aK = [];
		var G = [];
		var aJ = [];
		var D = [];
		var b = [];
		var K = [];
		var ar = [];
		var F = [];
		var aC = [];
		var f = 0;
		this.connectByData = {};
		if (this.is3DPlot) {
			if (this.xAxis.length > 0 && this.yAxis.length > 0 && this.zAxis.length > 0) {
				var aD, aL, at;
				var ae = {};
				var ac = {};
				var aB = this.getSampleIndices(this.yAxis[0]);
				if (this.data.z && this.data.z.hasOwnProperty(this.xAxis[0]) && !this.isNumeric(this.data.z[this.xAxis[0]])) {
					aD = this.getVariableLevelsByAnnotation(this.xAxis[0]);
					for (var ad = 0; ad < aD.length; ad++) {
						ae[aD[ad]] = ad
					}
					aL = false
				} else {
					aL = this.getSampleIndices(this.xAxis[0])
				}
				if (this.data.z && this.data.z.hasOwnProperty(this.zAxis[0]) && !this.isNumeric(this.data.z[this.zAxis[0]])) {
					aD = this.getVariableLevelsByAnnotation(this.zAxis[0]);
					for (var ad = 0; ad < aD.length; ad++) {
						ac[aD[ad]] = ad
					}
					at = false
				} else {
					at = this.getSampleIndices(this.zAxis[0])
				}
				S = 0;
				for (var ad = 0; ad < this.varIndices.length; ad++) {
					var U = this.varIndices[ad];
					var O = aL === false ? (ae[this.data.z[this.xAxis[0]][U]] * this.xAxisIncr) + (this.xAxisIncr / 2) : this.getDataAtPos(U, aL);
					var N = this.getDataAtPos(U, aB);
					var M = at === false ? (ac[this.data.z[this.zAxis[0]][U]] * this.zAxisIncr) + (this.zAxisIncr / 2) : this.getDataAtPos(U, at);
					var aw = this.xAxisMin < 0 ? 0 : this.xAxisMin;
					var av = this.yAxisMin < 0 ? 0 : this.yAxisMin;
					var au = this.zAxisMin < 0 ? 0 : this.zAxisMin;
					var C = ((O - aw) * this.xAxisUnit) - this.xAxisOffset;
					var B = this.yAxisOffset - ((N - av) * this.yAxisUnit);
					var A = ((M - au) * this.zAxisUnit) - this.zAxisOffset;
					ar.push(true);
					aK.push([O, N, M]);
					var aM = this.get3DTransfrom(C, B, A);
					G.push(aM);
					aJ.push(aM[2]);
					K.push(this.euclidianDistance([G[S][0], G[S][1], G[S][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
					aC.push([U, aB]);
					b.push(S++)
				}
			} else {
				if (this.isGroupedData && this.scatterType == "dot") {
					this.isGroupedData = false;
					var S = 0;
					for (var ad = 0; ad < this.varIndices.length; ad++) {
						var U = this.varIndices[ad];
						for (var ab = 0; ab < this.grpIndices.length; ab++) {
							for (var aa = 0; aa < this.data.w.grps[this.grpIndices[ab]].length; aa++) {
								var H = this.data.w.grps[this.grpIndices[ab]][aa];
								var O = (ab * this.xAxisIncr) + (this.xAxisIncr / 2);
								var N = this.getDataAtPos(U, H);
								var M = (ad * this.zAxisIncr) + (this.zAxisIncr / 2);
								var aw = 0;
								var av = this.yAxisMin < 0 ? 0 : this.yAxisMin;
								var au = 0;
								var C = ((O - aw) * this.xAxisUnit) - this.xAxisOffset;
								var B = this.yAxisOffset - ((N - av) * this.yAxisUnit);
								var A = ((M - au) * this.zAxisUnit) - this.zAxisOffset;
								ar.push(true);
								aK.push([O, N, M]);
								var aM = this.get3DTransfrom(C, B, A);
								G.push(aM);
								aJ.push(aM[2]);
								K.push(this.euclidianDistance([G[S][0], G[S][1], G[S][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
								aC.push([U, this.grpIndices[ab]]);
								b.push(S++)
							}
						}
					}
					this.isGroupedData = true
				} else {
					var S = 0;
					for (var ad = 0; ad < this.varIndices.length; ad++) {
						var U = this.varIndices[ad];
						for (var ab = 0; ab < this.smpIndices.length; ab++) {
							var H = this.smpIndices[ab];
							var O = (ab * this.xAxisIncr) + (this.xAxisIncr / 2);
							var N = this.getDataAtPos(U, H);
							var M = (ad * this.zAxisIncr) + (this.zAxisIncr / 2);
							var aw = 0;
							var av = this.yAxisMin < 0 ? 0 : this.yAxisMin;
							var au = 0;
							var C = ((O - aw) * this.xAxisUnit) - this.xAxisOffset;
							var B = this.scatterType && this.scatterType.match(/bar/) ? 0 : this.yAxisOffset - ((N - av) * this.yAxisUnit);
							var A = ((M - au) * this.zAxisUnit) - this.zAxisOffset;
							ar.push(true);
							aK.push([O, N, M]);
							var aM = this.get3DTransfrom(C, B, A);
							G.push(aM);
							aJ.push(aM[2]);
							K.push(this.euclidianDistance([G[S][0], G[S][1], G[S][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
							aC.push([U, H]);
							b.push(S++)
						}
					}
				}
			}
		} else {
			for (var ad = 0; ad < this.varIndices.length; ad++) {
				var U = this.varIndices[ad];
				var O = this.getDataAtPos(U, this.xAxisIndex);
				var N = this.getDataAtPos(U, this.yAxisIndex);
				var M = this.getDataAtPos(U, this.zAxisIndex);
				var aw = this.xAxisMin < 0 ? 0 : this.xAxisMin;
				var av = this.yAxisMin < 0 ? 0 : this.yAxisMin;
				var au = this.zAxisMin < 0 ? 0 : this.zAxisMin;
				var C = ((O - aw) * this.xAxisUnit) - this.xAxisOffset;
				var B = this.scatterType && this.scatterType.match(/bar/) ? 0 : this.yAxisOffset - ((N - av) * this.yAxisUnit);
				var A = ((M - au) * this.zAxisUnit) - this.zAxisOffset;
				var e = this.ellipseBy && this.data.z && this.data.z.hasOwnProperty(this.ellipseBy) ? this.data.z[this.ellipseBy][U] : this.ellipseBy && this.ellipseBy == "variable" ? "variable" : false;
				ar.push(this.is3DVisibleDataPoint(O, N, M));
				aK.push([O, N, M]);
				var aM = this.get3DTransfrom(C, B, A);
				G.push(aM);
				aJ.push(aM[2]);
				if (this.scatterType != "function") {
					b.push(ad);
					K.push(this.euclidianDistance([G[ad][0], G[ad][1], G[ad][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]))
				}
				if (this.ellipseBy && e) {
					if (!aN.data.hasOwnProperty(e)) {
						aN.data[e] = [
							[],
							[],
							[]
						]
					}
					aN.data[e][0].push(O);
					aN.data[e][1].push(N);
					aN.data[e][2].push(M)
				}
			}
			if (this.ellipseBy) {
				var am = this.ellipseBy && this.data.z && this.data.z.hasOwnProperty(this.ellipseBy) ? this.meta.data.z[this.ellipseBy] : false;
				var ad = this.varIndices.length;
				for (var e in aN.data) {
					aN.ellp[e] = this.errorEllipse(aN.data[e][0], aN.data[e][1], aN.data[e][2]);
					var ay = aN.ellp[e];
					aN.sphr[e] = this.sphere(ay.cx, ay.cy, ay.cz, ay.rx[0], ay.ry[0], ay.rz[0], ay.rot[0], ay.rot[1], ay.rot[2]);
					for (var ab = 0; ab < aN.sphr[e].length; ab++) {
						C = ((aN.sphr[e][ab][0] - aw) * this.xAxisUnit) - this.xAxisOffset;
						B = this.yAxisOffset - ((aN.sphr[e][ab][1] - av) * this.yAxisUnit);
						A = ((aN.sphr[e][ab][2] - au) * this.zAxisUnit) - this.zAxisOffset;
						aM = this.get3DTransfrom(C, B, A);
						G.push(aM);
						aJ.push(aM[2]);
						b.push(ad + ab);
						K.push(this.euclidianDistance([G[ad + ab][0], G[ad + ab][1], G[ad + ab][2]], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]))
					}
					ad += aN.sphr[e].length
				}
			}
		}
		var aG = this.range(aJ);
		if (this.scatterType && this.scatterType == "function") {
			var Y = Math.sqrt(G.length);
			var U = 0;
			var h = [];
			var aE = this.colorBy ? this.meta.data.y.range[this.colorBy] : false;
			var X = this.colorBy ? this.getColorBrew(this.colorSpectrum, aE.min, aE.max, this.colorSpectrumZeroValue, this.colorSpectrumBreaks) : false;
			for (var ad = 1; ad < Y; ad++) {
				for (var ab = 0; ab < Y - 1; ab++) {
					var ak = ((ad - 1) * Y) + ab;
					var ap = (ad * Y) + ab;
					var aj = ((ad - 1) * Y) + ab + 1;
					var al = (ad * Y) + ab + 1;
					var aF = [G[ak][0] + this.funcX, G[ap][0] + this.funcX, G[al][0] + this.funcX, G[aj][0] + this.funcX];
					var az = [G[ak][1] + this.funcY, G[ap][1] + this.funcY, G[al][1] + this.funcY, G[aj][1] + this.funcY];
					var an = [G[ak][2], G[ap][2], G[al][2], G[aj][2]];
					var L = this.colorBy ? this.getColorForValue(X, this.mean([aK[ak][1], aK[ap][1], aK[al][1], aK[aj][1]])) : false;
					b.push(U++);
					K.push(this.euclidianDistance([this.mean(aF), this.mean(az), this.mean(an)], [this.zero3DPoint[0], this.zero3DPoint[1], -this.x]));
					h.push([aF, az, L])
				}
			}
			b.sort(function(g, c) {
				return K[c] - K[g]
			});
			for (var U = 0; U < h.length; U++) {
				var ad = b[U];
				if (ar[ad]) {
					var ai = [ad, this.xAxisIndex, this.yAxisIndex, this.zAxisIndex];
					if (this.colorBy) {
						this.addArea(this.drawShape("polygon", h[ad][0], h[ad][1], false, false, h[ad][2], h[ad][2], "closed"), ai)
					} else {
						this.addArea(this.drawShape("polygon", h[ad][0], h[ad][1], false, false, false, this.foreground, "open"), ai)
					}
				}
			}
		} else {
			if (this.meta.system.browser == "Firefox") {
				b = this.radixSort(b)
			} else {
				b.sort(function(g, c) {
					return K[c] - K[g]
				})
			}
			var ao = this.is3DPlot ? this.scatterPointSize / (30 * this.bar3DInverseWeight) : this.scatterPointSize / (3 * this.bar3DInverseWeight);
			for (var U = 0; U < G.length; U++) {
				var ad = b[U];
				if (this.ellipseBy && ad >= this.varIndices.length) {
					var aH = 350;
					var aA = 25;
					var P = ad - this.varIndices.length;
					var ax = ad + 1;
					var ah = ad + aA;
					var aI = P % aA;
					var d = parseInt(P / aH);
					var m = (aH * d) + (aH / 2);
					var E = m - 24;
					if (!aI && ad + 1 < G.length) {
						this.drawLine("line", Z + G[ad][0], Q + G[ad][1], Z + G[ad + 1][0], Q + G[ad + 1][1], this.colors[d % this.colors.length])
					} else {
						if (parseInt(P / aA) == parseInt((P - 1) / aA) && parseInt(P / aH) == parseInt((P + 1) / aH) && ax < G.length) {
							this.drawLine("line", Z + G[ad][0], Q + G[ad][1], Z + G[ax][0], Q + G[ax][1], this.colors[d % this.colors.length]);
							if (parseInt(P / aH) == parseInt((P + aA) / aH) && ah < G.length) {
								if (P < E || P > m) {
									this.drawLine("line", Z + G[ad][0], Q + G[ad][1], Z + G[ah][0], Q + G[ah][1], this.colors[d % this.colors.length])
								}
							}
						}
					}
				} else {
					var P = this.is3DPlot ? aC[ad][0] : ad;
					var ag = this.colorBy ? this.getPropertyValue(this.varIndices[P], this.xAxisIndex, "colorBy") : this.is3DPlot ? this.colors[P % this.colors.length] : this.colors[0];
					var V = this.getPropertyValue(this.varIndices[P], this.xAxisIndex, "shapeBy");
					var R = this.getPropertyValue(this.varIndices[P], this.xAxisIndex, "sizeBy");
					var S = this.getPropertyValue(this.varIndices[P], this.xAxisIndex, "patternBy");
					var af = this.scatterType && this.scatterType.match(/image/i) ? this.images[ad] : false;
					var ai = this.is3DPlot ? [aC[ad][0], aC[ad][1]] : [this.varIndices[ad], this.xAxisIndex, this.yAxisIndex, this.zAxisIndex];
					if (ar[ad] && this.isVisibleSelectedDataPoint(ad, aq)) {
						if (this.scatterType && this.scatterType.match(/bar/)) {
							var R = this.isInSelectedDataPoints(ad, aq) ? this.selectedBackgroundColor : ag;
							this.draw3DBar(aK[ad][0], aK[ad][1], aK[ad][2], ao, R, ai)
						} else {
							if (this.scatterType && this.scatterType.match(/dot/)) {
								var T = af ? "image" : V;
								var O = Z + G[ad][0];
								var N = Q + G[ad][1];
								var W = G.length > this.scatterOutlineThreshold ? ag : this.foreground;
								var M = Math.floor(this.percentile(aG[0], aG[1], G[ad][2]));
								this.drawSelectedBackground(ai[1], aq, V, O, N, R, R);
								this.addArea(this.drawShape(T, O, N, R, R, ag, W, S, false, false, false, false, false, false, af), ai);
								this.drawSelectedBackgroundLabel(ai[1], aq, O, N)
							} else {
								var T = af ? "image" : V;
								var O = Z + G[ad][0];
								var N = Q + G[ad][1];
								var W = G.length > this.scatterOutlineThreshold ? ag : this.foreground;
								var M = Math.floor(this.percentile(aG[0], aG[1], G[ad][2]));
								this.drawSelectedBackground(ad, aq, V, O, N, R, R);
								this.addArea(this.drawShape(T, O, N, R, R, ag, W, S, false, false, false, false, false, false, af), ai);
								this.drawSelectedBackgroundLabel(this.varIndices[ad], aq, O, N);
								if (this.scatterType && this.scatterType.match(/line/)) {
									D[ad] = [G[ad][0], G[ad][1]]
								} else {
									if (this.connectBy) {
										if (!this.connectByData[this.data.z[this.connectBy][ad]]) {
											this.connectByData[this.data.z[this.connectBy][ad]] = []
										}
										this.connectByData[this.data.z[this.connectBy][ad]].push([G[ad][0], G[ad][1]])
									}
								}
							}
						}
					}
				}
			}
			if (this.scatterType && this.scatterType.match(/line/) && D.length > 0) {
				for (var ad = 0; ad < D.length - 1; ad++) {
					if (ar[ad] && this.isVisibleSelectedDataPoint(ad, aq) && ar[ad + 1] && this.isVisibleSelectedDataPoint(ad + 1, aq)) {
						var J = Z + D[ad][0];
						var w = Q + D[ad][1];
						var I = Z + D[ad + 1][0];
						var u = Q + D[ad + 1][1];
						this.drawLine("line", J, w, I, u, this.colors[0])
					}
				}
			} else {
				if (this.connectBy) {
					for (U in this.connectByData) {
						if (this.connectByData[U].length > 1) {
							for (var ad = 0; ad < this.connectByData[U].length - 1; ad++) {
								var J = Z + this.connectByData[U][ad][0];
								var w = Q + this.connectByData[U][ad][1];
								var I = Z + this.connectByData[U][ad + 1][0];
								var u = Q + this.connectByData[U][ad + 1][1];
								this.drawLine("line", J, w, I, u, this.connectByColor)
							}
						}
					}
				}
			}
		}
	};
	this.set3DprivateParams = function() {
		this.set3DText();
		this.set3DParams()
	};
	this.draw3DPlot = function() {
		this.validatePropertyValues();
		this.set3DXYDimensions();
		this.set3DprivateParams();
		this.set3DRotation();
		this.set3DAxes();
		this.set3DLayout(true);
		this.draw3DDataPoints();
		this.set3DLayout();
		this.drawLegend();
		this.drawTitle()
	};
	this.initializeScatter3D = function() {
		if (this.layoutValid) {
			this.drawLayoutCompartments(this.draw3DPlot)
		} else {
			this.draw3DPlot()
		}
	};
	if (!a) {
		this.initializeScatter3D()
	}
};
CanvasXpress.prototype.oneDPlot = function(a) {
	this.setVariableBlock = function() {
		var d = 0;
		var c = 0;
		if (this.treemapBy && this.data.z.hasOwnProperty(this.treemapBy)) {
			if (this.graphType == "Bar") {
				c = this.getVariableLevelsByAnnotation(this.treemapBy);
				d = c.length
			} else {
				if (this.graphType == "BarLine") {
					c = this.getVariableLevelsByAnnotation(this.treemapBy, this.xAxisVarIndices);
					d = c.length
				} else {
					d = this.varIndices.length
				}
			}
		} else {
			d = this.varIndices.length
		}
		this.variableBlock = d
	};
	this.setRowColBlocks = function() {
		this.setVariableBlock();
		var f = this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
		var h = ["Area", "AreaLine", "Heatmap", "Line", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine"];
		var g = 0;
		var i = 0;
		var d = this.graphType == "Bar" || this.graphType == "BarLine";
		if (this.isInArray(this.graphType, h)) {
			g = f;
			i = this.graphType == "Heatmap" ? this.varIndices.length : 1
		} else {
			if (d && this.data.a && this.treemapBy && this.data.z.hasOwnProperty(this.treemapBy)) {
				g = this.variableBlock * f;
				i = 1
			} else {
				if ((this.graphType == "BarLine" || this.graphType == "DotLine") && this.data.a) {
					var e = this.getVariablesVisibleByAxis("xAxis");
					g = e.length * f;
					i = 1
				} else {
					if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
						g = 1;
						i = 1
					} else {
						g = this.varIndices.length * f;
						i = 1
					}
				}
			}
		}
		this.rowBlocks = g;
		this.colBlocks = i
	};
	this.set1DFont = function() {
		if (this.autoScaleFont) {
			var f = 1 - this.percentAspectRatioPlotArea;
			var b = this.width * f;
			var g = this.height * f;
			var c = this.getAxisDescription();
			var e = this.getAxisDescription(true);
			this.setAxisFont(c.length > e.length ? c : e, this.graphOrientation == "vertical" ? g : b);
			this.setPropertyFontSize(b, "varTitleFont");
			this.setPropertyFontSize(b, "varLabelFont");
			this.setPropertyFontSize(this.graphOrientation == "vertical" ? b : g, "smpTitleFont");
			this.setPropertyFontSize(this.graphOrientation == "vertical" ? b : g, "smpLabelFont");
			if (this.graphType == "Heatmap" && this.heatmapLabelSizeAutoAdjust) {
				if (this.varLabelFontSize > this.colBlockSize) {
					this.varLabelFontSize = Math.min(Math.max(parseInt((this.colBlockSize - 1) * this.varLabelScaleFontFactor) + 1, this.minTextSize), this.maxTextSize);
					this.varLabelFont = this.varLabelFontStyle + " " + this.varLabelFontSize + "px " + this.fontName
				}
				if (this.smpLabelFontSize > this.rowBlockSize) {
					this.smpLabelFontSize = Math.min(Math.max(parseInt((this.rowBlockSize - 1) * this.smpLabelScaleFontFactor) + 1, this.minTextSize), this.maxTextSize);
					this.smpLabelFont = this.smpLabelFontStyle + " " + this.smpLabelFontSize + "px " + this.fontName
				}
			}
		}
	};
	this.setOverlays = function(u) {
		var r = this;
		var c = {};
		var l = this[u + "Overlays"];
		var e = this[u + "OverlayProperties"];
		var f = u == "smp" ? this.data.x : this.data.z;
		var t = (u == "var") || (u == "smp" && this.graphOrientation == "vertical") ? ["Bottom", "Top"] : ["Left", "Right"];
		var s = function() {
			for (var j = 0; j < l.length; j++) {
				if (l[j] != "-" && f.hasOwnProperty(l[j])) {
					if (!e[l[j]]) {
						e[l[j]] = {}
					}
					if (!e[l[j]]["type"]) {
						e[l[j]]["type"] = "Default"
					}
					if (!e[l[j]]["color"]) {
						e[l[j]]["color"] = r.colors[j]
					}
					if (!e[l[j]]["spectrum"]) {
						e[l[j]]["spectrum"] = r.colorSpectrum
					}
					if (!e[l[j]]["position"]) {
						if (r.graphType == "Heatmap" || r.graphOrientation == "horizontal") {
							e[l[j]]["position"] = u == "smp" ? "left" : "bottom"
						} else {
							e[l[j]]["position"] = "bottom"
						}
					} else {
						if ((u == "var") || (u == "smp" && r.graphOrientation == "vertical")) {
							if (!e[l[j]]["position"].match(/top|bottom/)) {
								e[l[j]]["position"] = e[l[j]]["position"] == "rigth" ? "top" : "bottom"
							}
						} else {
							if (!e[l[j]]["position"].match(/left|right/)) {
								e[l[j]]["position"] = e[l[j]]["position"] == "top" ? "right" : "left"
							}
						}
					}
				}
			}
		};
		var o = function() {
			var k = [];
			var m = [];
			for (var j = 0; j < l.length; j++) {
				if (l[j] == "-") {
					m.push(j)
				}
			}
			for (var j = 0; j < l.length; j++) {
				if (l[j] != "-" && e[l[j]]["position"].match(/left|bottom/)) {
					k.push(l[j])
				}
			}
			for (var j = 0; j < l.length; j++) {
				if (l[j] != "-" && e[l[j]]["position"].match(/right|top/)) {
					k.push(l[j])
				}
			}
			for (var j = 0; j < m.length; j++) {
				k.splice(m[j], 0, "-")
			}
			l = k;
			r[u + "Overlays"] = l
		};
		if (this.isDOE) {} else {
			s();
			o()
		}
		this[u + "OverlaysStrLength"] = 0;
		for (var n = 0; n < t.length; n++) {
			var b = t[n].toLowerCase();
			var q = false;
			this[u + "OverlaysThickness" + t[n]] = 0;
			if (this.showOverlays && l.length > 0) {
				if (u == "smp") {
					if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
						continue
					}
				} else {
					if (u == "var") {
						if (this.graphType != "Heatmap") {
							continue
						}
					} else {
						continue
					}
				}
				for (var h = 0; h < l.length; h++) {
					if (l[h] == "-") {
						if (h > 0 && q == b) {
							this[u + "OverlaysThickness" + t[n]] += this.margin
						}
					} else {
						if (!c.hasOwnProperty(l[h])) {
							q = e[l[h]]["position"];
							if (q == b) {
								var d = this.getOverlaysForTypePosition(u, e[l[h]]["type"], b, l[h]);
								this[u + "OverlaysThickness" + t[n]] += e[l[h]]["thickness"] || this.overlaysThickness;
								for (var g = 0; g < d.length; g++) {
									this[u + "OverlaysStrLength"] = Math.max(this[u + "OverlaysStrLength"], this.measureText(d[g], this.overlayFont) + this.margin);
									c[d[g]] = true
								}
							}
						}
					}
				}
				if (this[u + "OverlaysThickness" + t[n]] > 0) {
					this[u + "OverlaysThickness" + t[n]] += this.margin
				}
			}
		}
	};
	this.getOverlaysForTypePosition = function(h, e, k, f) {
		var b = [];
		var l = h == "smp" ? this.smpOverlayProperties : this.varOverlayProperties;
		var g = h == "smp" ? this.smpOverlays : this.varOverlays;
		for (var j = 0; j < g.length; j++) {
			var d = g[j];
			if (d != "-" && l.hasOwnProperty(d)) {
				var m = l[d]["type"];
				var c = l[d]["position"];
				if (k.match(/left|bottom/) && !c.match(/left|bottom/)) {
					continue
				} else {
					if (k.match(/top|right/) && !c.match(/top|right/)) {
						continue
					}
				}
				if (e.match(/Area|AreaLine/) && m.match(/Area|AreaLine/)) {
					b.push(d)
				} else {
					if (e.match(/Bar|BarLine/) && m.match(/Bar|BarLine/)) {
						b.push(d)
					} else {
						if (e.match(/Dotplot|DotLine/) && m.match(/Dotplot|DotLine/)) {
							b.push(d)
						} else {
							if (e == "Line" && m == "Line") {
								b.push(d)
							} else {
								if (e.match(/Heatmap|Default|Text/)) {
									return [f]
								} else {
									if (e == "Pie" && m == "Pie") {
										b.push(d)
									} else {
										if ((e == "StackedPercent" || e == "StackedPercentLine") && (m == "StackedPercent" || m == "StackedPercentLine")) {
											b.push(d)
										} else {
											if ((e == "Stacked" || e == "StackedLine") && (m == "Stacked" || m == "StackedLine")) {
												b.push(d)
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return b
	};
	this.getVariableTitleHeight = function() {
		if (this.varTitle && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			return this.varTitleFontSize + this.margin
		} else {
			return 0
		}
	};
	this.getVariableLabelLength = function() {
		if (this.showVariableNames && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			if (this.varLabelRotate && Math.abs(this.varLabelRotate) == 90) {
				return this.varLabelFontSize + this.margin
			} else {
				return this.measureText(this.shortenText(this.meta.data.y.maxVarStr, this.maxVarStringLen), this.varLabelFont) + this.margin
			}
		} else {
			return 0
		}
	};
	this.getVariableLabelDescLength = function() {
		if (this.showVariableNames && this.varLabelDescription && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			var b = this.meta.data.z[this.varLabelDescription];
			if (b.maxLevChr > this.maxVarStringLen) {
				return this.measureText(b.maxLevStr.substring(0, this.maxVarStringLen), this.varLabelFont)
			} else {
				return this.measureText(b.maxLevStr, this.varLabelFont)
			}
		} else {
			return 0
		}
	};
	this.getSampleTitleHeight = function() {
		if (this.smpTitle && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			return this.smpTitleFontSize + this.margin
		} else {
			return 0
		}
	};
	this.getSampleLabelLength = function() {
		if (this.showSampleNames && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			if (this.smpLabelRotate && Math.abs(this.smpLabelRotate) == 90) {
				return this.smpLabelFontSize + this.margin
			} else {
				var b;
				if (this.layoutValid && !this.layoutAdjust) {
					b = this.isGroupedData ? this.getMaxText(this.meta.data.g.smps) : this.meta.data.y.maxSmpStr
				} else {
					if (this.isGraphTime) {
						b = this.getMaxText(this.timeValues)
					} else {
						b = this.isGroupedData ? this.meta.data.w.maxSmpStr : this.meta.data.y.maxSmpStr
					}
				}
				if (b.len > this.maxSmpStringLen) {
					b = this.measureText(b.substring(0, this.maxSmpStringLen), this.smpLabelFont) + (this.margin * 2)
				} else {
					b = this.measureText(b, this.smpLabelFont) + (this.margin * 2)
				}
				b = this.smpLabelRotate ? b * (Math.cos(this.radians(this.smpLabelRotate))) : b;
				return b
			}
		} else {
			return 0
		}
	};
	this.getSampleLabelDescLength = function() {
		if (this.showSampleNames && this.smpLabelDescription && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			var b = this.meta.data.x[this.smpLabelDescription];
			if (b.maxLevChr > this.maxSmpStringLen) {
				return this.measureText(b.maxLevStr.substring(0, this.maxSmpStringLen), this.smpLabelFont)
			} else {
				return this.measureText(b.maxLevStr, this.smpLabelFont)
			}
		} else {
			return 0
		}
	};
	this.getAxisTitleTickLength = function(m) {
		if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
			return 0
		} else {
			if (this.graphOrientation == "vertical") {
				var f, k, e, c;
				if (this.tickRotate && Math.abs(this.tickRotate) == 90) {
					f = this.axisTickFontSize
				} else {
					if (((this.xAxisTransform && this.xAxisTransform.match(/log|exp/)) || (this.isTransformedData && this.isTransformedData.match(/log|exp/))) && !this.xAxisTransformTicks) {
						var j = this.xAxisValues;
						var h = this.xAxis2Values;
						var l = [];
						for (var d = 0; d < j.length; d++) {
							var b = j[d];
							l.push(this.formatNumber(this.transformValue(this.xAxisTransform || this.isTransformedData, b, true)))
						}
						e = this.getMaxText(l);
						var g = [];
						for (var d = 0; d < h.length; d++) {
							var b = h[d];
							g.push(this.transformValue(this.xAxis2Transform || this.isTransformedData, b, true))
						}
						c = this.getMaxText(g)
					} else {
						e = this.xAxisMaxStrLength;
						c = this.xAxis2MaxStrLength
					}
					if (this.graphType == "Candlestick") {
						if (this.showVolume) {
							f = Math.max(this.measureText(e, this.axisTickFont), this.measureText(c, this.axisTickFont))
						} else {
							if (this.summaryType == "candle") {
								f = this.measureText(e, this.axisTickFont)
							} else {
								f = this.measureText(c, this.axisTickFont)
							}
						}
					} else {
						if (this.graphType == "BarLine" || this.graphType == "DotLine") {
							f = m ? this.measureText(c, this.axisTickFont) : this.measureText(e, this.axisTickFont)
						} else {
							f = this.measureText(e, this.axisTickFont)
						}
					}
					k = m ? this.getAxisDescription(true) : this.getAxisDescription();
					k = k != "" && !this.layoutValid ? this.axisTitleFontSize : 0;
					if (m) {
						return this.xAxis2Show ? k + f + (this.margin * 4) : 0
					} else {
						return this.xAxisShow ? k + f + (this.margin * 4) : 0
					}
				}
			} else {
				k = m ? this.getAxisDescription(true) : this.getAxisDescription();
				k = k != "" && !this.layoutValid ? this.axisTitleFontSize : 0;
				if (m) {
					return this.xAxis2Show ? k + this.axisTickFontSize + (this.margin * 4) : 0
				} else {
					return this.xAxisShow ? k + this.axisTickFontSize + (this.margin * 4) : 0
				}
			}
		}
	};
	this.getHeatmapIndicatorWidth = function() {
		if (this.showHeatmapIndicator) {
			var b = this.getDefaultMetaDataObject();
			var c = this.xAxisTitle ? this.measureText(this.xAxisTitle, this.legendFont) : 0;
			if (this.heatmapIndicatorPosition == "right") {
				return Math.max(c, this.heatmapIndicatorHeight + (this.margin * 2) + b.maxLevLen)
			} else {
				return Math.max(c, this.heatmapIndicatorWidth + b.maxLevLen)
			}
		} else {
			return 0
		}
	};
	this.getHeatmapIndicatorHeight = function(b) {
		if (this.showHeatmapIndicator) {
			var c = (this.margin * 2) + this.legendFontSize;
			if (b && this.isMultidimensionalData && this.heatmapIndicatorPosition == "bottom") {
				return this.legendInside ? 0 : this.heatmapIndicatorHeight + (this.xAxisTitle ? this.margin + this.legendFontSize : 0) + c
			} else {
				return this.heatmapIndicatorHeight + this.margin + this.legendFontSize + c
			}
		} else {
			return 0
		}
	};
	this.getLegendHeight = function() {
		if (this.graphType == "Heatmap" && !this.isMultidimensionalData && !(this.colorBy || this.shapeBy || this.sizeBy || this.patternBy)) {
			return this.legendOverlaysHeight
		} else {
			if (this.isMultidimensionalData || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|Heatmap/))) {
				return this.legendPosition == "right" ? this.legendWidth + this.legendOverlaysWidth : this.legendHeight + this.legendOverlaysHeight
			} else {
				if (this.graphType == "Treemap") {
					return 0
				} else {
					return this.legendVariableHeight + this.legendOverlaysHeight + this.margin
				}
			}
		}
	};
	this.getLegendWidth = function() {
		if (this.graphType == "Heatmap" && !this.isMultidimensionalData && !(this.colorBy || this.shapeBy || this.sizeBy || this.patternBy)) {
			return this.legendOverlaysWidth
		} else {
			if (this.isMultidimensionalData || ((this.colorBy || this.shapeBy || this.sizeBy || this.patternBy) && this.graphType.match(/^Bar$|Boxplot|Dotplot|Treemap|Heatmap/))) {
				return this.legendPosition == "right" ? this.legendWidth + this.legendOverlaysWidth : this.legendHeight + this.legendOverlaysHeight
			} else {
				if (this.graphType == "Treemap") {
					return 0
				} else {
					return this.legendVariableWidth + this.legendOverlaysWidth + this.margin
				}
			}
		}
	};
	this.getVarTreeHeight = function() {
		var b = 0;
		if (this.graphType == "Heatmap" && this.showVarDendrogram && this.varDendrogram) {
			if (this.dendrogramHeight) {
				b = this.dendrogramHeight + this.margin
			} else {
				b = ((this.varDendrogram.depth + 1) * this.dendrogramSpace) + this.margin
			}
		}
		return b
	};
	this.getSmpTreeWidthHeight = function() {
		var b = 0;
		if (this.showSmpDendrogram && this.smpDendrogram && !this.isGroupedData && this.graphType != "Treemap" && this.graphType != "TagCloud") {
			if (this.dendrogramHeight) {
				b = this.dendrogramHeight + this.margin
			} else {
				b = ((this.smpDendrogram.depth + 1) * this.dendrogramSpace) + this.margin
			}
		}
		return b
	};
	this.getOverlaysTickLabelsLength = function() {
		var d = 0;
		if (this.smpOverlays.length > 0) {
			var b = this.meta.data.x;
			var c = [];
			for (var f = 0; f < this.smpOverlays.length; f++) {
				var h = this.smpOverlays[f];
				if (h != "-") {
					var g = this.smpOverlayProperties[h].position;
					var e = this.smpOverlayProperties[h].type;
					if (g.match(/left|right/i) && !e.match(/text|default|increase|decrease/i)) {
						c.push(b[h].min);
						c.push(b[h].max)
					}
				}
			}
			d = this.measureText(this.getMaxText(c), this.overlayFont)
		}
		return d ? d + (this.margin * 2) : 0
	};
	this.set1DXYDimensionsLeft = function() {
		var b = 0;
		if (this.graphOrientation == "vertical") {
			b = this.layoutValid && !this.layoutAdjust && !this.isShowDOEData ? this.margin * (this.layoutCollapse ? 0 : 1) : this.margin + this.getAxisTitleTickLength()
		} else {
			b = this.margin + this.getSampleTitleHeight() + this.getSampleLabelLength() + this.smpOverlaysThicknessLeft;
			if (this.smpDendrogramPosition != "right") {
				b += this.getSmpTreeWidthHeight()
			}
		}
		this.left = b
	};
	this.set1DXYDimensionsRight = function() {
		var b = 0;
		if (this.graphOrientation == "vertical") {
			b = this.layoutValid && !this.layoutAdjust && !this.isShowDOEData ? this.margin * (this.layoutCollapse ? 0 : 1) : this.margin + this.getAxisTitleTickLength(true)
		} else {
			b = this.margin + this.smpOverlaysThicknessRight;
			if (this.smpDendrogramPosition == "right") {
				b += this.getSmpTreeWidthHeight()
			}
			if (this.layoutValid && this.layoutCollapse) {
				b -= this.margin
			}
		}
		if (this.showLegend && this.legendPosition == "right" && !this.legendInside) {
			if (this.graphType == "Heatmap") {
				if (this.isMultidimensionalData && (this.colorBy || this.shapeBy || this.sizeBy || this.patternBy)) {
					b += this.getLegendWidth()
				}
			} else {
				b += this.getLegendWidth()
			}
		}
		if (this.graphType == "Heatmap") {
			var e = this.getSampleLabelDescLength();
			var c = 0;
			if (this.showOverlays) {
				c = this.varOverlaysStrLength
			}
			c = Math.max(e, c);
			e = this.margin + this.smpOverlaysThicknessRight;
			if (this.smpDendrogramPosition == "right") {
				e = this.getSmpTreeWidthHeight()
			}
			if (c > e) {
				b += c - e
			}
			if (this.heatmapIndicatorPosition == "right") {
				b += this.getHeatmapIndicatorWidth()
			}
			b += this.legendOverlaysWidth
		}
		this.right = b
	};
	this.set1DXYDimensionsTop = function() {
		var g = this.getOverlaysTickLabelsLength();
		var c = this.margin + this.getTitleSubtitleHeight();
		if (this.layoutValid) {
			c += ((this.getFontHeight() + (this.margin * 2)) * (this.segregateVariablesBy.length + this.segregateSamplesBy.length)) - this.margin
		}
		if (this.graphOrientation == "vertical") {
			c += this.smpOverlaysThicknessTop;
			if (this.smpDendrogramPosition != "bottom") {
				c += this.getSmpTreeWidthHeight()
			}
		} else {
			if (this.graphType == "Heatmap") {
				var b = 0;
				var e = this.layoutValid ? this.margin : this.getHeatmapIndicatorHeight();
				var f = e;
				b += this.varOverlaysThicknessTop;
				if (this.varDendrogramPosition != "bottom") {
					b += this.getVarTreeHeight()
				}
				if (this.varTitleLabelOverlayPosition != "bottom") {
					b += this.getVariableTitleHeight();
					b += this.getVariableLabelLength()
				} else {
					b += this.getVariableLabelDescLength()
				}
				if (!this.isOncoprint) {
					if (this.heatmapIndicatorPosition == "right") {} else {
						if (this.heatmapIndicatorPosition == "top") {
							b += e
						} else {
							if (this.heatmapIndicatorPosition == "topLeft") {
								if (this.left > (this.heatmapIndicatorWidth + (this.margin * 6))) {
									f = e - b;
									b = Math.max(b, e)
								} else {
									this.heatmapIndicatorY = b;
									b += e
								}
							} else {
								if (this.right > (this.heatmapIndicatorWidth + (this.margin * 6))) {
									f = e - b;
									b = Math.max(b, e)
								} else {
									b += e
								}
							}
						}
					}
				}
				c += b;
				this.heatmapIndicatorY = c + this.margin - f
			} else {
				c += this.getAxisTitleTickLength()
			}
		}
		this.top = Math.max(c, g)
	};
	this.set1DXYDimensionsBottom = function() {
		var c = this.margin;
		if (this.graphOrientation == "vertical") {
			c += this.getSampleTitleHeight() + this.getSampleLabelLength() + this.smpOverlaysThicknessBottom;
			if (this.smpDendrogramPosition == "bottom") {
				c += this.getSmpTreeWidthHeight()
			}
			if (this.showLegend && this.legendPosition == "bottom" && !this.legendInside) {
				c += this.getLegendHeight()
			}
			if (this.layoutValid && this.layoutCollapse) {
				c -= this.margin
			}
		} else {
			if (this.graphType == "Heatmap") {
				c += this.varOverlaysThicknessBottom;
				if (this.varTitleLabelOverlayPosition == "bottom") {
					c += this.getVariableLabelLength();
					c += this.getVariableTitleHeight()
				} else {
					c += Math.max(this.getVariableLabelDescLength(), this.smpOverlaysStrLength)
				}
				if (this.varDendrogramPosition == "bottom") {
					c += this.getVarTreeHeight()
				}
				if (this.isOncoprint) {
					c += this.legendOncoprintHeight
				}
				if (!this.legendInside && this.legendPosition == "bottom") {
					c += this.legendHeight
				}
			} else {
				c += this.getAxisTitleTickLength(true);
				if (this.showLegend && this.legendPosition == "bottom" && !this.legendInside) {
					c += this.getLegendHeight()
				}
				if (this.layoutValid && this.layoutCollapse) {
					c -= this.margin
				}
			}
		}
		this.bottom = c
	};
	this.adjustLegendFontSize = function() {
		var b = this.meta.config.orig;
		if (!b.legendFontSize && this.adjustAspectRatio) {
			b.legendFontSize = this.legendFontSize
		}
		if (this.legendFontSize > 3) {
			this.legendFontSize -= 2
		}
	};
	this.adjustSmpFontSize = function() {
		if (this.adjustAspectRatio) {
			var b = this.meta.config.orig;
			this.smpLabelFontSize = parseInt(this.smpLabelFontSize * 0.8);
			if (this.smpLabelFontSize < this.minTextSize) {
				if (!b.showSampleNames) {
					b.showSampleNames = this.showSampleNames;
					this.showSampleNames = false
				}
			}
			this.smpLabelFont = this.smpLabelFontStyle + " " + Math.min(Math.max(parseInt(this.smpLabelFontSize * this.smpLabelScaleFontFactor), this.minTextSize), this.maxTextSize) + "px " + this.fontName
		}
	};
	this.adjustVarFontSize = function() {
		if (this.adjustAspectRatio) {
			var b = this.meta.config.orig;
			this.varLabelFontSize = parseInt(this.varLabelFontSize * 0.8);
			if (this.varLabelFontSize < this.minTextSize) {
				if (!b.showVariableNames) {
					b.showVariableNames = this.showVariableNames;
					this.showVariableNames = false
				}
			}
			this.varLabelFont = this.varLabelFontStyle + " " + Math.min(Math.max(parseInt(this.varLabelFontSize * this.varLabelScaleFontFactor), this.minTextSize), this.maxTextSize) + "px " + this.fontName
		}
	};
	this.adjust1DYDimension = function() {
		var b = this.layoutComb ? this.layoutHeight * this.percentAspectRatioPlotArea : this.height * this.percentAspectRatioPlotArea;
		var c = this.meta.config.orig;
		while (this.adjustAspectRatioYTries <= this.adjustAspectRatioMax && this.y < b) {
			this.adjustLegendFontSize();
			this.setLegends();
			this.adjustVarFontSize();
			this.adjustSmpFontSize();
			this.set1DXYDimensionsTop();
			this.set1DXYDimensionsBottom();
			this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
			if (this.adjustAspectRatioYTries == this.adjustAspectRatioMax && this.y < b) {
				if (this.showLegend && this.legendPosition == "bottom" && !this.legendInside) {
					c.showLegend = this.showLegend;
					this.showLegend = false
				}
				if (this.varLabelDescription) {
					c.varLabelDescription = this.varLabelDescription;
					this.varLabelDescription = false
				}
				this.set1DXYDimensionsTop();
				this.set1DXYDimensionsBottom();
				this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
				if (this.y < b) {
					this.errors.push("The text size doesn't fit in the graph. Either make it smaller or make the graph bigger!\nYou can also reduce the maximum length for the text string!")
				}
			}
			this.adjustAspectRatioYTries++
		}
	};
	this.adjust1DXDimension = function() {
		var b = this.layoutComb ? this.layoutWidth * this.percentAspectRatioPlotArea : this.width * this.percentAspectRatioPlotArea;
		var c = this.meta.config.orig;
		while (this.adjustAspectRatioXTries <= this.adjustAspectRatioMax && this.x < b) {
			this.adjustLegendFontSize();
			this.setLegends();
			this.adjustVarFontSize();
			this.adjustSmpFontSize();
			this.set1DXYDimensionsLeft();
			this.set1DXYDimensionsRight();
			this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
			if (this.adjustAspectRatioXTries == this.adjustAspectRatioMax && this.x < b) {
				if (this.showLegend && this.legendPosition != "bottom" && !this.legendInside) {
					c.showLegend = this.showLegend;
					this.showLegend = false
				}
				if (this.smpLabelDescription) {
					c.smpLabelDescription = this.smpLabelDescription;
					this.smpLabelDescription = false
				}
				this.set1DXYDimensionsLeft();
				this.set1DXYDimensionsRight();
				this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
				if (this.x < b) {
					this.errors.push("The text size doesn't fit in the graph. Either make it smaller or make the graph bigger!\nYou can also reduce the maximum length for the text string!")
				}
			}
			this.adjustAspectRatioXTries++
		}
	};
	this.set1DXYDimensions = function() {
		var c = this.layoutComb ? this.layoutWidth * this.percentAspectRatioPlotArea : this.width * this.percentAspectRatioPlotArea;
		var b = this.layoutComb ? this.layoutHeight * this.percentAspectRatioPlotArea : this.height * this.percentAspectRatioPlotArea;
		if (this.isGraphTime) {
			if (!this.showVolume || (this.layoutComb && this.layoutCurrent == 0)) {
				this.setTimeAxis()
			}
		}
		this.setLegends();
		this.setRowColBlocks();
		this.set1DFont();
		if (this.graphOrientation == "vertical") {
			this.set1DXYDimensionsTop();
			this.set1DXYDimensionsBottom();
			if (this.adjustAspectRatio) {
				this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
				if (this.y < b) {
					this.adjust1DYDimension()
				}
			}
			this.set1DXYDimensionsLeft();
			this.set1DXYDimensionsRight();
			if (this.adjustAspectRatio) {
				this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
				if (this.x < c) {
					this.adjust1DXDimension()
				}
			}
		} else {
			this.set1DXYDimensionsLeft();
			this.set1DXYDimensionsRight();
			if (this.adjustAspectRatio) {
				this.x = this.layoutComb ? this.layoutWidth - (this.left + this.right) : this.width - (this.marginLeft + this.left + this.right + this.marginRight);
				if (this.x < c) {
					this.adjust1DXDimension()
				}
			}
			this.set1DXYDimensionsTop();
			this.set1DXYDimensionsBottom();
			if (this.adjustAspectRatio) {
				this.y = this.layoutComb ? this.layoutHeight - (this.top + this.bottom) : this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
				if (this.y < b) {
					this.adjust1DYDimension()
				}
			}
		}
	};
	this.set1DPrivateParams = function() {
		var i = this.isGroupedData ? this.grpIndices.length : this.smpIndices.length;
		if (this.isOncoprint) {
			var f = this.adjustAspectRatio ? this.x / this.varIndices.length : 10;
			var b = f * 3;
			var j = f * this.colBlocks;
			var g = b * this.rowBlocks;
			var k = this.marginLeft + this.left + j + this.right + this.marginRight;
			var e = this.marginTop + this.top + g + this.bottom + this.marginBottom;
			if (e <= this.height) {
				this.colBlockSize = f;
				this.rowBlockSize = b;
				this.blockSeparation = this.rowBlockSize
			} else {
				this.rowBlockSize = this.y / this.rowBlocks;
				this.blockSeparation = this.rowBlockSize;
				this.colBlockSize = this.rowBlockSize / 3
			}
			this.y = this.rowBlockSize * this.rowBlocks;
			this.x = this.colBlockSize * this.colBlocks;
			k = this.marginLeft + ((this.left + this.x + this.right) * this.layoutCols) + this.marginRight;
			e = this.marginTop + ((this.top + this.y + this.bottom) * this.layoutRows) + this.marginBottom;
			this.width = Math.max(k, this.width);
			this.height = Math.max(e, this.height);
			this.resizeCanvas()
		} else {
			if (!this.adjustAspectRatio) {
				this.rowBlockSize = this.widthFactor * (this.scaleTextToSize(this.rowBlocks) + this.scaleTextConstantAdd);
				if (this.graphType == "Heatmap") {
					if (this.colBlocks < 20) {
						this.colBlockSize = this.scaleTextToSize(this.colBlocks) + (this.scaleTextConstantAdd * 4)
					} else {
						this.colBlockSize = (parseInt(1 / Math.sqrt(this.colBlocks) * this.scaleTextConstantMult)) + 1
					}
					this.colBlockSize *= this.widthFactor;
					this.blockSeparation = this.rowBlockSize / 2;
					this.y = this.rowBlockSize * this.rowBlocks;
					this.x = this.colBlockSize * this.colBlocks
				} else {
					this.blockSeparation = this.rowBlockSize * this.sampleSeparationFactor;
					if (this.graphOrientation == "vertical") {
						if (this.graphType.match(/Area/)) {
							this.x = (this.rowBlockSize * (this.rowBlocks - 1)) + (this.blockSeparation * (i - 1))
						} else {
							if (this.plotByVariable) {
								this.x = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * this.variableBlock) + this.blockSeparation
							} else {
								this.x = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * i) + this.blockSeparation
							}
						}
						this.y = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom)
					} else {
						if (this.graphType.match(/Area/)) {
							this.y = (this.rowBlockSize * (this.rowBlocks - 1)) + (this.blockSeparation * (i - 1))
						} else {
							if (this.plotByVariable) {
								this.y = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * this.varIndices.length) + this.blockSeparation
							} else {
								this.y = (this.rowBlockSize * this.rowBlocks) + (this.blockSeparation * i) + this.blockSeparation
							}
						}
						this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
					}
					this.colBlockSize = 1
				}
				this.width = this.marginLeft + ((this.left + this.x + this.right) * this.layoutCols) + this.marginRight;
				this.height = this.marginTop + ((this.top + this.y + this.bottom) * this.layoutRows) + this.marginBottom;
				this.resizeCanvas()
			} else {
				if (this.graphType == "Heatmap") {
					this.rowBlockSize = this.y / this.rowBlocks;
					this.blockSeparation = this.rowBlockSize;
					this.colBlockSize = this.x / this.varIndices.length
				} else {
					if (this.graphType.match(/Area/)) {
						this.rowBlockSize = this.graphOrientation == "vertical" ? this.x / (this.rowBlocks + i - 2) : this.y / (this.rowBlocks + i - 2)
					} else {
						if (this.plotByVariable) {
							this.rowBlockSize = this.graphOrientation == "vertical" ? this.x / (this.rowBlocks + this.varIndices.length) : this.y / (this.rowBlocks + this.varIndices.length)
						} else {
							this.rowBlockSize = this.graphOrientation == "vertical" ? this.x / (this.rowBlocks + i) : this.y / (this.rowBlocks + i)
						}
					}
					var l = this.widthFactor + this.sampleSeparationFactor;
					var d = this.graphType.match(/Stacked/) ? 1 : this.varIndices.length;
					if (this.widthFactor > this.sampleSeparationFactor) {
						this.blockSeparation = this.rowBlockSize * (this.sampleSeparationFactor / l);
						this.rowBlockSize *= 1 + (this.widthFactor / (l * d))
					} else {
						if (this.sampleSeparationFactor > this.widthFactor) {
							this.blockSeparation = this.rowBlockSize * (1 + (this.sampleSeparationFactor / l));
							this.rowBlockSize -= ((this.blockSeparation - this.rowBlockSize) / d)
						} else {
							this.blockSeparation = this.rowBlockSize
						}
					}
					this.colBlockSize = 1
				}
			}
		}
	};
	this.get1DMinFloorValue = function() {
		if (this.xAxisTransform && this.xAxisTransform == "floor") {
			return this.xAxisTransformFloorValue
		} else {
			return this.minData
		}
	};
	this.get1DMaxCeilValue = function() {
		if (this.xAxisTransform && this.xAxisTransform == "ceil") {
			return this.xAxisTransformCeilValue
		} else {
			return this.maxData
		}
	};
	this.getTreemapVariable = function(h, e) {
		var j = [];
		var m = 0;
		for (var g = 0; g < e.length; g++) {
			var f = e[g];
			var k = this.getDataAtPos(f, h, false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue());
			if (!isNaN(k)) {
				m += k
			}
			var l = this.getPropertyValue(f, h, "colorBy");
			var b = this.getPropertyValue(f, h, "patternBy");
			j.push({
				area: k,
				color: l,
				pattern: b,
				index: [f, h]
			})
		}
		return [m, j]
	};
	this.getTreemap = function() {
		this.drawDendrogram("smpDendrogram");
		var j = this.varIndices[0];
		var b = [];
		var f = this;
		var h = function(m, i) {
			if (!m.left && !m.right) {
				var k = f.getSampleIndices(m.id);
				var n = f.getDataAtPos(j, k);
				i.push({
					area: n,
					label: f.data.y.smps[k],
					color: f.colorBy ? f.getPropertyValue(j, k, "colorBy") : f.colors[k % f.colors.length],
					index: [j, k]
				})
			} else {
				var l = [];
				h(m.left, l);
				h(m.right, l);
				i.push({
					area: l[0].area + l[1].area,
					index: -1,
					children: l
				})
			}
			return i
		};
		if (this.smpDendrogram) {
			b = h(this.smpDendrogram.object, [])
		} else {
			for (var e = 0; e < this.smpIndices.length; e++) {
				var c = this.smpIndices[e];
				var g = this.getDataAtPos(j, c);
				b.push({
					area: g,
					label: this.data.y.smps[c],
					color: this.colorBy ? this.getPropertyValue(j, c, "colorBy") : this.colors[c % this.colors.length],
					index: [j, c]
				})
			}
		}
		if (this.isDOE) {
			return this.processTreemap(b, {
				width: this.x - 20,
				height: this.y - 20,
				left: 10,
				top: 10
			})
		} else {
			return this.processTreemap(b, {
				width: this.x,
				height: this.y,
				left: 0,
				top: 0
			})
		}
	};
	this.set1DXAxis = function() {
		var b = this.graphOrientation == "vertical" ? "y" : "x";
		var c = ["BarLine", "DotLine", "AreaLine", "StackedLine", "StackedPercentLine"];
		this.setAxisUnits("xAxis", b);
		if ((this.isInArray(this.graphType, c) && this.data.a) || (this.graphType == "Candlestick" && this.showVolume)) {
			this.setAxisUnits("xAxis2", b)
		}
	};
	this.draw1DWireFrame = function() {
		var x, f, w, e, v, d, u, b, o, g, k, s, q;
		var h = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var y = this.xAxisTickStyle == "dotted" || this.yAxisTickStyle == "dotted" ? "dottedLine" : "line";
		var z = this.smpHairline == "dotted" ? "dottedLine" : "line";
		var p = this.marginLeft + this.offsetX + this.left;
		var n = this.marginTop + this.offsetY + this.top;
		if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
			return
		}
		this.disableGradientTransparencyShadow();
		if (this.graphType != "Heatmap") {
			if ((this.graphType == "BarLine" || this.graphType == "DotLine") && this.xAxis2Title) {
				var c = this.getVariablesVisibleByAxis("xAxis");
				s = c.length
			} else {
				if (this.graphType.match(/Stacked|Line|Area/)) {
					s = 1
				} else {
					s = this.varIndices.length
				}
			}
			k = s * this.rowBlockSize;
			q = (this.blockSeparation + k) / 2;
			if (this.graphOrientation == "vertical") {
				if (this.isGraphTime) {
					var j = this.x / h.length;
					var m = this.graphType.match(/Area/) ? 0 : p + ((this.blockSeparation + k) / 2);
					f = n;
					e = n + this.y;
					for (var r = 0; r < this.timeValueIndices.length; r++) {
						x = (this.timeValueIndices[r] * j) + m;
						if (this.smpHairline) {
							this.drawLine(z, x, f, x, e, this.smpHairlineColor, this.smpHairlineWidth, "butt")
						}
					}
				} else {
					if (!this.plotByVariable) {
						x = this.graphType.match(/Area/) ? p : p + this.blockSeparation + k;
						w = p;
						v = p + this.blockSeparation + k;
						f = n;
						e = this.y;
						for (var r = 0; r < h.length; r++) {
							if (this.blockContrast) {
								g = r % 2 ? this.evenColor : this.oddColor;
								this.rectangle(w, f, v, e, g, g);
								w = v;
								v = w + this.blockSeparation + k
							}
							if (this.smpHairline) {
								if (this.graphType.match(/Area/) && (r == 0 || r == h.length - 1)) {
									x += this.blockSeparation + k;
									continue
								}
								this.drawLine(z, x - q, f, x - q, f + e, this.smpHairlineColor, this.smpHairlineWidth, "butt")
							}
							x += this.blockSeparation + k
						}
					}
				}
				if (this.xAxisMinorTicks && this.summaryType != "volume") {
					for (var r = 0; r < this.xAxisMinorValues.length; r++) {
						var A = parseFloat(this.xAxisMinorValues[r]);
						if (A >= this.xAxisMin && A <= this.xAxisMax) {
							f = this.marginTop + this.offsetY + this.top + this.y - ((A - this.xAxisMin) * this.xAxisUnit);
							this.drawLine(y, p, f, p + this.x, f, this.xAxisTickColor, this.outlineWidth / 3, "butt")
						}
					}
				}
				x = this.marginLeft + this.offsetX + this.left - (this.margin * 2);
				w = p;
				v = p + this.x;
				for (var r = 0; r < this.xAxisValues.length; r++) {
					var A = parseFloat(this.xAxisValues[r]);
					if (A >= this.xAxisMin && A <= this.xAxisMax) {
						f = this.marginTop + this.offsetY + this.top + this.y - ((A - this.xAxisMin) * this.xAxisUnit);
						if (this.xAxisMajorTicks) {
							this.drawLine(y, w, f, v, f, this.xAxisTickColor, false, "butt")
						}
						if (this.xAxisShow || this.xAxisShowLayout) {
							this.drawLine(y, w - this.margin, f, w, f, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt")
						}
						if (this.xAxis2Show || this.xAxis2ShowLayout) {
							this.drawLine(y, v, f, v + this.margin, f, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt")
						}
					}
				}
			} else {
				if (this.isGraphTime) {
					var j = this.y / h.length;
					var m = this.graphType.match(/Area/) ? 0 : n + ((this.blockSeparation + k) / 2);
					x = p;
					w = this.x;
					for (var r = 0; r < this.timeValueIndices.length; r++) {
						f = (this.timeValueIndices[r] * j) + m;
						if (this.smpHairline) {
							this.drawLine(z, x, f, w, f, this.smpHairlineColor, this.smpHairlineWidth, "butt")
						}
					}
				} else {
					if (!this.plotByVariable) {
						x = p;
						w = this.x;
						f = this.graphType.match(/Area/) ? n : n + this.blockSeparation + k;
						e = n;
						d = n + this.blockSeparation + k;
						for (var r = 0; r < h.length; r++) {
							if (this.blockContrast) {
								b = r == 0 || r == h.length - 1 ? (this.blockSeparation * 1.5) + k : this.blockSeparation + k;
								g = r % 2 ? this.evenColor : this.oddColor;
								this.rectangle(x, e, w, b, g, g);
								e = d;
								d = e + this.blockSeparation + k
							}
							if (this.smpHairline) {
								if (this.graphType.match(/Area/) && (r == 0 || r == h.length - 1)) {
									f += this.blockSeparation + k;
									continue
								}
								this.drawLine(z, x, f - q, p + w, f - q, this.smpHairlineColor, this.smpHairlineWidth, "butt")
							}
							f += this.blockSeparation + k
						}
					}
				}
				if (this.xAxisMinorTicks && this.summaryType != "volume") {
					for (var r = 0; r < this.xAxisMinorValues.length; r++) {
						var A = parseFloat(this.xAxisMinorValues[r]);
						if (A >= this.xAxisMin && A <= this.xAxisMax) {
							x = this.graphInverted ? p + this.x - ((A - this.xAxisMin) * this.xAxisUnit) : p + ((A - this.xAxisMin) * this.xAxisUnit);
							this.drawLine(y, x, n, x, n + this.y, this.xAxisTickColor, this.outlineWidth / 3, "butt")
						}
					}
				}
				f = this.marginTop + this.offsetY + this.top - ((this.margin * 2) + (this.axisTickFontSize / 2));
				e = n;
				d = n + this.y;
				o = (this.segregateVariablesBy.length + this.segregateSamplesBy.length) * (this.getFontHeight() + (this.margin * 2));
				b = e - (o + this.margin);
				for (var r = 0; r < this.xAxisValues.length; r++) {
					var A = parseFloat(this.xAxisValues[r]);
					if (A >= this.xAxisMin && A <= this.xAxisMax) {
						x = this.graphInverted ? p + this.x - ((A - this.xAxisMin) * this.xAxisUnit) : p + ((A - this.xAxisMin) * this.xAxisUnit);
						if (this.xAxisMajorTicks) {
							this.drawLine(y, x, e, x, d, this.xAxisTickColor, false, "butt")
						}
						if (this.xAxisShow || this.xAxisShowLayout) {
							if (this.layoutValid) {
								if (this.layoutAdjust) {
									this.drawLine(y, x, e - this.margin, x, e, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt")
								} else {
									this.drawLine(y, x, b, x, b + this.margin, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt")
								}
							} else {
								this.drawLine(y, x, e - this.margin, x, e, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt")
							}
						}
						if (this.xAxis2Show || this.xAxis2ShowLayout) {
							this.drawLine(y, x, d, x, d + this.margin, this.backgroundType.match(/window/) ? this.foregroundWindow : this.xAxisTickColor, false, "butt")
						}
					}
				}
			}
		}
		this.enableGradientTransparencyShadow()
	};
	this.drawTrees = function() {
		if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
			return
		} else {
			if (!this.isGroupedData) {
				this.drawDendrogram("smpDendrogram");
				if (this.graphType == "Heatmap") {
					this.drawDendrogram("varDendrogram")
				}
			}
		}
	};
	this.getMaxDepthDendrogramXYs = function(d) {
		if (d.length > 0) {
			var b = [];
			for (var c = 0; c < d.length; c++) {
				b.push(d[c][1])
			}
			b.sort(function(f, e) {
				return e - f
			});
			for (var c = 0; c < d.length; c++) {
				if (d[c][1] == b[0]) {
					return c
				}
			}
		} else {
			return -1
		}
	};
	this.drawDendrogram = function(J) {
		var ad = this.marginLeft + this.offsetX + this.left;
		var Y = this.marginTop + this.offsetY + this.top;
		var O = J == "varDendrogram" ? "showVarDendrogram" : "showSmpDendrogram";
		var g = J == "varDendrogram" ? this.varIndices : this.smpIndices;
		var E, b, D, al, aj, K, P;
		var ab = this.dendrogramSpace / 2;
		if (this.graphType == "Treemap" && this.graphType == "TagCloud") {
			return
		}
		this.disableGradientTransparencyShadow();
		if (J == "varDendrogram") {
			if (this.varDendrogramPosition == "bottom") {
				P = [ad, Y + this.y, this.x, this.bottom]
			} else {
				P = [ad, this.marginTop + this.offsetY, this.x, this.top]
			}
		} else {
			if (this.graphOrientation == "vertical") {
				if (this.smpDendrogramPosition == "bottom") {
					P = [ad, Y + this.y, this.x, this.bottom]
				} else {
					P = [ad, this.marginTop + this.offsetY, this.x, this.top]
				}
			} else {
				if (this.smpDendrogramPosition == "right") {
					P = [ad + this.x, Y, this.right, this.y]
				} else {
					P = [this.marginLeft + this.offsetX, Y, this.left, this.y]
				}
			}
		}
		if (this.graphType != "Heatmap") {
			if ((this.graphType == "BarLine" || this.graphType == "DotLine") && this.xAxis2Title) {
				var J = this.getVariablesVisibleByAxis("xAxis");
				K = J.length
			} else {
				if (this.graphType.match(/Stacked|Line|Area/)) {
					K = 1
				} else {
					K = this.varIndices.length
				}
			}
			aj = K * this.rowBlockSize
		} else {
			aj = 0
		}
		if (this[O] && this[J]) {
			var H = this[J].data;
			var ak = this[J].idxs;
			var K = this[J].depth;
			var s = this.getMaxDepthDendrogramXYs(H);
			var f = this[J].max;
			var T = this.dendrogramHeight ? this.dendrogramHeight / K : this.dendrogramSpace;
			var F = (T * K) / f;
			var I = 0;
			var p = {};
			var C = {};
			var e = [];
			var k = this[J].heights.sort(function(j, i) {
				return j - i
			});
			if (J == "varDendrogram") {
				for (var ai = 0; ai < H.length; ai++) {
					e[ai] = this.createClusterNode(this.data.y.vars[ak[ai]], null, null, f, null)
				}
			} else {
				for (var ai = 0; ai < H.length; ai++) {
					e[ai] = this.createClusterNode(this.data.y.smps[ak[ai]], null, null, f, null)
				}
			}
			while (H.length > 1) {
				ai = s;
				var o = [ai];
				var V = H[ai][0];
				var U = H[ai][1];
				var S = H[ai][2];
				var X = H[ai][3];
				var v = [V];
				var u = [U];
				var q = [S];
				var A = [X];
				var h = this.isNumber(k[I]) ? k[I] : false;
				var L = {};
				var aa = "";
				var G = S;
				L[ai] = 1;
				for (var ag = ai + 1; ag < H.length; ag++) {
					var af = H[ag][0];
					var ae = H[ag][1];
					var ac = H[ag][2];
					var ah = H[ag][3];
					if (ae == U && ((ac == 0 && ah <= X) || (ah < X))) {
						v.push(af);
						u.push(ae);
						q.push(ac);
						A.push(ah);
						G += ac;
						L[ag] = 1;
						o.push(ag)
					} else {
						break
					}
				}
				if (v.length > 1) {
					if (J == "varDendrogram") {
						var m = this.colBlockSize / 2;
						var W;
						if (this.varDendrogramPosition == "bottom") {
							if (this.varTitleLabelOverlayPosition != "bottom") {
								W = (Y + this.y + this.bottom) - ((T * (K + 1)))
							} else {
								W = (Y + this.y + this.bottom) - ((T * (K + 1)) + this.getVariableTitleHeight())
							}
							if (this.isOncoprint) {
								W -= this.legendOncoprintHeight
							}
							if (!this.legendInside && this.legendPosition == "bottom") {
								W -= this.legendHeight
							}
						} else {
							if (this.varTitleLabelOverlayPosition != "bottom") {
								W = Y - (this.varOverlaysThicknessTop + this.getVariableLabelLength() + this.getVarTreeHeight())
							} else {
								W = Y - (this.margin + this.varOverlaysThicknessTop + this.getVarTreeHeight() + this.getVariableLabelDescLength())
							}
						}
						for (var ai = 0; ai < v.length; ai++) {
							E = (ad + m) + (this.colBlockSize * (v[ai] - 1));
							E = this.varIndicesStart > -1 ? E - (this.colBlockSize * this.varIndicesStart) : E;
							if (this.varDendrogramPosition == "bottom") {
								if (this.dendrogramHeight) {
									if (this.isLeafNode(e[o[ai]])) {
										b = W;
										al = b + T + (h * F)
									} else {
										b = W + ((f - e[o[ai]].dist) * F) + T;
										al = W + T + (h * F)
									}
								} else {
									if (this.isLeafNode(e[o[ai]]) && !this.dendrogramHang) {
										b = W;
										al = W + this.getVarTreeHeight() - ((T * u[ai]) + T)
									} else {
										b = al - T;
										al = W + this.getVarTreeHeight() - ((T * u[ai]) + T)
									}
								}
							} else {
								if (this.dendrogramHeight) {
									if (this.isLeafNode(e[o[ai]])) {
										b = W + (e[o[ai]].dist * F) - (h * F);
										al = W + (e[o[ai]].dist * F) + T
									} else {
										b = W + ((f - h) * F);
										al = W + (e[o[ai]].dist * F)
									}
								} else {
									if (this.isLeafNode(e[o[ai]]) && !this.dendrogramHang) {
										b = W + (T * u[ai]);
										al = W + (T * (K + 1))
									} else {
										b = W + (T * u[ai]);
										al = b + T
									}
								}
							}
							this.drawLine("line", E, b, E, al, this.dendrogramColor, false, "butt", false, false, true, P);
							if (!p.hasOwnProperty(X)) {
								p[X] = 0
							}
							if (!this.isLeafNode(e[o[ai]])) {
								this.addArea(["rect", E - ab, al - ab, E + ab, al + ab], [-X], "-" + p[X] + "-varDendrogram");
								p[X]++
							}
							if (ai < v.length - 1) {
								D = (ad + m) + (this.colBlockSize * (v[ai + 1] - 1));
								D = this.varIndicesStart > -1 ? D - (this.colBlockSize * this.varIndicesStart) : D;
								if (this.varDendrogramPosition == "bottom") {
									this.addArea(this.drawLine("line", E, al, D, al, this.dendrogramColor, false, "butt", false, false, true, P), ["varDendrogram"])
								} else {
									this.addArea(this.drawLine("line", E, b, D, b, this.dendrogramColor, false, "butt", false, false, true, P), ["varDendrogram"])
								}
							}
						}
					} else {
						if (this.graphOrientation == "vertical") {
							var W;
							if (this.smpDendrogramPosition == "bottom") {
								W = (Y + this.y + this.bottom) - (this.getSampleTitleHeight() + (T * (K + 1)) + this.margin);
								if (this.showLegend && this.legendPosition == "bottom" && !this.legendInside) {
									W -= this.getLegendHeight()
								}
							} else {
								W = Y - (this.getSmpTreeWidthHeight() + this.smpOverlaysThicknessTop)
							}
							for (var ai = 0; ai < v.length; ai++) {
								E = (ad + this.blockSeparation + (aj / 2)) + ((this.blockSeparation + aj) * (v[ai] - 1));
								if (this.graphType.match(/Area/)) {
									E -= aj * 1.5
								}
								E = this.smpIndicesStart > -1 ? E - ((this.blockSeparation + aj) * this.smpIndicesStart) : E;
								if (this.smpDendrogramPosition == "bottom") {
									if (this.dendrogramHeight) {
										if (this.isLeafNode(e[o[ai]])) {
											b = W;
											al = b + T + (h * F)
										} else {
											b = W + ((f - e[o[ai]].dist) * F) + T;
											al = W + T + (h * F)
										}
									} else {
										if (this.isLeafNode(e[o[ai]]) && !this.dendrogramHang) {
											b = W;
											al = W + this.getVarTreeHeight() - ((T * u[ai]) + T)
										} else {
											al = W + this.getVarTreeHeight() - ((T * u[ai]) + T);
											b = al - T
										}
									}
								} else {
									if (this.dendrogramHeight) {
										if (this.isLeafNode(e[o[ai]])) {
											b = W + (e[o[ai]].dist * F) - (h * F);
											al = W + (e[o[ai]].dist * F) + T
										} else {
											b = W + ((f - h) * F);
											al = W + (e[o[ai]].dist * F)
										}
									} else {
										if (this.isLeafNode(e[o[ai]]) && !this.dendrogramHang) {
											b = W + (T * u[ai]);
											al = W + (T * (K + 1))
										} else {
											b = W + (T * u[ai]);
											al = b + T
										}
									}
								}
								this.drawLine("line", E, b, E, al, this.dendrogramColor, false, "butt", false, false, true, P);
								if (!p.hasOwnProperty(X)) {
									p[X] = 0
								}
								if (!this.isLeafNode(e[o[ai]])) {
									this.addArea(["rect", E - ab, al - ab, E + ab, al + ab], [-X], "-" + p[X] + "-smpDendrogram");
									p[X]++
								}
								if (ai < v.length - 1) {
									D = (ad + this.blockSeparation + (aj / 2)) + ((this.blockSeparation + aj) * (v[ai + 1] - 1));
									if (this.graphType.match(/Area/)) {
										D -= aj * 1.5
									}
									D = this.smpIndicesStart > -1 ? D - ((this.blockSeparation + aj) * this.smpIndicesStart) : D;
									if (this.smpDendrogramPosition == "bottom") {
										this.addArea(this.drawLine("line", E, al, D, al, this.dendrogramColor, false, "butt", false, false, true, P), ["smpDendrogram"])
									} else {
										this.addArea(this.drawLine("line", E, b, D, b, this.dendrogramColor, false, "butt", false, false, true, P), ["smpDendrogram"])
									}
								}
							}
						} else {
							for (var ai = 0; ai < v.length; ai++) {
								if (this.graphType == "Heatmap") {
									b = (Y + this.blockSeparation) + (this.rowBlockSize * (v[ai] - 1));
									b = this.smpIndicesStart > -1 ? b - (this.rowBlockSize * this.smpIndicesStart) : b;
									if (this.adjustAspectRatio) {
										b -= this.blockSeparation / 2
									}
								} else {
									b = (Y + this.blockSeparation + (aj / 2)) + ((this.blockSeparation + aj) * (v[ai] - 1));
									if (this.graphType.match(/Area/)) {
										b -= aj * 1.5
									}
									b = this.smpIndicesStart > -1 ? b - ((this.blockSeparation + aj) * this.smpIndicesStart) : b
								}
								if (this.smpDendrogramPosition == "right") {
									if (this.dendrogramHeight) {
										if (this.isLeafNode(e[o[ai]])) {
											E = ad + this.x + this.getSampleLabelDescLength() + this.smpOverlaysThicknessRight + this.margin;
											D = E + (h * F) + T
										} else {
											E = ad + this.x + this.getSampleLabelDescLength() + this.smpOverlaysThicknessRight + this.margin + ((f - e[o[ai]].dist) * F) + T;
											D = ad + this.x + this.getSampleLabelDescLength() + this.smpOverlaysThicknessRight + this.margin + (h * F) + T
										}
									} else {
										if (this.isLeafNode(e[o[ai]]) && !this.dendrogramHang) {
											E = ad + this.x + this.getSampleLabelDescLength() + this.smpOverlaysThicknessRight + this.margin;
											D = E + ((T * (K + 1)) - (T * u[ai]))
										} else {
											D = (ad + this.x + this.getSampleLabelDescLength() + this.smpOverlaysThicknessRight + this.margin) + ((T * (K + 1)) - (T * u[ai]));
											E = D - T
										}
									}
								} else {
									if (this.dendrogramHeight) {
										if (this.isLeafNode(e[o[ai]])) {
											E = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight() + (e[o[ai]].dist * F) - (h * F);
											D = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight() + (T * (K + 1))
										} else {
											E = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight() + ((f - h) * F);
											D = E + (h * F) - (e[o[ai]].dist * F)
										}
									} else {
										if (this.isLeafNode(e[o[ai]]) && !this.dendrogramHang) {
											E = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight() + (T * u[ai]);
											D = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight() + (T * (K + 1))
										} else {
											E = this.marginLeft + this.offsetX + this.margin + this.getSampleTitleHeight() + (T * u[ai]);
											D = E + T
										}
									}
								}
								this.drawLine("line", E, b, D, b, this.dendrogramColor, false, "butt", false, false, true, P);
								if (!p.hasOwnProperty(X)) {
									p[X] = 0
								}
								if (!this.isLeafNode(e[o[ai]])) {
									this.addArea(["rect", D - ab, b - ab, D + ab, b + ab], [-X], "-" + p[X] + "-smpDendrogram");
									p[X]++
								}
								if (ai < v.length - 1) {
									if (this.graphType == "Heatmap") {
										al = (Y + this.blockSeparation) + (this.rowBlockSize * (v[ai + 1] - 1));
										al = this.smpIndicesStart > -1 ? al - (this.rowBlockSize * this.smpIndicesStart) : al;
										if (this.adjustAspectRatio) {
											al -= this.blockSeparation / 2
										}
									} else {
										al = (Y + this.blockSeparation + (aj / 2)) + ((this.blockSeparation + aj) * (v[ai + 1] - 1));
										if (this.graphType.match(/Area/)) {
											al -= aj * 1.5
										}
										al = this.smpIndicesStart > -1 ? al - ((this.blockSeparation + aj) * this.smpIndicesStart) : al
									}
									if (this.smpDendrogramPosition == "right") {
										this.addArea(this.drawLine("line", D, b, D, al, this.dendrogramColor, false, "butt", false, false, true, P), ["smpDendrogram"])
									} else {
										this.addArea(this.drawLine("line", E, b, E, al, this.dendrogramColor, false, "butt", false, false, true, P), ["smpDendrogram"])
									}
								}
							}
						}
					}
					var N, R, n;
					var c = [];
					var M = [];
					var Q = [];
					var B = this.mean(v);
					var d = false;
					if (!C.hasOwnProperty(X)) {
						C[X] = 0
					}
					aa = (X - 1) + "-" + C[X];
					for (var Z in L) {
						Q.push(e[Z])
					}
					if (J == "varDendrogram") {
						n = f - h
					} else {
						if (J == "smpDendrogram" && this.graphOrientation == "horizontal" && this.graphType != "Heatmap") {
							n = f - h
						} else {
							if (J == "smpDendrogram" && this.graphType != "Heatmap") {
								n = f - h
							} else {
								if (J == "smpDendrogram" && this.smpDendrogramPosition == "right") {
									n = f - h
								} else {
									n = h
								}
							}
						}
					}
					for (var ag = 0; ag < H.length; ag++) {
						if (!L.hasOwnProperty(ag)) {
							c.push(H[ag]);
							M.push(e[ag])
						} else {
							if (!d) {
								c.push([B, U - 1, G, A[A.length - 1]]);
								N = Q.shift();
								R = Q.pop();
								if (Q.length > 0) {
									M.push(this.createClusterNode(aa, N, R, n, null, Q))
								} else {
									M.push(this.createClusterNode(aa, N, R, n, null))
								}
								C[X]++;
								d = true
							}
						}
					}
					I++;
					H = c;
					e = M;
					s = this.getMaxDepthDendrogramXYs(H)
				}
			}
			this[J].object = e[0]
		}
		this.enableGradientTransparencyShadow()
	};
	this.draw1DYLayout = function() {
		var I, e, G, d, F, c, p, D;
		var y = this.marginLeft + this.offsetX + this.left + this.margin;
		var u = this.marginTop + this.offsetY + this.top;
		this.smpInfo = [];
		this.varInfo = [];
		if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
			return
		}
		if (this.smpTitle) {
			if (this.graphOrientation == "vertical") {
				I = y + (this.x / 2);
				if (this.segregateVariablesBy.length > 0) {
					e = (u + this.y + this.bottom + this.getSampleLabelLength() + (this.margin * 2)) - (this.margin + (this.smpTitleFontSize / 2))
				} else {
					e = (u + this.y + this.bottom) - (this.margin + (this.smpTitleFontSize / 2))
				}
				if (this.showLegend && this.legendPosition == "bottom" && !this.legendInside) {
					e -= this.getLegendHeight()
				}
				this.drawText(this.smpTitle, I, e, this.smpTitleFont, this.smpTitleFontColor, "center", "middle")
			} else {
				if (this.segregateVariablesBy.length > 1) {
					I = this.marginLeft + this.getFontHeight() + (this.margin * 2) + (this.smpTitleFontSize / 2)
				} else {
					if (this.segregateVariablesBy.length > 0) {
						I = this.marginLeft + (this.margin * (this.segregateSamplesBy.length > 0 ? 5 : 0)) + (this.smpTitleFontSize / 2)
					} else {
						I = this.marginLeft + this.offsetX + (this.smpTitleFontSize / 2)
					}
				}
				e = u + (this.y / 2);
				this.drawText(this.smpTitle, I, e, this.smpTitleFont, this.smpTitleFontColor, "center", "middle", -Math.PI / 2)
			}
		}
		var h = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var v = this.isGroupedData ? this.data.w.smps : this.data.y.smps;
		var J = this.isGroupedData ? this.data.w.smps : false;
		if (this.graphType == "Heatmap") {
			var q = !this.adjustAspectRatio ? this.rowBlockSize * 0.3 : 0;
			if (this.showSampleNames) {
				var B = Math.abs(this.smpLabelRotate) == 90 ? "center" : "right";
				if (this.isGraphTime) {
					var m = this.y / h.length;
					var A = m / 2;
					var r = u + A;
					I = (y) - (this.margin * 2);
					G = y + this.x + this.margin;
					for (var C = 0; C < this.timeValueIndices.length; C++) {
						e = (this.timeValueIndices[C] * m) + r + q;
						this.smpInfo[C] = e;
						if (this.smpLabelRotate) {
							this.addArea(this.drawText(this.timeValues[C], I - this.margin, e + q, this.smpLabelFont, f, B, "middle", this.smpLabelRotate * Math.PI / 180), ["Smp-" + C])
						} else {
							this.addArea(this.drawText(this.timeValues[C], I, e + q, this.smpLabelFont, f, "right", "middle"), ["Smp-" + C])
						}
						if (this.smpLabelDescription) {
							var n = this.shortenText(this.data.x[this.smpLabelDescription][h[C]], this.maxSmpStringLen);
							this.drawText(n, G, e + q, this.smpLabelFont, f, "right", "middle")
						}
					}
				} else {
					I = y;
					G = y + this.x + this.margin;
					e = u + this.blockSeparation;
					e -= this.blockSeparation / 2;
					D = 1;
					var g = this.smpOverlaysThicknessLeft;
					for (var C = 0; C < h.length; C++) {
						var k = C / this.smpLabelInterval;
						if (parseInt(k) == parseFloat(k)) {
							var s = h[C];
							var n = this.shortenText(J ? J[s] : v[s], this.maxSmpStringLen);
							var E = (this.margin * 2) + g;
							var f = this.getSmpColor(v[s]);
							this.smpInfo[C] = e;
							if (this.smpLabelRotate) {
								this.addArea(this.drawText(n, I - (E + this.margin), e + q, this.smpLabelFont, f, B, "middle", this.smpLabelRotate * Math.PI / 180), ["Smp-" + s])
							} else {
								this.addArea(this.drawText(n, I - E, e + q, this.smpLabelFont, f, "right", "middle"), ["Smp-" + s])
							}
							if (this.smpLabelDescription) {
								var n = this.shortenText(this.data.x[this.smpLabelDescription][s], this.maxSmpStringLen);
								this.drawText(n, G, e + q, this.smpLabelFont, f, "left", "middle")
							}
						}
						e += this.rowBlockSize
					}
				}
			}
			if (this.showVariableNames) {
				var A = this.colBlockSize / 2;
				I = y + A + this.margin;
				if (this.varTitleLabelOverlayPosition != "bottom") {
					var B = Math.abs(this.varLabelRotate) == 90 ? "center" : "left";
					e = u;
					e -= (this.margin + this.varOverlaysThicknessTop);
					d = u + this.y + this.margin;
					for (var C = 0; C < this.varIndices.length; C++) {
						var k = C / this.varLabelInterval;
						if (parseInt(k) == parseFloat(k)) {
							var s = this.varIndices[C];
							var x = this.shortenText(this.data.y.vars[s], this.maxVarStringLen);
							var f = this.getVarColor(this.data.y.vars[s]);
							var o = this.varLabelFontSize / 2;
							this.varInfo[C] = I - o;
							if (this.varLabelRotate) {
								this.addArea(this.drawText(x, I - o, e + this.margin, this.varLabelFont, f, B, "middle", -Math.PI / 2 + (this.varLabelRotate * Math.PI / 180)), ["Var-" + s])
							} else {
								this.addArea(this.drawText(x, I - o, e, this.varLabelFont, f, "left", "middle", -Math.PI / 2), ["Var-" + s])
							}
							if (this.varLabelDescription) {
								var x = this.shortenText(this.data.z[this.varLabelDescription][s], this.maxVarStringLen);
								this.drawText(x, I - o, d, this.varLabelFont, f, "right", "middle", -Math.PI / 2)
							}
						}
						I += this.colBlockSize
					}
				} else {
					var B = Math.abs(this.varLabelRotate) == 90 ? "center" : "right";
					e = u + this.y + this.margin;
					if (this.varOverlays.length > 0 && this.showOverlays && this.graphType == "Heatmap") {
						e += this.varOverlaysThicknessBottom
					}
					d = u - this.margin;
					for (var C = 0; C < this.varIndices.length; C++) {
						var k = C / this.varLabelInterval;
						if (parseInt(k) == parseFloat(k)) {
							var s = this.varIndices[C];
							var x = this.shortenText(this.data.y.vars[s], this.maxVarStringLen);
							var f = this.getVarColor(this.data.y.vars[s]);
							var o = this.varLabelFontSize / 2;
							this.varInfo[C] = I - o;
							if (this.varLabelRotate) {
								this.addArea(this.drawText(x, I - o, e, this.varLabelFont, f, B, "middle", -Math.PI / 2 + (this.varLabelRotate * Math.PI / 180)), ["Var-" + s])
							} else {
								this.addArea(this.drawText(x, I - o, e, this.varLabelFont, f, "right", "middle", -Math.PI / 2), ["Var-" + s])
							}
							if (this.varLabelDescription) {
								var x = this.shortenText(this.data.z[this.varLabelDescription][s], this.maxVarStringLen);
								this.drawText(x, I - o, d, this.varLabelFont, f, "left", "middle", -Math.PI / 2)
							}
						}
						I += this.colBlockSize
					}
				}
				if (this.varTitle) {
					I = y + (this.x / 2);
					if (this.varTitleLabelOverlayPosition != "bottom") {
						e = this.offsetY + (this.margin * 2) + this.top;
						e -= this.getVariableLabelLength();
						e -= this.varOverlaysThicknessTop;
						if (this.varDendrogramPosition == "top") {
							e -= this.getVarTreeHeight()
						}
					} else {
						e = u + this.y + this.bottom
					}
					this.drawText(this.varTitle, I, e, this.varTitleFont, this.varTitleFontColor, "center", "bottom")
				}
			}
		} else {
			if (this.showSampleNames) {
				if ((this.graphType == "BarLine" || this.graphType == "DotLine") && (this.xAxis2Title || this.layoutValid)) {
					var b = this.getVariablesVisibleByAxis("xAxis");
					D = b.length
				} else {
					if (this.graphType.match(/Stacked|Line|Area/)) {
						D = 1
					} else {
						D = this.plotByVariable ? h.length : this.varIndices.length
					}
				}
				p = D * this.rowBlockSize;
				if (this.graphOrientation == "vertical") {
					var B = Math.abs(this.smpLabelRotate) == 90 ? "center" : "right";
					var w = 0;
					if (this.isGraphTime) {
						var m = this.plotByVariable ? this.x / this.varIndices.length : this.x / h.length;
						var A = this.rowBlockSize / 2;
						var r = this.graphType.match(/Area/) ? 0 : y + ((this.blockSeparation + p) / 2);
						e = u + this.y + this.smpOverlaysThicknessBottom + this.margin + this.margin;
						if (this.plotByVariable) {
							I = r + A;
							for (var C = 0; C < this.varIndices.length; C++) {
								for (var z = 0; z < this.timeValueIndices.length; z++) {
									this.smpInfo[z] = I;
									if (this.smpLabelRotate) {
										this.addArea(this.drawText(this.timeValues[z], I, e + this.margin, this.smpLabelFont, f, B, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)), ["Smp-" + z])
									} else {
										this.addArea(this.drawText(this.timeValues[z], I, e, this.smpLabelFont, f, "right", "middle", -Math.PI / 2), ["Smp-" + z])
									}
									I += this.rowBlockSize
								}
								I += this.blockSeparation
							}
						} else {
							for (var C = 0; C < this.timeValueIndices.length; C++) {
								I = (this.timeValueIndices[C] * m) + r;
								this.smpInfo[C] = I;
								if (this.smpLabelRotate) {
									this.addArea(this.drawText(this.timeValues[C], I, e + this.margin, this.smpLabelFont, f, B, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)), ["Smp-" + C])
								} else {
									this.addArea(this.drawText(this.timeValues[C], I, e, this.smpLabelFont, f, "right", "middle", -Math.PI / 2), ["Smp-" + C])
								}
							}
						}
					} else {
						I = this.plotByVariable ? y + ((this.blockSeparation + this.rowBlockSize) / 2) : this.graphType.match(/Area/) ? y : y + ((this.blockSeparation + p) / 2);
						e = u;
						d = u + this.y;
						c = d + this.smpOverlaysThicknessBottom + this.margin;
						if (this.plotByVariable) {
							for (var C = 0; C < this.varIndices.length; C++) {
								for (var z = 0; z < h.length; z++) {
									var k = z / this.smpLabelInterval;
									if (parseInt(k) == parseFloat(k)) {
										var H = h[z];
										var n = this.shortenText(v[H], this.maxSmpStringLen);
										var f = this.getSmpColor(v[H]);
										this.smpInfo[z] = I;
										if (this.smpLabelRotate) {
											if (this.smpLabelRotate == 90) {
												this.addArea(this.drawText(n, I, c + this.margin + this.margin, this.smpLabelFont, f, B, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)), ["Smp-" + H])
											} else {
												this.addArea(this.drawText(n, I, c + this.margin, this.smpLabelFont, f, B, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)), ["Smp-" + H])
											}
										} else {
											this.addArea(this.drawText(n, I - this.margin, c, this.smpLabelFont, f, "right", "middle", -Math.PI / 2), ["Smp-" + H])
										}
									}
									I += this.rowBlockSize
								}
								I += this.blockSeparation
							}
						} else {
							var K;
							for (var C = 0; C < h.length; C++) {
								var k = C / this.smpLabelInterval;
								if (parseInt(k) == parseFloat(k)) {
									this.smpInfo[C] = I;
									if (C > 0 && this.parseInt(this.smpInfo[C]) < this.parseInt(this.smpInfo[K] + this.smpLabelFontSize)) {
										I += this.blockSeparation + p;
										continue
									}
									var s = h[C];
									var n = this.shortenText(J ? J[s] : v[s], this.maxSmpStringLen);
									var f = this.getSmpColor(v[s]);
									if (this.smpLabelRotate) {
										if (this.smpLabelRotate == 90) {
											this.addArea(this.drawText(n, I, c + this.margin + this.margin, this.smpLabelFont, f, B, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)), ["Smp-" + s])
										} else {
											this.addArea(this.drawText(n, I, c + this.margin, this.smpLabelFont, f, B, "middle", -Math.PI / 2 + (this.smpLabelRotate * Math.PI / 180)), ["Smp-" + s])
										}
									} else {
										this.addArea(this.drawText(n, I - this.margin, c, this.smpLabelFont, f, "right", "middle", -Math.PI / 2), ["Smp-" + s])
									}
									K = C
								}
								I += this.blockSeparation + p
							}
						}
					}
				} else {
					var B = Math.abs(this.smpLabelRotate) == 90 ? "center" : "right";
					if (this.isGraphTime) {
						var m = this.plotByVariable ? this.y / this.varIndices.length : this.y / h.length;
						var A = this.plotByVariable ? this.rowBlockSize / 2 : m / 2;
						var r = this.graphType.match(/Area/) ? 0 : u + ((this.blockSeparation + p) / 2);
						I = (y) - (this.margin * 2);
						if (this.plotByVariable) {
							e = r + A;
							for (var C = 0; C < this.varIndices.length; C++) {
								for (var z = 0; z < this.timeValueIndices.length; z++) {
									this.smpInfo[z] = I;
									if (this.smpLabelRotate) {
										this.addArea(this.drawText(this.timeValues[z], I - this.margin, e, this.smpLabelFont, f, B, "middle", this.smpLabelRotate * Math.PI / 180), ["Smp-" + z])
									} else {
										this.addArea(this.drawText(this.timeValues[z], I, e, this.smpLabelFont, f, "right", "middle"), ["Smp-" + z])
									}
									e += this.rowBlockSize
								}
								e += this.blockSeparation
							}
						} else {
							for (var C = 0; C < this.timeValueIndices.length; C++) {
								e = (this.timeValueIndices[C] * m) + r;
								this.smpInfo[C] = e;
								if (this.smpLabelRotate) {
									this.addArea(this.drawText(this.timeValues[C], I - this.margin, e, this.smpLabelFont, f, B, "middle", this.smpLabelRotate * Math.PI / 180), ["Smp-" + C])
								} else {
									this.addArea(this.drawText(this.timeValues[C], I, e, this.smpLabelFont, f, "right", "middle"), ["Smp-" + C])
								}
							}
						}
					} else {
						I = y;
						G = y + this.x;
						F = I - (this.smpOverlaysThicknessLeft + (this.margin * 2));
						e = this.plotByVariable ? u + ((this.blockSeparation + this.rowBlockSize) / 2) : this.graphType.match(/Area/) ? u : u + ((this.blockSeparation + p) / 2);
						if (this.plotByVariable) {
							for (var C = 0; C < this.varIndices.length; C++) {
								for (var z = 0; z < h.length; z++) {
									var k = z / this.smpLabelInterval;
									if (parseInt(k) == parseFloat(k)) {
										var H = h[z];
										var n = this.shortenText(v[H], this.maxSmpStringLen);
										var f = this.getSmpColor(v[H]);
										this.smpInfo[z] = e;
										if (this.smpLabelRotate) {
											this.addArea(this.drawText(n, F - this.margin, e, this.smpLabelFont, f, B, "middle", this.smpLabelRotate * Math.PI / 180), ["Smp-" + s])
										} else {
											this.addArea(this.drawText(n, F, e, this.smpLabelFont, f, "right", "middle"), ["Smp-" + s])
										}
									}
									e += this.rowBlockSize
								}
								e += this.blockSeparation
							}
						} else {
							var K;
							for (var C = 0; C < h.length; C++) {
								var k = C / this.smpLabelInterval;
								if (parseInt(k) == parseFloat(k)) {
									this.smpInfo[C] = e;
									if (C > 0 && this.parseInt(this.smpInfo[C]) < this.parseInt(this.smpInfo[K] + this.smpLabelFontSize)) {
										e += this.blockSeparation + p;
										continue
									}
									var s = h[C];
									var n = this.shortenText(J ? J[s] : v[s], this.maxSmpStringLen);
									var f = this.getSmpColor(v[s]);
									if (this.smpLabelRotate) {
										this.addArea(this.drawText(n, F - this.margin, e, this.smpLabelFont, f, B, "middle", this.smpLabelRotate * Math.PI / 180), ["Smp-" + s])
									} else {
										this.addArea(this.drawText(n, F, e, this.smpLabelFont, f, "right", "middle"), ["Smp-" + s])
									}
									K = C
								}
								e += this.blockSeparation + p
							}
						}
					}
				}
			}
		}
	};
	this.draw1DOverlaysDataPoints = function(x, B, H, Y, Z, b, E, g, k, S, U, M, K, v, o) {
		var R, y, ad, C, m, D, e, af;
		var I = U;
		var F = M;
		var u = [];
		var w = [];
		var V = [];
		var G = {};
		var T = 0;
		for (var X = 0; X < E.length; X++) {
			G[E[X]] = T;
			T++
		}
		if (Z != "Pie") {
			if (!v) {
				v = [];
				if (Z.match(/StackedPercent/)) {
					v = [0, 100]
				} else {
					if (Z.match(/Stacked/)) {
						for (var W = 0; W < Y.length; W++) {
							var f = 0;
							for (var X = 0; X < B.length; X++) {
								if (b[B[X]]["type"].match(/Line/)) {
									u.push(H[B[X]][Y[W]])
								} else {
									f += H[B[X]][Y[W]]
								}
							}
							v.push(f)
						}
						v.push(0);
						if (u.length > 0) {
							R = this.range(u);
							af = R[1]
						}
					} else {
						for (var X = 0; X < B.length; X++) {
							for (var W = 0; W < Y.length; W++) {
								v.push(H[B[X]][Y[W]])
							}
						}
					}
				}
			}
			R = this.range(v);
			if (af > R[1]) {
				R[1] = af
			}
			y = this[this.axisAlgorithm](0, R[1], 3, this.axisWilkinsonLoose);
			ad = Math.min(R[0], y[0]);
			C = Math.max(R[1], y[y.length - 1]);
			m = (g - 2) / (C - ad);
			D = ad < 0 ? Math.abs(ad) * m : 0;
			if (o) {
				e = k / o
			} else {
				T = 0;
				for (var X = 0; X < B.length; X++) {
					if (b[B[X]]["type"] != "Line") {
						if (b[B[X]]["type"] == Z) {
							T++
						}
					} else {
						T++
					}
				}
				e = k / T
			}
		}
		switch (Z) {
			case "Area":
			case "AreaLine":
				var ab = [];
				var ac = [];
				var Q = [];
				var ae = [];
				for (var X = 0; X < B.length; X++) {
					if (b[B[X]]["type"].match(/Line/)) {
						w.push(B[X]);
						continue
					}
					var L = [];
					for (var W = 0; W < Y.length; W++) {
						L.push(H[B[X]][Y[W]])
					}
					ab.push(L);
					ac.push(b[B[X]]["color"]);
					Q.push("closed");
					ae.push([x + "Ovr-" + G[B[X]]])
				}
				if (S == "vertical") {
					this.drawAreaPlot(ab, U + (k / 2), M, this.x - k, g, k, false, false, m, ad, C, S, false, ac, Q, ae, false, K)
				} else {
					if (this.graphType == "Area") {
						this.drawAreaPlot(ab, U, M, g, (Y.length - 1) * k, k, false, false, m, ad, C, S, false, ac, Q, ae, false, K)
					} else {
						this.drawAreaPlot(ab, U, M + (k / 2), g, (Y.length - 1) * k, k, false, false, m, ad, C, S, false, ac, Q, ae, false, K)
					}
				}
				if (w.length > 0) {
					this.draw1DOverlaysDataPoints(x, w, H, Y, "Line", b, E, g, k, S, I, F, K, v, w.length)
				}
				break;
			case "Bar":
			case "BarLine":
			case "Dotplot":
			case "DotLine":
			case "Line":
				var h = this.jitter;
				this.jitter = false;
				for (var X = 0; X < B.length; X++) {
					if (b[B[X]]["type"].match(/BarLine|DotLine/) && Z != "Line") {
						w.push(B[X]);
						continue
					}
					var ab = [];
					var ac = [];
					var O = [];
					var ae = [];
					var N = [];
					var Q = [];
					if (Z == "Dotplot") {
						for (var W = 0; W < Y.length; W++) {
							ab.push([H[B[X]][Y[W]]]);
							ac.push([b[B[X]]["color"]]);
							O.push([false]);
							ae.push([
								[x + "Ovr-" + Y[W] + "-" + G[B[X]]]
							]);
							N.push([this.margin]);
							Q.push(["circle"])
						}
					} else {
						for (var W = 0; W < Y.length; W++) {
							ab.push(H[B[X]][Y[W]]);
							ac.push(b[B[X]]["color"]);
							O.push(false);
							ae.push([x + "Ovr-" + Y[W] + "-" + G[B[X]]])
						}
					}
					if (Z == "Bar") {
						if (S == "vertical") {
							this.drawBarPlot(ab, false, U, M - D, e, k, false, m, D, ad, S, ac, O, ae, false, false, K)
						} else {
							this.drawBarPlot(ab, false, U, M, e, k, false, m, D, ad, S, ac, O, ae, false, false, K)
						}
					} else {
						if (Z == "Line") {
							if (S == "vertical") {
								this.drawLinePlot(ab, false, U + (k / 2), M, e, k, m, ad, S, ac[0], O, false, ae, false, false, K)
							} else {
								this.drawLinePlot(ab, false, U, M + (k / 2), e, k, m, ad, S, ac[0], O, false, ae, false, false, K)
							}
						} else {
							if (Z == "Dotplot") {
								var P = this.graphType;
								this.graphType = "Dotplot";
								if (S == "vertical") {
									this.drawDotPlot(ab, false, U + (k / 2), M, e, k, m, ad, N, S, ac, O, Q, 0, ae, false, false, K)
								} else {
									this.drawDotPlot(ab, false, U, M + (k / 2), e, k, m, ad, N, S, ac, O, Q, 0, ae, false, false, K)
								}
								this.graphType = P
							}
						}
					}
					if (S == "vertical" && Z != "Line") {
						U += e
					} else {
						if (S == "horizontal" && Z != "Line") {
							M += e
						}
					}
				}
				if (w.length > 0) {
					this.draw1DOverlaysDataPoints(x, w, H, Y, "Line", b, E, g, k, S, I, F, K, v, w.length)
				}
				this.jitter = h;
				break;
			case "Pie":
				this.showPieValues = false;
				for (var W = 0; W < Y.length; W++) {
					this.pieColors = [];
					var ab = [];
					var ae = [];
					for (var X = 0; X < B.length; X++) {
						this.pieColors.push(b[B[X]]["color"]);
						ab.push(H[B[X]][Y[W]]);
						ae.push([x + "Ovr-" + Y[W] + "-" + G[B[X]]])
					}
					var Q = this.setPieData(ab);
					if (S == "vertical") {
						this.drawPie(Q, U + (k / 2), M - (g / 2), Math.min((g / 2), (k / 2)) - 2, ae, false);
						U += k
					} else {
						if (S == "horizontal") {
							this.drawPie(Q, U + (g / 2), M + (k / 2), Math.min((g / 2), (k / 2)) - 2, ae, false);
							M += k
						}
					}
				}
				break;
			case "Stacked":
			case "StackedLine":
			case "StackedPercent":
			case "StackedPercentLine":
				for (var X = 0; X < B.length; X++) {
					if (b[B[X]]["type"].match(/Line/)) {
						w.push(B[X])
					} else {
						V.push(B[X])
					}
				}
				for (var W = 0; W < Y.length; W++) {
					var ab = [];
					var ac = [];
					var ae = [];
					var Q = [];
					var f = 0;
					for (var X = 0; X < V.length; X++) {
						f += H[V[X]][Y[W]]
					}
					for (var X = 0; X < V.length; X++) {
						ab.push(H[V[X]][Y[W]]);
						ac.push(b[V[X]]["color"]);
						Q.push(false);
						ae.push([x + "Ovr-" + Y[W] + "-" + G[B[X]]])
					}
					this.drawStackedPlot(ab, U, M, k, false, Z.match(/Percent/) ? true : false, f, m, S, ac, Q, ae, false, K);
					if (S == "vertical") {
						U += k
					} else {
						if (S == "horizontal") {
							M += k
						}
					}
				}
				if (w.length > 0) {
					if (Z.match(/Percent/)) {
						var A = {};
						for (var X = 0; X < w.length; X++) {
							A[w[X]] = [];
							R = this.range(H[w[X]]);
							for (var W = 0; W < Y.length; W++) {
								A[w[X]][Y[W]] = this.percentile(R[0], R[1], H[w[X]][Y[W]])
							}
						}
						this.draw1DOverlaysDataPoints(x, w, A, Y, "Line", b, E, g, k, S, I, F, K, v, w.length)
					} else {
						this.draw1DOverlaysDataPoints(x, w, H, Y, "Line", b, E, g, k, S, I, F, K, v, w.length)
					}
				}
				break
		}
		if (Z != "Pie") {
			this.disableGradientTransparencyShadow();
			if (S == "vertical" && !o) {
				var J = I - (this.margin * 1.5);
				for (var X = 0; X < y.length; X++) {
					var r = ((y[X] - ad) * m);
					var aa = F - r;
					this.drawLine("line", I - this.margin, aa, I, aa, this.xAxisTickColor);
					this.drawText(y[X].toString(), J, aa, this.overlayFont, this.overlayFontColor, "right", "middle")
				}
				this.rectangle(I, F - g, this.x, g, false, this.xAxisTickColor, "open", false, this.outlineWidth)
			} else {
				if (S == "horizontal" && !o) {
					var aa = F - (this.margin * 1.5);
					for (var X = 0; X < y.length; X++) {
						var r = ((y[X] - ad) * m);
						var J = K ? I + K - r : I + r;
						this.drawLine("line", J, F - this.margin, J, F, this.xAxisTickColor);
						this.drawText(y[X].toString(), J, aa, this.overlayFont, this.overlayFontColor, K ? "left" : "right", "middle", K ? -Math.PI / 2 : Math.PI / 2)
					}
					this.rectangle(I, F, g, this.y, false, this.xAxisTickColor, "open", false, this.outlineWidth)
				}
			}
			this.enableGradientTransparencyShadow()
		}
	};
	this.draw1DOverlays = function() {
		var u, c, s, V, q, U, Q, x, y, R, J, E;
		var v = {};
		var B = {};
		var L = this.marginLeft + this.offsetX + this.left;
		var H = this.marginTop + this.offsetY + this.top;
		var e = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var K = this.meta.data;
		this.smpOverlayInfo = {};
		this.varOverlayInfo = {};
		var G = this;
		var D = [];
		var C = function(j, i) {
			if (j.type == "Numeric") {
				return G.getColorForValue(j.colorBrew, i)
			} else {
				return j.colors[j.order[i]]
			}
		};
		if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
			return
		}
		if ((this.graphType == "BarLine" || this.graphType == "DotLine") && this.xAxis2Title) {
			x = this.getVariablesVisibleByAxis("xAxis");
			y = x.length
		} else {
			if (this.graphType.match(/Stacked|Line|Area|Heatmap/)) {
				y = 1
			} else {
				y = this.plotByVariable ? e.length : this.variableBlock
			}
		}
		if (this.showOverlays) {
			if (this.smpOverlays.length > 0) {
				J = 0;
				for (var N = 0; N < this.smpOverlays.length; N++) {
					B[this.smpOverlays[N]] = J;
					J++
				}
				Q = y * this.rowBlockSize;
				R = this.isGroupedData ? this.data.w.factors : this.data.x;
				if (this.graphOrientation == "vertical") {
					c = H + this.y + this.margin;
					for (var N = 0; N < this.smpOverlays.length; N++) {
						var z = this.smpOverlays[N];
						if (z != "-") {
							if (this.smpOverlayProperties[z]["position"] == "top" && !E) {
								c = H - this.smpOverlaysThicknessTop;
								E = true
							}
							u = this.graphType.match(/Area/) ? L - ((Q + this.blockSeparation) / 2) : L;
							s = Q + this.blockSeparation;
							q = 0;
							V = this.smpOverlayProperties[z]["thickness"] || this.overlaysThickness;
							if (!this.smpOverlayProperties[z]["type"].match(/Heatmap|Text|Default|Increase|Decrease/)) {
								if (v.hasOwnProperty(z)) {
									continue
								}
								var O = this.smpOverlayProperties[z]["type"];
								var F = this.smpOverlayProperties[z]["position"];
								var w = this.getOverlaysForTypePosition("smp", O, F);
								var b = [];
								for (var M = 0; M < w.length; M++) {
									b.unshift(w[M])
								}
								this.draw1DOverlaysDataPoints("smp", w, R, e, O, this.smpOverlayProperties, this.smpOverlays, V, s, "vertical", u, c + V);
								u = this.graphType.match(/Area/) ? (L + this.x + this.margin) + ((Q + this.blockSeparation) / 2) : L + this.x + this.margin;
								U = V / (w.length + 1);
								for (var M = 0; M < w.length; M++) {
									var I = b[M];
									v[I] = true;
									this.smpOverlayInfo[I] = c + (U * (M + 1));
									this.addArea(this.drawText(I, u, c + (U * (M + 1)), this.overlayFont, this.smpOverlayProperties[I]["color"], "left", "middle", false, Q * 2), ["SmpOverlay-" + B[I]])
								}
							} else {
								var O = this.smpOverlayProperties[z]["type"];
								for (var M = 0; M < e.length; M++) {
									this.addArea(["rect", u + q, c, u + s + q, c + V], ["SmpOvr-" + e[M] + "-" + N]);
									var A = R[z][e[M]];
									var f = A != null ? C(K.x[z], A) : this.missingDataColor;
									var P = false;
									if (M < e.length - 1) {
										P = R[z][e[M + 1]]
									}
									if (A === P) {
										q += s;
										continue
									}
									if (O != "Text") {
										var p = u;
										var k = u + s + q;
										var T = c;
										var S = c + V;
										if (O == "Increase") {
											this.drawShape("path", [p, k, k, p], [S, T, S, S], false, false, this.colors[2])
										} else {
											if (O == "Decrease") {
												this.drawShape("path", [p, k, p, p], [T, S, S, T], false, false, this.colors[2])
											} else {
												this.rectangle(u, c, s + q, V, f)
											}
										}
									}
									if (this.showLevelOverlays || O == "Text") {
										if ((s + q) > V) {
											this.drawText(this.shortenText(A, this.overlayFontSize, s + q), u + ((s + q) / 2), c + (V / 2), this.overlayFont, this.overlayFontColor, "center", "middle", false, (s + q) - 2)
										} else {
											this.drawText(this.shortenText(A, this.overlayFontSize, V), u + ((s + q) / 2), c + (V / 2), this.overlayFont, this.overlayFontColor, "center", "middle", -Math.PI / 2, V - 2)
										}
									}
									u += s + q;
									q = 0
								}
								u = this.graphType.match(/Area/) ? (L + this.x + this.margin) + ((Q + this.blockSeparation) / 2) : L + this.x + this.margin;
								this.smpOverlayInfo[z] = c + (V / 2);
								this.addArea(this.drawText(z, u, c + (V / 2), this.overlayFont, this.overlayFontColor, "left", "middle", false, Q * 2), ["SmpOverlay-" + N])
							}
							c += V
						} else {
							if (z == "-") {
								c += this.margin
							}
						}
					}
				} else {
					u = L - this.smpOverlaysThicknessLeft;
					for (var N = 0; N < this.smpOverlays.length; N++) {
						var z = this.smpOverlays[N];
						if (z != "-") {
							if (this.smpOverlayProperties[z]["position"] == "right" && !E) {
								u = L + this.x + this.margin;
								E = true
							}
							s = this.smpOverlayProperties[z]["thickness"] || this.overlaysThickness;
							c = this.graphType.match(/Area/) ? H - ((Q + this.blockSeparation) / 2) : H;
							V = this.graphType != "Heatmap" ? Q + this.blockSeparation : Q;
							U = 0;
							if (!this.smpOverlayProperties[z]["type"].match(/Heatmap|Text|Default|Increase|Decrease/)) {
								if (v.hasOwnProperty(z)) {
									continue
								}
								var O = this.smpOverlayProperties[z]["type"];
								var F = this.smpOverlayProperties[z]["position"];
								var w = this.getOverlaysForTypePosition("smp", O, F);
								var b = [];
								for (var M = 0; M < w.length; M++) {
									b.unshift(w[M])
								}
								this.draw1DOverlaysDataPoints("smp", w, R, e, O, this.smpOverlayProperties, this.smpOverlays, s, V, "horizontal", u, c, F == "left" ? s : false);
								c = this.graphType.match(/Area/) ? (H + this.y + this.margin) + ((Q + this.blockSeparation) / 2) : H + this.y + this.margin;
								q = s / (w.length + 1);
								for (var M = 0; M < w.length; M++) {
									var I = b[M];
									v[I] = true;
									this.smpOverlayInfo[I] = u + (q * (M + 1));
									this.addArea(this.drawText(I, u + (q * (M + 1)), c, this.overlayFont, this.smpOverlayProperties[I]["color"], F == "left" ? "right" : "left", "middle", F == "left" ? -Math.PI / 2 : Math.PI / 2), ["SmpOverlay-" + B[I]])
								}
							} else {
								var O = this.smpOverlayProperties[z]["type"];
								var F = this.smpOverlayProperties[z]["position"];
								for (var M = 0; M < e.length; M++) {
									this.addArea(["rect", u, c + U, u + s, c + V + U], ["SmpOvr-" + e[M] + "-" + N]);
									var A = R[z][e[M]];
									var f = A != null ? C(K.x[z], A) : this.missingDataColor;
									var P = false;
									if (M < e.length - 1) {
										P = R[z][e[M + 1]]
									}
									if (A === P) {
										U += V;
										continue
									}
									if (O != "Text") {
										var p = u;
										var k = u + s;
										var T = c;
										var S = c + V + U;
										if (O == "Increase") {
											this.drawShape("path", [k, k, p, k], [T, S, S, T], false, false, f)
										} else {
											if (O == "Decrease") {
												this.drawShape("path", [p, k, k, p], [T, T, S, T], false, false, f)
											} else {
												this.rectangle(u, c, s, V + U, f)
											}
										}
									}
									if (this.graphType == "Heatmap" && this.heatmapSmpSeparateBy && this.heatmapSmpSeparateBy == z) {
										var T = c + V + U;
										var d = T - (this.heatmapSeparatorWidth - this.heatmapCellBoxWidth);
										var h = T + (this.heatmapSeparatorWidth - this.heatmapCellBoxWidth);
										if (h < H + this.y) {
											if (this.heatmapCellBox) {
												this.drawLine("line", L, d, L + this.x + 1, d, this.heatmapCellBoxColor, this.heatmapCellBoxWidth);
												this.drawLine("line", L, h, L + this.x + 1, h, this.heatmapCellBoxColor, this.heatmapCellBoxWidth)
											}
											D.push(["line", L, T, L + this.x + 1, T, this.background, this.heatmapSeparatorWidth])
										}
									}
									if (this.showLevelOverlays || O == "Text") {
										if ((V + U) > s) {
											this.drawText(this.shortenText(A, this.overlayFontSize, (V + U)), u + (s / 2), c + ((V + U) / 2), this.overlayFont, this.overlayFontColor, "center", "middle", F == "left" ? -Math.PI / 2 : Math.PI / 2, (V + U) - 2)
										} else {
											this.drawText(this.shortenText(A, this.overlayFontSize, s), u + (s / 2), c + ((V + U) / 2), this.overlayFont, this.overlayFontColor, "center", "middle", false, s - 2)
										}
									}
									c += V + U;
									U = 0
								}
								c = this.graphType.match(/Area/) ? (H + this.y + this.margin) + ((Q + this.blockSeparation) / 2) : H + this.y + this.margin;
								this.smpOverlayInfo[z] = u + (s / 2);
								this.addArea(this.drawText(z, u + (s / 2), c, this.overlayFont, this.overlayFontColor, F == "left" ? "right" : "left", "middle", F == "left" ? -Math.PI / 2 : Math.PI / 2), ["SmpOverlay-" + N])
							}
							u += s
						} else {
							if (z == "-") {
								u += this.margin
							}
						}
					}
				}
			}
			v = {};
			E = false;
			if (this.varOverlays.length > 0 && this.graphType == "Heatmap") {
				J = 0;
				for (var N = 0; N < this.varOverlays.length; N++) {
					B[this.varOverlays[N]] = J;
					J++
				}
				c = this.varTitleLabelOverlayPosition != "bottom" ? H - this.varOverlaysThicknessTop : H + this.y + this.margin;
				for (var N = 0; N < this.varOverlays.length; N++) {
					var z = this.varOverlays[N];
					if (z != "-") {
						if (this.varOverlayProperties[z]["position"] == "top" && !E) {
							c = H - this.varOverlaysThicknessTop;
							E = true
						}
						u = L + (this.colBlockSize / 2);
						s = 0;
						V = this.varOverlayProperties[z]["thickness"] || this.overlaysThickness;
						if (!this.varOverlayProperties[z]["type"].match(/Heatmap|Text|Default|Increase|Decrease/)) {
							if (v.hasOwnProperty(z)) {
								continue
							}
							var O = this.varOverlayProperties[z]["type"];
							var F = this.varOverlayProperties[z]["position"];
							var w = this.getOverlaysForTypePosition("var", O, F);
							var b = [];
							for (var M = 0; M < w.length; M++) {
								b.unshift(w[M])
							}
							this.draw1DOverlaysDataPoints("var", w, this.data.z, this.varIndices, O, this.varOverlayProperties, this.varOverlays, V, this.colBlockSize, "vertical", u - (this.colBlockSize / 2), c + V);
							u = L + this.x + this.margin;
							U = V / (w.length + 1);
							for (var M = 0; M < w.length; M++) {
								var I = b[M];
								v[I] = true;
								this.varOverlayInfo[I] = c + (U * (M + 1));
								this.addArea(this.drawText(I, u, c + (U * (M + 1)), this.overlayFont, this.varOverlayProperties[I]["color"], "left", "middle", false, this.colBlockSize * 2), ["VarOverlay-" + B[I]])
							}
						} else {
							var O = this.varOverlayProperties[z]["type"];
							for (var M = 0; M < this.varIndices.length; M++) {
								this.addArea(["rect", u - (this.colBlockSize / 2), c, u + (this.colBlockSize / 2) + s, c + V], ["VarOvr-" + this.varIndices[M] + "-" + N]);
								var A = this.data.z[z][this.varIndices[M]];
								var f = A != null ? C(K.z[z], A) : this.missingDataColor;
								var P = M < this.varIndices.length - 1 ? this.data.z[z][this.varIndices[M + 1]] : false;
								if (A == P) {
									s += this.colBlockSize;
									continue
								}
								if (O != "Text") {
									var p = u - (this.colBlockSize / 2);
									var k = p + this.colBlockSize + s;
									var T = c;
									var S = c + V;
									if (O == "Increase") {
										this.drawShape("path", [p, k, k, p], [S, T, S, S], false, false, f)
									} else {
										if (O == "Decrease") {
											this.drawShape("path", [p, k, p, p], [T, S, S, T], false, false, f)
										} else {
											this.rectangle(u - (this.colBlockSize / 2), c, this.colBlockSize + s, V, f)
										}
									}
								}
								if (this.graphType == "Heatmap" && this.heatmapVarSeparateBy && this.heatmapVarSeparateBy == z) {
									var p = (u - (this.colBlockSize / 2)) + this.colBlockSize + s;
									var r = p - (this.heatmapSeparatorWidth - this.heatmapCellBoxWidth);
									var g = p + (this.heatmapSeparatorWidth - this.heatmapCellBoxWidth);
									if (g < L + this.x) {
										if (this.heatmapCellBox) {
											this.drawLine("line", r, H, r, H + this.y + 1, this.heatmapCellBoxColor, this.heatmapCellBoxWidth);
											this.drawLine("line", g, H, g, H + this.y + 1, this.heatmapCellBoxColor, this.heatmapCellBoxWidth)
										}
										D.push(["line", p, H, p, H + this.y + 1, this.background, this.heatmapSeparatorWidth])
									}
								}
								if (this.showLevelOverlays || O == "Text") {
									if (this.colBlockSize + s > V) {
										this.drawText(this.shortenText(A, this.overlayFontSize, this.colBlockSize + s), u + (s / 2), c + (V / 2), this.overlayFont, this.overlayFontColor, "center", "middle", false, (this.colBlockSize + s) - 2)
									} else {
										this.drawText(this.shortenText(A, this.overlayFontSize, V), u + (s / 2), c + (V / 2), this.overlayFont, this.overlayFontColor, "center", "middle", -Math.PI / 2, V - 2)
									}
								}
								u += this.colBlockSize + s;
								s = 0
							}
							u = L + this.x + this.margin;
							this.varOverlayInfo[z] = c + (V / 2);
							this.addArea(this.drawText(z, u, c + (V / 2), this.overlayFont, this.overlayFontColor, "left", "middle", false, this.colBlockSize * 2), ["VarOverlay-" + N])
						}
						c += V
					} else {
						if (z == "-") {
							c += this.margin
						}
					}
				}
			}
		}
		if (D.length > 0) {
			for (var N = 0; N < D.length; N++) {
				this.drawLine.apply(this, D[N])
			}
		}
	};
	this.getAxisDescription = function(d) {
		var c;
		var b = {
			standardDeviation: "Std Dev.",
			standardErrorMean: "Std Error of Mean",
			confidenceInterval95: "95% CI"
		};
		if (d) {
			if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a && this.xAxis2Title) {
				c = this.xAxis2Title ? this.xAxis2Title + " (Lines)" : "";
				if (this.showErrorBars && this.isGroupedData && this.graphType != "Boxplot") {
					if (c != "") {
						c = c + "; Error bars are the " + b[this.errorBarsType]
					} else {
						c = "Error bars are the " + b[this.errorBarsType]
					}
				}
			} else {
				c = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Title : this.xAxis2Title ? this.xAxis2Title : ""
			}
		} else {
			c = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Title : this.xAxisTitle ? this.xAxisTitle : "";
			if (this.data.a && this.xAxis2Title) {
				if (this.graphType.match(/BarLine|StackedLine|StackedPercentLine/)) {
					c = c + " (Bars)"
				} else {
					if (this.graphType.match(/DotLine/)) {
						c = c + " (Dots)"
					} else {
						if (this.graphType == "AreaLine") {
							c = c + " (Area)"
						}
					}
				}
			}
			if (this.showErrorBars && (this.isGroupedData || (this.layoutValid && this.data.l.group)) && this.graphType != "Boxplot") {
				if (c != "") {
					c = c + "; Error bars are the " + b[this.errorBarsType]
				} else {
					c = "Error bars are the " + b[this.errorBarsType]
				}
			}
		}
		return c
	};
	this.draw1DXLayout = function() {
		var m, q, v, n, d, o, c, r, b;
		var e = this.marginLeft + this.offsetX + this.left;
		var u = this.marginTop + this.offsetY + this.top;
		var s = this.layoutComb ? 0 : 0;
		var p = this.layoutComb ? 1 : 1;
		var k = this;
		var g = function(h) {
			if (k.xAxisTransform && k.xAxisTransform.match(/log|exp/) && !k.xAxisTransformTicks) {
				return k.formatAxisValue(k.transformValue(k.xAxisTransform, h, true), "xAxis")
			} else {
				if (k.isTransformedData && k.isTransformedData.match(/log|exp/) && !k.xAxisTransformTicks) {
					return k.formatAxisValue(k.transformValue(k.isTransformedData, h, true), "xAxis")
				} else {
					return h
				}
			}
		};
		if (this.graphType == "Treemap" || this.graphType == "TagCloud") {
			return
		}
		if (!this.layoutValid) {
			this.layoutAxis = 3
		}
		if (this.graphType == "Heatmap") {
			var j = this.getHeatmapIndicatorHeight();
			if (this.showHeatmapIndicator) {
				if (this.layoutValid) {
					c = (this.width / 2) - (this.heatmapIndicatorWidth / 2);
					r = this.height - this.layoutBottom
				} else {
					if (this.heatmapIndicatorPosition == "right") {
						this.heatmapIndicatorY = u;
						c = this.width - (this.marginRight + this.getHeatmapIndicatorWidth())
					} else {
						if (this.heatmapIndicatorPosition == "top") {
							c = (e + (this.x / 2)) - (this.heatmapIndicatorWidth / 2)
						} else {
							if (this.heatmapIndicatorPosition == "topLeft") {
								if (this.left > (this.heatmapIndicatorWidth + (this.margin * 6))) {
									c = e - (this.heatmapIndicatorWidth + (this.margin * 2))
								} else {
									c = this.marginLeft + this.offsetX + (this.margin * 6)
								}
							} else {
								if (this.right > (this.heatmapIndicatorWidth + (this.margin * 6))) {
									c = e + this.x + (this.margin * 2)
								} else {
									c = this.width - (this.marginRight + (this.heatmapIndicatorWidth + (this.margin * 6)))
								}
							}
						}
					}
					r = this.heatmapIndicatorY
				}
				if (!this.layoutValid && this.heatmapIndicatorPosition != "right") {
					if (this.varDendrogramPosition == "top") {
						r -= this.getVarTreeHeight()
					}
					r -= this.varOverlaysThicknessTop;
					if (this.varTitleLabelOverlayPosition != "bottom") {
						r -= this.getVariableTitleHeight();
						r -= this.getVariableLabelLength()
					} else {
						r -= this.getVariableLabelDescLength()
					}
					r += this.margin
				}
				if (!this.isOncoprint) {
					this.drawColorIndicator(c, r, this.getDefaultMetaDataObject(), this.xAxisTitle ? this.xAxisTitle : false, true)
				}
			}
		} else {
			if ((this.xAxisTransform && this.xAxisTransform.match(/log/) && !this.xAxisTransformTicks) || (this.isTransformedData && this.isTransformedData.match(/log|exp/) && !this.xAxisTransformTicks)) {
				this.xAxisDecs = parseInt(Math.abs(this.xAxisMin))
			}
			if (this.graphOrientation == "vertical") {
				if (this.xAxisShow && (this.layoutAxis == 1 || this.layoutAxis == 3)) {
					if (!this.layoutValid) {
						c = e + (this.axisTitleFontSize / 2) - this.getAxisTitleTickLength();
						r = u + (this.y / 2);
						m = this.getAxisDescription();
						this.drawText(m, c, r, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2)
					}
					n = Math.abs(this.tickRotate) == 90 ? "center" : "right";
					q = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Values : this.xAxisValues;
					c = e - (this.margin * 2);
					for (var f = s; f < q.length - p; f++) {
						d = q[f];
						if (parseFloat(d) >= this.xAxisMin && parseFloat(d) <= this.xAxisMax) {
							o = g(d);
							r = this.graphType == "Candlestick" && this.summaryType == "volume" ? u + this.y - ((parseFloat(d) - this.xAxis2Min) * this.xAxis2Unit) : u + this.y - ((parseFloat(d) - this.xAxisMin) * this.xAxisUnit);
							if (this.tickRotate) {
								this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, n, "middle", this.tickRotate * Math.PI / 180)
							} else {
								this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, "right", "middle")
							}
						}
					}
				}
				if (this.xAxis2Show && (this.layoutAxis == 2 || this.layoutAxis == 3)) {
					n = Math.abs(this.tickRotate) == 90 ? "center" : "left";
					c = e + this.x + (this.margin * 2);
					if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a && this.xAxis2Title) {
						for (var f = s; f < this.xAxis2Values.length - p; f++) {
							d = this.xAxis2Values[f];
							if (parseFloat(d) >= this.xAxis2Min && parseFloat(d) <= this.xAxis2Max) {
								o = g(d);
								r = u + this.y - ((parseFloat(d) - this.xAxis2Min) * this.xAxis2Unit);
								if (this.tickRotate) {
									this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, n, "middle", this.tickRotate * Math.PI / 180)
								} else {
									this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, "left", "middle")
								}
							}
						}
					} else {
						q = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Values : this.xAxisValues;
						for (var f = s; f < q.length - p; f++) {
							d = q[f];
							if (parseFloat(d) >= this.xAxisMin && parseFloat(d) <= this.xAxisMax) {
								o = g(d);
								r = this.graphType == "Candlestick" && this.summaryType == "volume" ? u + this.y - ((parseFloat(d) - this.xAxis2Min) * this.xAxis2Unit) : u + this.y - ((parseFloat(d) - this.xAxisMin) * this.xAxisUnit);
								if (this.tickRotate) {
									this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, n, "middle", this.tickRotate * Math.PI / 180)
								} else {
									this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, "left", "middle")
								}
							}
						}
					}
					if (!this.layoutValid) {
						c = e + this.x + this.getAxisTitleTickLength(true) - (this.axisTitleFontSize / 2);
						r = u + (this.y / 2);
						m = this.getAxisDescription(true);
						this.drawText(m, c, r, this.axisTitleFont, this.axisTitleColor, "center", "middle", -Math.PI / 2)
					}
				}
			} else {
				if (this.xAxisShow && (this.layoutAxis == 1 || this.layoutAxis == 3)) {
					if (!this.layoutValid) {
						c = e + (this.x / 2);
						r = u - ((this.margin * 4) + this.axisTickFontSize + (this.axisTitleFontSize / 2));
						m = this.getAxisDescription();
						this.drawText(m, c, r, this.axisTitleFont, this.axisTitleColor, "center", "middle")
					}
					q = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Values : this.xAxisValues;
					r = u - ((this.margin * 2) + (this.axisTickFontSize / 2));
					if (this.layoutValid && !this.layoutAdjust) {
						r -= (this.segregateVariablesBy.length + this.segregateSamplesBy.length) * (this.getFontHeight() + (this.margin * 2))
					}
					for (var f = s; f < q.length - p; f++) {
						d = q[f];
						if (parseFloat(d) >= this.xAxisMin && parseFloat(d) <= this.xAxisMax) {
							o = g(d);
							if (this.invertGraph) {
								c = this.graphType == "Candlestick" && this.summaryType == "volume" ? e + this.x - ((parseFloat(d) - this.xAxis2Min) * this.xAxis2Unit) : e + this.x - ((parseFloat(d) - this.xAxisMin) * this.xAxisUnit)
							} else {
								c = this.graphType == "Candlestick" && this.summaryType == "volume" ? e + ((parseFloat(d) - this.xAxis2Min) * this.xAxis2Unit) : e + ((parseFloat(d) - this.xAxisMin) * this.xAxisUnit)
							}
							if (this.tickRotate) {
								this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, "center", "middle", this.tickRotate * Math.PI / 180)
							} else {
								this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, "center", "middle")
							}
						}
					}
				}
				if (this.xAxis2Show && (this.layoutAxis == 2 || this.layoutAxis == 3)) {
					r = u + this.y + (this.margin * 2) + (this.axisTickFontSize / 2);
					if (this.graphType.match(/BarLine|DotLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a && this.xAxis2Title) {
						for (var f = s; f < this.xAxis2Values.length - p; f++) {
							d = this.xAxis2Values[f];
							if (parseFloat(d) >= this.xAxis2Min && parseFloat(d) <= this.xAxis2Max) {
								o = g(d);
								if (this.invertGraph) {
									c = e + this.x - ((d - this.xAxis2Min) * this.xAxis2Unit)
								} else {
									c = e + ((d - this.xAxis2Min) * this.xAxis2Unit)
								}
								this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, "center", "middle")
							}
						}
					} else {
						q = this.graphType == "Candlestick" && this.summaryType == "volume" ? this.xAxis2Values : this.xAxisValues;
						for (var f = s; f < q.length - p; f++) {
							d = q[f];
							if (d >= this.xAxisMin && d <= this.xAxisMax) {
								o = g(d);
								if (this.invertGraph) {
									c = this.graphType == "Candlestick" && this.summaryType == "volume" ? e + this.x - ((parseFloat(d) - this.xAxis2Min) * this.xAxis2Unit) : e + this.x - ((parseFloat(d) - this.xAxisMin) * this.xAxisUnit)
								} else {
									c = this.graphType == "Candlestick" && this.summaryType == "volume" ? e + ((parseFloat(d) - this.xAxis2Min) * this.xAxis2Unit) : e + ((parseFloat(d) - this.xAxisMin) * this.xAxisUnit)
								}
								if (this.tickRotate) {
									this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, "center", "middle", this.tickRotate * Math.PI / 180)
								} else {
									this.drawText(o, c, r, this.axisTickFont, this.axisTickColor, "center", "middle")
								}
							}
						}
					}
					if (!this.layoutValid) {
						c = e + (this.x / 2);
						r = u + this.y + (this.margin * 3) + this.axisTickFontSize + (this.axisTitleFontSize / 2);
						m = this.getAxisDescription(true);
						this.drawText(m, c, r, this.axisTitleFont, this.axisTitleColor, "center", "middle")
					}
				}
			}
			if (this.plotBox) {
				this.disableGradientTransparencyShadow();
				this.rectangle(e, u, this.x, this.y, this.plotBoxColor, this.plotBoxColor, "open", false, this.outlineWidth);
				this.enableGradientTransparencyShadow()
			}
		}
	};
	this.draw1DDataPoints = function() {
		if (this.smpIndices && this.smpIndices.length < 1) {
			return
		}
		if (!this.currentErrorBarsType) {
			this.currentErrorBarsType = this.errorBarsType
		}
		if (this.currentErrorBarsType != this.errorBarsType && this.isGroupedData) {
			this.regroupSamples();
			this.currentErrorBarsType = this.errorBarsType
		}
		this.setClipArea();
		switch (this.graphType) {
			case "Bar":
				this.draw1DBarDataPoints(this.varIndices, "xAxis");
				break;
			case "Line":
				this.draw1DLineDataPoints(this.varIndices, "xAxis");
				break;
			case "BarLine":
				this.draw1DBarDataPoints(this.xAxisVarIndices, "xAxis");
				this.draw1DLineDataPoints(this.xAxis2VarIndices, "xAxis2");
				break;
			case "Stacked":
			case "StackedPercent":
				this.draw1DStackedDataPoints();
				break;
			case "StackedLine":
			case "StackedPercentLine":
				this.draw1DStackedDataPoints();
				this.draw1DLineDataPoints(this.xAxis2VarIndices, "xAxis2");
				break;
			case "Area":
				this.draw1DAreaDataPoints(this.varIndices, "xAxis");
				break;
			case "AreaLine":
				this.draw1DAreaDataPoints(this.xAxisVarIndices, "xAxis");
				this.draw1DAreaDataPoints(this.xAxis2VarIndices, "xAxis2", true);
				break;
			case "Boxplot":
				if (this.showBoxplotOriginalData || this.showViolinBoxplot) {
					this.draw1DBoxplotDataPoints(true, true);
					this.draw1DDotplotDataPoints(true, true)
				} else {
					this.draw1DBoxplotDataPoints()
				}
				break;
			case "Candlestick":
				this.draw1DCandlestickDataPoints();
				break;
			case "Dotplot":
				this.draw1DDotplotDataPoints();
				break;
			case "DotLine":
				this.draw1DDotplotDataPoints();
				this.draw1DLineDataPoints(this.xAxis2VarIndices, "xAxis2");
				break;
			case "Heatmap":
				if (this.isContour) {
					if (this.contourType == "overlay") {
						this.draw1DHeatmapDataPoints()
					}
					this.draw1DContour()
				} else {
					this.draw1DHeatmapDataPoints()
				}
				break;
			case "Treemap":
				this.draw1DTreemapDataPoints();
				break;
			case "TagCloud":
				this.draw1DTagCloudDataPoints();
				break
		}
		this.resetClipArea();
		return true
	};
	this.draw1DBarDataPoints = function(k, h) {
		var B = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var u = B.length;
		var g = this.xAxisMin < 0 ? Math.abs(this.xAxisMin) * this.xAxisUnit : 0;
		var K = this.treemapBy && this.minData >= 0 ? this.getVariableLevelsByAnnotation(this.treemapBy, k) : false;
		var D = this.marginLeft + this.offsetX + this.left;
		var o = this.marginTop + this.offsetY + this.top;
		var C = this.plotByVariable ? this.rowBlockSize : this.blockSeparation + (this.rowBlockSize * (K ? K.length : k.length));
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			D += this.blockSeparation / 2;
			o = (o + this.y) - g
		} else {
			D += g;
			o += this.blockSeparation / 2
		}
		if (K) {
			for (var F = 0; F < K.length; F++) {
				var I = [];
				var G = [];
				var w = this.getVariablesByAnnotationLevel(this.treemapBy, K[F], k);
				for (var E = 0; E < u; E++) {
					var y = this.getTreemapVariable(B[E], w);
					I.push(y[0]);
					G.push(y[1])
				}
				this.drawBarPlot(I, false, D, o, this.rowBlockSize, C, G, this[h + "Unit"], g, this[h + "Min"], this.graphOrientation, J, A, L, false, true, this.invertGraph ? this.x - g : false);
				if (this.graphOrientation == "vertical") {
					D = this.plotByVariable ? D + (this.blockSeparation + (this.rowBlockSize * u)) : D + this.rowBlockSize
				} else {
					o = this.plotByVariable ? o + (this.blockSeparation + (this.rowBlockSize * u)) : o + this.rowBlockSize
				}
			}
		} else {
			for (var F = 0; F < k.length; F++) {
				var I = [];
				var H = [];
				var J = [];
				var L = [];
				var A = [];
				for (var E = 0; E < u; E++) {
					J.push(this.getPropertyValue(k[F], B[E], "colorBy"));
					A.push(this.getPropertyValue(k[F], B[E], "patternBy"));
					I.push(this.getDataAtPos(k[F], B[E], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
					if (this.isGroupedData || this.data.y.hasOwnProperty("stdev")) {
						H.push(this.getDataAtPos(k[F], B[E], "stdev", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()))
					}
					L.push([k[F], B[E]])
				}
				this.drawBarPlot(I, H, D, o, this.rowBlockSize, C, false, this[h + "Unit"], g, this[h + "Min"], this.graphOrientation, J, A, L, false, true, this.invertGraph ? this.x - g : false);
				if (this.graphOrientation == "vertical") {
					D = this.plotByVariable ? D + (this.blockSeparation + (this.rowBlockSize * u)) : D + this.rowBlockSize
				} else {
					o = this.plotByVariable ? o + (this.blockSeparation + (this.rowBlockSize * u)) : o + this.rowBlockSize
				}
			}
		}
	};
	this.draw1DLineDataPoints = function(F, E) {
		var k = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var H = k.length;
		var w = this.marginLeft + this.offsetX + this.left;
		var G = this.marginTop + this.offsetY + this.top;
		var b = this.graphType == "BarLine" || this.graphType == "DotLine" ? true : false;
		var h = b ? this.blockSeparation + (this.xAxisVarIndices.length * this.rowBlockSize) : this.blockSeparation + this.rowBlockSize;
		var u = ((this.blockSeparation + this.rowBlockSize) / 2);
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			w += u;
			G += this.y
		} else {
			G += u
		}
		for (var z = 0; z < F.length; z++) {
			var B = [];
			var A = [];
			var C = this.coordinateLineColor ? this.colors[z % this.colors.length] : this.getVariableColor(this.data.y.vars[F[z]]);
			var g = this.graphType == "DotLine" ? false : this.lineDecoration == "symbol" ? this.shapes[z % this.shapes.length] : "sphere";
			var f = [];
			var D = [];
			for (var y = 0; y < H; y++) {
				B.push(this.getDataAtPos(F[z], k[y], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
				if (this.isGroupedData || this.data.y.hasOwnProperty("stdev")) {
					A.push(this.getDataAtPos(F[z], k[y], "stdev", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
					f.push(this.getPropertyValue(F[z], k[y], "patternBy"))
				}
				D.push([F[z], k[y]])
			}
			this.drawLinePlot(B, A, w, G, this.rowBlockSize, h, this[E + "Unit"], this[E + "Min"], this.graphOrientation, C, f, g, D, false, true, this.invertGraph ? this.x : false);
			if (b && this.xAxisVarIndices.length == this.xAxis2VarIndices.length) {
				if (this.graphOrientation == "vertical") {
					w += this.rowBlockSize
				} else {
					G += this.rowBlockSize
				}
			}
		}
	};
	this.draw1DStackedDataPoints = function() {
		var A = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var u = A.length;
		var C = this.marginLeft + this.offsetX + this.left;
		var o = this.marginTop + this.offsetY + this.top;
		var B = this.blockSeparation + this.rowBlockSize;
		var k = this.graphType.match(/Line/) ? this.xAxisVarIndices : this.varIndices;
		var h = this.graphType == "StackedPercentLine" ? this.xAxisVarIndices : false;
		var z = this.graphType.match(/Percent/) ? true : false;
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			C += this.blockSeparation / 2;
			o += this.y
		} else {
			o += this.blockSeparation / 2
		}
		for (var E = 0; E < u; E++) {
			var F = this.sum(this.getDataForSmpGrpAtIndex(A[E], h));
			var I = [];
			var J = [];
			var y = [];
			var L = [];
			var G = [];
			if (this.treemapBy) {
				var K = this.getVariableLevelsByAnnotation(this.treemapBy);
				for (var D = 0; D < K.length; D++) {
					var x = this.getVariablesByAnnotationLevel(this.treemapBy, K[D]);
					var H = this.getTreemapVariable(A[E], x);
					I.push(H[0]);
					G.push(H[1])
				}
			} else {
				G = false;
				for (var D = 0; D < k.length; D++) {
					I.push(this.getDataAtPos(k[D], A[E], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
					J.push(this.getVariableColor(this.data.y.vars[k[D]]));
					y.push(this.getPropertyValue(k[E], A[E], "patternBy"));
					L.push([k[D], A[E]])
				}
			}
			this.drawStackedPlot(I, C, o, this.rowBlockSize, G, z, F, this.xAxisUnit, this.graphOrientation, J, y, L, false, this.invertGraph ? this.x : false);
			if (this.graphOrientation == "vertical") {
				C += B
			} else {
				o += B
			}
		}
	};
	this.draw1DAreaDataPoints = function(h, g, G) {
		var b = this;
		var B = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var r = B.length;
		var D = this.marginLeft + this.offsetX + this.left;
		var k = this.marginTop + this.offsetY + this.top;
		var C = this.rowBlockSize + this.blockSeparation;
		var H = [];
		var I = [];
		var w = [];
		var J = [];
		var y = [];
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			k += this.y
		}
		if (this.areaType != "stacked" && this.areaType != "percent") {
			var A = [];
			var K = [];
			for (var F = 0; F < h.length; F++) {
				A[F] = b.getDataAtPos(h[F], B[0], false, b.xAxisTransform, b.get1DMinFloorValue(), b.get1DMaxCeilValue());
				K[F] = F
			}
			h.sort(function(d, c) {
				return A[d] - A[c]
			})
		}
		for (var E = 0; E < r; E++) {
			y.push(0)
		}
		for (var F = 0; F < h.length; F++) {
			var e = [];
			var u = g == "xAxis" || this.coordinateLineColor ? this.colors[F % this.colors.length] : this.getVariableColor(this.data.y.vars[h[F]]);
			for (var E = 0; E < r; E++) {
				e.push(this.getDataAtPos(h[F], B[E], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
				y[E] += e[E]
			}
			H.push(e);
			I.push(u);
			w.push("closed");
			J.push([h[F]])
		}
		this.drawAreaPlot(H, D, k, this.x, this.y, C, this.areaType, y, this[g + "Unit"], this[g + "Min"], this[g + "Max"], this.graphOrientation, G, I, w, J, false, this.invertGraph ? this.x : false);
		if (this.areaType != "stacked" && this.areaType != "percent") {
			h.sort(function(d, c) {
				return K[d] - K[c]
			})
		}
	};
	this.draw1DBoxplotDataPoints = function(g, F) {
		var A = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var h = A.length;
		var e = this.varIndices;
		var C = this.marginLeft + this.offsetX + this.left;
		var f = this.marginTop + this.offsetY + this.top;
		var B = this.plotByVariable ? this.rowBlockSize : this.blockSeparation + (this.rowBlockSize * e.length);
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			C += this.blockSeparation / 2;
			if (this.showViolinBoxplot) {
				C += this.rowBlockSize / 3
			}
			f += this.y
		} else {
			f += this.blockSeparation / 2;
			if (this.showViolinBoxplot) {
				f += this.rowBlockSize / 3
			}
		}
		for (var G = 0; G < e.length; G++) {
			var H = [];
			var I = [];
			var w = [];
			var x = [];
			var J = [];
			for (var E = 0; E < h; E++) {
				var u = ["iqr1", "iqr3", "qtl1", "qtl3", "median", "out", "mean"];
				var b = [];
				var y = this.getGroupColor(e[G], A[E]);
				for (var D = 0; D < u.length; D++) {
					b.push(this.getDataAtPos(e[G], A[E], u[D], this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()))
				}
				if (F) {
					b[5] = false
				}
				H.push(b);
				I.push(g ? this.foreground : y);
				x.push(g ? "open" : this.getPropertyValue(e[G], A[E], "patternBy"));
				J.push([e[G], A[E]]);
				w.push(y)
			}
			if (this.showViolinBoxplot) {
				this.drawBoxPlot(H, C, f, this.rowBlockSize / 3, B, this.xAxisUnit, this.xAxisMin, this.graphOrientation, I, x, J, w)
			} else {
				this.drawBoxPlot(H, C, f, this.rowBlockSize, B, this.xAxisUnit, this.xAxisMin, this.graphOrientation, I, x, J, w)
			}
			if (this.graphOrientation == "vertical") {
				C = this.plotByVariable ? C + (this.blockSeparation + (this.rowBlockSize * h)) : C + this.rowBlockSize
			} else {
				f = this.plotByVariable ? f + (this.blockSeparation + (this.rowBlockSize * h)) : f + this.rowBlockSize
			}
		}
	};
	this.draw1DCandlestickDataPoints = function() {
		var B = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var w = B.length;
		var g = this.varIndices;
		var D = this.marginLeft + this.offsetX + this.left;
		var q = this.marginTop + this.offsetY + this.top;
		var C = this.blockSeparation + (this.rowBlockSize * g.length);
		var A = this.summaryType == "candle" ? true : false;
		var o = A ? this.xAxisUnit : this.xAxis2Unit;
		var f = A ? this.xAxisMin : this.xAxis2Min;
		var H = this.rowBlockSize / 2;
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			D += this.blockSeparation / 2;
			q += this.y
		} else {
			q += this.blockSeparation / 2
		}
		for (var G = 0; G < g.length; G++) {
			var I = [];
			var J = this.colors[G % this.colors.length];
			var L = [];
			for (var F = 0; F < w; F++) {
				var y = A ? ["open", "close", "high", "low"] : ["volume"];
				var e = [];
				for (var E = 0; E < y.length; E++) {
					e.push(this.getDataAtPos(g[G], B[F], y[E], this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()))
				}
				I.push(e);
				L.push([g[G], B[F]])
			}
			this.drawCandlestickPlot(I, D, q, this.rowBlockSize, C, o, f, A, this.graphOrientation, J, L);
			if (this.stockIndicators.length > 0) {
				for (var F = 0; F < this.stockIndicators.length; F++) {
					var K = this.getTechnicalIndicatorColor(this.stockIndicators[F]);
					var I = [];
					for (var E = 0; E < w; E++) {
						I.push(this.getDataAtPos(g[G], B[E], this.stockIndicators[F], this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()))
					}
					if (this.graphOrientation == "vertical") {
						this.drawLinePlot(I, [], D + H, q, this.rowBlockSize, C, o, f, this.graphOrientation, K, false, false, false, false, true)
					} else {
						this.drawLinePlot(I, [], D, q + H, this.rowBlockSize, C, o, f, this.graphOrientation, K, false, false, false, false, true)
					}
				}
			}
			if (this.graphOrientation == "vertical") {
				D += this.rowBlockSize
			} else {
				q += this.rowBlockSize
			}
		}
	};
	this.setConnectData = function(g) {
		if (this.connectBy && this.data.x.hasOwnProperty(this.connectBy)) {
			this.connectByData = {};
			var c, f;
			var e = 0;
			for (var d = 0; d < g.length; d++) {
				if (this.isGroupedData) {
					for (var b = 0; b < this.data.w.grps[g[d]].length; b++) {
						f = this.data.w.grps[g[d]][b];
						c = this.data.x[this.connectBy][f];
						if (!this.connectByData.hasOwnProperty(c)) {
							this.connectByData[c] = []
						}
						this.connectByData[c].push(e);
						e++
					}
				} else {
					f = g[d];
					c = this.data.x[this.connectBy][f];
					if (!this.connectByData.hasOwnProperty(c)) {
						this.connectByData[c] = []
					}
					this.connectByData[c].push(d)
				}
			}
		}
	};
	this.draw1DDotplotDataPoints = function(R, D) {
		var B = this;
		var A = function() {
			var b;
			if (B.x < 100 || B.y < 100) {
				b = B.rowBlockSize / 6
			} else {
				if (B.x < 200 || B.y < 200) {
					b = B.rowBlockSize / 3
				} else {
					b = B.rowBlockSize / 1.5
				}
			}
			return Math.min(b, B.maxTextSize * 2)
		};
		var Q = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var K = Q.length;
		var H = this.graphType == "DotLine" ? this.xAxisVarIndices : this.varIndices;
		var T = this.marginLeft + this.offsetX + this.left;
		var J = this.marginTop + this.offsetY + this.top;
		var ad = ((this.blockSeparation + this.rowBlockSize) / 2);
		var S = this.plotByVariable ? this.rowBlockSize : this.blockSeparation + (this.rowBlockSize * H.length);
		var N = R ? A() / this.boxplotDataPointRatio : A();
		this.setConnectData(Q);
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.graphOrientation == "vertical") {
			T += ad;
			J += this.y
		} else {
			J += ad
		}
		for (var W = 0; W < H.length; W++) {
			var ab = [];
			var aa = [];
			var ac = [];
			var X = [];
			var O = [];
			var Z = [];
			var ae = [];
			var Y = 0;
			var P;
			for (var V = 0; V < K; V++) {
				if (this.isGroupedData) {
					var C = [];
					var E = [];
					var F = [];
					var M = [];
					var G = [];
					var I = [];
					var L = this.isTransformedData || (this.showBoxplotOriginalData && this.data.y.trans) ? this.data.y.trans : this.data.y.data;
					for (var U = 0; U < this.data.w.grps[Q[V]].length; U++) {
						P = this.getPropertyValue(H[W], this.data.w.grps[Q[V]][U], "colorBy");
						C.push(L[H[W]][this.data.w.grps[Q[V]][U]]);
						G.push(this.getPropertyValue(H[W], this.data.w.grps[Q[V]][U], "shapeBy"));
						E.push(this.getPropertyValue(H[W], this.data.w.grps[Q[V]][U], "sizeBy"));
						F.push(R ? this.addColorTransparency(P, this.boxplotDataPointTransparency) : P);
						M.push(this.getPropertyValue(H[W], this.data.w.grps[Q[V]][U], "patternBy"));
						I.push([H[W], Q[V], this.data.w.grps[Q[V]][U]]);
						Y++
					}
					if (this.data.w.hasOwnProperty("stdev")) {
						aa.push([this.getDataAtPos(H[W], Q[V], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()), this.getDataAtPos(H[W], Q[V], "stdev", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue())])
					}
					ab.push(C);
					O.push(G);
					Z.push(E);
					ac.push(F);
					X.push(M);
					ae.push(I)
				} else {
					P = this.getPropertyValue(H[W], Q[V], "colorBy");
					ab.push([this.getDataAtPos(H[W], Q[V], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue())]);
					if (this.data.y.hasOwnProperty("stdev")) {
						aa.push([this.getDataAtPos(H[W], Q[V], "stdev", this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue())])
					}
					O.push([this.getPropertyValue(H[W], Q[V], "shapeBy")]);
					Z.push([this.getPropertyValue(H[W], Q[V], "sizeBy")]);
					ac.push([R ? this.addColorTransparency(P, this.boxplotDataPointTransparency) : P]);
					X.push([this.getPropertyValue(H[W], Q[V], "patternBy")]);
					ae.push([
						[H[W], Q[V]]
					])
				}
			}
			if (this.plotByVariable) {
				this.drawDotPlot(ab, aa, T, J, this.rowBlockSize, S, this.xAxisUnit, this.xAxisMin, Z, this.graphOrientation, ac, X, O, N, ae, false, true, this.invertGraph ? this.x : false)
			} else {
				this.drawDotPlot(ab, aa, T, J, this.blockSeparation, S, this.xAxisUnit, this.xAxisMin, Z, this.graphOrientation, ac, X, O, N, ae, false, true, this.invertGraph ? this.x : false)
			}
			if (this.graphOrientation == "vertical") {
				T = this.plotByVariable ? T + (this.blockSeparation + (this.rowBlockSize * K)) : T + this.rowBlockSize
			} else {
				J = this.plotByVariable ? J + (this.blockSeparation + (this.rowBlockSize * K)) : J + this.rowBlockSize
			}
		}
	};
	this.draw1DHeatmapDataPoints = function() {
		var P = this.isGroupedData ? this.grpIndices : this.smpIndices;
		var V = this.isGroupedData ? this.data.w : this.data.y;
		var K = P.length;
		var R = this.marginLeft + this.offsetX + this.left;
		var J = this.marginTop + this.offsetY + this.top;
		var W = this.colBlockSize < 4 || this.rowBlockSize < 4 || !this.heatmapCellBox ? true : false;
		var Q = Math.max(Math.min(this.colBlockSize, this.rowBlockSize) - 10, 3);
		var S = this.dataSizes && this.dataSizes.length > 0 ? Q / this.max(this.dataSizes) : 1;
		var L = this.outlineWidth;
		if (this.xAxisTransform && this.xAxisTransform == "percentile") {
			this.setRangeData(this.summaryType)
		}
		if (this.isMultidimensionalData || this.isOncoprint) {
			if (this.isOncoprint) {
				var g = "rgb(220,220,220)";
				var r = "rgb(255,0,0)";
				var F = "rgb(0,153,0)";
				var b = "rgb(0,0,255)";
				var A = this.colBlockSize * 0.8;
				var ab = this.rowBlockSize * 0.9;
				var h = this.rowBlockSize * 0.3;
				for (var U = 0; U < this.varIndices.length; U++) {
					for (var T = 0; T < K; T++) {
						var E = R + (U * this.colBlockSize) + (this.colBlockSize / 2);
						var C = J + (T * this.rowBlockSize) + (this.rowBlockSize / 2);
						var B = C + h;
						var H = this.getDataAtPos(this.varIndices[U], P[T], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue());
						var Q = this.getDataAtPos(this.varIndices[U], P[T], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue(), true);
						var M = this.getPropertyValue(this.varIndices[U], P[T], "patternByData");
						var Y = !isNaN(H) ? this.getColorForValue(false, H) : this.missingDataColor;
						var N = this.getPropertyValue(this.varIndices[U], P[T], "outlineByData");
						var I = this.getPropertyValue(this.varIndices[U], P[T], "shapeByData");
						var G = this.getPropertyValue(this.varIndices[U], P[T], "sizeByData");
						this.addArea(this.drawShape("rect", E, C, A, ab, g, g, M, false, false, true), [this.varIndices[U], P[T]]);
						if (H >= this.oncoprintAmplification) {
							this.drawShape("rect", E, C, A, ab, r, r, M, false, false, true)
						} else {
							if (H <= this.oncoprintDeletion) {
								this.drawShape("rect", E, C, A, ab, b, b, M, false, false, true)
							}
						}
						if (Q && ((isNaN(Q) && !Q.toString().match(/^no$|^-$|^neg$/i)) || Q > 0)) {
							this.drawShape("rect", E, C, A, A, F, F, M, false, false, true);
							if (this.oncoprintCode) {
								this.drawText(Q, E, C, this.varLabelFont, this.varLabelFontColor, "center", "middle")
							}
						}
						if (this.isMultidimensionalData) {
							var O = G ? this.percentile(this.sizes[0], this.sizes[this.sizes.length - 1], G) / 10 : 1;
							if (O == 0) {
								O = 1
							}
							if (I) {
								N = N ? N : this.foreground;
								this.drawShape(I, E, B, A * O, h * O, N, N, M, false, false, true)
							} else {
								if (N) {
									this.drawShape("circle", E, B, A * O, h * O, N, N, M, false, false, true)
								}
							}
						}
					}
				}
			} else {
				for (var U = 0; U < this.varIndices.length; U++) {
					for (var T = 0; T < K; T++) {
						var E = R + (U * this.colBlockSize) + (this.colBlockSize / 2);
						var C = J + (T * this.rowBlockSize) + (this.rowBlockSize / 2);
						var H = this.getDataAtPos(this.varIndices[U], P[T], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue());
						var Y = !isNaN(H) ? this.getColorForValue(false, H) : this.missingDataColor;
						N = this.getPropertyValue(this.varIndices[U], P[T], "outlineByData");
						var I = this.getPropertyValue(this.varIndices[U], P[T], "shapeByData");
						var G = this.getPropertyValue(this.varIndices[U], P[T], "sizeByData");
						var M = this.getPropertyValue(this.varIndices[U], P[T], "patternByData");
						this.addArea(this.drawShape(I, E, C, G, G, Y, N, M, false, false, true), [this.varIndices[U], P[T]]);
						if (this.showDataValues) {
							this.drawText(H, (E + (this.colBlockSize / 2)) - 2, (C + (this.rowBlockSize / 2)) - 2, this.overlayFont, this.foreground, "right", "bottom")
						}
					}
				}
			}
			this.outlineWidth = L
		} else {
			var I = 0;
			for (var U = 0; U < K; U++) {
				var X = [];
				var aa = [];
				var M = [];
				var L = U >= K - 1;
				for (var T = 0; T < this.varIndices.length; T++) {
					X.push(this.getDataAtPos(this.varIndices[T], P[U], false, this.xAxisTransform, this.get1DMinFloorValue(), this.get1DMaxCeilValue()));
					aa.push([this.varIndices[T], P[U]]);
					if (this.patternBy) {
						M.push(this.getPropertyValue(this.varIndices[T], P[U], "patternBy"))
					} else {
						M.push("solid")
					}
				}
				if (U > 0 && U < K - 1) {
					if (I >= 0.5) {
						this.drawHeatmap(X, R, J, this.colBlockSize, this.rowBlockSize, W, aa, false, M, this.meta.def.colorBrew, L);
						I = 0
					}
				} else {
					this.drawHeatmap(X, R, J, this.colBlockSize, this.rowBlockSize, W, aa, false, M, this.meta.def.colorBrew, L)
				}
				J += this.rowBlockSize;
				I += this.rowBlockSize
			}
			if (!W) {
				J = this.marginTop + this.offsetY + this.top;
				for (var U = 0; U <= this.varIndices.length; U++) {
					this.drawLine("line", R, J, R, J + this.y, this.heatmapCellBoxColor, this.heatmapCellBoxWidth);
					R += this.colBlockSize
				}
				R = this.marginLeft + this.offsetX + this.left;
				this.drawLine("line", R, J + this.y, R + this.x, J + this.y, this.heatmapCellBoxColor, this.heatmapCellBoxWidth)
			}
			if (this.highlightSmp.length > 0 || this.highlightVar.length > 0) {
				J = this.marginTop + this.offsetY + this.top;
				R = this.marginLeft + this.offsetX + this.left;
				var ac = this.getObjectArray(this.highlightVar);
				var Z = this.getObjectArray(this.highlightSmp);
				var G = this.heatmapCellBoxWidth + this.heatmapCellBoxHighlightWidth;
				var D = G / 2;
				if (this.highlightSmp.length == 0) {
					for (var U = 0; U < this.varIndices.length; U++) {
						if (ac.hasOwnProperty(V.vars[this.varIndices[U]])) {
							this.rectangle(R + D, J + D, this.colBlockSize - G, this.y - G, false, this.heatmapCellBoxColorHighlight, "open", false, G)
						}
						R += this.colBlockSize
					}
				} else {
					if (this.highlightVar.length == 0) {
						for (var U = 0; U < K; U++) {
							if (Z.hasOwnProperty(V.smps[P[U]])) {
								this.rectangle(R + D, J + D, this.x - G, this.rowBlockSize - G, false, this.heatmapCellBoxColorHighlight, "open", false, G)
							}
							J += this.rowBlockSize
						}
					} else {
						for (var U = 0; U < K; U++) {
							R = this.marginLeft + this.offsetX + this.left;
							for (var T = 0; T <= this.varIndices.length; T++) {
								if (Z.hasOwnProperty(V.smps[P[U]]) && ac.hasOwnProperty(V.vars[this.varIndices[T]])) {
									this.rectangle(R + D, J + D, this.colBlockSize - G, this.rowBlockSize - G, false, this.heatmapCellBoxColorHighlight, "open", false, G)
								}
								R += this.colBlockSize
							}
							J += this.rowBlockSize
						}
					}
				}
			}
		}
	};
	this.draw1DTreemapDataPoints = function() {
		var c = this.marginLeft + this.offsetX + this.left;
		var d = this.marginTop + this.offsetY + this.top;
		var b = this.getTreemap();
		this.drawTreemap(b, c, d)
	};
	this.draw1DTagCloudDataPoints = function(h) {
		var g = this.randomSeed;
		this.setTagCloud(h);
		var k = this.varIndices[0];
		for (var e = 0; e < this.smpIndices.length; e++) {
			var b = this.smpIndices[e];
			var j = this.getDataAtPos(k, b);
			var l = this.colorBy ? this.getPropertyValue(k, b, "colorBy") : this.foreground;
			if (!this.drawCloudTag(this.data.y.smps[b], j, l, [k, b])) {
				this.resizeCanvas();
				if (this.pseudoRandom) {
					this.randomSeed = g
				}
				this.draw1DTagCloudDataPoints(0.9);
				break
			}
		}
		if (this.pseudoRandom) {
			this.randomSeed = g
		}
	};
	this.draw1DContour = function() {
		var w, e, v, d;
		if (this.isContour) {
			var g = this.data.y.contour.list;
			var y = this.getColorBrew(this.colorSpectrum, 0, g[0].level, this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			var b = this.varIndices.length - 1;
			var n = this.smpIndices.length - 1;
			var p = (this.x - this.colBlockSize) / b;
			var o = (this.y - this.rowBlockSize) / n;
			var m = this.varIndices[0] * p;
			var k = this.smpIndices[0] * o;
			var r = (this.marginLeft + this.offsetX + this.left + (this.colBlockSize / 2)) - m;
			var h = (this.marginTop + this.offsetY + this.top + (this.rowBlockSize / 2)) - k;
			var x = 10;
			if (this.contourType == "overlay") {
				for (var u = 0; u < g.length; u++) {
					w = r + (g[u][0].x * p);
					e = h + (g[u][0].y * o);
					for (var s = 1; s < g[u].length; s++) {
						v = r + (g[u][s].x * p);
						d = h + (g[u][s].y * o);
						this.drawLine("line", w, e, v, d, this.foreground, false, false, false, false, true);
						w = v;
						e = d
					}
				}
			} else {
				if (this.contourType == "color") {
					this.rectangle(r, h, this.x - this.colBlockSize, this.y - this.rowBlockSize, this.getColorForValue(y, 0));
					for (var u = g.length - 1; u >= 0; u--) {
						var c = [];
						var q = [];
						var f = this.getColorForValue(y, g[u].level);
						for (var s = 0; s < g[u].length; s++) {
							c.push(r + (g[u][s].x * p));
							q.push(h + (g[u][s].y * o))
						}
						if (g[u][0].x != g[u][g[u].length - 1].x || g[u][0].y != g[u][g[u].length - 1].y) {
							if (g[u][0].x == 0 || g[u][0].x == b) {
								c.push(r + (g[u][0].x * p));
								q.push(h + (g[u][g[u].length - 1].y * o))
							} else {
								if (g[u][g[u].length - 1].x == 0 || g[u][g[u].length - 1].x == b) {
									c.push(r + (g[u][g[u].length - 1].x * p));
									q.push(h + (g[u][0].y * o))
								}
							}
						}
						this.drawShape("path", c, q, false, false, f, f, "closed", false, false, true)
					}
				}
			}
		}
	};
	this.checkOrientation = function() {
		if (this.graphType == "Heatmap") {
			this.graphOrientation = "horizontal"
		}
	};
	this.checkClustering = function() {
		if (this.samplesClustered) {
			this.clusterSamples(false, true)
		}
		if (this.variablesClustered) {
			this.clusterVariables(false, true)
		}
		if (this.samplesKmeaned) {
			this.kmeansSamples(false, true)
		}
		if (this.variablesKmeaned) {
			this.kmeansVariables(false, true)
		}
	};
	this.checkSamplesGrouping = function() {
		if (this.groupingFactors.length > 0 && !this.isGroupedData) {
			if (this.layoutComb && this.data.l && this.data.l.group && this.isSameObject(this.data.l.group.sort(), this.groupingFactors.sort())) {} else {
				this.groupSamples(this.getGroupingFactors(true), false, false, true, true)
			}
		}
	};
	this.checkDataTransform = function() {
		if (this.transformedData && this.transformType && !this.isTransformedData) {
			this.transform(this.transformType, this.transformAxis, false, false)
		}
	};
	this.checkSegregation = function() {
		if (this.graphType != "Candlestick" && !this.isDOE) {
			this.validateSegregation();
			if (this.data.l) {
				if (this.segregateSamplesBy.length == 0) {} else {
					if (!this.data.l.smps) {
						this.segregateSamples(this.segregateSamplesBy, true)
					}
				}
				if (this.segregateVariablesBy.length == 0) {} else {
					if (!this.data.l.vars) {
						this.segregateVariables(this.segregateVariablesBy, true)
					}
				}
			} else {
				if (this.segregateSamplesBy.length > 0 && this.segregateVariablesBy.length > 0) {
					this.segregateSamplesVariables(true)
				} else {
					if (this.segregateSamplesBy.length > 0) {
						this.segregateSamples(this.segregateSamplesBy, true)
					} else {
						if (this.segregateVariablesBy.length > 0) {
							this.segregateVariables(this.segregateVariablesBy, true)
						}
					}
				}
			}
		}
	};
	this.checkMultidimensional = function() {
		var d = this.graphType == "Heatmap" ? ["outline", "shape", "size", "pattern"] : ["color", "outline", "shape", "size", "pattern"];
		for (var c = 0; c < d.length; c++) {
			var b = d[c] + "ByData";
			if (this[b] && this.data.y[this[b]] && this.isArray(this.data.y[this[b]])) {
				this.isMultidimensionalData = true
			}
		}
	};
	this.checkTreemap = function() {
		if (this.graphType == "Treemap") {
			this.showVarDendrogram = true;
			if (this.isGroupedData) {
				this.ungroupSamples()
			}
		}
	};
	this.checkOncoprint = function() {
		if (this.isOncoprint) {
			if (!this.data.y.hasOwnProperty(this.isOncoprint)) {
				this.isOncoprint = false
			} else {
				this.summarizeOncoprint()
			}
		}
	};
	this.validate1DPropertyDefaults = function() {
		this.checkOrientation();
		this.checkSamplesGrouping();
		this.checkDataTransform();
		this.checkClustering();
		this.checkSegregation();
		this.checkMultidimensional();
		this.checkTreemap();
		this.checkOncoprint()
	};
	this.setOverlaysDendrogramVariable = function() {
		if (this.isDOE) {
			this.showOverlays = false;
			this.showVarDendrogram = false;
			this.showSmpDendrogram = false;
			this.smpTitle = false
		} else {
			if (this.plotByVariable) {
				if (this.graphType.match(/^Bar$|Boxplot|Dotplot/)) {
					this.showOverlays = false;
					this.showVarDendrogram = false;
					this.showSmpDendrogram = false
				} else {
					this.plotByVariable = false
				}
			}
		}
	};
	this.set1DAttributes = function() {
		this.setTrees();
		this.setOverlayFont()
	};
	this.set1DOverlays = function() {
		this.validateOverlays();
		this.setOverlays("var");
		this.setOverlays("smp")
	};
	this.draw1DLayout = function() {
		this.drawTrees();
		this.draw1DXLayout();
		this.draw1DYLayout()
	};
	this.draw1DData = function() {
		this.drawPlotWindow();
		this.draw1DWireFrame();
		this.draw1DDataPoints();
		this.draw1DLayout();
		this.draw1DOverlays();
		this.drawDecorationData();
		this.drawLegend();
		this.drawTitle()
	};
	this.draw1DPlot = function() {
		this.checkOrientation();
		this.validatePropertyValues();
		this.setOverlaysDendrogramVariable();
		this.set1DAttributes();
		this.set1DOverlays();
		this.set1DXYDimensions();
		this.set1DPrivateParams();
		this.set1DXAxis();
		this.draw1DData()
	};
	this.restoreOriginalSettings = function() {
		var e = this.meta.config.orig;
		var c = ["varLabelScaleFontFactor", "showVariableNames", "showSampleNames", "varLabelDescription", "smpLabelScaleFontFactor", "smpLabelDescription", "insideLegend", "legendFontSize", "showLegend", "legendPosition"];
		for (var b = 0; b < c.length; b++) {
			var d = c[b];
			if (e[d]) {
				this[d] = e[d];
				delete(e[d])
			}
		}
		this.adjustAspectRatioXTries = 0;
		this.adjustAspectRatioYTries = 0
	};
	this.initialize1DPlot = function() {
		if (!this.is1DPlotting) {
			this.is1DPlotting = true;
			this.validate1DPropertyDefaults();
			if (this.layoutValid) {
				this.drawLayoutCompartments(this.draw1DPlot)
			} else {
				this.draw1DPlot()
			}
			this.restoreOriginalSettings();
			this.is1DPlotting = false
		}
	};
	if (!a) {
		this.initialize1DPlot()
	}
};
CanvasXpress.prototype.Network = function(a) {
	this.findXYCoordinates = function(d) {
		var b = this.adjustedCoordinates(d);
		var f = {};
		f.x = (b.x / this.scaleFactor || 1) - this.offsetX;
		f.y = (b.y / this.scaleFactor || 1) - this.offsetY;
		return f
	};
	this.addNode = function(e, d) {
		if (e) {
			if (!e.id) {
				var b = 0;
				var f = "id" + b;
				while (this.nodes.hasOwnProperty(f)) {
					b++;
					f = "id" + b
				}
				e.id = f
			}
			if (!e.color) {
				e.color = this.colors[0]
			}
			if (!e.shape) {
				e.shape = this.shapes[0]
			}
			if (!e.size) {
				e.size = 1
			}
			if (d) {
				var c = this.findXYCoordinates(d);
				e.x = c.x;
				e.y = c.y
			}
			this.data.nodeIndices[e.id] = this.data.nodes.length;
			this.data.nodes.push(e);
			this.nodes[e.id] = e;
			return e
		}
	};
	this.getNodeConfigurableProperties = function(b) {
		var d = this.getObjectArray(this.nodeConfigurableProperties);
		if (b) {
			for (var c in this.data.nodes[b]) {
				d[c] = true
			}
		}
		return this.getKeys(d)
	};
	this.getEdgeConfigurableProperties = function(c) {
		var d = this.getObjectArray(this.edgeConfigurableProperties);
		if (c) {
			for (var b in this.data.edges[c]) {
				d[b] = true
			}
		}
		return this.getKeys(d)
	};
	this.removeNode = function(e, l) {
		if (e && e.id) {
			var b = l ? this.getObjectArray(this.findChildrenNodeIndices(e.id)) : false;
			var h = [];
			var d = 0;
			if (this.nodeParentHood[e.id] && this.nodeParentHood[e.id].children) {
				for (var k = 0; k < this.nodeParentHood[e.id].children.length; k++) {
					var m = this.nodeParentHood[e.id].children[k];
					if (this.data.nodeIndices[m] && this.data.nodes[this.data.nodeIndices[m]]) {
						delete(this.data.nodes[this.data.nodeIndices[m]].parentNode)
					}
				}
			}
			this.data.nodeIndices = {};
			for (var k = 0; k < this.data.nodes.length; k++) {
				if (this.data.nodes[k].id != e.id) {
					if (b && b.hasOwnProperty(k)) {
						var g = this.edgesForNode(this.data.edges, this.data.nodes[k].id);
						for (var f = 0; f < g.length; f++) {
							this.removeEdge(g[f])
						}
					} else {
						h.push(this.data.nodes[k]);
						this.data.nodeIndices[this.data.nodes[k].id] = d;
						d++
					}
				} else {
					var g = this.edgesForNode(this.data.edges, e.id);
					for (var f = 0; f < g.length; f++) {
						this.removeEdge(g[f])
					}
				}
			}
			this.data.nodes = h
		}
	};
	this.addEdge = function(b) {
		if (b && b.id1 && b.id2) {
			if (!b.color) {
				b.color = this.colors[0]
			}
			if (!b.width) {
				b.width = 1
			}
			if (!b.type) {
				b.type = "line"
			}
			this.data.edges.push(b)
		}
	};
	this.removeEdge = function(d) {
		if (d && d.id1 && d.id2) {
			var c = [];
			for (var b = 0; b < this.data.edges.length; b++) {
				if (this.data.edges[b].id1 != d.id1 || this.data.edges[b].id2 != d.id2) {
					c.push(this.data.edges[b])
				}
			}
			this.data.edges = c
		}
	};
	this.getAllObjectAttributes = function(d) {
		var e = [];
		if (this.data[d]) {
			for (var c = 0; c < this.data[d].length; c++) {
				for (var b in this.data[d][c]) {
					if (e.hasOwnProperty(b)) {
						e[b]++
					} else {
						e[b] = 1
					}
				}
			}
		}
		return e
	};
	this.setAllObjectAttributes = function(b, o, t, k) {
		if (this.data[b]) {
			var e = this.meta.data[b];
			var g = this.getAllObjectAttributeValues(b, t);
			if (g) {
				if (this.isNumeric(g)) {
					e[t] = {
						type: "Numeric"
					};
					var h = this.range(g);
					if (o == "color") {
						var r = this.getColorBrew(this.colorSpectrum, h[0], h[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
						this.networkColorBrew = r;
						for (var p = 0; p < this.data[b].length; p++) {
							if (this.data[b][p].hasOwnProperty(t)) {
								var u = this.data[b][p][t];
								var c = this.getColorForValue(r, u);
								this.data[b][p][o] = c
							} else {
								this.data[b][p][o] = this.missingDataColor
							}
						}
					} else {
						if (o == "size") {
							for (var p = 0; p < this.data[b].length; p++) {
								if (this.data[b][p].hasOwnProperty(t)) {
									var u = this.data[b][p][t];
									var n = this.percentile(h[0], h[1], u);
									var q = parseInt(n * 25 / 10);
									if (k) {
										this.data[b][p]["decorationSize"] = 1 + (q / 25)
									} else {
										this.data[b][p][o] = 1 + (q / 100)
									}
								} else {
									if (k) {
										this.data[b][p]["decorationSize"] = 0.1
									} else {
										this.data[b][p][o] = 0.1
									}
								}
							}
						} else {
							if (o == "shape") {
								if (b == "nodes") {
									var j = "square";
									for (var p = 0; p < this.data[b].length; p++) {
										if (this.data[b][p].hasOwnProperty(t)) {
											var u = this.data[b][p][t];
											var n = this.percentile(h[0], h[1], u);
											var m = parseInt(n / 10);
											if (m > 0) {
												m--
											}
											this.data[b][p][o] = "pie" + m
										} else {
											this.data[b][p][o] = j
										}
									}
								} else {
									if (b == "edges") {
										for (var p = 0; p < this.data[b].length; p++) {
											if (this.data[b][p].hasOwnProperty(t)) {
												var u = this.data[b][p][t];
												var n = this.percentile(h[0], h[1], u);
												var m = parseInt(n / 10);
												if (m > 0) {
													m--
												}
												this.data[b][p]["type"] = this.lines[m]
											} else {
												this.data[b][p]["type"] = this.lines[10]
											}
										}
									}
								}
							}
						}
					}
				} else {
					e[t] = {
						type: "String"
					};
					var d = 0;
					var s = 0;
					var f = 0.1;
					var l = {
						color: {},
						shape: {},
						size: {}
					};
					for (var p = 0; p < g.length; p++) {
						if (!l.color.hasOwnProperty(g[p])) {
							l.color[g[p]] = this.colors[d % this.colors.length];
							d++
						}
						if (b == "nodes") {
							if (!l.shape.hasOwnProperty(g[p])) {
								l.shape[g[p]] = this.shapes[s % this.shapes.length];
								s++
							}
						} else {
							if (!l.shape.hasOwnProperty(g[p])) {
								l.lines[g[p]] = this.lines[s % this.lines.length];
								s++
							}
						}
						if (!l.size.hasOwnProperty(g[p])) {
							l.size[g[p]] = f;
							f += 0.1
						}
					}
					for (var p = 0; p < this.data[b].length; p++) {
						if (this.data[b][p].hasOwnProperty(t)) {
							var u = this.data[b][p][t];
							this.data[b][p][o] = l[o][u]
						}
					}
				}
			}
		}
	};
	this.getAllObjectAttributeValues = function(d, b) {
		var e = [];
		if (this.data[d]) {
			for (var c = 0; c < this.data[d].length; c++) {
				if (this.data[d][c].hasOwnProperty(b)) {
					e.push(this.data[d][c][b])
				}
			}
		}
		return e
	};
	this.modifyXYEdgeElbow = function(e, d, c, b) {
		var f = this.data.edges[e].elbows[d];
		f[0] -= c;
		f[1] -= b
	};
	this.getNodeWidth = function(b) {
		return (b.width ? b.width : b.size ? (this.nodeSize * b.size) : this.nodeSize)
	};
	this.getNodeHeight = function(b) {
		return (b.height ? b.height : b.size ? (this.nodeSize * b.size) : this.nodeSize)
	};
	this.modifyNodeSize = function(e, b, c) {
		var d = this.data.nodes[this.data.nodeIndices[e]];
		delete(d.size);
		d.width = b;
		d.height = c
	};
	this.modifyXYNode = function(g, d, b) {
		var f = this.data.nodes[this.data.nodeIndices[g]];
		if (!f.fixed) {
			f.x -= d;
			f.y -= b;
			if (f.labelX != null && f.labelY != null) {
				this.modifyXYNodeLab(g, d, b)
			}
			if (f.decorationsX != null && f.decorationsY != null) {
				this.modifyXYNodeDec(g, d, b)
			}
			if (this.networkLayoutType != "radial") {
				if (this.nodeParentHood[f.id] && this.nodeParentHood[f.id]["children"]) {
					for (var e = 0; e < this.nodeParentHood[f.id]["children"].length; e++) {
						var c = this.nodeParentHood[f.id]["children"][e];
						this.modifyXYNode(c, d, b)
					}
				}
			}
		}
	};
	this.modifyXYNodeLab = function(e, c, b) {
		var d = this.data.nodes[this.data.nodeIndices[e]];
		if (!d.fixed) {
			d.labelX = d.labelX != null ? d.labelX - c : d.labelXi - c;
			d.labelY = d.labelY != null ? d.labelY - b : d.labelYi - b
		}
	};
	this.modifyXYNodeDec = function(e, c, b) {
		var d = this.data.nodes[this.data.nodeIndices[e]];
		if (!d.fixed) {
			d.decorationsX = d.decorationsX != null ? d.decorationsX - c : d.decorationsXi - c;
			d.decorationsY = d.decorationsY != null ? d.decorationsY - b : d.decorationsYi - b
		}
	};
	this.getHiddenNodes = function() {
		var c = [];
		if (this.data.nodes) {
			for (var b = 0; b < this.data.nodes.length; b++) {
				if (this.data.nodes[b].hide) {
					c.push(this.data.nodes[b])
				}
			}
		}
		return c
	};
	this.orderNodes = function(c) {
		for (var b in this.selectNode) {
			this[c](this.data.nodes[this.data.nodeIndices[b]])
		}
	};
	this.sendNodeToBack = function(d) {
		var c = [d];
		for (var b = 0; b < this.data.nodes.length; b++) {
			if (this.data.nodes[b].id != d.id) {
				c.push(this.data.nodes[b])
			}
		}
		this.data.nodes = c;
		this.setNodeIndices()
	};
	this.sendNodeBackward = function(e) {
		var d = [];
		var b = this.data.nodeIndices[e.id];
		if (b > 0) {
			for (var c = 0; c < b - 1; c++) {
				d.push(this.data.nodes[c])
			}
			d.push(this.data.nodes[b]);
			d.push(this.data.nodes[b - 1]);
			for (var c = b + 1; c < this.data.nodes.length; c++) {
				d.push(this.data.nodes[c])
			}
			this.data.nodes = d;
			this.setNodeIndices()
		}
	};
	this.bringNodeToFront = function(d) {
		var c = [];
		for (var b = 0; b < this.data.nodes.length; b++) {
			if (this.data.nodes[b].id != d.id) {
				c.push(this.data.nodes[b])
			}
		}
		c.push(d);
		this.data.nodes = c;
		this.setNodeIndices()
	};
	this.bringNodeForward = function(e) {
		var d = [];
		var b = this.data.nodeIndices[e.id];
		if (this.data.nodes.length - 1 > b) {
			for (var c = 0; c < b; c++) {
				d.push(this.data.nodes[c])
			}
			d.push(this.data.nodes[b + 1]);
			d.push(this.data.nodes[b]);
			for (var c = b + 2; c < this.data.nodes.length; c++) {
				d.push(this.data.nodes[c])
			}
			this.data.nodes = d;
			this.setNodeIndices()
		}
	};
	this.flashNode = function(j, e, b) {
		j = this.toArray(j);
		var q = (this.maxX - this.minX) / this.scaleFactor;
		var n = (this.maxY - this.minY) / this.scaleFactor;
		var d = 0.015;
		for (var k = 0; k < j.length; k++) {
			var c = j[k];
			var f = this.data.nodes[this.data.nodeIndices[c]];
			var p = f.width ? f.width : f.size ? f.size : this.nodeSize;
			var m = f.height ? f.height : f.size ? f.size : this.nodeSize;
			var l = (p < d * q ? d * q : p) * 1.35;
			var o = (m < d * n ? d * n : m) * 1.35;
			var g = this.adjustNetworkObjects(["circle", f.x, f.y, 1]);
			this.flash(g[1], g[2], l * this.scaleFactor, o * this.scaleFactor, e || this.nodeHighlightColor, b)
		}
	};
	this.highlightNodes = function(b) {
		this.functionCaller = "highlightNodes";
		if (this.isArray(b)) {
			this.highlightNode = this.highlightNode.concat(b)
		} else {
			this.highlightNode.push(b)
		}
		this.draw()
	};
	this.unHighlightNodes = function(b) {
		this.functionCaller = "unHighlightNodes";
		var e = [];
		b = this.toArray(b);
		for (var d = 0; d < this.highlightNode.length; d++) {
			var f = false;
			for (var c = 0; c < b.length; c++) {
				if (this.highlightNode[d] == b[c]) {
					f = true;
					break
				}
			}
			if (!f) {
				e.push(this.highlightNode[d])
			}
		}
		this.highlightNode = e;
		this.draw()
	};
	this.addToNetworkStack = function() {
		if (this.networkStack.length >= this.networkStackStates) {
			this.networkStack.shift()
		}
		this.networkStackIndex = this.networkStack.length;
		this.networkStack.push(this.cloneObject(this.data));
		if (this.userEvents.stackchange) {
			this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
		}
	};
	this.undoNetworkOp = function() {
		if (this.canNetworkUndoOp()) {
			this.networkStackIndex--;
			this.nodes = {};
			this.updateData(this.networkStack[this.networkStackIndex]);
			if (this.userEvents.stackchange) {
				this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
			}
		} else {
			if (this.debug) {
				alert("No data in Undo Stack")
			}
		}
	};
	this.canNetworkUndoOp = function() {
		return this.networkStackIndex > 0 ? true : false
	};
	this.redoNetworkOp = function() {
		if (this.canNetworkRedoOp()) {
			this.networkStackIndex++;
			this.nodes = {};
			this.updateData(this.networkStack[this.networkStackIndex]);
			if (this.userEvents.stackchange) {
				this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
			}
		} else {
			if (this.debug) {
				alert("No data in Redo Stack")
			}
		}
	};
	this.canNetworkRedoOp = function() {
		return this.networkStackIndex < this.networkStack.length - 1 ? true : false
	};
	this.clearNetworkStack = function() {
		this.stackNumber = false;
		this.networkStackIndex = 0;
		this.networkStack = [];
		if (this.userEvents.stackchange) {
			this.userEvents.stackchange.call(this, this.networkStackIndex, this.networkStack.length)
		}
	};
	this.addLegend = function(b, e, d) {
		this.inititalizeNetworkLegend();
		if (b && e) {
			if (d && b == "text") {
				var c = this.findXYCoordinates(d);
				e.x = c.x;
				e.y = c.y
			}
			this.data.legend[b].push(e);
			return e
		}
	};
	this.deleteLegend = function(d, e) {
		if (d && e && e.id) {
			var c = [];
			for (var b = 0; b < this.data.legend[d].length; b++) {
				if (this.data.legend[d][b].id != e.id) {
					c.push(this.data.legend[d][b])
				}
			}
			this.data.legend[d] = c;
			delete(this.data.legend.ids[d][e.id])
		}
	};
	this.alignDistributeSelectedNodes = function(k, d, p) {
		this.functionCaller = "alignDistributeSelectedNodes";
		var g, b, j, t, h;
		var l = this.getSelectedNodeCoordinates();
		if (l || d == 89 || d == 90) {
			if (k) {
				this.cancelEvent(k);
				this.stopEvent(k)
			}
			if (d == 84) {
				g = this.min(l.y);
				for (var h in this.selectNode) {
					var f = this.data.nodes[this.data.nodeIndices[h]];
					this.modifyXYNode(f.id, 0, f.y - g)
				}
			} else {
				if (d == 82) {
					g = this.max(l.x);
					for (var h in this.selectNode) {
						var f = this.data.nodes[this.data.nodeIndices[h]];
						this.modifyXYNode(f.id, f.x - g, 0)
					}
				} else {
					if (d == 66) {
						g = this.max(l.y);
						for (var h in this.selectNode) {
							var f = this.data.nodes[this.data.nodeIndices[h]];
							this.modifyXYNode(f.id, 0, f.y - g)
						}
					} else {
						if (d == 76) {
							g = this.min(l.x);
							for (var h in this.selectNode) {
								var f = this.data.nodes[this.data.nodeIndices[h]];
								this.modifyXYNode(f.id, f.x - g, 0)
							}
						} else {
							if (d == 86) {
								b = this.range(l.y);
								j = this.rank(l.y);
								t = (b[1] - b[0]) / (this.isSelectNodes - 1);
								g = b[0];
								for (var q = 0; q < j.length; q++) {
									h = l.i[j[q]];
									var f = this.data.nodes[this.data.nodeIndices[h]];
									this.modifyXYNode(f.id, 0, f.y - (g + (q * t)))
								}
							} else {
								if (d == 72) {
									b = this.range(l.x);
									j = this.rank(l.x);
									t = (b[1] - b[0]) / (this.isSelectNodes - 1);
									g = b[0];
									for (var q = 0; q < j.length; q++) {
										h = l.i[j[q]];
										var f = this.data.nodes[this.data.nodeIndices[h]];
										this.modifyXYNode(f.id, f.x - (g + (q * t)), 0)
									}
								} else {
									if (d == 90) {
										if (k.shiftKey || p) {
											if (this.canNetworkRedoOp()) {
												this.resetSelectedNodes();
												this.redoNetworkOp()
											}
										} else {
											if (this.canNetworkUndoOp()) {
												this.resetSelectedNodes();
												this.undoNetworkOp()
											}
										}
										return false
									}
								}
							}
						}
					}
				}
			}
			this.draw(false, false, false, true);
			this.addToNetworkStack()
		}
		return false
	};
	this.getSelectedNodeCoordinates = function() {
		var f = {
			x: [],
			y: [],
			i: []
		};
		var b = false;
		for (var d in this.selectNode) {
			var e = this.data.nodes[this.data.nodeIndices[d]];
			f.x.push(e.x);
			f.y.push(e.y);
			f.i.push(d);
			b = true
		}
		return b ? f : false
	};
	this.findNodesBy = function(h) {
		var b = [];
		var l = 0;
		for (var d in h) {
			h[d] = this.toArray(h[d]);
			l++
		}
		for (var k = 0; k < this.data.nodes.length; k++) {
			var e = this.data.nodes[k];
			var f = 0;
			for (var d in h) {
				var o = h[d];
				for (var g = 0; g < o.length; g++) {
					if (e[d] && e[d] == o[g]) {
						f++
					}
				}
			}
			if (f == l) {
				b.push(e)
			}
		}
		return b
	};
	this.setNetworkDimensions = function() {
		this.left = 0;
		this.top = this.getTitleSubtitleHeight();
		this.x = this.width;
		this.y = this.height - this.top
	};
	this.setNetworkPrivateParams = function(b) {
		if (this.data.nodes.length > 0) {
			this.layoutDone = false;
			this.left = 0;
			this.top = this.getTitleSubtitleHeight();
			this.x = this.width;
			this.y = this.height - this.top;
			if (this.networkLayoutType == "radial") {
				this.networkXCenter = this.x / 2;
				this.networkYCenter = this.y / 2
			} else {
				this.set3DParams();
				this.area = this.x * this.y;
				if (this.networkForceConstant != null && this.networkForceConstantOriginal != null) {
					this.networkForceConstantOriginal = this.networkForceConstant
				}
				if (this.temperature != null && this.temperatureOriginal != null) {
					this.temperatureOriginal = this.temperature
				}
				if (this.initialTemperature != null && this.initialTemperatureOriginal != null) {
					this.initialTemperatureOriginal = this.initialTemperature
				}
				this.networkForceConstant = this.networkForceConstant ? this.networkForceConstant : Math.sqrt(this.area / (b ? b.i.length : this.data.nodes.length));
				this.temperature = this.temperature ? this.temperature : (b ? b.i.length : this.data.nodes.length) + Math.floor(Math.sqrt(b ? b.e.length : this.data.edges.length));
				this.minimumTemperature = 1;
				this.initialTemperature = this.initialTemperature ? this.initialTemperature : this.temperature;
				this.iteration = 0;
				if (this.networkForceConstant < 0.001) {
					this.networkForceConstant = 0.001
				}
			}
			if (this.x <= 400 || this.y <= 400) {
				this.nodeFont = (this.nodeSize - 6) + "px " + this.fontName;
				this.showAnimationFont = this.nodeFont + "px " + this.fontName
			}
		} else {
			this.layoutDone = true
		}
	};
	this.networkContains = function(b, c) {
		return this.findNode(b, c) != null
	};
	this.findNode = function(c, e) {
		for (var d in c) {
			var b = c[d];
			if (e.call(b)) {
				return b
			}
		}
		return null
	};
	this.filterEdges = function(c, f) {
		var e = [];
		for (var d in c) {
			var b = c[d];
			if (f.call(b)) {
				e.push(b)
			}
		}
		return e
	};
	this.reduceNetwork = function(b, f, d) {
		var e = null;
		for (var c in b) {
			if (e == null) {
				if (d) {
					e = d.apply(d, [b[c]])
				} else {
					e = b[c]
				}
			} else {
				e = f.apply(b[c], [e, b[c]])
			}
		}
		return e
	};
	this.vectorDifference = function(e, d) {
		var c = e.x - d.x;
		var g = e.y - d.y;
		var f = e.z - d.z;
		if (c == 0) {
			c = 0.01 + this.random()
		}
		if (g == 0) {
			g = 0.01 + this.random()
		}
		if (this.is3DNetwork) {
			if (f == 0) {
				f = 0.01 + this.random()
			}
		}
		return {
			x: c,
			y: g,
			z: f
		}
	};
	this.vectorMagnitude = function(c) {
		var b;
		if (this.is3DNetwork) {
			b = Math.sqrt((c.x * c.x) + (c.y * c.y) + (c.z * c.z))
		} else {
			b = Math.sqrt((c.x * c.x) + (c.y * c.y))
		}
		return isNaN(b) ? 0 : b
	};
	this.normalizeGraph = function(j) {
		var h = [];
		var b = {};
		var k = this;
		for (var f in j.nodes) {
			if (!b.hasOwnProperty(j.nodes[f].id)) {
				var e = j.nodes[f];
				var d = [];
				b[e.id] = 1;
				if (!this.networkContains(d, function() {
						return k.networkContains(this.nodes, function() {
							return this.id = e.id
						})
					})) {
					var c = {};
					c.nodes = [];
					c.edges = [];
					this.addNodeToGraph(e, c, j);
					if (c.nodes.length > 0) {
						h.push(c)
					}
					for (var g = 0; g < c.nodes.length; g++) {
						b[c.nodes[g].id] = 1
					}
				}
			}
		}
		return h
	};
	this.addNodeToGraph = function(d, f, e) {
		if (this.findNodeForId(d.id, f) == null) {
			f.nodes.push(d);
			var b = this.edgesForNode(e.edges, d.id);
			for (edgeIndex in b) {
				var c = b[edgeIndex];
				f.edges.push(c);
				if (c.id1 == d.id) {
					this.addNodeToGraph(this.findNodeForId(c.id2, e), f, e)
				} else {
					this.addNodeToGraph(this.findNodeForId(c.id1, e), f, e)
				}
			}
		}
	};
	this.findNodeForId = function(c, b) {
		return this.findNode(b.nodes, function() {
			return c == this.id
		})
	};
	this.edgesForNode = function(b, c) {
		return this.filterEdges(b, function(d) {
			return (this.id1 == c || this.id2 == c)
		})
	};
	this.attractiveForce = function(b, c) {
		switch (this.attractiveForceFunction) {
			case "FruchtermanReingold":
				return (b * b) / c;
			case "Eades":
				return c * Math.log(b)
		}
	};
	this.repulsiveForce = function(b, c) {
		return (c * c) / b
	};
	this.storePositions = function() {
		var e = {};
		for (var c = 0; c < this.data.nodes.length; c++) {
			var d = this.data.nodes[c];
			if (!d.hide && !d.hiddenParent) {
				var b = {
					x: d.x,
					y: d.y,
					z: d.z
				};
				e[d.id] = b
			}
		}
		return e
	};
	this.calculateRepulsiveDisplacement = function(e) {
		var d = this;
		var b = function(l, s, h) {
			var r = h * h;
			for (var p = 0; p < s.length; p++) {
				var v = d.data.nodes[d.data.nodeIndices[s[p]]];
				var o = l[v.id];
				for (var n = 0; n < s.length; n++) {
					if (p != n) {
						var u = d.data.nodes[d.data.nodeIndices[s[n]]];
						var g = l[u.id];
						if (!v.hide && !v.hiddenParent && !u.hide && !u.hiddenParent) {
							var t = d.vectorDifference(v, u);
							var f = d.networkLayoutType == "organic" ? Math.max(d.vectorMagnitude(t) - (d.nodeSize * 2), d.networkNodeMinDistance) : d.vectorMagnitude(t);
							var q = r / f;
							if (!v.fixed) {
								o.x += (t.x / f) * q;
								o.y += (t.y / f) * q;
								o.z += (t.z / f) * q
							}
							if (!u.fixed && d.networkLayoutType == "organic") {
								g.x -= (t.x / f) * q;
								g.y -= (t.y / f) * q;
								g.z -= (t.z / f) * q
							}
						}
					}
				}
			}
		};
		if (this.subNetworks) {
			for (var c = 0; c < this.subNetworks.length; c++) {
				b(e[c], this.subNetworks[c].nodes, this.subNetworks[c].networkForceConstant)
			}
		} else {
			b(e, this.getKeys(this.data.nodeIndices), this.networkForceConstant)
		}
	};
	this.calculateAttractiveDisplacement = function(e) {
		var d = this;
		var b = function(p, o, h) {
			for (var j = 0; j < o.length; j++) {
				var l = o[j];
				if (!d.nodes || !d.nodes[l.id1] || !d.nodes[l.id2]) {
					alert('Nodes "' + l.id1 + '" and/or "' + l.id2 + '" are missing!');
					return
				}
				if (d.nodes && !d.nodes[l.id1].hide && !d.nodes[l.id2].hide && !d.nodes[l.id1].hiddenParent && !d.nodes[l.id2].hiddenParent) {
					var n = d.vectorDifference(d.nodes[l.id1], d.nodes[l.id2]);
					var f = d.networkLayoutType == "organic" ? Math.max(d.vectorMagnitude(n) - (d.nodeSize * 2), d.networkNodeMinDistance) : Math.max(d.vectorMagnitude(n), d.networkNodeMinDistance);
					var g = d.attractiveForce(f, h);
					if (!d.nodes[l.id1].fixed) {
						p[l.id1].x -= (n.x / f) * g;
						p[l.id1].y -= (n.y / f) * g;
						p[l.id1].z -= (n.z / f) * g
					}
					if (!d.nodes[l.id2].fixed) {
						p[l.id2].x += (n.x / f) * g;
						p[l.id2].y += (n.y / f) * g;
						p[l.id2].z += (n.z / f) * g
					}
				}
			}
		};
		if (this.subNetworks) {
			for (var c = 0; c < this.subNetworks.length; c++) {
				b(e[c], this.subNetworks[c].edges, this.subNetworks[c].networkForceConstant)
			}
		} else {
			b(e, this.data.edges, this.networkForceConstant)
		}
	};
	this.applyDisplacement = function(e) {
		var d = this;
		var c = function(j, g) {
			for (var k in j) {
				var h = d.nodes[k];
				if (!h.hide && !h.fixed) {
					var i = j[k];
					var f = Math.max(d.vectorMagnitude(i), 0.001);
					h.x += (i.x / f) * Math.min(g, Math.abs(i.x));
					h.y += (i.y / f) * Math.min(g, Math.abs(i.y));
					h.z += (i.z / f) * Math.min(g, Math.abs(i.z))
				}
			}
		};
		if (this.nodes) {
			if (this.subNetworks) {
				for (var b = 0; b < this.subNetworks.length; b++) {
					c(e[b], this.subNetworks[b].temperature)
				}
			} else {
				c(e, this.temperature)
			}
		}
	};
	this.isLayoutDone = function() {
		var f = this;
		var e = this.storePositions();
		var g = 0;
		var c = 0;
		var b = function(h, l) {
			var w = 0;
			var m = 0;
			var r = {
				x: Number.MAX_VALUE,
				y: Number.MAX_VALUE
			};
			var v = {
				x: Number.MAX_VALUE * -1,
				y: Number.MAX_VALUE * -1
			};
			for (var s = 0; s < h.length; s++) {
				var q = f.data.nodes[f.data.nodeIndices[h[s]]];
				if (!q.hide && !q.hiddenParent && !q.fixed) {
					var k = e[q.id];
					r.x = Math.min(r.x, k.x);
					r.y = Math.min(r.y, k.y);
					r.z = Math.min(r.z, k.z);
					v.x = Math.max(v.x, k.x);
					v.y = Math.max(v.y, k.y);
					v.z = Math.max(v.z, k.z);
					w += Math.abs(f.vectorMagnitude(f.vectorDifference(f.previousNodePositions[q.id], k)));
					m++
				}
			}
			var u = w / m;
			var t = Math.abs(f.vectorMagnitude(f.vectorDifference(r, v)));
			var j = Math.abs(f.vectorMagnitude({
				x: l.x,
				y: l.y,
				z: parseInt((l.x + l.y) / 2)
			}));
			l.minimumTemperature = t / j;
			l.layoutDone = u < l.minimumTemperature;
			if (l.layoutDone) {
				c++
			}
			if (l.initialProgress == null && l.temperature <= l.minimumTemperature) {
				l.initialProgress = u - (l.minimumTemperature / 2)
			}
			if (l.initialProgress != null) {
				l.layoutProgress = Math.max(l.layoutProgress, 1 - ((u - (l.minimumTemperature / 2)) / l.initialProgress))
			}
			g += l.layoutProgress
		};
		if (this.subNetworks) {
			for (var d = 0; d < this.subNetworks.length; d++) {
				b(this.subNetworks[d].nodes, this.subNetworks[d])
			}
			this.layoutProgress = g / this.subNetworks.length;
			this.layoutDone = c == this.subNetworks.length ? true : false
		} else {
			b(this.getKeys(this.data.nodeIndices), this)
		}
		this.previousNodePositions = e
	};
	this.setInitialForceDirectedLayout = function() {
		var d = this;
		var b = function(j, e, h) {
			for (var f = 0; f < j.length; f++) {
				var g = d.data.nodes[d.data.nodeIndices[j[f]]];
				if (!g.hide && !g.hiddenParent) {
					g.x = Math.floor(d.random() * e);
					g.y = Math.floor(d.random() * h);
					g.z = d.is3DNetwork ? Math.floor(d.random() * parseInt((e + h) / 2)) : 0
				}
			}
		};
		this.layoutProgress = 0;
		if (this.subNetworks) {
			for (var c = 0; c < this.subNetworks.length; c++) {
				b(this.subNetworks[c].nodes, this.subNetworks[c].x, this.subNetworks[c].y)
			}
		} else {
			b(this.getKeys(this.data.nodeIndices), this.x, this.y)
		}
		this.previousNodePositions = this.storePositions()
	};
	this.setInitialNodeDisplacement = function() {
		var d = this.subNetworks ? [] : {};
		if (this.subNetworks) {
			for (var c = 0; c < this.subNetworks.length; c++) {
				d[c] = {};
				for (var b = 0; b < this.subNetworks[c].nodes.length; b++) {
					d[c][this.subNetworks[c].nodes[b]] = {
						x: 0,
						y: 0,
						z: 0
					}
				}
			}
		} else {
			for (var c = 0; c < this.data.nodes.length; c++) {
				if (!this.data.nodes[c].hide && !this.data.nodes[c].hiddenParent) {
					d[this.data.nodes[c].id] = {
						x: 0,
						y: 0,
						z: 0
					}
				}
			}
		}
		return d
	};
	this.updateForceDirectedLayout = function(d) {
		var f = new Date().getTime();
		var c = f;
		if (this.data.edges.length > 1) {
			if (!this.layoutDone) {
				while (c - f < d) {
					var e = this.setInitialNodeDisplacement();
					this.calculateRepulsiveDisplacement(e);
					this.calculateAttractiveDisplacement(e);
					this.applyDisplacement(e);
					if (this.subNetworks) {
						for (var b = 0; b < this.subNetworks.length; b++) {
							this.subNetworks[b].temperature = Math.max(this.subNetworks[b].temperature - (this.subNetworks[b].initialTemperature / 100), this.subNetworks[b].minimumTemperature)
						}
					} else {
						this.temperature = Math.max(this.temperature - (this.initialTemperature / 100), this.minimumTemperature)
					}
					this.isLayoutDone();
					this.iteration++;
					c = new Date().getTime()
				}
			}
		} else {
			this.layoutDone = true
		}
		return this.layoutDone
	};
	this.renderNetwork = function() {
		this.setNetworkRotation();
		this.resizeCanvas();
		if (!this.layoutDone && !this.showAnimation) {
			this.drawNetworkProgressBar(true);
			return
		}
		if (this.data.nodes.length > 0) {
			if (this.layoutDone) {
				this.setXYNodePrecision()
			}
			this.setNetworkMinMaxRangeXY();
			this.setNetworkScaleFactor();
			if (this.scaleFactor) {
				if (this.showAnimation) {
					if (this.preScaleNetwork) {
						this.centerNetwork();
						this.drawNetworkNodes(true);
						if (this.networkNodesOnTop) {
							this.drawNetworkEdges();
							this.drawNetworkNodes()
						} else {
							this.drawNetworkNodes();
							this.drawNetworkEdges()
						}
						this.drawNetworkCommunitiesConvexHulls();
						if (this.layoutDone) {
							this.drawNetworkLegend()
						}
					} else {
						this.scaleCanvas(this.scaleFactor, this.scaleFactor);
						this.translateCanvas(this.offsetX, this.offsetY);
						this.drawNetworkNodes(true);
						if (this.networkNodesOnTop) {
							this.drawNetworkEdges();
							this.drawNetworkNodes()
						} else {
							this.drawNetworkNodes();
							this.drawNetworkEdges()
						}
						this.drawNetworkCommunitiesConvexHulls();
						if (this.layoutDone) {
							this.drawNetworkDecorations();
							this.drawNetworkLegend()
						}
						this.translateCanvas(-this.offsetX, -this.offsetY);
						this.scaleCanvas(1 / this.scaleFactor, 1 / this.scaleFactor)
					}
					this.drawCitation();
					this.drawNetworkColorIndicator();
					this.drawTitle();
					this.drawCanvasBox(true)
				} else {
					this.drawCitation();
					this.drawNetworkColorIndicator();
					this.drawTitle();
					this.drawCanvasBox(true);
					if (this.preScaleNetwork) {
						this.centerNetwork()
					} else {
						this.scaleCanvas(this.scaleFactor, this.scaleFactor);
						this.translateCanvas(this.offsetX, this.offsetY)
					}
					if (this.networkNodesOnTop) {
						this.drawNetworkEdges();
						this.drawNetworkNodes()
					} else {
						this.drawNetworkNodes();
						this.drawNetworkEdges()
					}
					this.drawNetworkCommunitiesConvexHulls();
					if (this.layoutDone) {
						this.drawNetworkDecorations();
						this.drawNetworkLegend()
					}
				}
				this.drawNetworkProgressBar()
			}
		}
	};
	this.reRootRadialNetwork = function(f) {
		this.functionCaller = "reRootRadialNetwork";
		var e = this.data.nodes[f].id;
		this.networkCurrentAngle = this.getAngle(this.finalRadialNodePositions[e].x, this.finalRadialNodePositions[e].y, this.finalRadialNodePositions[this.networkRoot].x, this.finalRadialNodePositions[this.networkRoot].y, 0) + 180;
		this.orderRadialNetwork = {};
		var c = this.data.nodeIndices[e];
		var d = 0;
		for (var b = c; b < this.data.nodes.length; b++) {
			this.orderRadialNetwork[this.data.nodes[b].id] = d;
			d++
		}
		for (var b = 0; b < c; b++) {
			this.orderRadialNetwork[this.data.nodes[b].id] = d;
			d++
		}
		this.networkXCenter = this.finalRadialNodePositions[e].x;
		this.networkYCenter = this.finalRadialNodePositions[e].y;
		this.networkRoot = e;
		this.layoutDone = false;
		this.draw()
	};
	this.renderRadialLayout = function() {
		this.scaleCanvas(this.scaleFactor, this.scaleFactor);
		this.translateCanvas(this.offsetX, this.offsetY);
		var b = this.data.nodes[this.data.nodeIndices[this.networkRoot]];
		for (var c = 1; c < this.networkDepth; c++) {
			this.drawShape("circle", b.x, b.y, c * this.networkLevelSize * 2, c * this.networkLevelSize * 2, this.background, this.infoAreaColor, "open")
		}
	};
	this.centerNetwork = function() {
		for (var b = 0; b < this.data.nodes.length; b++) {
			var c = this.data.nodes[b];
			if (!c.hide && !c.hiddenParent) {
				c.x = (this.offsetX + c.x) * this.scaleFactor;
				c.y = (this.offsetY + c.y) * this.scaleFactor
			}
		}
		this.scaleFactor = 0.9;
		this.offsetX = this.x * 0.05;
		this.offsetY = this.y * 0.05
	};
	this.setXYNodePrecision = function() {
		if (this.approximateNodePositions) {
			for (var b = 0; b < this.data.nodes.length; b++) {
				var c = this.data.nodes[b];
				if (c.x) {
					c.x = parseInt(c.x);
					this.nodes[c.id].x = c.x
				}
				if (c.y) {
					c.y = parseInt(c.y);
					this.nodes[c.id].y = c.y
				}
				if (c.z) {
					c.z = parseInt(c.z);
					this.nodes[c.id].z = c.z
				}
			}
		}
	};
	this.getLengthToNodeBoundary = function(d, j, c, i, f, e) {
		if (f) {
			var h = f.size ? f.size : 1;
			var b = e && f.height ? f.height : f.width ? f.width : this.nodeSize * h;
			var g = e && f.width ? f.width : f.height ? f.height : this.nodeSize * h;
			var k = this.clip("line", [d, j, c, i], [d - (b / 2), j - (g / 2), b, g]);
			return this.lineLength(k[0], k[1], k[2], k[3]) + (this.margin * 2)
		} else {
			return this.margin * 2
		}
	};
	this.drawNetworkEdges = function() {
		if (this.nodes) {
			var b = {};
			var c = 1;
			var g = this.foreground;
			for (var v = 0; v < this.data.edges.length; v++) {
				var h = this.data.edges[v];
				var t = this.nodes[h.id1];
				var s = this.nodes[h.id2];
				var z = false;
				if (!t.hide && !t.hiddenParent && !s.hide && !s.hiddenParent && !h.anchor) {
					z = true
				} else {
					if (this.showHiddenChildEdges) {
						if (t.hide || t.hiddenParent || (t.parentNode && this.nodes[t.parentNode].hideChildren)) {
							t = this.findVisibleParentNode(h.id1);
							if (t) {
								z = true
							}
						}
						if (s.hide || s.hiddenParent || (s.parentNode && this.nodes[s.parentNode].hideChildren)) {
							s = this.findVisibleParentNode(h.id2);
							if (s) {
								z = true
							}
						}
					}
				}
				var B = t.id + ":" + s.id;
				if (z && !h.hide) {
					if (!b.hasOwnProperty(B)) {
						var d = this.selectNode.hasOwnProperty(t.id) && this.selectNode.hasOwnProperty(s.id) ? this.nodeHighlightColor : h.color ? h.color : g;
						var l = h.width ? h.width : this.edgeWidth;
						var k = h.cap ? h.cap : false;
						var e = h.exact ? h.exact : false;
						var o, m, x, w;
						if (this.is3DNetwork) {
							o = t.x3d;
							m = t.y3d;
							x = s.x3d;
							w = s.y3d
						} else {
							o = t.x;
							m = t.y;
							x = s.x;
							w = s.y
						}
						var n = h.type ? h.type : "line";
						var r = n.match(/curved/) ? true : false;
						var A = e ? 0 : h.elbows && h.elbows.length > 0 ? this.getLengthToNodeBoundary(o, m, h.elbows[0][0], h.elbows[0][1], t, r) : this.getLengthToNodeBoundary(o, m, x, w, t, r);
						var f = e ? 0 : h.elbows && h.elbows.length > 0 ? this.getLengthToNodeBoundary(x, w, h.elbows[h.elbows.length - 1][0], h.elbows[h.elbows.length - 1][1], s, r) : this.getLengthToNodeBoundary(x, w, o, m, s, r);
						var y = this.drawLine(n, o, m, x, w, d, l / this.zoom, k, Math.max(0, A / this.zoom / 1.25), Math.max(0, f / this.zoom / 1.25), false, false, h.elbows);
						if (this.layoutDone && !this.isAnimation) {
							if (this.preScaleNetwork) {
								if (h.elbows) {
									var p = h.elbows;
									for (var u = 0; u < y.length; u++) {
										this.addArea(y[u], [v + this.data.nodes.length])
									}
									for (var u = 0; u < p.length; u++) {
										this.addArea(["rect", p[u][0] - 2, p[u][1] - 2, p[u][0] + 2, p[u][1] + 2], [v + this.data.nodes.length, u], "-elbow")
									}
								} else {
									this.addArea(y, [v + this.data.nodes.length])
								}
							} else {
								if (h.elbows) {
									var p = h.elbows;
									for (var u = 0; u < y.length; u++) {
										this.addArea(this.adjustNetworkObjects(y[u]), [v + this.data.nodes.length])
									}
									for (var u = 0; u < p.length; u++) {
										this.addArea(this.adjustNetworkObjects(["rect", p[u][0] - 2, p[u][1] - 2, p[u][0] + 2, p[u][1] + 2]), [v + this.data.nodes.length, u], "-elbow")
									}
								} else {
									this.addArea(this.adjustNetworkObjects(y), [v + this.data.nodes.length])
								}
							}
							c++
						}
						b[B] = 1
					}
				}
			}
		}
	};
	this.drawNetworkSelectionNodePoint = function(v, p, o, q, A, s, n) {
		var m, g, e, c, B, d, b, D, t, k, j, C, f, l, u;
		this.drawShape("rect", p, o, q, A, this.nodeHighlightColor, this.foreground, "open", s, false, false, false, false, false, false, n);
		if (s) {
			l = Math.cos(s);
			u = Math.sin(s);
			k = -(u * ((-A / 2) - 10));
			j = (l * ((-A / 2) - 10));
			C = -(u * (-A / 2));
			f = (l * (-A / 2));
			this.drawLine("line", k + p, j + o, C + p, f + o, this.foreground);
			k = -(u * ((-A / 2) - 10));
			j = (l * ((-A / 2) - 10));
			m = this.drawShape("rect", k + p, j + o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			k = (l * (-q / 2)) - (u * (-A / 2));
			j = (l * (-A / 2)) + (u * (-q / 2));
			g = this.drawShape("rect", k + p, j + o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			k = -(u * (-A / 2));
			j = (l * (-A / 2));
			e = this.drawShape("rect", k + p, j + o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			k = (l * (q / 2)) - (u * (-A / 2));
			j = (l * (-A / 2)) + (u * (q / 2));
			c = this.drawShape("rect", k + p, j + o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			k = (l * (-q / 2));
			j = (u * (-q / 2));
			B = this.drawShape("rect", k + p, j + o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			k = (l * (-q / 2)) - (u * (A / 2));
			j = (l * (A / 2)) + (u * (-q / 2));
			d = this.drawShape("rect", k + p, j + o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			k = -(u * (A / 2));
			j = (l * (A / 2));
			b = this.drawShape("rect", k + p, j + o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			k = (l * (q / 2)) - (u * (A / 2));
			j = (l * (A / 2)) + (u * (q / 2));
			D = this.drawShape("rect", k + p, j + o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			k = (l * (q / 2));
			j = (u * (q / 2));
			t = this.drawShape("rect", k + p, j + o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n)
		} else {
			this.drawLine("line", p, o - ((A / 2) + 10), p, o - (A / 2), this.foreground);
			m = this.drawShape("rect", p, o - ((A / 2) + 10), this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			g = this.drawShape("rect", p - (q / 2), o - (A / 2), this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			e = this.drawShape("rect", p, o - (A / 2), this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			c = this.drawShape("rect", p + (q / 2), o - (A / 2), this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			B = this.drawShape("rect", p - (q / 2), o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			d = this.drawShape("rect", p - (q / 2), o + (A / 2), this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			b = this.drawShape("rect", p, o + (A / 2), this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			D = this.drawShape("rect", p + (q / 2), o + (A / 2), this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n);
			t = this.drawShape("rect", p + (q / 2), o, this.margin, this.margin, this.nodeHighlightColor, this.foreground, "closed", s, false, false, false, false, false, false, n)
		}
		if (this.preScaleNetwork) {
			this.addArea(m, [v], "-resizeROT");
			this.addArea(g, [v], "-resizeTL");
			this.addArea(e, [v], "-resizeTM");
			this.addArea(c, [v], "-resizeTR");
			this.addArea(B, [v], "-resizeML");
			this.addArea(d, [v], "-resizeBL");
			this.addArea(b, [v], "-resizeBM");
			this.addArea(D, [v], "-resizeBR");
			this.addArea(t, [v], "-resizeMR")
		} else {
			this.addArea(this.adjustNetworkObjects(m), [v], "-resizeROT");
			this.addArea(this.adjustNetworkObjects(g), [v], "-resizeTL");
			this.addArea(this.adjustNetworkObjects(e), [v], "-resizeTM");
			this.addArea(this.adjustNetworkObjects(c), [v], "-resizeTR");
			this.addArea(this.adjustNetworkObjects(B), [v], "-resizeML");
			this.addArea(this.adjustNetworkObjects(d), [v], "-resizeBL");
			this.addArea(this.adjustNetworkObjects(b), [v], "-resizeBM");
			this.addArea(this.adjustNetworkObjects(D), [v], "-resizeBR");
			this.addArea(this.adjustNetworkObjects(t), [v], "-resizeMR")
		}
	};
	this.drawNetworkNodeLabel = function(g, j, b, p, m) {
		var f, d;
		var n = this.labelNodePosition == "auto" ? "center" : this.labelNodePosition;
		var o = g.label ? g.label : g.name ? g.name : g.id;
		var i = this.getNodeColor(g.id, g.labelColor);
		var r = g.labelSize ? this.nodeFontSize * g.labelSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
		var e = this.nodeFontStyle + " " + Math.min(Math.max((parseInt(r / this.zoom * 1.25)), this.minTextSize), this.maxTextSize) + "px " + this.fontName;
		var c = this.measureText(o, e);
		var q = r;
		if (g.labelX != null && g.labelY != null) {
			f = g.labelX;
			d = g.labelY;
			this.drawText(o, g.labelX, g.labelY, e, i, "center", "middle")
		} else {
			var k = this.isMultipleLines(o);
			var l = parseInt(r) + 4;
			if (k) {
				if (k % 2) {
					b += (parseInt(k / 2) * l) + (l / 2)
				} else {
					b = (b + parseInt(k / 2) * l)
				}
			}
			if (g.labelPosition) {
				n = g.labelPosition
			}
			switch (n) {
				case "top":
					f = j - (c / 2);
					d = b - ((m / 2) + this.margin + (q / 2));
					this.drawText(o, j, d, e, i, "center", "middle");
					g.labelXi = j;
					g.labelYi = d;
					break;
				case "bottom":
					f = j - (c / 2);
					d = b + ((m / 2) + this.margin + (q / 2));
					this.drawText(o, j, d, e, i, "center", "middle");
					g.labelXi = j;
					g.labelYi = d;
					break;
				case "right":
					f = j + ((p / 2) + this.margin + (c / 2));
					d = b - (q / 2);
					this.drawText(o, f, b, e, i, "center", "middle");
					g.labelXi = f;
					g.labelYi = b;
					break;
				case "left":
					f = j - ((p / 2) + this.margin + (c / 2));
					d = b - (q / 2);
					this.drawText(o, f, b, e, i, "center", "middle");
					g.labelXi = f;
					g.labelYi = b;
					break;
				case "center":
					this.drawText(o, j, b, e, i, "center", "middle");
					g.labelXi = j;
					g.labelYi = b;
					break
			}
		}
		return ["rect", f, d, f + c, d + q]
	};
	this.drawNetworkNodes = function(u) {
		var l = this.data.nodes.length / this.zoom < this.showNodeNameThreshold ? true : false;
		var g = this.foreground;
		var x = this.shapes[0];
		var c = 6001;
		var h = this.rangeX > this.rangeY ? "bottom" : "right";
		var b = this.autoHideOnDecorationsCenter && this.decorationsPosition == "center" && this.decorations.length > 0 ? true : false;
		for (var y = 0; y < this.data.nodes.length; y++) {
			var v = this.data.nodes[y];
			if (u) {
				if (!v.eventless) {
					continue
				}
			} else {
				if (v.eventless) {
					continue
				}
			}
			var j = this.overrideAnchorNodes ? false : v.anchor;
			if (!v.hide && !v.hiddenParent && !j) {
				var o = this.is3DNetwork ? v.x3d : v.x;
				var B = this.is3DNetwork ? v.y3d : v.y;
				var r = v.shape ? v.shape : x;
				var z = v.outline ? v.outline : this.foreground;
				var A = v.size ? v.size : 1;
				var n = v.width ? v.width / this.zoom : this.nodeSize * A / this.zoom;
				var t = v.height ? v.height / this.zoom : this.nodeSize * A / this.zoom;
				var w = this.selectNode.hasOwnProperty(v.id) ? true : false;
				var f = w ? this.nodeHighlightColor : this.colorNodeBy ? v.color : v.communityColor && this.isCoordinateNodeColorsNetworkConvexHull ? v.communityColor : v.gradient && v.color1 && v.color2 && v.color3 ? this.getRadialGradient(o, B, Math.max(n, t) / 2, v.color1, v.color2, v.color3) : v.color ? v.color : g;
				var p = v.pattern ? v.pattern : "closed";
				var k = v.rotate ? v.rotate * Math.PI / 180 : false;
				var s = v.outlineWidth ? v.outlineWidth : false;
				var e = v.imagePath ? v.imagePath : false;
				var d = v.zIndex ? v.zIndex : e ? c : false;
				var q = v.eventless ? false : true;
				var C = this.drawShape(r, o, B, n, t, f, z, p, k, s, false, false, false, false, e, d);
				if (this.layoutDone && !this.isAnimation) {
					if (q || this.overrideEventlessNodes) {
						if (this.preScaleNetwork) {
							this.addArea(C, [y])
						} else {
							this.addArea(this.adjustNetworkObjects(C), [y])
						}
					}
					if (w && !v.fixed) {
						this.drawNetworkSelectionNodePoint(y, o, B, n, t, k, s)
					} else {
						if (w && v.fixed) {
							this.drawNetworkSelectionNodePoint(v, o, B, n, t, k, s)
						}
					}
					if (l && !v.hideLabel) {
						var m = this.drawNetworkNodeLabel(v, o, B, n, t);
						if (q || this.overrideEventlessNodes) {
							if (this.preScaleNetwork && !this.isAnimation) {
								this.addArea(m, [y], "-lab")
							} else {
								this.addArea(this.adjustNetworkObjects(m), [y], "-lab")
							}
						}
					}
				}
				c++
			}
		}
	};
	this.drawNetworkCommunitiesConvexHulls = function() {
		var k, b, q, o, g, m, l;
		if (this.isNetworkConvexHull) {
			for (var f = 0; f < this.networkCommunities; f++) {
				if (this.networkConvexHulls[f]["nodes"]) {
					var d = [];
					var p = [];
					k = this.addColorTransparency(this.colors[f % this.colors.length], 0.2);
					var g = this.getHull(this.networkConvexHulls[f]["nodes"]);
					this.networkConvexHulls[f]["convexHull"] = g[0];
					for (var e = 0; e < g[0].length; e++) {
						d.push(g[0][e][0]);
						p.push(g[0][e][1])
					}
					this.drawShape("hull", d, p, g[2] - g[1], g[4] - g[3], k)
				}
			}
		} else {
			if (this.isNetworkCommunities) {
				this.setNetworkCommunities();
				this.drawNetworkCommunitiesConvexHulls()
			}
		}
	};
	this.drawNetworkDecorations = function() {
		if (this.showDecorations && this.decorations.length > 0) {
			var g = this;
			var x = function() {
				var p = {};
				for (var E = 0; E < g.data.nodes.length; E++) {
					var F = g.data.nodes[E];
					if (!F.hide && !F.hiddenParent && !e) {
						for (var z = 0; z < g.decorations.length; z++) {
							var G = g.decorations[z];
							if (F[G] || (F.decorations && F.decorations[G])) {
								p[E] = true
							}
						}
					}
				}
				return g.getKeys(p).sort(function(j, i) {
					return j - i
				})
			};
			var r = function(z) {
				var G = {
					vals: {}
				};
				for (var F = 0; F < z.length; F++) {
					var H = g.data.nodes[z[F]];
					for (var E = 0; E < g.decorations.length; E++) {
						var J = g.decorations[E];
						var I = H[J] ? H[J] : H.decorations ? H.decorations[J] : false;
						if (g.isObject(I)) {
							G.type = "m";
							for (var p in I) {
								G.vals[p] = true
							}
						} else {
							G.type = "s"
						}
					}
				}
				return G
			};
			var h = function(z, p, M) {
				var K = g.getKeys(p.vals);
				var H = {
					vals: [],
					area: [],
					cols: [],
					col2: [],
					patt: [],
					shpe: [],
					shp2: []
				};
				if (p.type == "m") {
					if (g.decorationsType == "heatmap") {
						for (var I = 0; I < K.length; I++) {
							H.vals[I] = [];
							H.area[I] = [];
							H.patt[I] = []
						}
					} else {
						for (var I = 0; I < g.decorations.length; I++) {
							H.vals[I] = [];
							H.area[I] = [];
							H.patt[I] = [];
							H.cols[I] = []
						}
					}
				}
				for (var I = 0; I < g.decorations.length; I++) {
					var E = g.decorations[I];
					var J = g.decorationsProperties[E] && g.decorationsProperties[E].color ? g.decorationsProperties[E].color : g.decorationsColors[I];
					var O = g.decorationsProperties[E] && g.decorationsProperties[E].shape ? g.decorationsProperties[E].shape : "circle";
					if (p.type == "m") {
						for (var G = 0; G < K.length; G++) {
							var N = z[E] ? z[E][K[G]] : z.decorations && z.decorations[E] ? z.decorations[E][K[G]] : "NA";
							var F = g.decorationsProperties[K[G]] && g.decorationsProperties[K[G]].color ? g.decorationsProperties[K[G]].color : g.decorationsColors[g.decorations.length + G];
							var L = g.decorationsProperties[K[G]] && g.decorationsProperties[K[G]].shape ? g.decorationsProperties[K[G]].shape : "square";
							if (g.decorationsType == "heatmap") {
								H.vals[G].push(N);
								H.area[G].push([M + "-" + I + "-" + K[G]]);
								H.patt[G].push("closed");
								if (I == 0) {
									H.cols.push(F);
									H.shpe.push(L)
								}
							} else {
								if (g.decorationsType.match(/stacked/)) {
									H.vals[I].push(N);
									H.area[I].push([M + "-" + I + "-" + K[G]]);
									H.cols[I].push(F);
									H.patt[I].push("closed")
								}
							}
						}
						H.col2.push(J);
						if (g.decorationsType == "heatmap") {
							H.shp2.push(O)
						} else {
							H.shpe.push(O)
						}
					} else {
						if (!H.vals[0]) {
							H.vals[0] = []
						}
						var N = z[E] ? z[E] : z.decorations && z.decorations[E] ? z.decorations[E] : "NA";
						var J = g.decorationsProperties[E] && g.decorationsProperties[E].color ? g.decorationsProperties[E].color : g.decorationsColors[I];
						var O = g.decorationsProperties[E] && g.decorationsProperties[E].shape ? g.decorationsProperties[E].shape : "circle";
						if (N == "NA") {
							continue
						}
						H.vals[0].push(N);
						H.area.push([M + "-" + I]);
						H.cols.push(J);
						H.patt.push("closed");
						H.shpe.push(O)
					}
				}
				return H
			};
			var o = x();
			var m = r(o);
			var w = this.decorations.length * this.decorationsWidth / 2;
			var f = this.decorationsWidth * 0.7;
			var d = this.decorationsHeight / 2;
			var A = this.getColorBrew(this.colorSpectrum, this.decorationsRange[0], this.decorationsRange[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			for (var t = 0; t < o.length; t++) {
				var q = this.data.nodes[o[t]];
				var C = h(q, m, o[t]);
				var e = this.overrideAnchorNodes ? false : q.anchor;
				if (!q.hide && !q.hiddenParent && !e) {
					var l = this.is3DNetwork ? q.x3d : q.x;
					var u = this.is3DNetwork ? q.y3d : q.y;
					var D = q.size ? this.nodeSize * q.size : this.nodeSize;
					var b = D / 2;
					var v, c;
					if (q.decorationsX != null && q.decorationsY != null) {
						v = q.decorationsX;
						c = q.decorationsY
					} else {
						switch (this.decorationsPosition) {
							case "top":
								v = this.decorationsType == "pie" ? l : l - w;
								if (this.decorationsType == "pie") {
									c = u - (b + d + this.decorationsWidth)
								} else {
									c = u - (b + this.decorationsHeight + this.decorationsWidth)
								}
								break;
							case "bottom":
								v = this.decorationsType == "pie" ? l : l - w;
								c = u + (b + this.decorationsWidth);
								c = this.decorationsType == "pie" ? c + d : c;
								break;
							case "right":
								v = l + b + this.decorationsWidth;
								c = this.decorationsType == "pie" ? u : u - d;
								v = this.decorationsType == "pie" ? v + d : v;
								break;
							case "left":
								if (this.decorationsType == "pie") {
									v = l - (b + (this.decorationsHeight / 2) + this.decorationsWidth)
								} else {
									v = l - (b + (this.decorationsWidth * (this.decorations.length + 1)))
								}
								c = this.decorationsType == "pie" ? u : u - d;
								break;
							case "center":
								v = this.decorationsType == "pie" ? l : l - w;
								c = this.decorationsType == "pie" ? u : u - d;
								break
						}
						q.decorationsXi = v;
						q.decorationsYi = c
					}
					if (this.decorationsType == "bar") {
						var k = this.decorationsRange[0] < 0 ? Math.abs(this.decorationsRange[0]) * this.decorationsUnits : 0;
						this.drawBarPlot(C.vals[0], [], v, c + this.decorationsHeight - k, this.decorationsWidth, this.decorationsWidth, false, this.decorationsUnits, k, this.decorationsRange[0], "vertical", C.cols, C.patt, C.area, "-dec")
					} else {
						if (this.decorationsType.match(/stacked/)) {
							var n = this.decorationsType.match(/percent/) ? true : false;
							c += this.decorationsHeight;
							if (this.decorationsPosition == "top") {
								c -= this.decorationsWidth
							}
							for (var s = 0; s < this.decorations.length; s++) {
								this.drawStackedPlot(C.vals[s], v, c, this.decorationsWidth, false, n, this.sum(C.vals[s]), this.decorationsUnits, "vertical", C.cols[s], C.patt[s], C.area[s], "-dec");
								this.drawShape(C.shpe[s], v + this.decorationsWidth / 2, c + this.decorationsWidth, f, f, C.col2[s], this.foreground, "closed");
								v += this.decorationsWidth
							}
						} else {
							if (this.decorationsType == "heatmap") {
								if (m.type == "m") {
									var B = this.decorationsHeight / C.vals.length;
									switch (this.decorationsPosition) {
										case "top":
											c -= this.decorationsWidth;
											break;
										case "bottom":
											break;
										case "right":
											v += this.decorationsWidth;
											break;
										case "left":
											break;
										case "center":
											break
									}
									for (var s = 0; s < C.vals.length; s++) {
										this.drawHeatmap(C.vals[s], v, c, this.decorationsWidth, B, false, C.area[s], "-dec", C.patt[s], A);
										this.drawShape(C.shpe[s], v - this.decorationsWidth, c + (B / 2), f, f, C.cols[s], this.foreground, "closed");
										c += B
									}
									for (var s = 0; s < this.decorations.length; s++) {
										this.drawShape(C.shp2[s], v + this.decorationsWidth / 2, c + this.decorationsWidth, f, f, C.col2[s], this.foreground, "closed");
										v += this.decorationsWidth
									}
								} else {
									if (this.decorationsPosition == "top") {
										c -= this.decorationsWidth
									}
									this.drawHeatmap(C.vals[0], v, c, this.decorationsWidth, this.decorationsHeight, false, C.area, "-dec", C.patt, A);
									for (var s = 0; s < this.decorations.length; s++) {
										this.drawShape(C.shpe[s], v + this.decorationsWidth / 2, c + this.decorationsHeight + this.decorationsWidth, f, f, C.cols[s], this.foreground, "closed");
										v += this.decorationsWidth
									}
								}
							} else {
								var y = this.colors;
								this.colors = C.cols;
								this.drawPie(this.setPieData(C.vals[0], false, C.cols), v, c, this.sizeDecorationBy && q.decorationSize ? q.decorationSize : d, C.area, "-dec");
								this.colors = y
							}
						}
					}
				}
			}
		}
	};
	this.getLegendId = function(c, d) {
		if (c) {
			if (!d) {
				var b = 0;
				d = c + "LegendId" + b;
				if (this.data.legend.ids.hasOwnProperty(c)) {
					while (this.data.legend.ids[c].hasOwnProperty(d)) {
						b++;
						d = c + "LegendId" + b
					}
				} else {
					this.data.legend.ids[c] = {}
				}
			}
			this.data.legend.ids[c][d] = true;
			return d
		}
	};
	this.findNetworkXYRange = function(c) {
		var b = Number.MAX_VALUE;
		var h = Number.MAX_VALUE * -1;
		var j = Number.MAX_VALUE;
		var g = Number.MAX_VALUE * -1;
		if (!c) {
			c = this.getKeys(this.data.nodeIndices)
		}
		if (c && c.length > 0) {
			if (this.is3DNetwork && this.layoutDone && this.scaleFactor) {
				for (var e = 0; e < c.length; e++) {
					var f = this.data.nodes[this.data.nodeIndices[c[e]]];
					var d = this.overrideAnchorNodes ? false : f.anchor;
					if (!f.hide && !f.hiddenParent && !d) {
						b = Math.min(b, f.x3d);
						h = Math.max(h, f.x3d);
						j = Math.min(j, f.y3d);
						g = Math.max(g, f.y3d)
					}
				}
			} else {
				for (var e = 0; e < c.length; e++) {
					var f = this.data.nodes[this.data.nodeIndices[c[e]]];
					var d = this.overrideAnchorNodes ? false : f.anchor;
					if (!f.hide && !f.hiddenParent && !d) {
						b = Math.min(b, f.x);
						h = Math.max(h, f.x);
						j = Math.min(j, f.y);
						g = Math.max(g, f.y)
					}
				}
			}
		}
		return ({
			minX: b,
			maxX: h,
			minY: j,
			maxY: g
		})
	};
	this.inititalizeNetworkLegend = function() {
		if (!this.data.legend) {
			this.data.legend = {}
		}
		if (!this.data.legend.pos) {
			this.data.legend.pos = {}
		}
		if (!this.data.legend.pos.nodes) {
			this.data.legend.pos.nodes = {
				x: false,
				y: false
			}
		}
		if (!this.data.legend.pos.edges) {
			this.data.legend.pos.edges = {
				x: false,
				y: false
			}
		}
		if (!this.data.legend.pos.decorations) {
			this.data.legend.pos.decorations = {
				x: false,
				y: false
			}
		}
		if (!this.data.legend.ids) {
			this.data.legend.ids = {
				nodes: {},
				edges: {},
				text: {},
				decorations: {}
			}
		}
	};
	this.drawNetworkLegend = function() {
		if (this.showLegend) {
			this.inititalizeNetworkLegend();
			var b = this.findNetworkXYRange();
			this.curLegendX = b.minX;
			this.curLegendY = b.minY;
			if (this.showNetworkNodesLegend) {
				this.drawNetworkLegendNodes()
			}
			if (this.showNetworkEdgesLegend) {
				this.drawNetworkLegendEdges()
			}
			if (this.showNetworkTextLegend) {
				this.drawNetworkLegendText()
			}
			if (this.showNetworkDecorationsLegend) {
				this.drawNetworkLegendDecorations()
			}
		}
	};
	this.drawNetworkColorIndicator = function() {
		if (this.colorNodeBy && this.meta.data.nodes[this.colorNodeBy].type == "Numeric") {
			if (this.legendPosition = ~/top/) {
				this.drawColorIndicator(this.width - (this.heatmapIndicatorWidth + 10 + (this.margin * 2)), (this.margin * 2), this.networkColorBrew, this.colorNodeBy, true)
			} else {
				this.drawColorIndicator((this.margin * 2), this.height - (this.heatmapIndicatorWidth + 20 + (this.margin * 2)), this.networkColorBrew, this.colorNodeBy)
			}
		}
	};
	this.drawNetworkLegendNodes = function() {
		if (this.data.legend.nodes && this.data.legend.nodes.length > 0) {
			var g = this.data.legend.pos.nodes.x != null && !isNaN(this.data.legend.pos.nodes.x) ? this.data.legend.pos.nodes.x : this.curLegendX;
			var e = this.data.legend.pos.nodes.y != null && !isNaN(this.data.legend.pos.nodes.y) ? this.data.legend.pos.nodes.y : this.curLegendY;
			this.data.legend.pos.nodes.x = parseInt(g);
			this.data.legend.pos.nodes.y = parseInt(e);
			var x = 0;
			var w = 0;
			var l = 0;
			for (var y = 0; y < this.data.legend.nodes.length; y++) {
				var t = this.data.legend.nodes[y];
				var q = t.size ? t.size * this.nodeFontSize : this.nodeFontSize;
				var m = t.width ? t.width : q;
				var s = t.height ? t.height : q;
				var C = t.font ? t.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				w = Math.max(w, m);
				l = Math.max(l, Math.max(s, C + this.margin))
			}
			l /= 2;
			for (var y = 0; y < this.data.legend.nodes.length; y++) {
				var t = this.data.legend.nodes[y];
				t.id = this.getLegendId("nodes", t.id);
				var v = t.color || this.nodeFontColor;
				var z = t.outline ? t.outline : this.foreground;
				var b = t.shape || this.shapes[0];
				var q = t.size ? t.size * this.nodeFontSize : this.nodeFontSize;
				var m = t.width ? t.width : q;
				var s = t.height ? t.height : q;
				var n = t.pattern ? t.pattern : "closed";
				var k = t.rotate ? t.rotate * Math.PI / 180 : false;
				var u = t.outlineWidth ? t.outlineWidth : false;
				var h = t.imagePath ? t.imagePath : false;
				var c = t.zIndex ? t.zIndex : false;
				var j = t.font ? t.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				var p = this.nodeFontStyle + " " + (parseInt(j)) + "px " + this.fontName;
				var o = t.text ? t.text : "";
				var r = this.measureText(o, p);
				q = parseFloat(sprintf("%.1f", q));
				x = Math.max(x, (this.margin * 3) + (w * 1.5) + r);
				e += l;
				this.drawShape(b, g + w - this.margin, this.margin + e + l, m, s, v, z, n, k, u, false, false, false, false, h, c);
				this.drawText(o, this.margin + g + (w * 1.5), this.margin + e + l, p, this.nodeFontColor, "left", "middle");
				e += l
			}
			e += this.margin + l;
			var B = this.data.legend.pos.nodes.x;
			var f = this.data.legend.pos.nodes.y + (l * 0.5);
			var A = x;
			var d = e - this.data.legend.pos.nodes.y;
			if (this.legendBox) {
				this.disableGradientTransparencyShadow();
				this.rectangle(B, f, A, d, false, this.legendBoxColor, "open");
				this.enableGradientTransparencyShadow()
			}
			var D = ["rect", B, f, B + A, f + d];
			if (this.preScaleNetwork) {
				this.addArea(D, [-1], "-legend-Nodes")
			} else {
				this.addArea(this.adjustNetworkObjects(D), [-1], "-legend-Nodes")
			}
			this.curLegendX = g;
			this.curLegendY = e
		}
	};
	this.drawNetworkLegendEdges = function() {
		if (this.data.legend.edges && this.data.legend.edges.length > 0) {
			var e = this.data.legend.pos.edges.x != null && !isNaN(this.data.legend.pos.edges.x) ? this.data.legend.pos.edges.x : this.curLegendX;
			var c = this.data.legend.pos.edges.y != null && !isNaN(this.data.legend.pos.edges.y) ? this.data.legend.pos.edges.y : this.curLegendY;
			this.data.legend.pos.edges.x = parseInt(e);
			this.data.legend.pos.edges.y = parseInt(c);
			var p = 0;
			var h = 0;
			for (var q = 0; q < this.data.legend.edges.length; q++) {
				var f = this.data.legend.edges[q];
				f.id = this.getLegendId("edges", f.id);
				var o = f.color || this.nodeFontColor;
				var j = f.type || "line";
				var n = f.width || 1;
				var m = f.size ? f.size * this.nodeFontSize : this.nodeFontSize;
				var g = f.font ? f.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				var l = this.nodeFontStyle + " " + (parseInt(g)) + "px " + this.fontName;
				var k = f.text || "";
				var r = this.measureText(k, l);
				m = parseFloat(sprintf("%.1f", m));
				p = Math.max(p, (this.margin * 3) + m + r);
				h = g / 2;
				c += h;
				this.drawLine(j, this.margin + e, this.margin + c + h, e + m, this.margin + c + h, o, n * this.edgeWidth, false, 0, 0);
				this.drawText(k, (this.margin * 2) + e + m, this.margin + c + h, l, this.nodeFontColor, "left", "middle");
				c += g
			}
			c += this.margin + h;
			var t = this.data.legend.pos.edges.x;
			var d = this.data.legend.pos.edges.y;
			var s = p;
			var b = c - this.data.legend.pos.edges.y;
			if (this.legendBox) {
				this.disableGradientTransparencyShadow();
				this.rectangle(t, d, s, b, false, this.legendBoxColor, "open");
				this.enableGradientTransparencyShadow()
			}
			var u = ["rect", t, d, t + s, d + b];
			if (this.preScaleNetwork) {
				this.addArea(u, [-1], "-legend-Edges")
			} else {
				this.addArea(this.adjustNetworkObjects(u), [-1], "-legend-Edges")
			}
			this.curLegendX = e;
			this.curLegendY = c
		}
	};
	this.drawNetworkLegendText = function() {
		if (this.data.legend.text && this.data.legend.text.length > 0) {
			var j = 0;
			for (var q = 0; q < this.data.legend.text.length; q++) {
				var g = this.data.legend.text[q];
				g.id = this.getLegendId("text", g.id);
				var f = g.x != null && !isNaN(g.x) ? g.x : this.curLegendX;
				var d = g.y != null && !isNaN(g.y) ? g.y : this.curLegendY;
				g.x = parseInt(f);
				g.y = parseInt(d);
				var n = g.boxed || this.legendBox;
				var l = g.margin || this.margin;
				var b = this.setNetworkLegendMargins(l);
				var p = g.color || this.nodeFontColor;
				var k = g.text || "";
				var h = g.font ? g.font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				var m = this.nodeFontStyle + " " + (parseInt(h)) + "px " + this.fontName;
				var o = this.measureText(k, m);
				j = h / 2;
				this.drawText(k, b[3] + f, b[0] + d + j, m, p, "left", "middle");
				var s = g.x;
				var e = g.y;
				var r = b[1] + b[3] + o;
				var c = b[0] + b[2] + h;
				if (n) {
					this.disableGradientTransparencyShadow();
					this.rectangle(s, e, r, c, false, this.legendBoxColor, "open");
					this.enableGradientTransparencyShadow()
				}
				d += b[0] + b[2] + h;
				var t = ["rect", s, e, s + r, e + c];
				if (this.preScaleNetwork) {
					this.addArea(t, [-1], "-legend-Text" + q)
				} else {
					this.addArea(this.adjustNetworkObjects(t), [-1], "-legend-Text" + q)
				}
				this.curLegendX = f;
				this.curLegendY = d
			}
		}
	};
	this.drawNetworkLegendDecorations = function() {
		if (this.data.legend.decorations && this.data.legend.decorations.length > 0) {
			var f = this.data.legend.pos.decorations.x != null && !isNaN(this.data.legend.pos.decorations.x) ? this.data.legend.pos.decorations.x : this.curLegendX;
			var d = this.data.legend.pos.decorations.y != null && !isNaN(this.data.legend.pos.decorations.y) ? this.data.legend.pos.decorations.y : this.curLegendY;
			this.data.legend.pos.decorations.x = parseInt(f);
			this.data.legend.pos.decorations.y = parseInt(d);
			var t = 0;
			var j = 0;
			for (var u = 0; u < this.data.legend.decorations.length; u++) {
				this.data.legend.decorations[u].id = this.getLegendId("decorations", this.data.legend.decorations[u].id);
				var s = this.data.legend.decorations[u].color || this.nodeFontColor;
				var v = this.data.legend.decorations[u].outline ? this.data.legend.decorations[u].outline : this.foreground;
				var b = this.data.legend.decorations[u].shape || this.shapes[0];
				var o = this.data.legend.decorations[u].size ? this.data.legend.decorations[u].size * this.nodeFontSize : this.nodeFontSize;
				var k = this.data.legend.decorations[u].width ? this.data.legend.decorations[u].width : o;
				var q = this.data.legend.decorations[u].height ? this.data.legend.decorations[u].height : o;
				var l = this.data.legend.decorations[u].pattern ? this.data.legend.decorations[u].pattern : "closed";
				var h = this.data.legend.decorations[u].rotate ? this.data.legend.decorations[u].rotate * Math.PI / 180 : false;
				var r = this.data.legend.decorations[u].outlineWidth ? this.data.legend.decorations[u].otlineWidth : false;
				var g = this.data.legend.decorations[u].font ? this.data.legend.decorations[u].font * this.nodeFontSize * this.nodeScaleFontFactor : this.nodeFontSize * this.nodeScaleFontFactor;
				var n = this.nodeFontStyle + " " + (parseInt(g)) + "px " + this.fontName;
				var m = this.data.legend.decorations[u].text ? this.data.legend.decorations[u].text : "";
				var p = this.measureText(m, n);
				o = parseFloat(sprintf("%.1f", o));
				t = Math.max(t, (this.margin * 3) + o + p);
				j = o / 2;
				d += j;
				this.drawShape(b, this.margin + f + j, this.margin + d + j, k, q, s, v, l, h, r);
				this.drawText(m, (this.margin * 2) + f + o, this.margin + d + j, n, this.nodeFontColor, "left", "middle");
				d += o
			}
			d += this.margin + j;
			var x = this.data.legend.pos.decorations.x;
			var e = this.data.legend.pos.decorations.y;
			var w = t;
			var c = d - this.data.legend.pos.decorations.y;
			if (this.legendBox) {
				this.disableGradientTransparencyShadow();
				this.rectangle(x, e, w, c, false, this.legendBoxColor, "open");
				this.enableGradientTransparencyShadow()
			}
			var y = ["rect", x, e, x + w, e + c];
			if (this.preScaleNetwork) {
				this.addArea(y, [-1], "-legend-Decorations")
			} else {
				this.addArea(this.adjustNetworkObjects(y), [-1], "-legend-Decorations")
			}
			this.curLegendX = f;
			this.curLegendY = d
		}
	};
	this.setNetworkLegendMargins = function(b) {
		if (isNaN(b)) {
			var c = b.split(/[,\s]+/);
			if (c.length > 3) {
				return [parseInt(c[0]), parseInt(c[1]), parseInt(c[2]), parseInt(c[3])]
			} else {
				if (c.length == 3) {
					return [parseInt(c[0]), parseInt(c[1]), parseInt(c[2]), parseInt(c[1])]
				} else {
					if (c.length == 2) {
						return [parseInt(c[0]), parseInt(c[1]), parseInt(c[0]), parseInt(c[1])]
					} else {
						return [parseInt(c[0]), parseInt(c[0]), parseInt(c[0]), parseInt(c[0])]
					}
				}
			}
		} else {
			return [parseInt(b), parseInt(b), parseInt(b), parseInt(b)]
		}
	};
	this.drawNetworkProgressBar = function(c) {
		if (!this.layoutDone) {
			var b = (new Date().getTime() - this.preUpdateTime) / (this.layoutTime * 1000);
			b = Math.max(b, this.layoutProgress);
			if (c) {
				this.rectangle(this.width / 2, this.height / 2, 10, 5, this.foreground, this.foreground, "closed");
				this.drawText("Calculating ...", (this.width / 2) - 50, (this.height / 2) + 10, this.showAnimationFont, this.showAnimationFontColor, "left", "top")
			} else {
				this.rectangle(this.width - 110, this.height - 20, 10, 5, this.foreground, this.foreground, "closed")
			}
		}
	};
	this.packSubNetworks = function() {
		var l = this;
		var q = function(u, t, s) {
			for (var v = 0; v < u.length; v++) {
				l.modifyXYNode(u[v], t, s)
			}
		};
		var c = function(i, u, s, t) {
			this.x = i;
			this.y = u;
			this.w = s;
			this.h = t
		};
		c.prototype.fits = function(i) {
			return i.w >= this.w && i.h >= this.h
		};
		c.prototype.sameSize = function(i) {
			return i.w == this.w && i.h == this.h
		};
		var e = function() {
			this.l = null;
			this.r = null;
			this.a = null;
			this.f = false
		};
		e.prototype.insert = function(i) {
			if (this.l != null) {
				return this.l.insert(i) || this.r.insert(i)
			}
			if (this.f) {
				return null
			}
			if (!i.fits(this.a)) {
				return null
			}
			if (i.sameSize(this.a)) {
				this.f = true;
				return this
			}
			this.l = new e();
			this.r = new e();
			var s = this.a.w - i.w;
			var u = this.a.h - i.h;
			var t = this.a;
			if (s > u) {
				this.l.a = new c(t.x, t.y, i.w, t.h);
				this.r.a = new c(t.x + i.w, t.y, t.w - i.w, t.h)
			} else {
				this.l.a = new c(t.x, t.y, t.w, i.h);
				this.r.a = new c(t.x, t.y + i.h, t.w, t.h - i.h)
			}
			return this.l.insert(i)
		};
		for (var k = 0; k < this.subNetworks.length; k++) {
			this.subNetworks[k].mnm = this.findNetworkXYRange(this.subNetworks[k].nodes);
			this.subNetworks[k].w = (this.subNetworks[k].mnm.maxX - this.subNetworks[k].mnm.minX);
			this.subNetworks[k].h = (this.subNetworks[k].mnm.maxY - this.subNetworks[k].mnm.minY);
			q(this.subNetworks[k].nodes, this.subNetworks[k].mnm.minX, this.subNetworks[k].mnm.minY)
		}
		var r = this.subNetworks[1];
		for (var k = 0; k < this.subNetworks.length; k++) {
			this.subNetworks[k].w += (r.w * 0.5);
			this.subNetworks[k].h += (r.h * 0.5)
		}
		var d = this.subNetworks[0];
		var b = d.nodes.length / this.data.nodes.length;
		var h = ((2 + b) * ((this.x / this.y) * d.w));
		var g = ((2 + b) * ((this.y / this.x) * d.h));
		var m = new e();
		var o, n;
		m.a = new c(0, 0, h, g);
		for (var k = 0; k < this.subNetworks.length; k++) {
			var f = this.subNetworks[k];
			var p = new c(0, 0, f.w, f.h);
			var j = m.insert(p);
			if (j) {
				q(this.subNetworks[k].nodes, -j.a.x, -j.a.y)
			}
		}
		this.scaleFactor *= 0.1
	};
	this.setNetworkMinMaxRangeXY = function() {
		if (!this.networkFreeze || (this.rangeX == null || this.rangeY == null)) {
			if (this.subNetworks && !this.isAnimation) {
				this.packSubNetworks();
				if (!this.isAnimation) {
					this.subNetworks = false
				}
			}
			this.minX = Number.MAX_VALUE;
			this.minY = Number.MAX_VALUE;
			this.maxX = 0;
			this.maxY = 0;
			if (this.is3DNetwork && this.layoutDone) {
				for (var c = 0; c < this.data.nodes.length; c++) {
					var e = this.data.nodes[c];
					var b = e.width ? e.width : e.size ? (this.nodeSize * e.size) : this.nodeSize;
					var d = e.height ? e.height : e.size ? (this.nodeSize * e.size) : this.nodeSize;
					if (!e.hide) {
						this.minX = Math.min(this.minX, e.x3d - b / 2);
						this.minY = Math.min(this.minY, e.y3d - d / 2);
						this.maxX = Math.max(this.maxX, e.x3d + b / 2);
						this.maxY = Math.max(this.maxY, e.y3d + d / 2)
					}
				}
			} else {
				for (var c = 0; c < this.data.nodes.length; c++) {
					var e = this.data.nodes[c];
					var b = e.width ? e.width : e.size ? (this.nodeSize * e.size) : this.nodeSize;
					var d = e.height ? e.height : e.size ? (this.nodeSize * e.size) : this.nodeSize;
					if (!e.hide) {
						this.minX = Math.min(this.minX, e.x - b / 2);
						this.minY = Math.min(this.minY, e.y - d / 2);
						this.maxX = Math.max(this.maxX, e.x + b / 2);
						this.maxY = Math.max(this.maxY, e.y + d / 2)
					}
				}
			}
			this.minX -= (this.nodeSize * 1.5);
			this.minY -= (this.nodeSize * 1.5);
			this.maxX += (this.nodeSize * 1.5);
			this.maxY += (this.nodeSize * 1.5);
			this.rangeX = this.maxX - this.minX;
			this.rangeY = this.maxY - this.minY
		}
	};
	this.setNetworkRotation = function() {
		if (this.is3DNetwork && this.layoutDone) {
			var k = [];
			var e = [];
			var p = [];
			this.set3DRotation();
			for (var f = 0; f < this.data.nodes.length; f++) {
				e.push(f);
				var c = this.data.nodes[f];
				var g = this.get3DTransfrom(c.x, c.y, c.z);
				c.x3d = g[0];
				c.y3d = g[1];
				c.z3d = g[2];
				k.push(Math.sqrt((c.x3d * c.x3d) + (c.y3d * c.y3d) + (c.z3d * c.z3d)))
			}
			e.sort(function(j, i) {
				return k[i] - k[j]
			});
			for (var o = 0; o < this.data.nodes.length; o++) {
				var f = e[o];
				var c = this.data.nodes[f];
				p.push(c)
			}
			this.data.nodes = p;
			this.setNodeIndices()
		} else {
			if (this.network2DRotate != 0) {
				if (this.network2DRotate >= Math.abs(360)) {
					this.network2DRotate = 0
				}
				var l = Math.PI * this.network2DRotate / 360;
				for (var f = 0; f < this.data.nodes.length; f++) {
					var c = this.data.nodes[f];
					if (c.x != null && c.y != null) {
						var n = c.x;
						var m = c.y;
						c.x = (n * Math.cos(l)) - (m * Math.sin(l));
						c.y = (m * Math.cos(l)) + (n * Math.sin(l))
					}
				}
				for (var f = 0; f < this.data.edges.length; f++) {
					var b = this.data.edges[f];
					if (b.elbows && b.elbows.length > 0) {
						for (var d = 0; d < b.elbows.length; d++) {
							var n = b.elbows[d][0];
							var m = b.elbows[d][1];
							b.elbows[d][0] = (n * Math.cos(l)) - (m * Math.sin(l));
							b.elbows[d][1] = (m * Math.cos(l)) + (n * Math.sin(l))
						}
					}
				}
				if (this.data.legend.pos.nodes.x && this.data.legend.pos.nodes.y) {
					var n = this.data.legend.pos.nodes.x;
					var m = this.data.legend.pos.nodes.y;
					this.data.legend.pos.nodes.x = (n * Math.cos(l)) - (m * Math.sin(l));
					this.data.legend.pos.nodes.y = (m * Math.cos(l)) + (n * Math.sin(l))
				}
				if (this.data.legend.pos.edges.x && this.data.legend.pos.edges.y) {
					var n = this.data.legend.pos.edges.x;
					var m = this.data.legend.pos.edges.y;
					this.data.legend.pos.edges.x = (n * Math.cos(l)) - (m * Math.sin(l));
					this.data.legend.pos.edges.y = (m * Math.cos(l)) + (n * Math.sin(l))
				}
				if (this.data.legend.text) {
					for (var f = 0; f < this.data.legend.text.length; f++) {
						var h = this.data.legend.text[f];
						var n = h.x;
						var m = h.y;
						h.x = (n * Math.cos(l)) - (m * Math.sin(l));
						h.y = (m * Math.cos(l)) + (n * Math.sin(l))
					}
				}
				this.network2DRotate = 0
			}
		}
	};
	this.setNetworkScaleFactor = function() {
		if (!this.networkFreeze || this.scaleFactor == null || isNaN(this.scaleFactor)) {
			this.scaleFactor = this.networkLayoutType == "radial" ? 0.3 : Math.min(this.x / (this.maxX - this.minX), this.y / (this.maxY - this.minY))
		}
		this.scaleFactor *= this.zoom;
		if (this.networkFreeze) {
			this.zoomGlobal *= this.zoom;
			this.zoom = 1
		}
		this.widthBounds = this.x / this.scaleFactor;
		this.heightBounds = this.y / this.scaleFactor;
		this.offsetX = ((this.widthBounds / 2) - ((this.minX + this.maxX) / 2)) + this.panningX + this.panningGlobalX;
		this.offsetY = ((this.heightBounds / 2) - ((this.minY + this.maxY) / 2)) + this.panningY + this.panningGlobalY
	};
	this.optimizeNetworkLayout = function(e) {
		if (this.data.nodes.length > 0) {
			this.isAnimation = true;
			this.setInitialForceDirectedLayout();
			this.preUpdateTime = new Date().getTime();
			this.networkUpdateTime = 0;
			var b = this.layoutTime * 1000;
			var c = this.maxIterations * (e ? e.i.length : this.data.nodes.length) * 10;
			var d = this;
			var f = e ? {
				minX: d.min(e.x),
				maxX: d.max(e.x),
				minY: d.min(e.y),
				maxY: d.max(e.y)
			} : false;
			var g = function() {
				this.update = function() {
					var j = function() {
						var n = {
							minX: Number.MAX_VALUE,
							maxX: -Number.MAX_VALUE,
							minY: Number.MAX_VALUE,
							maxY: -Number.MAX_VALUE
						};
						for (var m = 0; m < e.i.length; m++) {
							var o = d.data.nodes[d.data.nodeIndices[e.i[m]]];
							n.minX = Math.min(n.minX, o.x);
							n.maxX = Math.max(n.maxX, o.x);
							n.minY = Math.min(n.minY, o.y);
							n.maxY = Math.max(n.maxY, o.y)
						}
						var q = (n.maxX - n.minX) / (f.maxX - f.minX);
						var p = (n.maxY - n.minY) / (f.maxY - f.minY);
						var l = (n.minX / q) - f.minX;
						var k = (n.minY / p) - f.minY;
						for (var m = 0; m < e.i.length; m++) {
							var o = d.data.nodes[d.data.nodeIndices[e.i[m]]];
							o.x = (o.x / q) - l;
							o.y = (o.y / p) - k
						}
					};
					var i = new Date().getTime();
					if (e) {
						j()
					}
					if (d.updateForceDirectedLayout(30) || i - d.preUpdateTime > b || d.iteration > c) {
						d.layoutDone = true;
						clearInterval(h);
						d.isAnimation = false;
						d.iteration = 0;
						if (e) {
							j()
						}
					}
					d.renderNetwork()
				};
				var h = setInterval(this.update, 30)
			};
			g.call()
		}
	};
	this.recalculateLayoutSelectedNodes = function() {
		if (this.data.nodes.length > 0) {
			this.layoutDone = false;
			this.randomSeed = 8;
			this.networkForceConstant = 0;
			this.temperature = 0;
			this.initialTemperature = 0;
			var b = this.data.edges;
			var d = this.getSelectedNodeCoordinates();
			d.e = [];
			for (var c = 0; c < b.length; c++) {
				if (this.selectNode.hasOwnProperty(b[c].id1) && this.selectNode.hasOwnProperty(b[c].id2)) {
					d.e.push[b[c].id1, b[c].id2] = true
				}
			}
			this.showHideSelectedDataPoint(false, 1000, true);
			this.setNetworkPrivateParams(d);
			this.optimizeNetworkLayout(d)
		}
	};
	this.getAngle = function(e, g, c, f, d) {
		var b = (Math.atan2(f - g, c - e) * 180 / Math.PI) % 360;
		if (!d) {
			d = 0
		}
		while (b < d) {
			b += 360
		}
		while (b >= (d + 360)) {
			b -= 360
		}
		return b
	};
	this.getPolar = function(c, b) {
		return {
			x: this.networkXCenter + c * Math.cos(b * Math.PI / 180),
			y: this.networkYCenter + c * Math.sin(b * Math.PI / 180)
		}
	};
	this.setNodePositions = function(b) {
		for (var d in b) {
			var c = this.data.nodes[this.data.nodeIndices[d]];
			c.x = b[d].x;
			c.y = b[d].y
		}
	};
	this.animateRadialNodePositions = function() {
		this.isAnimation = true;
		var f = this;
		var e = 15;
		var d = 0;
		var c = 0;
		for (var h in f.finalRadialNodePositions) {
			if (this.initialRadialNodePositions[h].r == 0) {
				this.initialRadialNodePositions[h].a = this.finalRadialNodePositions[h].a
			}
			if (this.finalRadialNodePositions[h].r == 0) {
				this.finalRadialNodePositions[h].a = this.initialRadialNodePositions[h].a
			}
			var b = (this.finalRadialNodePositions[h].a - this.initialRadialNodePositions[h].a);
			if (b < 0) {
				b += 360
			}
			if (b > 360) {
				b -= 360
			}
			if (b > 180) {
				b -= 360
			}
			this.finalRadialNodePositions[h].a = (this.initialRadialNodePositions[h].a + b)
		}
		var g = function() {
			this.update = function() {
				var k = {};
				var s = Math.atan((d / e) * 10 - 5) * 0.5 / Math.atan(5) + 0.5;
				var p = 1 - s;
				for (var m in f.finalRadialNodePositions) {
					var j = ((p * f.initialRadialNodePositions[m].a) + (s * f.finalRadialNodePositions[m].a));
					var l = ((p * f.initialRadialNodePositions[m].r) + (s * f.finalRadialNodePositions[m].r));
					var q = f.getPolar(l, j);
					k[m] = {
						x: q.x,
						y: q.y
					}
				}
				if (d >= e) {
					clearInterval(i);
					f.isAnimation = false;
					k = f.finalRadialNodePositions
				}
				d++;
				f.setNodePositions(k);
				f.renderNetwork();
				if (!f.isAnimation && f.networkLayoutType == "radial" && f.showNetworkRadialLayout) {
					f.renderRadialLayout()
				}
			};
			var i = setInterval(this.update, 50)
		};
		g.call()
	};
	this.setFinalRadialNodePositions = function(e, d) {
		if (!this.finalRadialNodePositions) {
			this.finalRadialNodePositions = {}
		}
		if (!this.nodeParentHood.drawn.hasOwnProperty(e)) {
			var m, o, g, n, b;
			var f = this.data.nodes[this.data.nodeIndices[e]];
			if (!f.hide && !f.hiddenParent) {
				if (this.nodeParentHood[e].children.length > 1 && !d) {
					var k = [];
					var j = this;
					if (this.orderRadialNetwork) {
						this.nodeParentHood[e].children.sort(function(i, c) {
							return j.orderRadialNetwork[i] - j.orderRadialNetwork[c]
						})
					}
					for (var h = 0; h < this.nodeParentHood[e].children.length; h++) {
						if (this.nodeParentHood[this.nodeParentHood[e].children[h]].level > this.nodeParentHood[e].level) {
							this.setFinalRadialNodePositions(this.nodeParentHood[e].children[h]);
							k.push(this.nodeParentHood[this.nodeParentHood[e].children[h]].angle)
						}
					}
					if (k.length > 0) {
						if (k.length == 1) {
							n = k[0]
						} else {
							if (k[0] > k[k.length - 1]) {
								n = ((k[0] + k[k.length - 1]) % 360) / 2
							} else {
								n = (k[0] + k[k.length - 1]) / 2
							}
						}
					} else {
						this.setFinalRadialNodePositions(e, true)
					}
				} else {
					n = this.networkCurrentAngle;
					this.networkCurrentAngle = (this.networkCurrentAngle + this.networkAngleStep)
				}
				g = (this.networkDepth - 1) - this.nodeParentHood[e].level;
				m = this.getPolar(this.networkRadialRadius, n);
				o = this.shortenLine(this.networkXCenter, this.networkYCenter, m.x, m.y, 0, this.networkLevelSize * g, "line");
				b = this.lineLength(this.networkXCenter, this.networkYCenter, o[2], o[3]);
				if (this.nodeParentHood[e].level == 0) {
					n = 0;
					b = 0
				}
				this.finalRadialNodePositions[f.id] = {
					x: o[2],
					y: o[3],
					r: b,
					a: n % 360
				};
				this.nodeParentHood.drawn[e] = true;
				this.nodeParentHood[e].angle = n
			}
		}
	};
	this.setInitialRadialNodePositions = function() {
		if (!this.initialRadialNodePositions) {
			this.initialRadialNodePositions = {};
			for (var b = 0; b < this.data.nodes.length; b++) {
				if (!this.data.nodes[b].hide && !this.data.nodes[b].hiddenParent) {
					var c = this.data.nodes[b];
					this.initialRadialNodePositions[c.id] = {
						x: this.networkXCenter,
						y: this.networkYCenter,
						r: 0,
						a: 0
					}
				}
			}
		} else {
			this.initialRadialNodePositions = this.finalRadialNodePositions;
			this.finalRadialNodePositions = false
		}
	};
	this.setRadialNetwrorkLayout = function() {
		if (this.data.nodes.length > 0) {
			this.networkLevelSize = this.x * 4 / (this.networkDepth * 2);
			this.networkAngleStep = 360 / this.networkDivisions;
			this.networkCurrentAngle = this.networkCurrentAngle ? this.networkCurrentAngle : 0;
			this.networkRadialRadius = this.networkLevelSize * (this.networkDepth - 1);
			this.setInitialRadialNodePositions();
			this.setFinalRadialNodePositions(this.networkRoot);
			this.layoutDone = true;
			if (this.showAnimation) {
				this.animateRadialNodePositions()
			} else {
				this.setNodePositions(this.finalRadialNodePositions);
				this.renderNetwork()
			}
		}
	};
	this.unsetNetworkCommunities = function() {
		this.functionCaller = "unsetNetworkCommunities";
		this.networkCommunities = 0;
		this.networkConvexHulls = [];
		this.isNetworkConvexHull = false;
		this.draw(false, false, false, true);
		this.removeMenus()
	};
	this.setNetworkCommunities = function(d) {
		this.functionCaller = "setNetworkCommunities";
		this.networkCommunities = 0;
		this.networkConvexHulls = [];
		var e = [];
		for (var g = 0; g < this.data.nodes.length; g++) {
			e.push(this.data.nodes[g].id)
		}
		var b = 0;
		var h;
		if (this.calculateNetworkCommunities) {
			h = jLouvain().nodes(e).edges(this.data.edges)();
			for (var g = 0; g < this.data.nodes.length; g++) {
				var k = h[this.data.nodes[g].id];
				b = Math.max(b, k);
				this.data.nodes[g].community = k;
				this.data.nodes[g].communityColor = this.colors[this.data.nodes[g].community % this.colors.length]
			}
		} else {
			for (var g = 0; g < this.data.nodes.length; g++) {
				var k = this.data.nodes[g].community || 0;
				b = Math.max(b, k);
				this.data.nodes[g].communityColor = this.colors[this.data.nodes[g].community % this.colors.length]
			}
		}
		this.networkCommunities = b + 1;
		for (var g = 0; g < this.networkCommunities; g++) {
			var e = [];
			for (var f = 0; f < this.data.nodes.length; f++) {
				if (this.data.nodes[f].community == g) {
					e.push(f)
				}
			}
			this.networkConvexHulls[g] = {
				nodes: e,
				drawn: false
			}
		}
		this.isNetworkConvexHull = true;
		this.removeMenus();
		if (d) {
			this.draw(false, false, false, true)
		}
	};
	this.drawNetworkCommunities = function() {
		var b = this;
		var c = function() {
			this.update = function() {
				if (b.layoutDone) {
					b.setNetworkCommunities(true);
					clearInterval(d)
				}
			};
			var d = setInterval(this.update, 30)
		};
		c.call()
	};
	this.getHull = function(s) {
		var c = this;
		var b = function(m, l, i) {
			return (l[0] - m[0]) * (i[1] - m[1]) - (l[1] - m[1]) * (i[0] - m[0])
		};
		var d = function(p) {
			var m = p.size ? p.size : 1;
			var i = p.width ? p.width : c.nodeSize * m;
			var l = p.height ? p.height : c.nodeSize * m;
			return [p.x, p.y, i, l]
		};
		var v = [];
		var C, D;
		var A, B;
		var o = 0;
		for (var w = 0; w < s.length; w++) {
			var r = d(this.data.nodes[s[w]]);
			var f = r.x;
			var e = r.y;
			if (r[0] > C || !C) {
				C = r[0]
			}
			if (r[0] < D || !D) {
				D = r[0]
			}
			if (r[1] > A || !A) {
				A = r[1]
			}
			if (r[1] < B || !B) {
				B = r[1]
			}
			o = Math.max(o, Math.max(r[2], r[3]));
			v.push([r[0], r[1]])
		}
		var h = (D + C) / 2;
		var g = (B + A) / 2;
		if (v.length == 1) {
			var r = d(this.data.nodes[s[0]]);
			v.push([h - r[2], g]);
			v.push([h, g - r[3]]);
			v.push([h + r[2], g]);
			v.push([h, g + r[3]])
		} else {
			if (v.length == 2) {
				var r = d(this.data.nodes[s[0]]);
				var t = d(this.data.nodes[s[1]]);
				v.push([h - o, g]);
				v.push([h, g - o]);
				v.push([h + o, g]);
				v.push([h, g + o])
			}
		}
		v.sort(function(l, i) {
			return (l[0] - i[0]) || (l[1] - i[1])
		});
		var E = [0, 0];
		var F = [];
		var z = [];
		var w, u;
		for (w = 0, u = v.length; w < u; w++) {
			var k = v[w];
			var j = v[u - w - 1];
			while (F.length >= 2 && b(F[F.length - 2], F[F.length - 1], k) <= 0) {
				F.pop()
			}
			F.push(k);
			while (z.length >= 2 && b(z[z.length - 2], z[z.length - 1], j) <= 0) {
				z.pop()
			}
			z.push(j);
			E[0] += k[0];
			E[1] += k[1]
		}
		E[0] *= 1 / s.length;
		E[1] *= 1 / s.length;
		z.pop();
		F.pop();
		return [this.expandPolygon(F.concat(z), o * this.hullScale), D, C, B, A]
	};
	this.createRandomNetwork = function(u) {
		var m = {};
		var b = {};
		if (u) {
			m = this.createMesh()
		} else {
			m.nodes = [];
			var e = Math.floor(this.random() * this.randomNetworkNodes) + 1;
			for (var o = 0; o < e; o++) {
				var h = {};
				var s = Math.floor(this.random() * this.shapes.length);
				var f = Math.floor(this.random() * this.colors.length);
				h.id = "id" + o;
				h.shape = this.shapes[s];
				if (h.shape == "image") {
					h.imagePath = "cx"
				}
				h.color = this.colors[f];
				h.size = 1;
				m.nodes.push(h)
			}
			m.edges = [];
			if (this.lines.length == 0) {
				this.lines = this.setLineTypes()
			}
			for (var o = 0; o < m.nodes.length; o++) {
				var g = m.nodes[o];
				var l = [];
				for (var k = 0; k < Math.floor(this.random() * this.randomNetworkNodeEdgesMax) - 1; k++) {
					l.push(Math.floor(this.random() * e))
				}
				for (var k = 0; k < l.length; k++) {
					var d = m.nodes[l[k]];
					var r = o + ":" + l[k];
					var q = l[k] + ":" + o;
					if (g.id != d.id && !b.hasOwnProperty(r) && !b.hasOwnProperty(r)) {
						var c = {};
						var t = Math.floor(this.random() * this.lines.length);
						var f = Math.floor(this.random() * this.colors.length);
						c.id1 = g.id;
						c.id2 = d.id;
						c.width = 1;
						c.type = this.lines[t];
						c.color = this.colors[f];
						m.edges.push(c);
						b[r] = 1;
						b[q] = 1
					}
				}
			}
		}
		if (this.randomNetworkReduce) {
			var p = this.normalizeGraph(m);
			m = this.reduceNetwork(p, function(j, i) {
				if (j.nodes && i.nodes) {
					if (j.nodes.length >= i.nodes.length) {
						return j
					} else {
						return i
					}
				} else {
					if (j.nodes) {
						return j
					} else {
						if (i.nodes) {
							return i
						} else {
							return null
						}
					}
				}
			})
		}
		if (m.nodes.length < 5) {
			return this.createRandomNetwork(true)
		} else {
			var l = [];
			for (var o = 0; o < m.edges.length; o++) {
				if (m.edges[o].id1 && m.edges[o].id2) {
					l.push(m.edges[o])
				}
			}
			m.edges = l;
			this.resetObjectAttributes();
			return m
		}
	};
	this.createMesh = function() {
		var g = {};
		g.nodes = [];
		g.edges = [];
		var f = 7;
		var b = this;
		for (var i = 0; i < f * f; i++) {
			var d = {};
			var h = Math.floor(this.random() * this.shapes.length);
			var c = Math.floor(this.random() * this.colors.length);
			d.id = "id" + i;
			d.shape = this.shapes[h];
			d.color = this.colors[c];
			d.size = 1;
			g.nodes.push(d)
		}
		var e = function(n, m) {
			var l = {};
			var j = Math.floor(b.random() * b.lines.length);
			var k = Math.floor(b.random() * b.colors.length);
			l.id1 = g.nodes[n].id;
			l.id2 = g.nodes[m].id;
			l.width = 1;
			l.type = b.lines[j];
			l.color = b.colors[k];
			return l
		};
		for (var i = 0; i < g.nodes.length; i++) {
			if (Math.floor(this.random() * f) != 0) {
				if (i + 1 < g.nodes.length && (i + 1) % f != 0) {
					g.edges.push(e(i, i + 1))
				}
				if (i + f < g.nodes.length) {
					g.edges.push(e(i, i + f))
				}
			}
		}
		return g
	};
	this.setNodeChildren = function(g, c, h) {
		this.networkDepth = c > this.networkDepth ? c : this.networkDepth;
		var e = this.data.nodes[this.data.nodeIndices[g]];
		if (!e.hide && !e.hiddenParent) {
			var b = this.edgesForNode(this.data.edges, g);
			if (!this.nodeParentHood.hasOwnProperty(g)) {
				if (b.length == 1) {
					this.networkDivisions++
				}
				if (b.length > 0) {
					for (var d = 0; d < b.length; d++) {
						if (!this.nodeParentHood[g]) {
							this.nodeParentHood[g] = {};
							this.nodeParentHood[g].children = [];
							this.nodeParentHood[g].level = c;
							this.nodeParentHood[g].angle = 0;
							this.nodeParentHood[g].parent = h
						}
						this.nodeParentHood[g].level = c < this.nodeParentHood[g].level ? c : this.nodeParentHood[g].level;
						if (b[d].id1 == g) {
							this.nodeParentHood[g].children.push(b[d].id2);
							this.setNodeChildren(b[d].id2, c + 1, g)
						} else {
							if (b[d].id2 == g) {
								this.nodeParentHood[g].children.push(b[d].id1);
								this.setNodeChildren(b[d].id1, c + 1, g)
							}
						}
					}
				}
			} else {
				this.nodeParentHood[g].level = c < this.nodeParentHood[g].level ? c : this.nodeParentHood[g].level;
				for (var d = 0; d < this.nodeParentHood[g].children.length; d++) {
					var f = this.nodeParentHood[g].children[d];
					if (this.nodeParentHood[f]) {
						if ((c + 1) < this.nodeParentHood[f].level) {
							this.nodeParentHood[f].level = c + 1;
							this.nodeParentHood[f].parent = g
						}
					}
				}
			}
		}
	};
	this.setNodeParentHood = function() {
		this.nodeParentHood = {};
		if (this.networkLayoutType == "radial") {
			if (!this.networkRoot) {
				this.networkRoot = this.data.nodes[0].id
			}
			this.nodeParentHood.drawn = {};
			this.networkDepth = 0;
			this.networkDivisions = 0;
			this.setNodeChildren(this.networkRoot, 0, false)
		} else {
			for (var b = 0; b < this.data.nodes.length; b++) {
				if (!this.data.nodes[b].hide) {
					if (this.data.nodes[b].parentNode || this.data.nodes[b].hideChildren) {
						if (this.data.nodes[b].parentNode && !this.nodeParentHood.hasOwnProperty(this.data.nodes[b].parentNode)) {
							this.nodeParentHood[this.data.nodes[b].parentNode] = {}
						}
						if (this.data.nodes[b].parentNode) {
							if (!this.nodeParentHood[this.data.nodes[b].parentNode].children) {
								this.nodeParentHood[this.data.nodes[b].parentNode].children = []
							}
							this.nodeParentHood[this.data.nodes[b].parentNode].children.push(this.data.nodes[b].id);
							if (this.data.nodes[this.data.nodeIndices[this.data.nodes[b].parentNode]].hideChildren) {
								this.data.nodes[b].hiddenParent = true
							}
						}
						if (this.data.nodes[b].hideChildren) {
							if (!this.nodeParentHood.hasOwnProperty(this.data.nodes[b].id)) {
								this.nodeParentHood[this.data.nodes[b].id] = {}
							}
							this.nodeParentHood[this.data.nodes[b].id].hideChildren = true
						}
					}
				}
			}
			for (var c in this.nodeParentHood) {
				if (this.data.nodes[this.data.nodeIndices[c]].hideChildren || this.isParentHidden(c)) {
					this.hideUnhideChildrenNodes(c, true)
				} else {
					if (this.nodeParentHood[c].children) {
						this.hideUnhideChildrenNodes(c, false)
					}
				}
			}
		}
	};
	this.isParentHidden = function(d) {
		var c = this.findParentNodes(d);
		if (c) {
			for (var b = 0; b < c.length; b++) {
				if (this.data.nodes[this.data.nodeIndices[c[b]]].hideChildren) {
					return true
				}
			}
		}
		return false
	};
	this.findParentNodes = function(d, b) {
		if (this.data.nodes[this.data.nodeIndices[d]].parentNode) {
			var c = this.data.nodes[this.data.nodeIndices[d]].parentNode;
			if (!b) {
				b = []
			}
			b.push(c);
			b = this.findParentNodes(c, b);
			return b
		} else {
			return b ? b.reverse() : false
		}
	};
	this.findChildrenNodeIndices = function(d, c) {
		if (!c) {
			c = []
		}
		if (this.networkLayoutType != "radial") {
			if (this.nodeParentHood[d] && this.nodeParentHood[d]["children"]) {
				for (var b = 0; b < this.nodeParentHood[d]["children"].length; b++) {
					c.push(this.data.nodeIndices[this.nodeParentHood[d]["children"][b]]);
					c = this.findChildrenNodeIndices(this.nodeParentHood[d]["children"][b], c)
				}
			}
		}
		return c.length > 0 ? c : false
	};
	this.hasChildren = function(b) {
		return this.nodeParentHood[b] && this.nodeParentHood[b].children
	};
	this.findVisibleParentNode = function(d) {
		var c = this.findParentNodes(d);
		if (c) {
			c.reverse();
			for (var b = 0; b < c.length; b++) {
				if (!this.nodes[c[b]].hide && !this.nodes[c[b]].hiddenParent) {
					return this.nodes[c[b]]
				}
			}
		}
		return false
	};
	this.collateNetworks = function() {
		if (this.data.nodes.length > 0) {
			var l = this.normalizeGraph({
				nodes: this.data.nodes,
				edges: this.data.edges
			});
			if (l.length > 1) {
				var b = [];
				for (var h = 0; h < l.length; h++) {
					b.push(h)
				}
				b.sort(function(j, i) {
					return l[i].nodes.length - l[j].nodes.length
				});
				this.subNetworks = [];
				for (var p = 0; p < l.length; p++) {
					var h = b[p];
					var d = [];
					var m = [];
					var g = l[h].nodes.length;
					var k = l[h].edges.length;
					var c = g / this.data.nodes.length;
					var o = c * (this.x * Math.log(l.length));
					var n = c * (this.y * Math.log(l.length));
					var e = o * n;
					for (var f = 0; f < l[h].nodes.length; f++) {
						d.push(l[h].nodes[f].id)
					}
					for (var f = 0; f < l[h].edges.length; f++) {
						if (typeof l[h].edges[f] != "function") {
							m.push(l[h].edges[f])
						}
					}
					this.subNetworks.push({
						nodes: d,
						edges: m,
						x: o,
						y: n,
						area: e,
						networkForceConstant: Math.sqrt(e / g),
						temperature: g + Math.floor(Math.sqrt(k)),
						minimumTemperature: 1,
						initialTemperature: g + Math.floor(Math.sqrt(k)),
						initialProgress: null,
						layoutProgress: 0,
						layoutDone: false
					})
				}
			}
		}
	};
	this.setObjectAttributes = function() {
		if (this.colorNodeBy) {
			this.setAllObjectAttributes("nodes", "color", this.colorNodeBy)
		}
		if (this.shapeNodeBy) {
			this.setAllObjectAttributes("nodes", "shape", this.shapeNodeBy)
		}
		if (this.sizeNodeBy) {
			this.setAllObjectAttributes("nodes", "size", this.sizeNodeBy)
		}
		if (this.sizeDecorationBy) {
			this.setAllObjectAttributes("nodes", "size", this.sizeDecorationBy, true)
		}
		if (this.colorEdgeBy) {
			this.setAllObjectAttributes("edges", "color", this.colorEdgeBy)
		}
		if (this.shapeEdgeBy) {
			this.setAllObjectAttributes("edges", "shape", this.shapeEdgeBy)
		}
		if (this.sizeEdgeBy) {
			this.setAllObjectAttributes("edges", "size", this.sizeEdgeBy)
		}
	};
	this.resetObjectAttributes = function() {
		this.colorNodeBy = false;
		this.shapeNodeBy = false;
		this.sizeNodeBy = false;
		this.sizeDecorationBy = false;
		this.colorEdgeBy = false;
		this.shapeEdgeBy = false;
		this.sizeEdgeBy = false
	};
	this.setDecorationsRangeUnits = function() {
		this.decorationsRange = [];
		var c = {};
		var d = {};
		if (this.showDecorations && this.decorations.length > 0) {
			var n = [];
			for (var l = 0; l < this.data.nodes.length; l++) {
				var f = this.data.nodes[l];
				for (var h = 0; h < this.decorations.length; h++) {
					if (f[this.decorations[h]] || (f.decorations && f.decorations[this.decorations[h]])) {
						var o = f[this.decorations[h]] ? f[this.decorations[h]] : f.decorations[this.decorations[h]];
						if (this.isObject(o)) {
							if (this.decorationsType == "stacked") {
								var q = 0;
								for (var g in o) {
									if (!isNaN(o[g])) {
										d[g] = true;
										q += o[g]
									}
								}
								n.push(q)
							} else {
								if (this.decorationsType == "stackedpercent") {
									for (var g in o) {
										if (!isNaN(o[g])) {
											d[g] = true
										}
									}
									n = [0, 100]
								} else {
									if (this.decorationsType == "heatmap") {
										for (var g in o) {
											if (!isNaN(o[g])) {
												d[g] = true;
												n.push(o[g])
											}
										}
									} else {
										alert("Ooops! canvasXpress does not support " + this.decorationsType + " for this multidimensional plotting");
										return
									}
								}
							}
						} else {
							if (!isNaN(f[this.decorations[h]]) || (f.decorations && !isNaN(f.decorations[this.decorations[h]]))) {
								n.push(f[this.decorations[h]] ? f[this.decorations[h]] : f.decorations[this.decorations[h]])
							}
						}
					}
				}
			}
			this.decorationsRange = this.range(n);
			if (this.decorationsType == "stacked") {
				this.decorationsRange[0] = 0
			}
			var b = this.decorationsRange[1] - this.decorationsRange[0];
			if (b == 0) {
				this.decorationsRange[1] = this.max(n) + 1
			}
			var m = this.decorationsType.match(/stacked/) ? this.decorationsRange[0] : this.decorationsRange[0] - (b * 0.05);
			if (m > 0) {
				this.decorationsRange[0] = m;
				b = this.decorationsRange[1] - this.decorationsRange[0]
			}
			this.decorationsUnits = this.decorationsHeight / b;
			if (!this.data.legend) {
				this.data.legend = {}
			}
			this.data.legend.decorations = [];
			for (var l = 0; l < this.decorations.length; l++) {
				if (this.decorationsColors[l]) {
					c[this.decorationsColors[l]] = true;
					this.data.legend.decorations.push({
						shape: this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].shape ? this.decorationsProperties[this.decorations[l]].shape : "circle",
						color: this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].color ? this.decorationsProperties[this.decorations[l]].color : this.decorationsColors[l],
						text: this.decorations[l],
						size: 0.5,
						font: 0.5
					})
				} else {
					for (var h = 0; h < this.colors.length; h++) {
						if (!c.hasOwnProperty(this.colors[h])) {
							var e = this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].color ? this.decorationsProperties[this.decorations[l]].color : this.colors[h];
							var p = this.decorationsProperties[this.decorations[l]] && this.decorationsProperties[this.decorations[l]].shape ? this.decorationsProperties[this.decorations[l]].shape : "circle";
							this.decorationsColors[l] = e;
							c[e] = true;
							this.data.legend.decorations.push({
								shape: p,
								color: e,
								text: this.decorations[l],
								size: 0.5,
								font: 0.5
							});
							break
						}
					}
				}
			}
			var l = this.decorations.length;
			for (var g in d) {
				if (this.decorationsColors[l]) {
					c[this.decorationsColors[l]] = true;
					this.data.legend.decorations.push({
						shape: this.decorationsProperties[g] && this.decorationsProperties[g].shape ? this.decorationsProperties[g].shape : "square",
						color: this.decorationsProperties[g] && this.decorationsProperties[g].color ? this.decorationsProperties[g].color : this.decorationsColors[l],
						text: g,
						size: 0.5,
						font: 0.5
					})
				} else {
					for (var h = 0; h < this.colors.length; h++) {
						if (!c.hasOwnProperty(this.colors[h])) {
							var e = this.decorationsProperties[g] && this.decorationsProperties[g].color ? this.decorationsProperties[g].color : this.colors[h];
							var p = this.decorationsProperties[g] && this.decorationsProperties[g].shape ? this.decorationsProperties[g].shape : "square";
							this.decorationsColors[l] = e;
							c[e] = true;
							this.data.legend.decorations.push({
								shape: p,
								color: e,
								text: g,
								size: 0.5,
								font: 0.5
							});
							break
						}
					}
				}
				l++
			}
		}
	};
	this.checkCalculateLayout = function() {
		if (!this.calculateLayout) {
			for (var b = 0; b < this.data.nodes.length; b++) {
				var c = this.data.nodes[b];
				if (this.is3DNetwork) {
					if (c.x3d == null || c.y3d == null) {
						this.calculateLayout = true;
						return
					}
				} else {
					if (c.x == null || c.y == null) {
						this.calculateLayout = true;
						return
					}
				}
			}
		}
	};
	this.recalculateLayout = function() {
		this.calculateLayout = true;
		this.initializeNetwork()
	};
	this.validateXYNodeCoordinates = function() {
		for (var b = 0; b < this.data.nodes.length; b++) {
			var c = this.data.nodes[b];
			if (this.is3DNetwork) {
				if (c.x3d == null) {
					c.x3d = -1
				}
				if (c.y3d == null) {
					c.y3d = -1
				}
			} else {
				if (c.x == null) {
					c.x = -1
				}
				if (c.y == null) {
					c.y = -1
				}
			}
		}
	};
	this.drawNetworkPlot = function() {
		this.showAnimationFont = (this.showAnimationFontSize) + "px " + this.fontName;
		this.setNodeParentHood();
		this.setObjectAttributes();
		this.setDecorationsRangeUnits();
		if (this.calculateLayout) {
			this.collateNetworks();
			this.setNetworkPrivateParams();
			if (this.networkLayoutType == "radial") {
				this.setRadialNetwrorkLayout()
			} else {
				this.optimizeNetworkLayout()
			}
			this.calculateLayout = false
		} else {
			this.validateXYNodeCoordinates();
			this.layoutDone = true;
			if (this.networkLayoutType == "radial" && this.showAnimation) {
				this.setRadialNetwrorkLayout()
			} else {
				this.renderNetwork()
			}
		}
		if (this.networkFreezeOnLoad && this.layoutDone) {
			this.networkFreezeOnLoad = false;
			this.networkFreeze = true
		}
	};
	this.initializeNetwork = function() {
		this.checkCalculateLayout();
		this.setNetworkDimensions();
		if (!this.nodes && this.data.nodes) {
			this.setNodes()
		}
		this.drawNetworkPlot()
	};
	if (!a) {
		this.initializeNetwork()
	}
};
CanvasXpress.prototype.Genome = function() {
	this.setGenomeSubtracks = function() {
		this.subtracks = [];
		this.subtracksInfo = [];
		this.y = this.margin;
		var a = this.marginTop + this.top;
		var G = 0;
		var C = this.xAxisMin * this.xAxisUnit;
		var u = this.xAxisMax * this.xAxisUnit;
		for (var I = 0; I < this.data.tracks.length; I++) {
			var g, q, K, n;
			var f = [];
			var A = [];
			var F = 0;
			var w = this.data.tracks[I];
			var d = w.data;
			var b = w.type ? w.type : this.featureTypeDefault;
			var J = w.height ? w.height : this.featureHeightDefault;
			var B = w.subtracksMax || this.subtracksMaxDefault;
			var L = w.bumpSpace ? w.bumpSpace : 0;
			if (!w.hide) {
				if (w.name && !w.hideName) {
					this.y += this.trackNameFontSize + (this.margin * 2)
				}
				w.startY = this.marginTop + this.top + this.y;
				this.subtracks[I] = [];
				if (this.featureStaggered) {
					for (var E = 0; E < d.length; E++) {
						var c = d[E];
						var p = this.shortenText(c.label || c.name || c.id, this.maxFeatureStringLen);
						var y = c.hideName || w.hideFeatureNames ? 0 : this.measureText(p, this.featureNameFont) + (this.margin * 3);
						var M = c.data;
						if (!c.hide) {
							c.index = E;
							c.counter = G++;
							if (b == "box") {
								g = this.getGenomeBoxRange(M);
								q = g[0] * this.xAxisUnit;
								K = (g[1] + L) * this.xAxisUnit;
								if (c.showDir && this.xAxisUnit > 0.001) {
									if (c.dir == "right") {
										K += 11
									} else {
										q -= 11
									}
								}
								K = Math.max(q + y, K)
							} else {
								if (b == "sequence") {
									var x = this.setGenomeGaps(c.gaps, c.sequence.length, c.dir);
									if (c.offsetLeft && !c.offset) {
										c.offset = (c.offsetLeft - (c.sequence.length + x.total)) + 1
									}
									q = c.offset * this.xAxisUnit;
									K = q + ((c.sequence.length + x.total + L) * this.xAxisUnit);
									K = Math.max(q + y, K)
								} else {
									q = (c.offset + L) * this.xAxisUnit;
									K = w.autowidth && this.isArray(M) ? q + (M[0].length * this.xAxisUnit) : q + w.width ? w.width : this.featureWidthDefault;
									K = Math.max(q + y, K)
								}
							}
							n = q >= C && q <= u ? true : K >= C && K <= u ? true : q <= C && K >= u ? true : false;
							f.push([q, K, n, E])
						}
					}
					if (f.length > 0) {
						f.sort(function(h, e) {
							return h[0] - e[0]
						});
						for (var E = 0; E < f.length; E++) {
							if (f[E][2]) {
								n = false;
								for (var D = 0; D < A.length; D++) {
									K = Math.round(A[D][A[D].length - 1][1]);
									if (Math.round(f[E][0]) >= K) {
										A[D].push(f[E]);
										n = true;
										break
									}
								}
								if (!n) {
									A.push([f[E]])
								}
							}
						}
						for (var E = 0; E < A.length; E++) {
							if (E < B) {
								this.subtracks[I][E] = [];
								F += A[E].length;
								var H = 0;
								var t = 0;
								var o = 0;
								for (var D = 0; D < A[E].length; D++) {
									c = d[A[E][D][3]];
									this.subtracks[I][E].push(A[E][D][3]);
									this.subtracksInfo[c.counter] = {
										track: I,
										subtrack: E,
										index: c.index,
										name: c.label || c.name || c.id,
										start: a + this.y
									};
									if (b == "box") {
										H = Math.max(H, this.getBoxFeatureHeight(c));
										t = Math.max(t, c.translatesTop || 0);
										o = Math.max(o, c.translatesBottom || 0)
									} else {
										if (b == "sequence") {
											H = Math.max(H, this.getSequenceFeatureHeight(c))
										}
									}
								}
								if (!this.isNameInSubtrack(w, this.subtracks[I][E])) {
									this.y += this.featureNameFontSize + this.margin
								}
								this.y += J + this.margin;
								if (b == "box" || b == "sequence") {
									this.y += H
								}
								for (var D = 0; D < A[E].length; D++) {
									c = d[A[E][D][3]];
									this.subtracksInfo[c.counter].end = a + this.y;
									this.subtracksInfo[c.counter].maxHeight = H;
									this.subtracksInfo[c.counter].translateTop = t;
									this.subtracksInfo[c.counter].translateBottom = o
								}
							}
						}
					}
				} else {
					for (var E = 0; E < d.length; E++) {
						var c = d[E];
						if (!c.hide) {
							c.index = E;
							c.counter = G++;
							if (E < B) {
								F++;
								this.subtracks[I][E] = [E];
								this.subtracksInfo[c.counter] = {
									track: I,
									subtrack: E,
									index: c.index,
									name: c.label || c.name || c.id,
									start: a + this.y
								};
								this.y += J + this.margin;
								if (b == "box") {
									this.subtracksInfo[c.counter].maxHeight = this.getBoxFeatureHeight(c);
									this.subtracksInfo[c.counter].translateTop = c.translatesTop || 0;
									this.subtracksInfo[c.counter].translateBottom = c.translatesBottom || 0;
									this.y += this.subtracksInfo[c.counter].maxHeight
								} else {
									if (b == "sequence") {
										this.subtracksInfo[c.counter].maxHeight = this.getSequenceFeatureHeight(c);
										this.y += this.subtracksInfo[c.counter].maxHeight
									}
								}
								this.subtracksInfo[c.counter].end = a + this.y
							}
						}
					}
				}
				w.endY = this.y;
				w.displayedFeatures = F;
				w.totalFeatures = d.length;
				this.y += (this.margin * 2)
			}
		}
	};
	this.isNameInSubtrack = function(a, e) {
		for (var c = 0; c < e.length; c++) {
			var d = e[c];
			var b = a.data[d];
			if (!b.hideName && !a.hideFeatureNames) {
				return false
			}
		}
		return true
	};
	this.getGenomeRange = function(a) {
		var f = [];
		var d = [];
		for (var e = 0; e < a.length; e++) {
			if (a[e].range) {
				f.push(a[e].range[0]);
				d.push(a[e].range[1])
			} else {
				var h = [];
				var g = a[e].data;
				if (this.isArray(g[0])) {
					for (var c = 0; c < g.length; c++) {
						for (var b = 0; b < g[c].length; b++) {
							h = h.concat(g[c][b])
						}
					}
				} else {
					for (var c = 0; c < g.length; c++) {
						h = h.concat(g[c])
					}
				}
				a[e].range = this.range(h);
				f.push(a[e].range[0]);
				d.push(a[e].range[1])
			}
		}
		return this.range([this.min(f), this.max(d)])
	};
	this.getGenomeBoxRange = function(c) {
		if (c) {
			var a = [];
			for (var b = 0; b < c.length; b++) {
				a.push(c[b][0]);
				a.push(c[b][1])
			}
			a.sort(function(e, d) {
				return e - d
			});
			return [a[0], a[a.length - 1]]
		} else {
			return [0, 1]
		}
	};
	this.setGenomeGaps = function(e, a, b) {
		var d = 0;
		var f = {
			total: d
		};
		if (e && this.isArray(e) && e.length > 0) {
			for (var c = 0; c < e.length; c++) {
				var h = b == "left" ? a - e[c][0] : e[c][0];
				f[h] = e[c][1];
				d += e[c][1]
			}
			f.total = d
		}
		return f
	};
	this.getBoxFeatureHeight = function(b) {
		if (this.genomeResolution != "low" && (b.translate || b.sequence)) {
			if (b.dir == "left" && !b.sequenceRC) {
				b.sequenceRC = this.getReverseComplement(b.sequence)
			}
			if (b.cds && !b.translate) {
				var a = b.cds[0] % 3 || 3;
				b.translate = b.dir == "left" ? [a * -1] : [a]
			}
			if (b.translate && !b.translateRC && this.featureTranslateShow) {
				b.translateRC = this.translate(b.translate, b.dir == "left" ? b.sequenceRC : b.sequence)
			}
			if (b.translate && this.genomeResolution == "high") {
				return this.featureTranslateHeight * b.translate.length
			}
		}
		return 0
	};
	this.getSequenceFeatureHeight = function(b) {
		var c = 0;
		if (this.genomeResolution == "high") {
			if (b.trace && this.featureTracesShow) {
				c += this.featureTraceHeight
			}
			if (b.translate && this.featureTranslateShow) {
				for (var a = 0; a < b.translate.length; a++) {
					c += this.featureTranslateHeight
				}
			}
			if (b.quality && this.featureQualityShow) {
				c += this.featureQualityHeight
			}
			if (b.signalToNoise && this.featureSignalToNoiseShow) {
				c += this.featureSignalToNoiseHeight
			}
			if (b.coordinate && this.featureCoordinateShow) {
				c += this.featureCoordinateHeight
			}
		} else {
			if (this.genomeResolution == "medium") {
				if (b.trace && this.featureTracesShow) {
					c += this.featureTraceHeight
				}
			}
		}
		return c
	};
	this.getReverseComplement = function(d) {
		var b = d.split("");
		var a = [];
		for (var c = 0; c < b.length; c++) {
			a.unshift(this.reverseComplement[b[c]] || b[c])
		}
		return a.join("")
	};
	this.translate = function(b, g) {
		var a = {
			top: [],
			bottom: []
		};
		var m = g.split("");
		var e = this.getReverseComplement(g).split("").reverse();
		for (var h = 0; h < b.length; h++) {
			var l = b[h];
			var f = {
				seq: [],
				off: 0,
				rf: b[h]
			};
			if (l == "-1") {
				f.off = e.length % 3;
				for (var d = e.length - 1; d >= 0; d -= 3) {
					var n = e[d] + e[d - 1] + e[d - 2];
					var k = this.codon[n.toUpperCase()];
					f.seq.unshift(k ? k[0] : "")
				}
				a.bottom.push(f)
			} else {
				if (l == "-2") {
					f.off = (e.length - 1) % 3;
					for (var d = e.length - 2; d >= 0; d -= 3) {
						var n = e[d] + e[d - 1] + e[d - 2];
						var k = this.codon[n.toUpperCase()];
						f.seq.unshift(k ? k[0] : "")
					}
					a.bottom.push(f)
				} else {
					if (l == "-3") {
						f.off = (e.length - 2) % 3;
						for (var d = e.length - 3; d >= 0; d -= 3) {
							var n = e[d] + e[d - 1] + e[d - 2];
							var k = this.codon[n.toUpperCase()];
							f.seq.unshift(k ? k[0] : "")
						}
						a.bottom.push(f)
					} else {
						if (l == "1") {
							f.off = 0;
							for (var d = 0; d < m.length; d += 3) {
								var n = m[d] + m[d + 1] + m[d + 2];
								var k = this.codon[n.toUpperCase()];
								f.seq.push(k ? k[0] : "")
							}
							a.top.push(f)
						} else {
							if (l == "2") {
								f.off = 1;
								for (var d = 1; d < m.length; d += 3) {
									var n = m[d] + m[d + 1] + m[d + 2];
									var k = this.codon[n.toUpperCase()];
									f.seq.push(k ? k[0] : "")
								}
								a.top.push(f)
							} else {
								if (l == "3") {
									f.off = 2;
									for (var d = 2; d < m.length; d += 3) {
										var n = m[d] + m[d + 1] + m[d + 2];
										var k = this.codon[n.toUpperCase()];
										f.seq.push(k ? k[0] : "")
									}
									a.top.push(f)
								}
							}
						}
					}
				}
			}
		}
		return a
	};
	this.setReverseTrace = function(j) {
		if (!j.reversed) {
			var d = j.A.length;
			var b = j.T.reverse();
			var m = j.G.reverse();
			var h = j.C.reverse();
			var f = j.A.reverse();
			var k = [];
			for (var e = 0; e < j.peak.length; e++) {
				k.unshift(d - j.peak[e])
			}
			j.A = b;
			j.C = m;
			j.G = h;
			j.T = f;
			j.peak = k;
			j.reversed = true
		}
	};
	this.getCoordinateStep = function() {
		var a = 1;
		if (this.xAxisUnit * 0.2 > this.sequenceFontSize) {
			a = 1
		} else {
			if (this.xAxisUnit * 0.5 > this.sequenceFontSize) {
				a = 5
			} else {
				if (this.xAxisUnit * 1 > this.sequenceFontSize) {
					a = 10
				} else {
					if (this.xAxisUnit * 200 > this.sequenceFontSize) {
						a = 20
					} else {
						if (this.xAxisUnit * 500 > this.sequenceFontSize) {
							a = 50
						} else {
							if (this.xAxisUnit * 1000 > this.sequenceFontSize) {
								a = 100
							} else {
								if (this.xAxisUnit * 2500 > this.sequenceFontSize) {
									a = 250
								} else {
									if (this.xAxisUnit * 5000 > this.sequenceFontSize) {
										a = 500
									} else {
										if (this.xAxisUnit * 2000 > this.sequenceFontSize) {
											a = 1000
										} else {
											if (this.xAxisUnit * 10000 > this.sequenceFontSize) {
												a = 5000
											} else {
												if (this.xAxisUnit * 20000 > this.sequenceFontSize) {
													a = 10000
												} else {
													if (this.xAxisUnit * 100000 > this.sequenceFontSize) {
														a = 50000
													} else {
														if (this.xAxisUnit * 200000 > this.sequenceFontSize) {
															a = 100000
														} else {
															if (this.xAxisUnit * 2000000 > this.sequenceFontSize) {
																a = 1000000
															} else {
																if (this.xAxisUnit * 20000000 > this.sequenceFontSize) {
																	a = 10000000
																} else {
																	if (this.xAxisUnit * 200000000 > this.sequenceFontSize) {
																		a = 100000000
																	} else {
																		if (this.xAxisUnit * 2000000000 > this.sequenceFontSize) {
																			a = 1000000000
																		} else {
																			if (this.xAxisUnit * 20000000000 > this.sequenceFontSize) {
																				a = 10000000000
																			} else {
																				if (this.xAxisUnit * 200000000000 > this.sequenceFontSize) {
																					a = 100000000000
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (this.xAxisRange / a > 10) {
			a *= (a * 0.1);
			while (a * 10 > this.xAxisRange) {
				a *= 0.1
			}
			return a
		} else {
			if (a * 3 > this.xAxisRange) {
				return a * 0.1
			} else {
				return a
			}
		}
	};
	this.getGenomeObjectColor = function(c, b, a, e) {
		if (b[c]) {
			return b[c]
		} else {
			if (a[c]) {
				return a[c]
			} else {
				if (this[c]) {
					return this[c]
				} else {
					if (e) {
						return e
					} else {
						return false
					}
				}
			}
		}
	};
	this.drawBoxSequenceName = function(k, b, e, p, n, j, c, r, d) {
		var l = this;
		var m = function(s, i) {
			var u = l.getGenomeObjectColor("featureDirColor", s, i);
			if (!u) {
				u = l.getGenomeObjectColor("featureFillColor", s, i);
				if (!u) {
					u = l.getGenomeObjectColor("fill", s, i, l.foreground)
				}
			}
			return u
		};
		var f = r.dir;
		var q = m(r, d);
		var g = this.getGenomeObjectColor("featureNameFontColor", r, d, this.foreground);
		var a = r.counter;
		var o = this.featureNameFontSize / 2;
		var h = this.measureText(b, this.featureNameFont) + this.margin;
		if (j >= this.xAxisMin && c <= this.xAxisMax) {
			e = n + e;
			this.addArea(this.drawText(b, e, p + o, this.featureNameFont, g, "left", "middle"), ["track-" + k + ":" + a])
		} else {
			if (j <= this.xAxisMin && c >= this.xAxisMin) {
				e = n;
				this.addArea(this.drawText(b, e, p + o, this.featureNameFont, g, "left", "middle"), ["track-" + k + ":" + a])
			} else {
				if ((j <= this.xAxisMax && c >= this.xAxisMax)) {
					e = n + e;
					this.addArea(this.drawText(b, e, p + o, this.featureNameFont, g, "left", "middle"), ["track-" + k + ":" + a])
				} else {
					e = n + e
				}
			}
		}
		if (f == "right") {
			this.drawShape("polygon", [e + h, e + h + (this.margin * 2), e + h], [p - 1, p + o - 1, p + (o * 2) - 1], false, false, q, q, "closed")
		} else {
			if (f == "left") {
				this.drawShape("polygon", [e + h, e + h + (this.margin * 2), e + h + (this.margin * 2)], [p + o - 1, p - 1, p + (o * 2) - 1], false, false, q, q, "closed")
			}
		}
	};
	this.drawGenomeLabels = function() {
		if (!this.featureStaggered) {
			var g = this;
			var h = function(j, i) {
				var k = g.getGenomeObjectColor("featureDirColor", j, i);
				if (!k) {
					k = g.getGenomeObjectColor("featureFillColor", j, i);
					if (!k) {
						k = g.getGenomeObjectColor("fill", j, i, g.foreground)
					}
				}
				return k
			};
			var z = this.marginLeft;
			var c = this.marginTop + this.top + this.margin;
			var b = this.featureNameFontSize / 2;
			var a = 0;
			for (var y = 0; y < this.data.tracks.length; y++) {
				var r = this.data.tracks[y];
				var d = r.type || this.featureTypeDefault;
				var p = r.height || this.featureHeightDefault;
				if (!r.hide) {
					if (r.name && !r.hideName) {
						c += this.trackNameFontSize + (this.margin * 2)
					}
					for (var w = 0; w < this.subtracks[y].length; w++) {
						var A = this.subtracks[y][w];
						if (!A) {
							continue
						}
						for (var t = 0; t < A.length; t++) {
							var o = A[t];
							var e = r.data[o];
							var x = e.counter;
							var u = this.getGenomeObjectColor("featureNameFontColor", e, r, this.foreground);
							var v = h(e, r);
							var m = this.shortenText(e.label || e.name || e.id, this.maxFeatureStringLen);
							var f = this.measureText(m, this.featureNameFont) + this.margin;
							if (!e.hideName && !r.hideFeatureNames) {
								this.addArea(this.drawText(m, this.marginLeft, c + (p / 2), this.featureNameFont, u, "left", "middle"), ["track-" + y + ":" + x])
							}
							if (d == "box" || d == "sequence") {
								if (e.dir == "right") {
									this.drawShape("polygon", [z + f, z + f + (this.margin * 2), z + f], [c, c + b, c + (b * 2)], false, false, v, v, "closed")
								} else {
									if (e.dir == "left") {
										this.drawShape("polygon", [z + f, z + f + (this.margin * 2), z + f + (this.margin * 2)], [c + b, c, c + (b * 2)], false, false, v, v, "closed")
									}
								}
								if (e.translate && this.genomeResolution == "high") {
									var n = (this.featureNameFontSize - 2) + "px " + this.fontName;
									a = -5;
									if (e.trace && this.featureTracesShow) {
										a += this.featureTraceHeight
									}
									if (e.translate && this.featureTranslateShow) {
										for (var s = 0; s < e.translate.length; s++) {
											var q = "+" + e.translate[s];
											if (q == "+1") {
												this.drawText(q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle");
												a += this.featureTranslateHeight
											} else {
												if (q == "+2") {
													this.drawText(q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle");
													a += this.featureTranslateHeight
												} else {
													if (q == "+3") {
														this.drawText(q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle");
														a += this.featureTranslateHeight
													}
												}
											}
										}
										a += this.sequenceFontSize + 2;
										for (var s = 0; s < e.translate.length; s++) {
											var q = e.translate[s];
											if (q == "-1") {
												this.drawText(q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle");
												a += this.featureTranslateHeight
											} else {
												if (q == "-2") {
													this.drawText(q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle");
													a += this.featureTranslateHeight
												} else {
													if (q == "-3") {
														this.drawText(q, this.marginLeft + this.left - 15, c + a + (p / 2), n, u, "left", "middle");
														a += this.featureTranslateHeight
													}
												}
											}
										}
									}
								}
								if (d == "box") {
									c += this.getBoxFeatureHeight(e)
								} else {
									c += this.getSequenceFeatureHeight(e)
								}
							}
							c += p + this.margin
						}
					}
					c += this.margin * 2
				}
			}
		}
	};
	this.setMinMaxGenome = function(c, a, b) {
		if (a != null) {
			c = Math.max(c, a)
		}
		if (b != null) {
			c = Math.min(c, b)
		}
		return c
	};
	this.plotGenomeData = function() {
		var A, z, ai, y, ag, x, g, U, C;
		var M = this.marginLeft + this.left;
		var a = this.marginTop + this.top;
		var af = this.xAxisUnit / 2;
		var P = this;
		var e = function(i, h) {
			var j = P.getGenomeObjectColor("featureDirColor", i, h);
			if (!j) {
				j = P.getGenomeObjectColor("featureFillColor", i, h);
				if (!j) {
					j = P.getGenomeObjectColor("fill", i, h, P.foreground)
				}
			}
			return j
		};
		this.setClipArea();
		for (var Z = 0; Z < this.data.tracks.length; Z++) {
			var E = this.data.tracks[Z];
			var ah = E.type || this.featureTypeDefault;
			var f = E.height || this.featureHeightDefault;
			var D = E.subtracksMax || this.subtracksMaxDefault;
			var G = this.setMaxY != null ? this.setMaxY : E.setMaxY != null ? E.setMaxY : null;
			var ae = this.setMinY != null ? this.setMinY : E.setMinY != null ? E.setMinY : null;
			var r = ah.match(/bar|heatmap|line/) && G != null && ae != null ? [G, ae] : ah.match(/bar|heatmap|line/) ? this.getGenomeRange(E.data) : false;
			var B = ah.match(/bar|line|box/) && E.fill ? E.fill : false;
			var F = ah.match(/bar|line|box/) && E.outline ? E.outline : this.foreground;
			var p = B ? "closed" : "open";
			var O = false;
			A = M;
			if (!E.hide) {
				if (r) {
					if (G != null) {
						r[1] = G
					}
					if (ae != null) {
						r[0] = ae
					}
					if (r[0] == r[1]) {
						r[1] += 0.1;
						C = f
					} else {
						U = (r[1] - r[0]) * 1.05;
						C = f / U
					}
				}
				var T = this.getColorBrew(this.colorSpectrum, r[0], r[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
				if (E.name && !E.hideName) {
					var w = E.name;
					if (E.displayedFeatures != E.totalFeatures) {
						w += " (Showing " + E.displayedFeatures + " out of " + E.totalFeatures + ")"
					}
					this.addArea(this.drawText(w, A, a + (this.trackNameFontSize / 2) + this.margin, this.trackNameFont, E.trackNameFontColor || this.trackNameFontColor, "left", "middle"), ["track-" + Z]);
					a += this.trackNameFontSize + (this.margin * 2)
				}
				if (E.highlight && this.genomeResolution != "low") {
					var aa = E.highlight;
					for (var X = 0; X < aa.length; X++) {
						if (aa[X].offset) {
							var ad = aa[X].color ? aa[X].color : this.colors[Z % this.colors.length];
							A = this.marginLeft + this.left + (((aa[X].offset - 0.5) - this.xAxisMin) * this.xAxisUnit);
							z = aa[X].width ? aa[X].width * this.xAxisUnit : this.xAxisUnit;
							this.rectangle(A, E.startY, z, (E.endY - E.startY) + f, ad, ad, "closed", false, false, true)
						}
					}
				}
				for (var X = 0; X < this.subtracks[Z].length; X++) {
					var u = this.subtracks[Z][X];
					if (!u) {
						continue
					}
					if (this.featureStaggered) {
						O = this.isNameInSubtrack(E, u)
					}
					for (var W = 0; W < u.length; W++) {
						var ac = u[W];
						var N = E.data[ac];
						var ab = N.data;
						var w = this.shortenText(N.label || N.name || N.id, this.maxFeatureStringLen);
						var J = this.getGenomeObjectColor("featureNameFontColor", N, E, this.foreground);
						if (ah == "box") {
							if (ab.length > 0) {
								this.setGenomeBoxExons(N);
								if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
									if (!N.hideName) {
										A = (((N.start - this.xAxisMin) * this.xAxisUnit)) - af;
										this.drawBoxSequenceName(Z, w, A, a, M, N.start, N.end, N, E)
									}
									a += this.featureNameFontSize + this.margin
								}
								this.drawGenomeBox(a, f, N, E);
								if (this.genomeResolution == "high" && N.translate && this.featureTranslateShow) {
									a += this.featureTranslateHeight * N.translate.length
								}
							}
						} else {
							if (ah == "sequence") {
								var v = this.setGenomeGaps(N.gaps, N.sequence.length, N.dir);
								if (N.offsetLeft && !N.offset) {
									N.offset = (N.offsetLeft - (N.sequence.length + v.total)) + 1
								}
								if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
									if (!N.hideName) {
										A = ((N.offset - this.xAxisMin) * this.xAxisUnit) - af;
										this.drawBoxSequenceName(Z, w, A, a, M, N.offset, N.offset + N.sequence.length + v.total, N, E)
									}
									a += this.featureNameFontSize + this.margin
								}
								if (this.genomeResolution == "high") {
									if (N.trace && this.featureTracesShow) {
										this.drawGenomeTrace(a, N.counter, this.featureTraceHeight - 1, N.offset, N.trace, v, N.dir);
										a += this.featureTraceHeight
									}
									this.drawGenomeSequence(a, f, v, N, E);
									a += f;
									if (N.translate && this.featureTranslateShow) {
										for (var V = 0; V < N.translate.length; V++) {
											a += this.featureTranslateHeight
										}
									}
									if (N.quality && this.featureQualityShow) {
										this.drawGenomeQuality(a, N.counter, this.featureQualityHeight - 1, N.offset, N.quality, v, N.dir, E);
										a += this.featureQualityHeight
									}
									if (N.signalToNoise && this.featureSignalToNoiseShow) {
										this.drawGenomeSignalToNoise(a, N.counter, this.featureSignalToNoiseHeight - 1, N.offset, N.signalToNoise, v, N.dir, E);
										a += this.featureSignalToNoiseHeight
									}
									if (N.coordinate && this.featureCoordinateShow) {
										this.drawGenomeCoordinate(a + 1, N.counter, this.featureCoordinateHeight - 1, N.offset, N.coordinate, N.sequence.length, v, N.dir, E);
										a += this.featureCoordinateHeight
									}
									a -= f
								} else {
									if (this.genomeResolution == "medium") {
										if (N.trace && this.featureTracesShow) {
											this.drawGenomeTrace(a, N.counter, this.featureTraceHeight - 1, N.offset, N.trace, v, N.dir);
											a += this.featureTraceHeight
										}
										this.drawGenomeSequence(a, f, v, N, E);
										if (N.coordinate && this.featureCoordinateShow) {
											this.drawGenomeCoordinate(a + 1, N.counter, this.featureCoordinateHeight - 1, N.offset, N.coordinate, N.sequence.length, v, N.dir, E)
										}
									} else {
										this.drawGenomeSequence(a, f, v, N, E);
										if (N.coordinate && this.featureCoordinateShow) {
											this.drawGenomeCoordinate(a + 1, N.counter, this.featureCoordinateHeight - 1, N.offset, N.coordinate, N.sequence.length, v, N.dir, E)
										}
									}
								}
							} else {
								if (ah == "bar") {
									var n;
									if (this.genomeResolution == "high") {
										n = this.xAxisUnit / ab.length
									} else {
										n = E.autowidth ? this.xAxisUnit : N.width ? N.width : E.width ? E.width : this.featureWidthDefault
									}
									var Y = n * ab.length;
									A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit) - ((Y / 2) + 1);
									if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
										if (!N.hideName) {
											this.addArea(this.drawText(w, A, a + (this.featureNameFontSize / 2), this.featureNameFont, J, "left", "middle", false, false, false, true), ["track-" + Z + ":" + N.counter])
										}
										a += this.featureNameFontSize + this.margin
									}
									this.addArea(["rect", A, a, A + (ab.length * n), a + f], [N.counter]);
									z = A;
									var b = r[1] < 0 ? a : r[0] >= 0 ? a + f : (a + f) - Math.abs(r[0] * C);
									for (var R = 0; R < ab.length; R++) {
										var m = N.fill || B;
										var Q = N.outline || F;
										var L = this.isArray(m) && m.length == ab.length ? m[R] : this.isArray(m) ? m[0] : this.foreground;
										var t = this.isArray(Q) && Q.length == ab.length ? Q[R] : this.isArray(Q) ? Q[0] : this.foreground;
										var aa = ab[R] * C;
										if (ab[R]) {
											if (aa > 0) {
												this.rectangle(z, b - aa, n, aa, L, t, "closed", false, false, true)
											} else {
												this.rectangle(z, b, n, -aa, L, t, "closed", false, false, true)
											}
										}
										if (E.autowidth) {
											z += n
										} else {
											z += n + 2
										}
									}
								} else {
									if (ah == "heatmap") {
										var n;
										if (this.genomeResolution == "high") {
											n = this.xAxisUnit
										} else {
											n = E.autowidth ? this.xAxisUnit : N.width ? N.width : E.width ? E.width : this.featureWidthDefault
										}
										A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit) - ((n / 2) + 1);
										if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
											if (!N.hideName) {
												this.addArea(this.drawText(w, A, a + (this.featureNameFontSize / 2), this.featureNameFont, J, "left", "middle", false, false, false, true), ["track-" + Z + ":" + N.counter])
											}
											a += this.featureNameFontSize + this.margin
										}
										this.addArea(["rect", A, a, A + n, a + f], [N.counter]);
										var aa = E.autowidth ? f : f / ab.length;
										ai = a;
										for (var R = 0; R < ab.length; R++) {
											var I = ab[R];
											var o = this.getColorForValue(T, I);
											if (isNaN(I)) {
												this.rectangle(A, ai, n, aa, this.missingDataColor, this.missingDataColor, "closed", false, false, true)
											} else {
												this.rectangle(A, ai, n, aa, o, o, "closed", false, false, true)
											}
											if (E.autowidth) {
												A += n
											} else {
												ai += aa
											}
										}
									} else {
										if (ah == "line") {
											var n = E.autowidth ? this.xAxisUnit : N.width ? N.width : E.width ? E.width : this.featureWidthDefault;
											A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit);
											if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
												if (!N.hideName) {
													this.addArea(this.drawText(w, A, a + (this.featureNameFontSize / 2), this.featureNameFont, J, "left", "middle", false, false, false, true), ["track-" + Z + ":" + N.counter])
												}
												a += this.featureNameFontSize + this.margin
											}
											if (this.isArray(ab[0])) {
												var d = 0;
												for (var S = 0; S < ab.length; S++) {
													d = Math.max(ab[S].length, d)
												}
												this.addArea(["rect", A, a, A + (d * n), a + f], [N.counter]);
												for (var S = 0; S < ab.length; S++) {
													A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit);
													var t = this.isArray(F) && F[S] ? F[S] : this.foreground;
													for (var R = 0; R < ab[S].length - 1; R++) {
														var K = this.setMinMaxGenome((ab[S][R] - r[0]), ae, G) * C;
														var H = this.setMinMaxGenome((ab[S][R + 1] - r[0]), ae, G) * C;
														this.drawLine("line", A, f + a - K, A + n, f + a - H, t, false, "butt", false, false, true);
														if (E.autowidth) {
															A += n
														} else {
															A += n + 2
														}
													}
												}
											} else {
												this.addArea(["rect", A, a, A + (ab.length * n), a + f], [N.counter]);
												var t = this.isArray(F) ? F[0] : this.foreground;
												for (var R = 0; R < ab.length - 1; R++) {
													var K = this.setMinMaxGenome((ab[R] - r[0]), ae, G) * C;
													var H = this.setMinMaxGenome((ab[R + 1] - r[0]), ae, G) * C;
													this.drawLine("line", A, f + a - K, A + n, f + a - H, t, false, "butt", false, false, true);
													if (E.autowidth) {
														A += n
													} else {
														A += n + 2
													}
												}
											}
										} else {
											if (ah == "triangle") {
												A = this.marginLeft + this.left + ((N.offset - this.xAxisMin) * this.xAxisUnit);
												B = N.fill ? N.fill : this.foreground;
												F = N.outline ? N.outline : this.foreground;
												if (this.featureStaggered && !E.hideFeatureNames && (!N.hideName || !O)) {
													if (!N.hideName) {
														this.addArea(this.drawText(w, A, a + (this.featureNameFontSize / 2), this.featureNameFont, J, "left", "middle", false, false, false, true), ["track-" + Z + ":" + N.counter])
													}
													a += this.featureNameFontSize + this.margin
												}
												this.addArea(this.drawShape("triangle", A, a + (f / 2), f, f, B, F, "closed", false, false, true), [N.counter])
											}
										}
									}
								}
							}
						}
						if (this.featureStaggered) {
							if (W < u.length - 1) {
								if (!O) {
									a -= (this.featureNameFontSize + this.margin)
								}
								if (ah == "box") {
									a -= this.getBoxFeatureHeight(N)
								} else {
									if (ah == "sequence") {
										a -= this.getSequenceFeatureHeight(N)
									}
								}
							}
						}
					}
					a += f + this.margin
				}
				a += this.margin * 2
			}
		}
		this.resetClipArea()
	};
	this.setGenomeBoxExons = function(b) {
		var e = b.data;
		if (!b.start || !b.end) {
			b.start = e[0][0];
			b.end = e[e.length - 1][1];
			if (b.sequence) {
				var g = b.dir == "left" ? b.sequence.length : 1;
				for (var a = 0; a < e.length; a++) {
					if (e[a].length == 2) {
						var f = e[a][1] - e[a][0];
						if (b.dir == "left") {
							b.data[a].push(g - f, g)
						} else {
							b.data[a].push(g, g + f)
						}
					}
					g = b.dir == "left" ? g - (f + 1) : g + f + 1
				}
			}
		}
	};
	this.setGenomeBoxArea = function(g, h, i) {
		if (!i.insertion) {
			var c = this.marginLeft + this.left;
			var d = this.xAxisUnit / 2;
			var e = this.xAxisUnit / 4;
			var b = (((i.start - this.xAxisMin) * this.xAxisUnit) - d);
			var a = (((i.end - this.xAxisMin) * this.xAxisUnit) + d);
			var f = this.subtracksInfo[i.counter].maxHeight;
			if (i.showDir && this.xAxisUnit > 0.001) {
				if (i.dir == "right") {
					this.addArea(["rect", c + b, g, c + a + 10, g + h + f], [i.counter])
				} else {
					this.addArea(["rect", (c + b) - 10, g, c + a, g + h + f], [i.counter])
				}
			} else {
				this.addArea(["rect", c + b, g, c + a, g + h + f], [i.counter])
			}
		}
	};
	this.drawGenomeBoxLines = function(d, j, h, k) {
		var q, p, o, n;
		var a = h.scaleHeight ? h.scaleHeight : 1;
		var c = d + ((j * a) / 2);
		var b = h.dir == "right" ? d : d + (j * a);
		var e = this.marginLeft + this.left;
		var r = e + this.x;
		var s = h.data;
		var g = this.validateColor(h.fill || h.connect || k.connect || this.foreground);
		var f = this.xAxisUnit / 2;
		var m = [];
		for (var l = 0; l < s.length; l++) {
			q = (((s[l][0] - this.xAxisMin) * this.xAxisUnit) - f);
			p = ((((s[l][1] - this.xAxisMin) * this.xAxisUnit) + f) - q);
			if (!h.insertion && (k.connect || h.connect)) {
				if (l < s.length - 1) {
					o = ((s[l + 1][0] - this.xAxisMin) * this.xAxisUnit);
					n = (q + p + o + 1 - f) / 2;
					if (Math.floor(o - (p + q)) > 2 && e + q + p < r && e + o > e) {
						if (Math.abs(b - c) < 3) {
							this.drawLine("line", e + q + p + 1, c + j - (j * a), e + o, c + j - (j * a), g, false, "butt", false, false, true)
						} else {
							this.drawLine("line", e + q + p + 1, c + j - (j * a), e + n, b + j - (j * a), g, false, "butt", false, false, true);
							this.drawLine("line", e + n, b + j - (j * a), e + o - f, c + j - (j * a), g, false, "butt", false, false, true)
						}
					}
				}
			}
			if (h.insertion) {
				q = ((((s[l][0] + s[l][1]) / 2) - this.xAxisMin) * this.xAxisUnit);
				m.push([e + q, (d + j) - (j * a) + ((j * a) / 2), f / 2, (j * a)])
			} else {
				m.push([e + q, (d + j) - (j * a), p, (j * a)])
			}
		}
		if (h.showDir && this.xAxisUnit > 0.001 && !h.insertion) {
			g = this.validateColor(h.showDir) || g;
			q = e + (((h.start - this.xAxisMin) * this.xAxisUnit)) - f;
			p = e + (((h.end - this.xAxisMin) * this.xAxisUnit)) + f;
			o = 10;
			n = 5;
			if (h.dir == "right") {
				if (p < r && p + o > e) {
					this.drawLine("line", p, c, p + o, c, g, false, "butt", false, false, true);
					this.drawLine("line", p + n, c - (j / 3), p + o, c, g, false, "butt", false, false, true);
					this.drawLine("line", p + n, c + (j / 3), p + o, c, g, false, "butt", false, false, true)
				}
			} else {
				if (q - o < r && q > e) {
					this.drawLine("line", q, c, q - o, c, g, false, "butt", false, false, true);
					this.drawLine("line", q - n, c - (j / 3), q - o, c, g, false, "butt", false, false, true);
					this.drawLine("line", q - n, c + (j / 3), q - o, c, g, false, "butt", false, false, true)
				}
			}
		}
		return m
	};
	this.drawGenomeBoxAlleles = function(e, s, d, q, f) {
		var n = q / f.length;
		for (var m = 0; m < f.length; m++) {
			var r = f[m].split("");
			var g = (d - e) / r.length;
			var p = s + (n * m);
			for (var k = 0; k < r.length; k++) {
				var b = e + (g * k);
				if (r[k] == "-") {
					r[k] = "Gap"
				}
				var o = "sequence" + r[k].toUpperCase() + "Color";
				this.rectangle(b, p, g, n, this[o], this[o], "closed", false, false, true)
			}
		}
	};
	this.drawGenomeBox = function(d, v, m, x) {
		var q = this;
		var a = {};
		var s = function() {
			if (q.genomeResolution != "low" && m.sequence) {
				return m.dir == "left" ? m.sequenceRC.split("") : m.sequence.split("")
			} else {
				return false
			}
		};
		var A = this.validateColor(m.fill || m.connect || x.fill || x.connect || this.foreground);
		var F = m.outline || x.outline || A;
		var o = A ? "closed" : "open";
		var B = this.xAxisUnit / 2;
		var u = this.sequenceFontSize > v ? (v - 3) + "px " + this.fontName : this.sequenceFont;
		var r = s();
		var f = m.translateRC;
		var p = m.data;
		var g = this.marginLeft + this.left;
		var G = g + this.x;
		this.setGenomeBoxArea(d, v, m);
		if (this.genomeResolution == "high" && f) {
			d += f.top.length * this.featureTranslateHeight
		}
		var w = this.drawGenomeBoxLines(d, v, m, x);
		for (var C = 0; C < w.length; C++) {
			var E = w[C][0];
			var D = E + w[C][2];
			if (Math.floor(D - E) < 3) {
				var z = parseInt(D);
				if (a.hasOwnProperty(z)) {
					continue
				}
				a[z] = true;
				a[z + 1] = true
			}
			if (E < G && D > g) {
				if (this.genomeResolution != "low" && m.alleles && m.alleles[C] && !m.insertion) {
					this.drawGenomeBoxAlleles(E, d, D, v, m.alleles[C])
				}
				if (!f || this.genomeResolution != "high") {
					if (m.insertion) {
						var c = m.dir == "left" ? "triangle" : "triangle2";
						this.drawShape(c, w[C][0], w[C][1], w[C][2], w[C][3], A, F, o, false, false, true);
						this.addArea(["rect", w[C][0] - (w[C][2] / 2), w[C][1] - (w[C][3] / 2), w[C][0] + (w[C][2] / 2), w[C][1] + (w[C][3] / 2)], [m.counter])
					} else {
						if (this.genomeResolution != "low" && m.sequence && (m.sequenceFill || x.sequenceFill || this.sequenceFill)) {
							this.rectangle(w[C][0], w[C][1], w[C][2], w[C][3], m.sequenceFill || x.sequenceFill || this.sequenceFill, F, o, false, false, true)
						} else {
							this.rectangle(w[C][0], w[C][1], w[C][2], w[C][3], A, F, o, false, false, true)
						}
					}
				}
				if (this.genomeResolution != "low" && m.sequence && !m.insertion) {
					var e = {};
					var b = p[C][0];
					var n = p[C][1];
					var H = m.dir == "left" ? r.length - p[C][3] + 1 : p[C][2];
					var h = m.dir == "left" ? r.length - p[C][2] + 1 : p[C][3];
					var l = H - 3;
					if (n - b != h - H) {
						this.errors.push("Exon length for segment " + C + " in feature " + m.id + "is different to the box dimmension")
					}
					if (r.length > 0) {
						E += B;
						for (var y = H; y <= h; y++) {
							var t = r[y - 1];
							if (!t) {
								this.errors.push("Nucleotide " + y + " in exon " + (C + 1) + " in feature " + m.id + "not specified")
							}
							if (t) {
								var k = "sequence" + t.toUpperCase() + "Color";
								if (this.genomeResolution == "high") {
									if (f && (!m.cds || (m.cds && y >= m.cds[0] && y <= m.cds[1]))) {
										this.drawTranslationTop(f, E, d, B, l, F, u, 0, e);
										this.drawText(t, E, d + (v / 2), u, this[k], "center", "middle", false, false, false, true);
										this.drawTranslationBottom(f, E, d, B, l, F, u, 0, e)
									} else {
										this.drawText(t, E, d + (v / 2), u, this[k], "center", "middle", false, false, false, true)
									}
								} else {
									this.rectangle(E - 0.5, d + 1, 1, v - 2, this[k], this[k], "closed", false, false, true)
								}
							} else {
								if (this.genomeResolution == "high") {
									this.drawText("-", E, d + (v / 2), u, this.missingDataColor, "center", "middle", false, false, false, true)
								} else {
									this.rectangle(E - 0.5, d + 1, 1, v - 2, this.missingDataColor, this.missingDataColor, "closed", false, false, true)
								}
							}
							l++;
							E += this.xAxisUnit
						}
					}
				}
			}
		}
	};
	this.drawGenomeTrace = function(b, m, q, f, z, t, s) {
		if (this.genomeResolution != "low") {
			if (s == "left" && !z.reversed) {
				this.setReverseTrace(z)
			}
			var o = [];
			var g = ["A", "C", "G", "T"];
			var D = this.marginLeft + this.left + (((f - 1) - this.xAxisMin) * this.xAxisUnit);
			var u = this.marginLeft + this.left;
			var p = this.marginLeft + this.left + this.x;
			var a = b + q;
			if (z.max == null) {
				for (var A = 0; A < g.length; A++) {
					o = o.concat(z[g[A]])
				}
				if (this.meta.system.browser == "Firefox") {
					o = this.radixSort(o)
				} else {
					o.sort(function(j, i) {
						return j - i
					})
				}
				var B = Math.floor(o.length * this.featureTraceTrim / 100);
				z.max = o[o.length - (B + 1)]
			}
			var v = q / z.max;
			var e = g.length;
			for (var A = 0; A < e; A++) {
				var c = 0;
				var h = [];
				var y = [];
				var C = D;
				var d = "sequence" + g[A].toUpperCase() + "Color";
				var F = z.peak.length;
				for (var x = 0; x < F; x++) {
					if (C > u - this.xAxisUnit && C < p) {
						var n = this.xAxisUnit / (z.peak[x] - c);
						if (t[x]) {
							var E = Math.floor((z.peak[x] - c) / 2);
							for (var w = c; w < (z.peak[x] - E); w++) {
								h.push(C);
								y.push(a - (Math.min(z.max, z[g[A]][w]) * v));
								C += n
							}
							c += E;
							if (h.length > 1 && y.length > 1) {
								this.drawShape("path", h, y, false, false, this[d], this[d], "open", false, false, true)
							}
							h = [];
							y = [];
							for (var w = 0; w < t[x]; w++) {
								C += this.xAxisUnit
							}
						}
						for (var w = c; w <= z.peak[x]; w++) {
							h.push(C);
							y.push(a - (Math.min(z.max, z[g[A]][w]) * v));
							C += n
						}
						C -= n;
						c = z.peak[x]
					} else {
						if (t[x]) {
							for (var w = 0; w < t[x]; w++) {
								C += this.xAxisUnit
							}
						}
						c = z.peak[x];
						C += this.xAxisUnit
					}
				}
				if (C > u - this.xAxisUnit && C < p) {
					for (var w = c; w < z[g[A]].length; w++) {
						h.push(C);
						y.push(a - (Math.min(z.max, z[g[A]][w]) * v));
						C += n
					}
				}
				if (h.length > 1 && y.length > 1) {
					this.drawShape("path", h, y, false, false, this[d], this[d], "open", false, false, true)
				}
			}
		}
	};
	this.drawTranslationTop = function(p, b, k, f, j, n, m, o, d) {
		if (p.top && p.top.length > 0) {
			for (var e = 0; e < p.top.length; e++) {
				y1 = k - ((p.top.length - e) * this.featureTranslateHeight);
				var g = p.top[e];
				if (j - g.off >= 0 && (j - g.off) % 3 == 0) {
					var a = g.seq[Math.floor((j - g.off) / 3)];
					var l = j % 2 ? this.oddColor : this.evenColor;
					if (a == "M") {
						l = this.sequenceStartColor
					} else {
						if (a == "*") {
							l = this.sequenceEndColor
						}
					}
					if (!d[g.rf]) {
						d[g.rf] = b - (this.xAxisUnit * (o + 2.5))
					}
					x0 = (b - d[g.rf]) + f;
					this.rectangle(d[g.rf], y1, x0, this.featureTranslateHeight, l, n, "closed", false, false, true);
					this.drawText(a, d[g.rf] + (x0 / 2), y1 + (this.featureTranslateHeight / 2) + 1, m, this.foreground, "center", "middle", false, false, false, true);
					d[g.rf] = b + f
				}
			}
		}
	};
	this.drawTranslationBottom = function(p, b, k, f, j, n, m, o, d) {
		if (p.bottom && p.bottom.length > 0) {
			for (var e = 0; e < p.bottom.length; e++) {
				y1 = k + ((e + 1) * this.featureTranslateHeight);
				var g = p.bottom[e];
				if (j - g.off >= 0 && (j - g.off) % 3 == 0) {
					var a = g.seq[Math.floor((j + g.off + 1) / 3)];
					var l = j % 2 ? this.oddColor : this.evenColor;
					if (a == "M") {
						l = this.sequenceStartColor
					} else {
						if (a == "*") {
							l = this.sequenceEndColor
						}
					}
					if (!d[g.rf]) {
						d[g.rf] = b - (this.xAxisUnit * (o + 2.5))
					}
					x0 = (b - d[g.rf]) + f;
					this.rectangle(d[g.rf], y1, x0, this.featureTranslateHeight, l, n, "closed", false, false, true);
					this.drawText(a, d[g.rf] + (x0 / 2), y1 + (this.featureTranslateHeight / 2) + 1, m, this.foreground, "center", "middle", false, false, false, true);
					d[g.rf] = b + f
				}
			}
		}
	};
	this.drawGenomeSequence = function(a, d, m, y, u) {
		var f = y.counter;
		var t = y.fill ? y.fill : u.fill ? u.fill : this.background;
		var v = y.outline || this.foreground;
		var k = t ? "closed" : "open";
		var e = this.sequenceFontSize > d ? (d - 3) + "px " + this.fontName : this.sequenceFont;
		var D = y.offset;
		var M = y.sequence;
		var P = y.sequenceRC;
		var C = y.translate;
		var L = y.translateRF;
		var O = y.dir;
		if (O == "left" && !P) {
			P = M;
			M = this.getReverseComplement(M)
		}
		if (C && !L) {
			L = C;
			C = this.translate(C, M)
		}
		var g = M.split("");
		var q = this.marginLeft + this.left + ((D - this.xAxisMin) * this.xAxisUnit);
		var I = this.marginLeft + this.left;
		var G = this.marginLeft + this.left + this.x;
		var p = (g.length + m.total) * this.xAxisUnit;
		var H = 0;
		var F = u.subtype.match(/DNA|RNA/) ? 1 : 3;
		var E = this.xAxisUnit * 4;
		var K = this.xAxisUnit / 2;
		var N = -2;
		var w = {};
		var Q = a;
		var B = 0;
		var z = 0;
		var A = this;
		if (this.genomeResolution == "high") {
			var o = q + (H * this.xAxisUnit);
			if (C) {
				a += C.top.length * this.featureTranslateHeight
			}
			while (g.length > 0) {
				if (o > I - E && o < G + E) {
					var b = g.shift();
					if (b == "[") {
						b = g.shift();
						var x = [];
						while (b != "]") {
							x.push(b);
							b = g.shift()
						}
						this.drawText(x.join("/"), q + (H * this.xAxisUnit), a + (d / 2), e, this.sequenceMColor, "center", "middle", false, false, false, true)
					} else {
						var j = "sequence" + b.toUpperCase() + "Color";
						if (C) {
							this.drawTranslationTop(C, o, a, K, N, v, e, z, w);
							this.drawText(b, o, a + (d / 2), e, this[j], "center", "middle", false, false, false, true);
							this.drawTranslationBottom(C, o, a, K, N, v, e, z, w)
						} else {
							this.drawText(b, o, a + (d / 2), e, this[j], "center", "middle", false, false, false, true)
						}
					}
					H += F;
					o = q + ((H + B) * this.xAxisUnit);
					N++;
					z = 0;
					if (m[parseInt(H / F)]) {
						for (var J = 0; J < m[parseInt(H / F)]; J++) {
							this.drawText("-", o, a + (d / 2), e, this.missingDataColor, "center", "middle", false, false, false, true);
							B++;
							z++;
							o = q + ((H + B) * this.xAxisUnit)
						}
					}
				} else {
					g.shift();
					H += F;
					o = q + ((H + B) * this.xAxisUnit);
					N++;
					z = 0;
					if (m[parseInt(H / F)]) {
						for (var J = 0; J < m[parseInt(H / F)]; J++) {
							B++;
							z++;
							o = q + ((H + B) * this.xAxisUnit)
						}
					}
				}
			}
		} else {
			q = this.marginLeft + this.left + (((D - 0.5) - this.xAxisMin) * this.xAxisUnit);
			this.rectangle(q, a, p, d, t, v, "closed", false, false, true);
			for (var J in m) {
				q = this.marginLeft + this.left + ((((D - 0.5) + parseInt(J) + z) - this.xAxisMin) * this.xAxisUnit);
				p = m[J] * this.xAxisUnit;
				z += m[J];
				this.rectangle(q, a, p, d, this.missingDataColor, v, k, false, false, true)
			}
		}
		this.addArea(["rect", q, a, p, a + d], [f])
	};
	this.drawGenomeQuality = function(a, f, p, d, c, v, q, t) {
		if (this.genomeResolution != "low") {
			var h = q == "left" ? this.cloneObject(c).reverse() : c;
			var m = this.range(h);
			var C = this.getColorBrew(this.colorSpectrum, m[0], m[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			var B = this.marginLeft + this.left + (((d - 0.5) - this.xAxisMin) * this.xAxisUnit);
			var x = this.marginLeft + this.left;
			var o = this.marginLeft + this.left + this.x;
			var A = B;
			var u = 0;
			var k = t.subtype.match(/DNA|RNA/) ? 1 : 3;
			var g = k * this.xAxisUnit;
			var e = (this.featureQualityHeight - 3) + "px " + this.fontName;
			for (var z = 0; z < h.length; z++) {
				if (A + g > x && A < o) {
					if (v[z]) {
						for (var y = 0; y < v[z]; y++) {
							A += g
						}
					}
					var b = this.getColorForValue(C, h[z]);
					this.rectangle(A, a, g, p, b, b, "closed", false, false, true);
					if (A > x && this.genomeResolution == "high" && this.featureQualityValues) {
						this.drawText(h[z], A + (g / 2), a + (p / 2), e, this.foreground, "center", "middle", false, false, false, true)
					}
				}
				A += g
			}
			this.addArea(["rect", B, a, B + A, a + p], [f])
		}
	};
	this.drawGenomeSignalToNoise = function(a, f, o, d, z, u, p, q) {
		if (this.genomeResolution != "low") {
			var c = p == "left" ? this.cloneObject(z).reverse() : z;
			var k = this.range(c);
			var C = this.getColorBrew(this.colorSpectrum, k[0], k[1], this.colorSpectrumZeroValue, this.colorSpectrumBreaks);
			var B = this.marginLeft + this.left + (((d - 0.5) - this.xAxisMin) * this.xAxisUnit);
			var v = this.marginLeft + this.left;
			var m = this.marginLeft + this.left + this.x;
			var A = B;
			var t = 0;
			var h = q.subtype.match(/DNA|RNA/) ? 1 : 3;
			var g = h * this.xAxisUnit;
			var e = (this.featureSignalToNoiseHeight - 3) + "px " + this.fontName;
			for (var y = 0; y < c.length; y++) {
				if (A + g > v && A < m) {
					if (u[y]) {
						for (var x = 0; x < u[y]; x++) {
							A += g
						}
					}
					var b = this.getColorForValue(C, c[y]);
					this.rectangle(A, a, g, o, b, b, "closed", false, false, true);
					if (A > v && this.genomeResolution == "high" && this.featureSignalToNoiseValues) {
						this.drawText(c[y], A + (g / 2), a + (o / 2), e, this.foreground, "center", "middle", false, false, false, true)
					}
				}
				A += g
			}
			this.addArea(["rect", B, a, B + A, a + o], [f])
		}
	};
	this.drawGenomeCoordinate = function(a, g, m, e, C, b, x, p, u) {
		if (this.genomeResolution != "low") {
			var A = this.marginLeft + this.left + ((e - this.xAxisMin) * this.xAxisUnit);
			var y = this.marginLeft + this.left;
			var k = this.marginLeft + this.left + this.x;
			var v = C;
			var j = u.subtype.match(/DNA|RNA/) ? 1 : 3;
			var h = j * this.xAxisUnit;
			var B = this.getCoordinateStep();
			var o = b + x.total;
			var i = C + o;
			var f = (m - 3) + "px " + this.fontName;
			if (p == "left") {
				var z = A + ((o - 1) * h);
				while (C < i - x.total) {
					if (x[(o - (C - v)) - 2]) {
						z -= (h * x[(o - (C - v)) - 2])
					}
					if (z > y && z < k) {
						if (C % B == 0) {
							this.drawText(C, z, a + (m / 2), f, this.foreground, "center", "middle")
						}
					}
					z -= h;
					C++
				}
			} else {
				var z = A;
				while (C < i - x.total) {
					if (x[C - v]) {
						z += (h * x[C - v])
					}
					if (z > y && z < k) {
						if (C % B == 0) {
							this.drawText(C, z, a + (m / 2), f, this.foreground, "center", "middle")
						}
					}
					z += h;
					C++
				}
			}
		}
	};
	this.setGenomeWireFrame = function() {
		var b = this.marginLeft + this.left;
		var a = this.marginLeft + this.left + this.x;
		var f = this.getCoordinateStep();
		var g = Math.floor(this.xAxisMin);
		var e = this.getFontPt(this.featureNameFont) / 2;
		if (this.genomeResolution == "low") {
			f *= 5
		}
		while (b <= a) {
			b = this.marginLeft + this.left + ((g - this.xAxisMin) * this.xAxisUnit);
			if (g % f == 0) {
				if (this.xAxisTickStyle == "dotted") {
					this.drawLine("dottedLine", b, this.marginTop + this.top, b, this.marginTop + this.top + this.y, this.wireColor, false, "butt", false, false, true)
				} else {
					this.drawLine("line", b, this.marginTop + this.top, b, this.marginTop + this.top + this.y, this.wireColor, false, "butt", false, false, true)
				}
			}
			g++
		}
	};
	this.setGenomeTicks = function() {
		var e = this.marginLeft + this.left;
		var b = this.marginLeft + this.left + this.x;
		var f = this.marginLeft + this.left;
		var h = this.getCoordinateStep();
		var i = Math.floor(this.xAxisMin);
		var g = this.getFontPt(this.featureNameFont) / 2;
		if (this.genomeResolution == "low") {
			h *= 5
		}
		while (e <= b) {
			e = this.marginLeft + this.left + ((i - this.xAxisMin) * this.xAxisUnit);
			if (i % h == 0) {
				var a = this.measureText(i.toString(), this.featureNameFont);
				if (e >= f) {
					this.drawText(i.toString(), e, this.marginTop + this.top + this.y + this.margin + g, this.featureNameFont, this.xAxisTickColor, "center", "middle");
					f = e + (a * 1.5)
				}
			}
			i++
		}
	};
	this.setGenomeLeftDimentions = function() {
		var e = [];
		for (var d = 0; d < this.data.tracks.length; d++) {
			var a = this.data.tracks[d];
			for (var b = 0; b < a.data.length; b++) {
				var c = a.data[b];
				e.push(c.label || c.name || c.id)
			}
		}
		return this.measureText(this.shortenText(this.getMaxText(e), this.maxFeatureStringLen), this.featureNameFont) + (this.margin * 4)
	};
	this.setGenomeYDimentions = function() {
		this.bottom += this.margin + this.getFontPt(this.featureNameFont);
		if (this.adjustAspectRatio || this.height < (this.marginTop + this.top + this.y + this.bottom + this.marginBottom)) {
			this.height = this.marginTop + this.top + this.y + this.bottom + this.marginBottom
		}
		this.resizeCanvas();
		this.resizeViewport()
	};
	this.setGenomeAxisUnits = function() {
		this.setAxisUnits("xAxis");
		this.genomeResolution = this.xAxisUnit > this.sequenceFontSize ? "high" : this.xAxisUnit * 5 > this.sequenceFontSize ? "medium" : "low"
	};
	this.setGenomeXDimentions = function() {
		if (this.featureStaggered) {
			if (this.width) {
				this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
			} else {
				this.width = this.marginLeft + this.left + this.x + this.right + this.marginRight
			}
		} else {
			this.left = this.setGenomeLeftDimentions();
			if (this.width) {
				this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight)
			} else {
				this.width = this.marginLeft + this.left + this.x + this.right + this.marginRight
			}
		}
	};
	this.setGenomeFontsColors = function() {
		this.trackNameFont = this.trackNameFontStyle + " " + this.trackNameFontSize + "px " + this.fontName;
		this.featureNameFont = this.featureNameFontStyle + " " + this.featureNameFontSize + "px " + this.fontName;
		this.sequenceFont = (this.sequenceFontSize) + "px " + this.fontName;
		if (!this.wireColor.match(/,0.1\)$/)) {
			this.wireColor = this.wireColor.replace(/\)$/, ",0.1)")
		}
	};
	this.drawGenome = function() {
		this.setGenomeFontsColors();
		this.setGenomeXDimentions();
		this.setGenomeAxisUnits();
		this.setGenomeSubtracks();
		this.setGenomeYDimentions();
		this.setGenomeWireFrame();
		this.plotGenomeData();
		this.drawGenomeLabels();
		this.setGenomeTicks()
	};
	this.initializeGenome = function() {
		this.drawGenome()
	};
	this.initializeGenome()
};
CanvasXpress.prototype.Circular = function() {
	this.setCircularXYDimensions = function() {
		this.x = this.width - (this.marginLeft + this.left + this.right + this.marginRight);
		this.y = this.height - (this.marginTop + this.top + this.bottom + this.marginBottom);
		this.r = Math.min(this.x, this.y) / 2;
		this.d = this.r * 2;
		this.cx = this.marginLeft + this.left + this.r;
		this.cy = this.marginTop + this.top + this.r
	};
	this.setCircularSampleOverlays = function() {
		this.validateSegregation();
		if (this.segregateSamplesBy.length > 0 && this.data.x.hasOwnProperty(this.segregateSamplesBy[0]) && this.smpOverlays.length == 0) {
			this.smpOverlays = [this.segregateSamplesBy[0]]
		}
	};
	this.setCircularFonts = function() {
		if (this.autoScaleFont) {
			var a = Math.min(this.width, this.height) * (1 - this.percentAspectRatioPlotArea) * 0.5;
			this.setPropertyFontSize(a, "varLabelFont");
			this.setPropertyFontSize(a, "varTitleFont");
			this.setPropertyFontSize(a, "smpLabelFont");
			this.setPropertyFontSize(a, "smpTitleFont");
			this.setAxisFont(this.data.y.desc ? this.data.y.desc[0] : "NA", a)
		}
	};
	this.setCircularLegendDimensions = function() {
		this.legendVariableWidth = 0;
		this.legendVariableHeight = 0;
		if (this.showLegend) {
			var a = this.getFontPt(this.legendFont);
			var b = this.shortenText(this.meta.data.y.maxVarStr, this.maxVarStringLen);
			var c = this.getVariableInLegends();
			this.legendVariableWidth = (a - 1) + this.measureText(b, this.legendFont) + (this.margin * 3);
			this.legendVariableHeight = (c * (a + this.margin)) + this.margin
		}
	};
	this.getVariableInLegends = function() {
		var b = 0;
		for (var a = 0; a < this.ringsNumber; a++) {
			if (this.rAxisIndex >= 0 && a == this.rAxisIndex) {
				continue
			}
			if (this.rAxisIndex < 0 && this.ringsType[a] == "heatmap") {
				continue
			}
			b += this.ringsVarIndices[a].length
		}
		return b
	};
	this.getCircularSampleLabelLength = function() {
		if (this.showSampleNames && this.rAxisIndex < 0) {
			if (this.smpLabelOrientation == "circular") {
				return this.getFontPt(this.smpLabelFont) + this.margin
			} else {
				if (this.meta.data.y.maxSmpChr > this.maxSmpStringLen) {
					return this.measureText(this.meta.data.y.maxSmpStr.substring(0, this.maxSmpStringLen), this.smpLabelFont) + this.margin
				} else {
					return this.measureText(this.meta.data.y.maxSmpStr, this.smpLabelFont) + this.margin
				}
			}
		} else {
			return 0
		}
	};
	this.getCircularOverlaysWidth = function() {
		var b = 0;
		if (this.showOverlays && this.smpOverlays.length > 0) {
			if (this.segregateSamplesBy.length > 0 && this.data.x[this.segregateSamplesBy[0]]) {
				b++
			}
			for (var a = 0; a < this.smpOverlays.length; a++) {
				if (this.data.x.hasOwnProperty(this.smpOverlays[a])) {
					if (this.segregateSamplesBy.length > 0 && this.data.x[this.segregateSamplesBy[0]] && this.smpOverlays[a] == this.segregateSamplesBy[0]) {
						continue
					}
					b++
				}
			}
			if (b > 0) {
				b = b * (this.overlaysThickness + this.margin)
			}
		}
		return b
	};
	this.getCircularXAxisTickLength = function() {
		return this.measureText(this.xAxisMaxStrLength, this.axisTickFont)
	};
	this.getCircularRAxisTickLength = function() {
		if (this.rAxisShow && this.rAxisIndex >= 0) {
			return this.axisTickFontSize
		} else {
			return this.measureText(this.rAxisMaxStrLength, this.axisTickFont)
		}
	};
	this.getCircularSmpTreeHeight = function() {
		var a = 0;
		if (this.showSmpDendrogram && this.smpDendrogram) {
			a = ((this.smpDendrogram.depth + 1) * this.dendrogramSpace) + this.margin
		}
		return a
	};
	this.setCircularArcSegments = function() {
		this.rAxisIndex = this.rAxis ? this.getVariableIndices(this.rAxis) : -1;
		this.arcSegmentsCenter = this.xAxisShow ? (this.margin * 1.5) + this.arcLengthToDegrees(this.r * this.circularCenterProportion * 2, this.getCircularXAxisTickLength()) : 0;
		var b = this.xAxisShow ? ((this.arcSegmentsSeparation + this.arcSegmentsCenter) * Math.PI / 360) : 0;
		this.circularStart = (Math.PI * 1.5) + b;
		this.currentRadius = this.r;
		this.arcSegments = [];
		this.arcSegmentsSampleIndices = [];
		this.arcSegmentsSamplePosition = [];
		this.arcSegmentsRange = [];
		this.arcSegmentsMin = [];
		this.arcSegmentsMax = [];
		this.arcSegmentsRangeMap = {};
		this.arcSegmentsDims = [];
		if (this.segregateSamplesBy.length > 0 && this.data.x[this.segregateSamplesBy[0]]) {
			var t = [];
			var m = [];
			var k = this.getSmpAnnotations(this.segregateSamplesBy[0], this.smpIndices);
			for (var l = 0; l < k.length; l++) {
				this.arcSegments.push(k[l]);
				this.arcSegmentsRangeMap[k[l]] = l;
				var f = this.getSamplesByAnnotationLevel(this.segregateSamplesBy[0], k[l]);
				this.arcSegmentsSampleIndices.push(f);
				t = t.concat(f)
			}
			for (var l = 0; l < t.length; l++) {
				if (this.hiddenSmps[t[l]]) {
					m.push(true)
				} else {
					m.push(false)
				}
			}
			this.smpIndices = t;
			this.hiddenSmps = m;
			if (this.rAxisIndex >= 0) {
				var h = {};
				var p = 0;
				for (var l = 0; l < this.data.y.smps.length; l++) {
					var u = this.data.x[this.segregateSamplesBy[0]][l];
					if (!h[u]) {
						h[u] = []
					}
					h[u].push(this.data.y.data[this.rAxisIndex][l])
				}
				for (var u in h) {
					var l = this.arcSegmentsRangeMap[u];
					var a = this.range(h[u]);
					this.arcSegmentsMin[l] = a[0];
					this.arcSegmentsMax[l] = a[1];
					if (this.rAxisZero) {
						p += a[1];
						this.arcSegmentsRange[l] = a[1]
					} else {
						p += (a[1] - a[0]);
						this.arcSegmentsRange[l] = a[1] - a[0]
					}
				}
				this.rAxisUnit = (360 - ((this.arcSegmentsSeparation * this.arcSegmentsSampleIndices.length) + this.arcSegmentsCenter)) / p
			} else {
				this.rAxisUnit = (360 - ((this.arcSegmentsSeparation * this.arcSegmentsSampleIndices.length) + this.arcSegmentsCenter)) / this.data.y.smps.length;
				var u = this.circularStart;
				for (var l = 0; l < this.arcSegmentsSampleIndices.length; l++) {
					this.arcSegmentsSamplePosition[l] = [];
					for (var g = 0; g < this.arcSegmentsSampleIndices[l].length; g++) {
						this.arcSegmentsSamplePosition[l].push(u);
						u += this.rAxisUnit * Math.PI / 180
					}
					u += this.arcSegmentsSeparation * Math.PI / 180
				}
			}
			var u = this.circularStart;
			for (var c in this.arcSegmentsRangeMap) {
				var l = this.arcSegmentsRangeMap[c];
				var d = this.rAxisIndex >= 0 ? this.arcSegmentsRange[l] : this.arcSegmentsSampleIndices[l].length;
				var q = this.rAxisUnit * d * Math.PI / 180;
				this.arcSegmentsDims.push([u, u + q]);
				u += q + (this.arcSegmentsSeparation * Math.PI / 180)
			}
		} else {
			this.arcSegments = false;
			this.arcSegmentsSampleIndices = [this.smpIndices];
			if (this.rAxisIndex >= 0) {
				var a = this.range(this.data.y.data[this.rAxisIndex]);
				this.arcSegmentsMin.push(a[0]);
				this.arcSegmentsMax.push(a[1]);
				if (this.rAxisZero) {
					this.rAxisUnit = (360 - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / a[1];
					this.arcSegmentsRange.push(a[1])
				} else {
					this.rAxisUnit = (360 - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / (a[1] - a[0]);
					this.arcSegmentsRange.push(a[1] - a[0])
				}
			} else {
				this.rAxisUnit = (360 - (this.arcSegmentsSeparation + this.arcSegmentsCenter)) / this.data.y.smps.length;
				var u = this.circularStart;
				for (var l = 0; l < this.arcSegmentsSampleIndices.length; l++) {
					this.arcSegmentsSamplePosition[l] = [];
					for (var g = 0; g < this.arcSegmentsSampleIndices[l].length; g++) {
						this.arcSegmentsSamplePosition[l].push(u);
						u += this.rAxisUnit * Math.PI / 180
					}
					u += this.arcSegmentsSeparation * Math.PI / 180
				}
			}
			var q = (this.rAxisUnit * Math.PI / 180) * (this.rAxisIndex >= 0 ? this.arcSegmentsRange[0] : this.smpIndices.length);
			this.arcSegmentsDims.push([this.circularStart, this.circularStart + q])
		}
		this.arcSegmentsNumber = this.arcSegmentsSampleIndices.length
	};
	this.setCircularRings = function() {
		this.ringsVarIndices = [];
		if (this.rAxisIndex >= 0) {
			this.ringsVarIndices.push([this.rAxisIndex])
		}
		if (this.segregateVariablesBy.length > 0 && this.data.z[this.segregateVariablesBy[0]]) {
			var d = {};
			for (var f = 0; f < this.data.z[this.segregateVariablesBy[0]].length; f++) {
				if (this.rAxisIndex >= 0 && f == this.rAxisIndex) {
					continue
				}
				var c = this.data.z[this.segregateVariablesBy[0]][f];
				if (!d[c]) {
					this.ringsVarIndices.push(this.getVariablesByAnnotationLevel(this.segregateVariablesBy[0], c));
					d[c] = true
				}
			}
		} else {
			var b = [];
			var e = 0;
			for (var f = 0; f < this.data.y.vars.length; f++) {
				if (this.rAxisIndex >= 0 && f == this.rAxisIndex) {
					continue
				}
				b.push(e++)
			}
			this.ringsVarIndices.push(b)
		}
		this.ringsNumber = this.ringsVarIndices.length;
		if (this.ringsType.length < this.ringsNumber) {
			for (var f = this.ringsType.length; f < this.ringsNumber; f++) {
				this.ringsType.push("dot")
			}
		}
		if (this.ringsWeight && this.ringsWeight.length > 0) {
			while (this.ringsWeight.length != this.ringsNumber) {
				if (this.ringsWeight.length > this.ringsNumber) {
					this.ringsWeight.pop()
				} else {
					this.ringsWeight.push(this.ringsWeight[this.ringsWeight.length - 1])
				}
			}
		} else {
			this.ringsWeight = [];
			for (var f = 0; f < this.ringsNumber; f++) {
				if (this.rAxisShow && this.rAxisIndex >= 0 && f == this.rAxisIndex) {
					this.ringsWeight.push(0);
					continue
				}
				this.ringsWeight.push(1)
			}
		}
		var a = 0;
		for (var f = 0; f < this.ringsWeight.length; f++) {
			if (this.rAxisShow && this.rAxisIndex >= 0 && f == this.rAxisIndex) {
				continue
			}
			a += parseFloat(this.ringsWeight[f])
		}
		for (var f = 0; f < this.ringsWeight.length; f++) {
			this.ringsWeight[f] /= a
		}
	};
	this.drawCircularRadialAxis = function() {
		if (this.rAxisShow && this.rAxisIndex >= 0) {
			if (this.rAxisLabelOrientation == "circular") {
				var h = this.rAxisUnit * Math.PI / 180;
				for (var f = 0; f < this.arcSegmentsRange.length; f++) {
					var n = this.arcSegmentsDims[f][0];
					var a = this.getAxisIncrements(this.arcSegmentsMin[f], this.arcSegmentsMax[f], this.rAxisTicks);
					var m = this.rAxisUnit * a * Math.PI / 180;
					for (var d = 0; d < this.rAxisTicks; d++) {
						var b = this.bestFormatNumber(this.arcSegmentsMin[f] + (a * d));
						if (b <= this.arcSegmentsMax[f]) {
							var g = this.measureText(b, this.axisTickFont);
							this.drawArcText(b, this.cx, this.cy, this.currentRadius + (this.axisTickFontSize / 2), n - (h * g / 7), h * g / 3.5, this.axisTickFont, this.rAxisTickColor, false, false, true);
							n += m
						}
					}
				}
			} else {
				this.saveCanvas();
				this.translateCanvas(this.cx, this.cy);
				for (var f = 0; f < this.arcSegmentsRange.length; f++) {
					var n = this.arcSegmentsDims[f][0] - (Math.PI / 2);
					var a = this.getAxisIncrements(this.arcSegmentsMin[f], this.arcSegmentsMax[f], this.rAxisTicks);
					var m = this.rAxisUnit * a * Math.PI / 180;
					this.saveCanvas();
					this.rotateCanvas(n);
					for (var d = 0; d < this.rAxisTicks; d++) {
						var b = this.bestFormatNumber(this.arcSegmentsMin[f] + (a * d));
						var k = b <= this.arcSegmentsMax[f] ? this.axisTickColor : this.background;
						var g = this.measureText(b, this.axisTickFont);
						if (n < Math.PI * 2) {
							this.drawText(b, 0, this.currentRadius - (this.margin - g), this.axisTickFont, k, "right", "middle", Math.PI / 2)
						} else {
							this.drawText(b, 0, this.currentRadius - this.margin, this.axisTickFont, k, "right", "middle", -Math.PI / 2)
						}
						n += m;
						this.rotateCanvas(m)
					}
					this.restoreCanvas()
				}
				this.restoreCanvas()
			}
			this.currentRadius -= this.getCircularRAxisTickLength()
		}
	};
	this.drawCircularOverlays = function() {
		if (this.showOverlays && this.smpOverlays.length > 0) {
			var t = this;
			var f = this.meta.data;
			var z = this.circularStart;
			var y = this.segregateSamplesBy;
			var r = (this.overlaysThickness - this.overlayFontSize) / 2;
			var h = function(e, c) {
				if (e.type == "Numeric") {
					return t.getColorForValue(e.colorBrew, c)
				} else {
					return e.colors[e.order[c]]
				}
			};
			if (y.length > 0 && this.data.x[y[0]]) {
				var a = this.rAxisIndex >= 0 ? 0.033 : 0;
				for (var b in f.x[y[0]].order) {
					var w = h(f.x[y[0]], b);
					var d = this.rAxisIndex >= 0 ? this.arcSegmentsRange[this.arcSegmentsRangeMap[b]] : (this.getSamplesByAnnotationLevel(y[0], b)).length;
					var u = this.rAxisUnit * d * Math.PI / 180;
					this.addArea(this.drawShape("arc2", this.cx, this.cy, this.overlaysThickness, this.currentRadius, w, w, false, false, false, false, false, z - a, z + u + a), ["SmpOvrSgr-" + 0 + "-" + b]);
					this.drawArcText(b, this.cx, this.cy, this.currentRadius - r, z, u, this.overlayFont, this.overlayFontColor, false, false, true);
					z += u + (this.arcSegmentsSeparation * Math.PI / 180)
				}
				z -= (this.arcSegmentsSeparation * Math.PI / 180);
				z = z % (Math.PI * 2);
				this.drawArcText(y[0], this.cx, this.cy, this.currentRadius - r, z, this.circularStart - z, this.overlayFont, this.overlayFontColor, false, false, true);
				this.currentRadius -= this.overlaysThickness;
				z = this.circularStart
			}
			if (this.rAxisIndex < 0) {
				for (var q = 0; q < this.smpOverlays.length; q++) {
					var b = this.smpOverlays[q];
					if (y.length > 0 && this.data.x[y[0]] && b == y[0]) {
						continue
					}
					var u = this.rAxisUnit * Math.PI / 180;
					if (b != "-") {
						for (var l = 0; l < this.arcSegmentsSampleIndices.length; l++) {
							for (var g = 0; g < this.arcSegmentsSampleIndices[l].length; g++) {
								var x = this.data.x[b][this.smpIndices[this.arcSegmentsSampleIndices[l][g]]];
								var w = h(f.x[b], x);
								this.addArea(this.drawShape("arc2", this.cx, this.cy, this.overlaysThickness, this.currentRadius, w, w, false, false, false, false, false, z, z + u), ["SmpOvr-" + this.arcSegmentsSampleIndices[l][g] + "-" + q]);
								if (this.showLevelOverlays) {
									this.drawArcText(x, this.cx, this.cy, this.currentRadius - r, z, u, this.overlayFont, this.overlayFontColor, false, false, true)
								}
								z += u
							}
							z += (this.arcSegmentsSeparation * Math.PI / 180)
						}
						z -= (this.arcSegmentsSeparation * Math.PI / 180);
						z = z % (Math.PI * 2);
						this.drawArcText(b, this.cx, this.cy, this.currentRadius - r, z, this.circularStart - z, this.overlayFont, this.overlayFontColor, false, false, true)
					}
					this.currentRadius -= this.overlaysThickness;
					z = this.circularStart
				}
			}
		}
	};
	this.drawCircularSampleLabels = function() {
		if (this.showSampleNames && this.rAxisIndex < 0) {
			var h = this.rAxisUnit * Math.PI / 180;
			if (this.smpLabelOrientation == "circular") {
				var g = this.circularStart;
				for (var f = 0; f < this.arcSegmentsSampleIndices.length; f++) {
					for (var d = 0; d < this.arcSegmentsSampleIndices[f].length; d += this.smpLabelInterval) {
						var b = this.data.y.smps[this.smpIndices[this.arcSegmentsSampleIndices[f][d]]];
						var k = this.getSmpColor(b);
						this.addArea(this.drawArcText(b, this.cx, this.cy, this.currentRadius, g, h, this.smpLabelFont, k, false, false, true), ["Smp-" + this.smpIndices[this.arcSegmentsSampleIndices[f][d]]]);
						g += (h * this.smpLabelInterval)
					}
					g += this.arcSegmentsSeparation * Math.PI / 180
				}
			} else {
				var g = this.circularStart + (h / 2) - (Math.PI / 2);
				var a = this.getCircularSampleLabelLength();
				this.saveCanvas();
				this.translateCanvas(this.cx, this.cy);
				this.rotateCanvas(g);
				for (var f = 0; f < this.arcSegmentsSampleIndices.length; f++) {
					for (var d = 0; d < this.arcSegmentsSampleIndices[f].length; d += this.smpLabelInterval) {
						var b = this.data.y.smps[this.smpIndices[this.arcSegmentsSampleIndices[f][d]]];
						var k = this.getSmpColor(b);
						if (g < Math.PI * 2) {
							this.drawText(b, 0, this.currentRadius - a, this.smpLabelFont, k, "left", "middle", Math.PI / 2)
						} else {
							this.drawText(b, 0, this.currentRadius - a, this.smpLabelFont, k, "right", "middle", -Math.PI / 2)
						}
						g += (h * this.smpLabelInterval);
						this.rotateCanvas(h * this.smpLabelInterval)
					}
					g += this.arcSegmentsSeparation * Math.PI / 180;
					this.rotateCanvas(this.arcSegmentsSeparation * Math.PI / 180)
				}
				for (var f = 0; f < this.smpIndices.length + 2; f++) {
					this.restoreCanvas()
				}
			}
			this.currentRadius -= this.getCircularSampleLabelLength()
		}
	};
	this.drawCircularData = function() {
		var b = this.circularCenterProportion * this.r;
		var a = this.currentRadius - b;
		var f = this.varIndices;
		var c = 0;
		for (var d = 0; d < this.ringsNumber; d++) {
			if (this.rAxisIndex >= 0 && d == this.rAxisIndex) {
				continue
			}
			if (this.ringsType[d] == "heatmap") {
				this.circularHeatmap = true
			}
			var e = this.circularStart;
			var g = (a * this.ringsWeight[d]);
			this.setVariablesVisible(this.ringsVarIndices[d]);
			this.setAxes();
			this.xAxisUnit = (g - (this.showRingLegend ? this.axisTickFontSize : 0)) / this.xAxisRange;
			this.drawCircularRingLegend(e, g, this.ringsType[d] == "heatmap");
			this.drawCircularDataAxis(e, g, this.ringsType[d] == "heatmap");
			this.drawCircularDataPoints(e, g, d, c);
			c += this.varIndices.length;
			this.currentRadius -= (g + this.ringSeparation)
		}
		this.varIndices = f
	};
	this.drawCircularRingLegend = function(j, m, g) {
		if (this.showRingLegend) {
			var n = [];
			var k = this.arcSegmentsDims[0][0];
			var c = this.arcSegmentsDims[this.arcSegmentsNumber - 1][1] % (Math.PI * 2);
			if (g && this.rAxisIndex < 0) {
				var b = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
				for (var d = 0; d < this.varIndices.length; d++) {
					n.push(b[d] + ": " + this.data.y.vars[this.varIndices[d]])
				}
			} else {
				for (var d = 0; d < this.varIndices.length; d++) {
					n.push(this.data.y.vars[this.varIndices[d]])
				}
			}
			v = n.join(", ");
			this.drawArcText(v, this.cx, this.cy, this.currentRadius + (this.axisTickFontSize / 2), c + ((c - k) / 2), (k - c) * 2, this.axisTickFont, this.axisTickColor, false, false, true)
		}
	};
	this.drawCircularDataAxis = function(o, F, B) {
		var E = this.arcSegmentsDims[0][0];
		var x = this.arcSegmentsDims[this.arcSegmentsNumber - 1][1] % (Math.PI * 2);
		var G = this.showRingLegend ? this.currentRadius - this.axisTickFontSize : this.currentRadius;
		if (B && this.rAxisIndex < 0) {
			var u = (F - (this.showRingLegend ? this.axisTickFontSize : 0)) / this.varIndices.length;
			var I = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
			for (var A = 0; A < this.varIndices.length; A++) {
				G -= u;
				this.drawArcText(I[A], this.cx, this.cy, G + (u / 2) + (this.axisTickFontSize / 2), x, E - x, this.axisTickFont, this.axisTickColor, false, false, true)
			}
		} else {
			var w = this.rAxisIndex >= 0 ? 0.033 : 0;
			var q = [];
			for (var A = 0; A < this.xAxisValues.length; A++) {
				var J = parseFloat(this.xAxisValues[A]);
				if (J >= this.xAxisMin && J <= this.xAxisMax) {
					q.push(J)
				}
			}
			for (var A = 0; A < q.length; A++) {
				var m = G - ((this.xAxisMax - q[A]) * this.xAxisUnit);
				for (var z = 0; z < this.arcSegmentsNumber; z++) {
					if (z == 0) {
						this.drawArcText(q[A], this.cx, this.cy, m + 2, x, E - x, this.axisTickFont, this.axisTickColor, false, false, true)
					}
					var k = A == 0 || A == q.length - 1 ? this.foreground : this.xAxisTickColor;
					this.drawShape("arc3", this.cx, this.cy, m, m, k, k, false, false, false, false, false, this.arcSegmentsDims[z][0] - w, this.arcSegmentsDims[z][1] + w)
				}
			}
			var D, C, g, d;
			var n = G - ((this.xAxisMax - q[0]) * this.xAxisUnit);
			var H = G - ((this.xAxisMax - q[q.length - 1]) * this.xAxisUnit);
			for (var A = 0; A < this.arcSegmentsNumber; A++) {
				D = n * Math.cos(this.arcSegmentsDims[A][0] - w);
				g = n * Math.sin(this.arcSegmentsDims[A][0] - w);
				C = H * Math.cos(this.arcSegmentsDims[A][0] - w);
				d = H * Math.sin(this.arcSegmentsDims[A][0] - w);
				this.drawLine("line", D + this.cx, g + this.cy, C + this.cx, d + this.cy, this.foreground);
				D = n * Math.cos(this.arcSegmentsDims[A][1] + w);
				g = n * Math.sin(this.arcSegmentsDims[A][1] + w);
				C = H * Math.cos(this.arcSegmentsDims[A][1] + w);
				d = H * Math.sin(this.arcSegmentsDims[A][1] + w);
				this.drawLine("line", D + this.cx, g + this.cy, C + this.cx, d + this.cy, this.foreground)
			}
		}
	};
	this.drawCircularDataPoints = function(A, M, K, w) {
		var d = this.xAxisMin < 0 ? Math.abs(this.xAxisMin) * this.xAxisUnit : 0;
		var F = (this.rAxisUnit * Math.PI / 180) * 0.3;
		var L = F / 2;
		var P = (this.rAxisUnit * Math.PI / 180) * 0.7 / this.ringsVarIndices[K].length;
		var a = this.showRingLegend ? this.currentRadius - this.axisTickFontSize : this.currentRadius;
		if (this.rAxisIndex < 0) {
			if (this.ringsType[K] != "heatmap") {
				A += L
			}
			for (var J = 0; J < this.arcSegmentsSampleIndices.length; J++) {
				var N = 0.002;
				for (var I = 0; I < this.arcSegmentsSampleIndices[J].length; I++) {
					if (this.ringsType[K] == "heatmap") {
						if (N >= 0.002) {
							var B = (M - (this.showRingLegend ? this.axisTickFontSize : 0)) / this.varIndices.length;
							var D = 0;
							for (var H = 0; H < this.varIndices.length; H++) {
								var u = this.getDataAtPos(this.varIndices[H], this.smpIndices[this.arcSegmentsSampleIndices[J][I]]);
								var O = !isNaN(u) ? this.getColorForValue(false, u) : this.missingDataColor;
								this.addArea(this.drawShape("arc2", this.cx, this.cy, B, a - D, O, O, false, false, false, false, false, A, A + this.rAxisUnit * Math.PI / 180), [this.varIndices[H], this.arcSegmentsSampleIndices[J][I]]);
								D += B
							}
							N = 0
						}
						A += this.rAxisUnit * Math.PI / 180;
						N += this.rAxisUnit * Math.PI / 180
					} else {
						for (var H = 0; H < this.varIndices.length; H++) {
							var u = this.getDataAtPos(this.varIndices[H], this.smpIndices[this.arcSegmentsSampleIndices[J][I]]);
							var O = this.colors[(H + w) % this.colors.length];
							var G = this.ringsType[K] == "bar" ? (u - this.xAxisMin) * this.xAxisUnit : (this.xAxisMax - u) * this.xAxisUnit;
							if (this.ringsType[K] == "bar") {
								if (u >= 0) {
									this.addArea(this.drawShape("arc2", this.cx, this.cy, G, this.currentRadius + d - ((M - G)), O, O, false, false, false, false, false, A, A + P), [this.varIndices[H], this.arcSegmentsSampleIndices[J][I]])
								} else {
									this.addArea(this.drawShape("arc2", this.cx, this.cy, -G, this.currentRadius - ((M - G)), O, O, false, false, false, false, false, A, A + P), [this.varIndices[H], this.arcSegmentsSampleIndices[J][I]])
								}
							} else {
								if (this.ringsType[K] == "dot") {
									var g = this.cx + (a - G) * Math.cos(A + (P / 2));
									var f = this.cy + (a - G) * Math.sin(A + (P / 2));
									this.addArea(this.drawShape("circle", g, f, this.margin, this.margin, O, O), [this.varIndices[H], this.arcSegmentsSampleIndices[J][I]])
								}
							}
							A += P
						}
						A += F
					}
				}
				A += this.arcSegmentsSeparation * Math.PI / 180
			}
		} else {
			for (var J = 0; J < this.arcSegmentsSampleIndices.length; J++) {
				var A = this.arcSegmentsDims[J][0];
				var G = this.rAxisZero && this.arcSegmentsMin[J] < 0 ? this.arcSegmentsMin[J] : 0;
				for (var I = 0; I < this.arcSegmentsSampleIndices[J].length; I++) {
					for (var H = 0; H < this.varIndices.length; H++) {
						var O = this.colors[(H + w) % this.colors.length];
						var o = this.getDataAtPos(this.rAxisIndex, this.smpIndices[this.arcSegmentsSampleIndices[J][I]]);
						var n = this.getDataAtPos(this.varIndices[H], this.smpIndices[this.arcSegmentsSampleIndices[J][I]]);
						if (this.rAxisZero && o < 0) {
							continue
						}
						var E = (o + G - this.arcSegmentsMin[J]) * (this.rAxisUnit * Math.PI / 180);
						var C = ((n - this.xAxisMin) * this.xAxisUnit);
						var g = this.cx + ((this.currentRadius - ((M - C))) * Math.cos(A + E));
						var f = this.cy + ((this.currentRadius - ((M - C))) * Math.sin(A + E));
						this.addArea(this.drawShape("circle", g, f, this.margin, this.margin, O, O), [this.varIndices[H], this.arcSegmentsSampleIndices[J][I]])
					}
				}
			}
		}
	};
	this.getCircularCoordinates = function(m) {
		var f = this;
		var h = this.rAxisUnit * Math.PI / 180;
		var i = this.currentRadius;
		var q = function(t) {
			for (var e = 0; e < f.arcSegmentsSampleIndices.length; e++) {
				for (var c = 0; c < f.arcSegmentsSampleIndices[e].length; c++) {
					var u = f.arcSegmentsSampleIndices[e][c];
					if (f.data.y.smps[u] == t) {
						return f.arcSegmentsSamplePosition[e][c]
					}
				}
			}
			return false
		};
		var g = function(e) {
			var t = f.arcSegmentsRangeMap[e[1]];
			var x = f.arcSegmentsRangeMap[e[3]];
			if (t != null && x != null) {
				var c = f.rAxisZero && f.arcSegmentsMin[t] < 0 ? f.arcSegmentsMin[t] : 0;
				var A = f.rAxisZero && f.arcSegmentsMin[x] < 0 ? f.arcSegmentsMin[x] : 0;
				if (e[2] >= f.arcSegmentsMin[t] && e[2] <= f.arcSegmentsMax[t] && e[4] >= f.arcSegmentsMin[x] && e[4] <= f.arcSegmentsMax[x]) {
					var w, z, u, y;
					w = f.arcSegmentsDims[t][0] + ((e[2] + c - f.arcSegmentsMin[t]) * (f.rAxisUnit * Math.PI / 180));
					z = f.arcSegmentsDims[x][0] + ((e[4] + A - f.arcSegmentsMin[x]) * (f.rAxisUnit * Math.PI / 180));
					if (e[5] != null || e[6] != null) {
						u = f.arcSegmentsDims[t][0] + ((Math.min(e[2] + (e[5] || 0), f.arcSegmentsMax[t]) + c - f.arcSegmentsMin[t]) * (f.rAxisUnit * Math.PI / 180));
						y = f.arcSegmentsDims[x][0] + ((Math.min(e[4] + (e[6] || 0), f.arcSegmentsMax[x]) + A - f.arcSegmentsMin[x]) * (f.rAxisUnit * Math.PI / 180));
						return [w, z, u, y]
					}
					return [w, z]
				}
			}
			return false
		};
		if (this.rAxisIndex < 0) {
			var s = q(m[1]);
			var j = q(m[2]);
			if (s && j) {
				var d = this.cx + (i * Math.cos(s));
				var p = this.cy + (i * Math.sin(s));
				var b = this.cx + (i * Math.cos(j + h));
				var o = this.cy + (i * Math.sin(j + h));
				var a = this.cx + (i * Math.cos(j));
				var l = this.cy + (i * Math.sin(j));
				var r = this.cx + (i * Math.cos(s + h));
				var k = this.cy + (i * Math.sin(s + h));
				return [d, p, b, o, a, l, r, k, s, s + h, j, j + h]
			}
		} else {
			if (this.segregateSamplesBy.length > 0 && this.data.x[this.segregateSamplesBy[0]]) {
				var n = g(m);
				if (n) {
					var d, p, b, o, a, l, r, k;
					if (n.length > 2) {
						d = this.cx + (i * Math.cos(n[0]));
						p = this.cy + (i * Math.sin(n[0]));
						b = this.cx + (i * Math.cos(n[3]));
						o = this.cy + (i * Math.sin(n[3]));
						a = this.cx + (i * Math.cos(n[1]));
						l = this.cy + (i * Math.sin(n[1]));
						r = this.cx + (i * Math.cos(n[2]));
						k = this.cy + (i * Math.sin(n[2]));
						return [d, p, b, o, a, l, r, k, n[0], n[2], n[1], n[3]]
					} else {
						d = this.cx + (i * Math.cos(n[0]));
						p = this.cy + (i * Math.sin(n[0]));
						b = this.cx + (i * Math.cos(n[1]));
						o = this.cy + (i * Math.sin(n[1]));
						return [d, p, b, o]
					}
				} else {}
			}
		}
		return false
	};
	this.drawCircularConnections = function() {
		if (this.showCircularConnections && this.data.c) {
			var h = function(c) {
				if (c.length > 3) {
					return c[1] + "[" + c[2] + "] " + c[5] + " - " + c[3] + "[" + c[4] + "] " + c[6]
				} else {
					return c[1] + " - " + c[2]
				}
			};
			this.currentRadius += (this.margin * 2);
			var g = this.rAxisUnit * Math.PI / 180;
			for (var b = 0; b < this.data.c.length; b++) {
				var j = this.getCircularCoordinates(this.data.c[b]);
				var a = h(this.data.c[b]);
				var d = this.addColorTransparency(this.data.c[b][0], this.circularConnectionsTransparency);
				if (j.length > 4) {
					this.addArea(this.drawShape("arch", [j[0], this.cx, j[2], j[4], this.cx, j[6]], [j[1], this.cy, j[3], j[5], this.cy, j[7]], [j[8], j[9], j[10], j[11]], this.currentRadius, d, d, "solid"), ["Connect:" + a])
				} else {
					this.drawLine("arch", [j[0], this.cx, j[2]], [j[1], this.cy, j[3]], false, false, d, d)
				}
			}
		}
	};
	this.drawNetworkColorIndicator = function() {
		if (this.circularHeatmap) {
			this.drawColorIndicator(this.margin * 4, this.top, this.meta.def.colorBrew, "Color Indicator", true)
		}
	};
	this.drawCircularPlot = function() {
		this.setLegends();
		this.setCircularArcSegments();
		this.setCircularRings();
		this.setCircularLegendDimensions();
		this.drawCircularRadialAxis();
		this.drawCircularOverlays();
		this.drawCircularSampleLabels();
		this.drawCircularData();
		this.drawCircularConnections();
		this.drawLegend();
		this.drawNetworkColorIndicator();
		this.drawTitle()
	};
	this.setCircularAttributes = function() {
		this.setCircularXYDimensions();
		this.setCircularSampleOverlays();
		this.setCircularFonts();
		this.setTrees();
		this.setOverlayFont();
		this.validatePropertyValues()
	};
	this.initializeCircular = function() {
		this.setCircularAttributes();
		this.drawCircularPlot()
	};
	this.initializeCircular()
};
CanvasXpress.prototype.Video = function() {
	this.videoPlay = function(a) {
		return function(b) {
			a.drawVideo(this, a.width, a.height)
		}
	}(this);
	this.videoUpdate = function() {
		var h = this.video.currentTime;
		if (this.videoCurrentTime) {
			this.drawText(h, this.width / 2, 20, false, this.videoColor)
		}
		if (this.videoGrid) {
			var g = (this.width - 1) / this.videoGridStep;
			var f = (this.height - 1) / this.videoGridStep;
			for (var d = 0; d <= this.videoGridStep; d++) {
				this.drawLine("line", g * d, 0, g * d, this.height, this.videoColor);
				this.drawLine("line", 0, f * d, this.width, f * d, this.videoColor)
			}
		}
		for (var d = 0; d < this.data.video.length; d++) {
			var j = this.data.video[d][0];
			var b = j + this.data.video[d][1];
			if (h >= j && h <= b) {
				var c = this.data.video[d][2];
				var e = this.data.video[d][3];
				var a = this.data.video[d][4];
				switch (c) {
					case "text":
						this.drawText(e, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9]);
						break;
					case "line":
						this.drawLine(e, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10]);
						break;
					case "shape":
						this.drawShape(e, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14]);
						break
				}
			}
		}
	};
	this.initializeVideo = function() {
		if (!this.data) {
			this.data = {
				video: {}
			}
		}
		if (!this.data.video) {
			this.data.video = {}
		}
	};
	this.initializeVideo()
};
CanvasXpress.images = {
	"081": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAFQSURBVHjapFNLasMwEB0X400JhULagwS8ViABL7L1GXIEn6FX6BW8zcILg7s29CCtSRdx2lof251xJMVKSUip4KE38puZJ1ny+r6H/ww/TdM+jmPvGvH6+ZWmAsH00ovfdd1RkT5dLDCbJVCWJQvDcIiJ+0qpq+22bWth4hsTwHr5K2EJeYHoNQpqdgpfSnm2IwpYFEUDz7KMkdaABs0Xt0AC832c7BQYOSggz+3pwmIxF0IAgYbhUh7XiNsComlYsFod+GbDApw559A0zbBGnLRCHB0QtwW+93sI6trhlMQbbgscHMiRg9EZfO52cLfdOpwrdMBdB2fP4AuToKocLm6F3YLpTg1NzvAbzT0g26AdGC4D1y4lkN64Jm63IKiTPgPD1VRZsUk+vYlekiTjx/H314iYIyaIe8QU8Yh40PFE68jaB+Id8YaodFz/CDAAbztQlsKQhv4AAAAASUVORK5CYII=",
	"083": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAFqSURBVHjapFM7TsQwEHVQ2i2MBFQ0ewWfAMlpqLYJRyBHwA0SosoVdq+QZiuaRILQp8kB6AGJFFvmM8z4t0lYtgBLo4wnb+a9GdsBALD/rDDLMojjOGBJdBghJbCiIO9qFn+meDgMw1GGSin9FXePD4fiYdd1x/JBSBlo7/Z+8kNUr6ZA3/fauYk5NE1Drk7ICwaRNL5e2bRFbvFh27Y6UJal/q4un9i6UpCIFJMVi5c5VFXlC7u1ra+nLWCiBrxxZZlNj5vNxjDKbNLaihn8iVOw5gUQs2XSZ7tsUsDEgIx8lzxW41twU8XjcXIB1Xig9WHeildA03YTt2xeyZh5pGQ6g0iaAAFGzAHnZtoY97ERwV4BTdsl58WegU6nruv5/QiEEFQE/D1w0xYiZYkgJbpvfzrz5fC+Baz4A4iKfr2iDk9v4UUpBfyvr9G+sgXaKdoZ2gXaud0vLG6H9oX2gfaO9mn3u28BBgCmP7IZ0Bm6VQAAAABJRU5ErkJggg==",
	"084": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAIbSURBVHjapFM7b9pQFD64rikggZogZHfgB7DZrEQCiWxeK6LMpv0LXYKqTK06dStkrFQhZWWLUjwwFLUWykAkJAibMZRHQQaMefVcC98ihS7tkc59nHu/c7/zuJ7tdgv/IywZXhe0fVsM9QxVzmtvJJzJCzXUEmoR9Z7ezN8A467j8TiZsizL3kYikQtci5BOg21ZsJUkcS0IF/Z6fYv7rGunDFarFVSr1azf7y9Eo1EIhUKg67pzYW6awB0dwRPU7fExb93dFeZFQgSuOBwcBrZtxzabzSXP8+Dz+cjeUeh0YDqZODNRFvP1VBBgPp9foj1GGViWdYZgnuM4cgg7G4JaMCMOWi0atpeAOI7/NRiQPOUcB4uFJT/zemE2ndKLaHNeJSE4DPbEjyF3TFOmDixrIXoYBqazGb2ENmcmydI07VAFxf0QKHUi3W6X2NRddTyH0K5TdpfE2mg0EgOBgAM2DEP9lvyZOoXnZTxOHuygl+naDYDklrE0HA7FCSYMy6f+yL9KnXw+KcuyfBBcr9eh3W6XKAPSYf1+X8FSNpBySvoklTOZTHI8Hj8CDwYDaDQaxnK5LO47uEfwuah8V7+qH8qKoiSbzeYjMIaJFW2BaZo5t6U99DNdv4cX9Y9JhmG+YEsI4XAYgsGgc0RCQ4bQ6/UMDDeXSCSuKpUK6G/1Pw7cD3X9cEo/k1uqv32m4bvhHoN/lN8CDADC1RzhZ9STGgAAAABJRU5ErkJggg==",
	CRAN: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACkklEQVR42qWSX0hTURzHv+fezW1uRndLy5bpnNMKSdTMVCzRQsFCiIKSCIKeorcIMugpCuqh5x6CfAgKUh+EeinqpdA00KFOlw/O+WfzT5vt6u52d3dP9x5JXGQE/eDC+f3uOZ/z/f7Oj+A/g/xeUBSFxmIixI0NKCmF1SwWMxwOB0xZRrIjQD+4EFpCKBRGMpnUc6iqqq1ltk4raTid+SgvPwyb1UoyAIlEgk5M+SFJCahpFalUiv2xWrLB8zzLRXEdK8ur4A08WppPIi8vl2wBvGMTNCaKoCoFxxG4XUUQ7HYoGizDnixjZHQcs4EALlzsYEpIJBKlk9+mmUSO43CsqgJms5nc7fbS3uEoKKXsMKWqZimN9uq9aDogIl8woa6uhpDZuXkaDM4zmWWeEt0nU6UDeoYi0ATBZuYhab2Q5DQD3mxzosy8iLPtrYTMBII0MBtkjaqurIDdLjBAV/co7R2KorwgG31dtWQ1lqQ1tz4yFdfPuFCZM7cJCC8t07FxH9Ka32JXIUo97i1Az5fvEKwcLjc6EVyJo29ggdm5fa4AlbkSGhpqCdv86fMgjUTXQLS0of447IJA7jwfoa8HV5hk/dNvNvIEnacKUGYJo6O1frOJOiAel+jA4DCiGkR/e7fbhe6BON54Y3DkGHGidDf6h0Kw23icP2pC5+lDcBfmk4xBSsop6vNNYmpqGrLWsJe+bPgjJuy3Kbh0ZAMvRgkW4yYc3GPBhwct2lTymYDtExkKL+FhXwBvvWsoyTPi8RUP5n5wuPH0K7Pz6FoVrjYX/xnwK+6/8tFn72ZQUbQL/fca2b6mrvfUP7+GfYIFw0/aYDDwZEfAuiRT/d0N2nAJOSayvaaHYM36O+Bf4ycC1zggzvjnSQAAAABJRU5ErkJggg==",
	RepRsrch: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACUUlEQVR42oWSX0hTURzHv+dex5x3ilu6/qzlVlYIg1FS9JAlSSKE9FJBEmQUgZFP0UMPvdRDhG+C0EPYa5BGjLJgiUnetmaQo1zaS66y2Vbbcrq73d3d072HMMc2/MGFc84Pvufz+9xDoJWiKHQx+hPR6BJyuZy+h6qq2lpm64JSgN2+FW53C8yCQLCuSDabpbNz85CkLNSCinw+r50CgqkGPM+zfTq9gnjsF/gqHh3HjsBma1wLIaEPs3Q5nQZVKTiOYJfLCYvVCkULW1+KLOP9zEdEFhbQ29vzP0AMBKmOyHEcxj5XY3Q6CUopa1KqaqMUcKJ1M26dcbGz5y98RRTktRigOube3c0Y8sUwEkxAA4G5moekOZDkAgu82mXHxY6mNYpTp08yH2Ricorqolr3eTDgjWA0mITbUYPhvhYonBEHrk0wikvHXejv2l5K4Bt/RQvavDtdTXggpjHy9jcsAoezbXZ8jWfw2L/I0K93O3Cu3VnigUxpIySSKRBCIMZseBSIM2T902828AS8oaasl8HLHkIyGYn6A9NIaiGTS414FlrGploDDu2phzcYhdXMYzVvrOiFYeTkPA2HP2FYXMXTmT/YZlb+/boMfmSMMJnqKnopelV9gyIdC6XQbDNg/E4nefImQq/cewdBqK/opSjg9sMwve/7Ao+zDt6bbazXfuMl/ZZQS7z0HHXAJtDigBVJpvp8VdqjstQaWa9/yE/Leek+aMf5ww3FAeVKDyjnZUeDCeJAJ9kwoJIXfZy7F/ZvTFDJy/z3FLZYTPgLN2NmirAwbrAAAAAASUVORK5CYII=",
	X: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAArElEQVR42qWTAQ6AIAhF4R52jzqIp+wgdI86SLqB+xG4tdiYjeT5QWT6ady8NF90jeyC7+LipwE29RIki662r9vZ/PCAGkB64q4JXeUK0AGgCQQVmAnGGH7MICZZPBABBqkA8aXsCqAMQKCiBqUY4PoKSFVEJdiVrvSeDwFI2sQtiGEpDxWcJOPw+Ft5qPCDVOAU0RKmDeXg9DGm0NRoQgUBS7DBANlDG4/pl92yoEi5GT/1LgAAAABJRU5ErkJggg==",
	accept: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAiVJREFUeNpi/P//PwMlgIlUDS2ro4SAmJksAxqXh+WwMLK+/ff37x8g2wkkxkisF2oWBeZzsfNM8DKNZvj47S3D3gvrGf79++sJd0HZbG82XJqBcvksDGwT3I3CGN5/vs3AyvSLwUk3gOHv77/bwQYUTHGtA3J+gmggRjEIyM9nYWSb4GEazvDi/TWG919eA+n7DA9fXmH48eMnA/Mrnr0VwrziLSGOqQx/fv9yfPryvv7WY/M/eFsl3cnqsc1nZ+Gc4GMVzfD8/WWGL9/fM/z+84vh+evnDJdvXQaq/23LmNpq8T/MPZXh8ZsLDNIiWgzfv/9h2HVsDcOPX98qebj42v0d4xievLnI8P3XZ7CL3r5/z3Dv4SMGYNjZzq05dYRZw1Lw572nV13YuZgZXn98xMAEjCBzHXeGT18+utibeDHcfXESGGhvGH4BbX7x+jXDnbsPGH4DbV7YcO4IPBZCStS7eHi4ShWUpRiYmJgYONh4GNRlzBnuPDvD8PXHR7DNH95/Znj88AXY5jU9N4/AwggejX458l3cPJylssriYEOQwcf3XxiePXwN1rxpysMjyHIo6cAjVbKLi5ezVFpJhIGRiREs9vn9V4YXD9+BNe+Y/fwIehRjJCSnOOFeLl6OIillIYYvH38wvHzwHqx536K3R7ClEawp0TaSr5edi63o1/ffIM0Oh5d/OogziYIMwIYtQzgNgJgZlzwMM1KanQECDABGPi0ENq7EYAAAAABJRU5ErkJggg==",
	add: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAc5JREFUeJyNU8FqE1EUPffNdOxIrGJ04wR3FSwoQmPduBFEyC4FNxW/wLWrLhSF7l35C1kmu27ciC40xGIVgyiixKlkYalmknQmk3uvixj7mgmpZ/V499x7znmPS6oKGxc/3L7s0dwjR03RgSmwMBIZhImkjUQGD78vb76z+WQPuNK8U3XIlFtJG3scgcEAAAcGOfjI6wJSGdZaK5urhwbcD5/MP4+2Pv8c/ip8G/zALOT5BHz2wqB3evHVzUpsAOBZp175n2YA2HUidGm/8GW+XQEAKjbvXhVofav/MUPW5cbI5ptipnaml4OIrJhYBhutpD1b9nUnc9X1YqTEG8anY0t7HB1pfRKJy6BUl1xVDcavbdu2ofc+/TuP4ygphCUwLJxpmAkrDqvAHQrvODABQw4U/pLGyvT0QmYOKcDCO25X+s0c/OA3egfVawtZ5Yk7igF2pWnmxFnP65SGI2AihqS8TqqK8/VStY+4vOtM+Y1xZsuB6Qg05pqUtlcNACwm59Z89sJT6fHp1ieb+xzq1/01YGKZzr68UYVouevFSFyG0qhGOspsIgZDalLaPrxMNk6+uH4JrI+VtahDKbAKGBwySUNIH8itt+9t/h/sYf0JXvR+8AAAAABJRU5ErkJggg==",
	add1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAO1JREFUeNpi/P//PwM6aFkdNQ1IZaIJT68JXZaFrpaFAQv4+/dvZppbDYrYrF0tIAOJNODPH4ZbT/djiGEDWA348/sPw68/vzDEiDbg9+/fDD9//8QQw2pAwRQXbAHG8PPXd1QDfv1iAKpFD/HpLL9+/srMD2/FMPnMrQ0o/MyAegw1E1dWZ7KATD58ZRkDIYBNDUgvyAUM339+ZyAHgPRCDfhGvgFAZ0w/dfICRiDqGqqh8C+fv4XNjOmM2JKyX47Cf20jZRSxq+fuMmya8oCRuHQADBxs0UibhESTpAzMONNvnHyAkZ2xqQUIMACEko/8sPYHvQAAAABJRU5ErkJggg==",
	add2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACDklEQVR42o2TzWsTQRiHfzOz3XwhWr9vHjyYCooa9SJIYgRBELTW0qqXJG3t31M9K5SiUtQq/gFNUxLbHtywadMokXpNQrpmW1NoPsY3s2lFm8MOvLzDzDvPvjwzy9BjnHswO88YD4MxdII5Obk+ez/yfy3rBQgOvpeJyeg/a69eLiL/9h5zBxiak4mJCLKmBXunDb3fh0Imi7XXd90BBoY/yfhYGMl0GdZ2C96TAZRyeazN3HEHOD/yWcYSN5HKVLD5uw3PiQDKuXWsTt8+CHCEiTA4B+sGuEAsfgOLS1VYdQIc96NkFqiaK6/qu05+w4KD72TiWVQtSmW82xdN0iubsMjB6TOHcP2sD93T+2N6xgALPiTjE1EYOQs1uwEmODXAVd6qt9CmQ5pXw5GA5lwpp9Bo39eHb5kCAYY+yPj4LaRWqqj+cgCgoqZkaLUkuCagUbHWxyEUmKka6dFgrRbBBh7NydhYBMvf66iS8XoDaFJ7p/p11Co7kEJAP+bfB/BOB7TflhJlowMY/jjPuAhTKHlMBcfo02tIGzXYDQb9qB9Vs+gI3nuZjsWfPa/xQiwpR59cxRfTVgAPdVDJFmG8CLl7BxfjfwFbTa4AJWrXeH7FLWCBACEs5bdhNxm8h30oZX/g69Rll4DEghx5HMLyxi7sXUDXBSrmBgEuuQWkSCx3xIo9sSJJgAO/8x/US8HZpQ+1EwAAAABJRU5ErkJggg==",
	alignBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAPklEQVR42mNkgIL/YIQKGMEIP2AcNYCwAYZ+/zHEz29iZBw1YFAaQC6AGfCfXL1g4sCBAyQb4ODggDCAEgAA84c5EQvEkCoAAAAASUVORK5CYII=",
	alignLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAPUlEQVR42mNkoBAwgogDBw78d3BwgPMpMuA/A8P/UQMoNIAUzVgNMPT7j9MF5zcxMo4aQIQBZMUCJYBiAwBfDlIHHhC2qgAAAABJRU5ErkJggg==",
	alignRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQUlEQVR42mNkoBAwkqnv/4EDBxgcHBwYGf8DOSTayDhqAJoBpGhGAvgNMPT7j9NV5zcxEnbBqAFEAYoNgAOKDQAAbldSEYIq7KMAAAAASUVORK5CYII=",
	alignTop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQ0lEQVR42mNkoBAwgogDBw78J1Wjg4MDI9wAICDZAJheRjI0YpoCdcJ/LJKMhn7/McTPb2JkHDVgSBnAQACMGsDAAACueDkR2b7HeAAAAABJRU5ErkJggg==",
	alt: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAkklEQVR42u3XywqAIBAF0BGhb6r/X/RNLqRGIRBRxx6jBFewB9rckwtBQ0QLd0dz2mb4coQn7/3QZGttvEfA6PAUAQAAAABwC3DtXqX5+Vhr7mtAqbA6IA2XANLcx4DW36muQE/xIYBSqwV+BqgVkgLVAfmYCkAq0gL0fv+vnRAAAAAAQA0QXmYeTlfu+5Ql4PwTMtDaO1Md92oAAAAASUVORK5CYII=",
	altToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABMUlEQVR42u3XvY5EUBQH8P8dvIpCLVFSKTWj0KgkSokHUE0tEqVkqmkUo9DqlBJP4FV83LWS3VhrdpLNXKZwGk7ujfNzEfcQOkbXdYjjGNfrFU3T4DNnETzPQxRFOI4Dz/OmnLRtSw3DQFmWcF0XiqJAEAQmgLEWqqpCkiTQNA15noOEYUiDIJgAsiwzKbyMuq6hqioulwuIJElU13VEUbRJ8a/wfR9FUYCMz4HebjdYlrUpIE1T2LYNMp7T+/2O8/m8KSDLMpimeQAOwJsDhmH4kXMcNx37vv81dzk2z0+n02sBawjmgHnxZ4Dl3PF/9xrA2t1tsgJ/XXxTwFo8Qr0M8OjNf7YqzAHLIkwAhJCHxZ8B5uP//gpYxgE4AAfgG7D7tnz3xmT31mz35nTv9vwD6gGSTuZUDwAAAAAASUVORK5CYII=",
	altZero: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAjElEQVR42u3XSwrAIAwEUD2g4FEDHrCtgiCiif3EUJgsWsSQee1C0LuriOhwBhVj9L6GhxC2hqeUyrsAdoe3CAAAAACAJUA9tUZ9/R7X+xowGqwOaMMlgNT7GMB9neofWBm+BTCqWeBngNkgKVAd0O+pAKQhHOAO4j8nIQAAAACAOiAvzC6n+WF5PT8BN7Ad8soKt7UAAAAASUVORK5CYII=",
	altZeroToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABMUlEQVR42u3XsYqDQBAG4H9FX8XCWrCMVUohaJHGSrAU8gBW1iJYCqnSWCiS1s5S8Al8FcU9I9yR8/SEkNUUTqPDLjvfrgoOoX20bYswDHG9XlHXNR45i+B5HqIowrIsOI4z5KRpGqppGoqigG3bUBQFgiAwAfS1UJYloiiCqqq43+8gvu9T13UHgCzLTAqPo6oqHA4HeJ4HIkkSPR6PCIJgleLfcblckOc5SP8c6O12w/l8XhUQxzFM0wTp72mSJNB1fVVAmqYwDGMH7IAPB3Rd9yvPsmy4nk6nP3PHY885x3HvBUwhmAOeiy8BxnOn1n4JMLW7VU7gv8VXBUzFHOptgLk3f+lUmAPGRZgAHpPmii8Bnsdf/gpYxg7YATvgB7D5b/nmjcnmrdnmzenW7fkXNr6STvELKhkAAAAASUVORK5CYII=",
	amp: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVElEQVR42sVTyw4AIAiK///ounWRh6u1vKlBwCbGZeEVwex+BAOG6P8QHFmI/jsEEPO9gwBDeC8zt2RKSh6WnSgqlhNBVILwkIVnQ2QAl8m7Y2rXAn5zGhEIQ04gAAAAAElFTkSuQmCC",
	application1Toolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAFHElEQVR42sVXW0hjVxTdeaoxadREcaKxiQl+1DrVFgZR/BIVFHwMaCf+aaWTD1G0IAhOpAPjGJBxpDgoaCJCoR+KxV8RtGCUKrQMtor1wVg6tnVifESjedl9bnLTmNwbM+m03RBy7zn33LPOWuucvS/nGgP+x+AQAJOTk9DR0QE2m41qJJg4HA7Q2Mg1UwT3s12HPkd+crkcRkZGoK6uzgdAJpPB8fExcLlciIuL+1dXfHV1BR6PB9RqNezs7PgAEFR8Ph8WFhYgLy+PAhJJGZohRkqDVi2RSODs7OzGOIvFAlVVVSASiai+AADScH5+/s5XXFBQAHt7e9Si6Dg9PYWEhARmAHK5bMDrvZaMjo7m1dfXF93GApP2wUwIhULY39+HxMTEQH9KSgo7AIGAv45yXJlMJolO15hDTxZKb/C1xbL0w+rq6r7X6xViu6u0tPSDu3c/0pL+kpISWF9fvyEZIwPEAy6Xi/xvIogLBCB+8ECXEw3Njx9/+d3AwIDd5XKn8fk86/PnQ5ktLS25bM/zeDx2D2DnhkAgcJjNJjHNQKQgDPT2Gn5++rRf6na7M1Dr34eHh716vV4RkweQgQ38OQgDjY3RAniEAIwBAC9eDHsfPvQBeGsPIIUUAyaTWXz//n2VXv/5FyiN1D/wemjoqyehIEIBBDMQiweQAR4FoLa2NluhSP/Wbr+4RwYqlcqN3d3dinAA7BJE7QGiETmh/mbAJK6urtGkpaVaLi4cJYRtpTLzx1ev9gtCX2gwPPqpv9+Y9I88EMyAUChwjI8TANWa1FS5xeG4DACYnZ2NMxr7v/Z6PYkAXHdxcbH68PDwEwTAyACTB5KTk2/bBXxKgpoawkAaMnBBAVAoFC8nJswpdXW1v1xeXmk5HO6lTqezojQyo9EoQQbvhJowag8E7wIfgHAJMjIyXo6Njd1BZmzIVg4OO8Ot+qtKpRKwAWAKwnYkAJv4uzCbzX4JUlGC2AGweSA+Ph7sdjuzBMQD5ChGBrKRgaVgBsbHxxQI4MjpJAA4CEAXDCCdx+P+QTyAADJi8kDwLqipqVWrVFkmNOHHfg/s4cvvNTQ0rCED7+O4c0xYrqysLNHg4OApAkhFANZnzwYzm5s/+5DNAycnJ5FN6GdA3NDwqXZ19fs9TDIi/2qcGo1Wvrm5eYjDSOXiweqGj0UM//Xr3xzYxsd3udXq7PfS09OlMXsA73nd3d3esrIy2W1HMdsJjQs5KSoq0saSC7aQyiyU4k8cRJczKN6NCojcXJMSD6h0QLSlOL6mmjkcb0JC/JLNdqKPOheQBtzv+KDoG0yrSn99QV6Ir+ZyyDz+uf1IfPekNPCDCTzB5XI8YnHi3Js3R0+iPgdoAP9FsHpgZWUFtFotdSSzFZ5MpTrdRvY2rbXT6aS2IN1H36+trVE7g3EXHB0dQWFhYZhpogmSyPLz82Fubg7a2tpgamoKmpuboa+vD1pbW2F6ehqampowc/aCVCplZgCTCiQlJYWZhi442UpxEgcHB4CJCba3tykWCZDKykrY2toCPKhgfn4eKioqqH4yRxgAMiFhAAvKMNOEUh0qAd1HAJCVGgwGmJiYoJjo6uqCnp6ewH17ezvFQJgExBiLi4uQm5sLePDcmCjSpxYdZAwpNEIjdMzy8nL4hwmmXLBarUAXJqErDS3Dg9vYvgvYxhOvkNBoNJQ8FICZmRno7OykQET6JGNy/m3BJBUe04A5BcrLy30A3sru7zj+AsE9Cd3tl5Z+AAAAAElFTkSuQmCC",
	applicationToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEdUlEQVR42sWXy28bRRzHf2s7fqyfa0dWRITAdqmp0igSEqeGEEQThMKhOXLgVhAIqVLybyAQEoqUG1KQEPEBU6CC9hSrig3i0qoSTWNM2sAhTpzYjh0/6sfynX3YW2ftOA6BkSzvzO7MfOb7e8wMJ6LQ/1g4BrCyskILCwuUzWalRsbEcRypbOxZr2jfd3vu/I79hoeHaXl5mebn52UAn89HuVyODAYDWSyWc11xtVqlRqNBgUCAUqmUDMCoTCYTra2t0fj4uATSyzKqQrqSdqy6s188Hqe5uTnieZ4KhUIbgDWk02m6dCn8QS53+JbfP7yaSm1F/m0FisUieTwestls+gA+n/fXWq3+stcrfJ3J7H/0nwMIgudeo9EM4j+yv39wfZBJwuGX3qlUKs83m00zq1utlu1k8s9oTwDmAywKBEG4DycJAGAVAO8PAoC+X2HwqWZT5Fmd523rxeLRNRXA7XZ39wHQ3QN58CwAHo/7+8PDwlUMLQEgsmJQ5PU+TSDABPUgPlo9OMgOCOACQLEFABPEyuVTATTOqMAAAG0fkJ0QUbCKKJAAJiYuv1oul0fxyIJchKR7Dx78vt4vQKcJdH2AJZ98Pq9rAuSEL3K5/IwMwIlwqt9Qf69fHxhQAU8kk5HD0OVyRguF4rwyPgD4u0dHR1M9FLgJBWZOpcCzeaCh5IHsdWVF0Xz+UANgA0CpK4Db7boJ4JmBnZCFIXwgsreXkQCcTkcUcdwCsNv5u6hPhcMX3mC+gf4GmKZuNpszyWTqjsvl+gETvdlWwAwFqv0BsDzAFMCqI9lsTlcBTLSOXW2ym284HPY7pVJ5sq2AFQqUnwFAm/TcNQyZAogCXR+w2axxTHAFE92CKd5GGxSgKtoTaJ+GQrch+WvdTHCCDwiKAiwK5DwAm0bh1S0ADLiOASdhmlswRQsAq0pgpdMAuw2QgQGUvUBAIpLzgNPphA8UNQDWOCbqqsBxE5zCCTV7QWs31FEAAJUr3RXgAVAZDEBvOwZARAuAzvCB0jQAvlMBMEYFCvwCRWYcDsePeN8yAdpjUORqTwDWsLu7q7sXhEKBDzHgKySduDhxaGgo+eTJX58Egy9+jPAaB5MR72qIjj8eP97+LBh84Ua1+vQilLQoCmxsbW1/2hcAQg4mEM+0GfUqfSWier1+gSUT7A3vngfAiWEIgMsmk/FvONUjvCuRctyXh5BOvWo/qYLDrqgc+dnJVzk0K6/wGXswGg1P4Rs/PXz46MueCni93vu1Wm0CfZr41dkgyqx653T1bK73jbbOnps8b/05nd67pgtgt9tpZ2eHRkef+xxpNoDtmVPO9tKS5LpcVVbH6iK1LkOiMhEna0Lae4PIGY3GCvzrm42NzW91TcC241gsRmNjYwTvbS/jhKuWWlgfTHJcoo4+iUTi+MXE7/cTsh6pBxPtrUYF0A6kbdO7E3YCaPuzaxkroVCINjc3ZYBoNEqLi4sSRK8rmXbF/V6qO69wrN/IyAgtLS3R7OysDNDXSOdU/gEePzbd28AGbQAAAABJRU5ErkJggg==",
	area: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAj0lEQVR42qWTURKAIAhE5WTu0b0ZaYOBhI7WTh8R8NytiVJVKYUBUBJxvWrx1DPJnAL4fqZaQfosteV2k4FwMILYgx4HM0AEWQJIemx2LOAVs0cAcpBzhPjlwUEE8JBJvDUggpAxsowQQcilGB2wJD2QAjJcx4A4eA/S1wge8NvBKeDTdtr447YB+jlBJ/UFYjRjdSgdKiMAAAAASUVORK5CYII=",
	areaLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAxklEQVR42qWT0RHEIAhEoTLtScuIPdkZJxIRyDg3l+NHg+5bIAnCiN475Zx5iwRwzQ1ABR8kaZe40AB4TyPZ1gUDWWKFqBGLecOAm1gCpATnaCIVpJydiC+ZtYay1eQAmJXGSuoq25msFhggQjskN7NHMMQMMbVwPHqndoKwGZ8dACI+QXalWPZbSGMGSEYcYXA7ksvvCiYAgjhACCGa2A+JLUSMfpgiHHA+11Xu+Ba+xRL7N2FaeBEKeCNWwD+hAPtT/fL8ASFmlYbeMRjkAAAAAElFTkSuQmCC",
	arrow: "data:image/gif;base64,R0lGODlhAwAFAIABALW1tf///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTlDMzQ5NDg5RjJBMTFERjk4Q0ZCRTMyRDcwNkNBOTYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTlDMzQ5NDk5RjJBMTFERjk4Q0ZCRTMyRDcwNkNBOTYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1OUMzNDk0NjlGMkExMURGOThDRkJFMzJENzA2Q0E5NiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1OUMzNDk0NzlGMkExMURGOThDRkJFMzJENzA2Q0E5NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAEAAAEALAAAAAADAAUAQAIFRGKHuwUAOw==",
	art: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAJ0lEQVR42mNkYGAwY4CAU1D2KUaogBmSIAO6IJiNLAg3ghFNFVgBAHi3Bt558F+pAAAAAElFTkSuQmCC",
	ats: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWklEQVR42rWTSxIAEAxD5f6Hjo1F0UYxzcYveUaB9ilUApjxQwSRmT+ZOPq2nXIeAAusBdANwGDMF4ANUW10C5A1uD7/CYAMSN1CpLAG1qDW5EPyQNJf+plS6uTCIhEGHbKnAAAAAElFTkSuQmCC",
	axes: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaElEQVR42t2PUQoAIQgF9WR5dD1ZtcJKWNjq5z6CEHvDhDDT50EAhEKwa1/bNUBkwMx9nYloexMafAKsBr7gczV4AK01W4rIHeANIsDJKGXgdwrIGBwBPzSARDaDTPmNGVTKBli/kb0HB9t8DwxAzZsAAAAASUVORK5CYII=",
	axesMinorTicks: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANklEQVR42mNkAIL/QMTIwMDIQAZg/A/Wz8Bw8MABcvRDbB11wagLRl2AcAFZuhmQnA3zBqk0ACl9O8i+QcHhAAAAAElFTkSuQmCC",
	axesS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaklEQVR42r2SCQ7AIAgE4Wc8nZ/ZaCWhVex6pBsSL1xHkakqlSDiErgeydkENVDVJCLM1lkmMIM3gZ/vjRuD4wTI/SGCCH2LYPkNejRDgi/8euCt339iaDCzuTHwFGg7hQsReOUqRGtWnQsoHmYPNhZtQAAAAABJRU5ErkJggg==",
	axesTickType: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATklEQVR42t1SOQ4AIAyCn/Xp+DJvN5cSJ0kTJiikZQX6AOwjqUZEijnEw4TTIw9+lMDZvhcvnBpZtnpfE9gGp3+R/ARPzvhBAkuNB4/UAIGTjIcSFbTaAAAAAElFTkSuQmCC",
	axesTickTypeDotted: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOklEQVR42mNkAIL/QMTIwMDIQAZg/A/WD9bNeODAgf8ODg4k0YyjLhh1wagLUF1Aju1QiyEA5g1SaQASDerIeRQUrwAAAABJRU5ErkJggg==",
	axesTickTypeSolid: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANklEQVR42mNkAIL/QMTIwMDIQAZg/A/Wz8Bw8MABcvRDbB11wagLRl2AcAFZuhmQnA3zBqk0ACl9O8i+QcHhAAAAAElFTkSuQmCC",
	axesTitles: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVklEQVR42u3S0Q4AEAgF0Pqy+vT6srxgljYZ3tw3yz1jIBwGjwEDsCpNmIjYuGZmfAv4gk8KIKI+VNW7QHSiLcDPPlCBccPqH4SvsFOIMgHtSokiXgEKoTdoEXweOTEAAAAASUVORK5CYII=",
	axesTitlesS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZ0lEQVR42rWRWQoAIAhE82Ye3ZvZQkF7o5AE/syMT6NQS0Q0d2amYKhBnEPQgKalNFaTg9wELWAmmGlOdP8IkP0hgleoi8B9g92AKwFCNIhdv2A5GBRgMS8BPQXaTbgQQV9a3tFYvBGjXXlQ9bByeQAAAABJRU5ErkJggg==",
	axis1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcklEQVR42sWSYQrAIAhG62R59DpZI0H2zabZCCb9EK3Hq8wJovNKKfO6o9baJSeiRy9LUxoD8hmABngII2ww6qUU3tRaiwG0wRtA22wbYG0CRAxcwD8G+mG2DaxJtOZg+oXVplWYAHwbK3cBxwy8+x8BXOtZmhHnXVVzAAAAAElFTkSuQmCC",
	axisTitle1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR42sWSbQrAIAhA58n06HqytdwfMS0bwSQo1B6vD7hMMPPdZyKCKB/V4KloEXS8zZ8B1sBuslE26DMiapOI1ADeIAJ4m20DmxsAFYMp4B8DfzHbBtlPzP7B8AqrplWkgMjGr6eAYwaz8x8BNGQvoBHZBWFKAAAAAElFTkSuQmCC",
	background: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB6klEQVR42p2STUhUURTH/+9pTgSDizAIqxE3FRFILiL7ooWLKYv3pfDcCAq2KpQWs2mjaRAUtJkKU4ii0vC90aRBxmljPR1aRa6i1dgo8x4zEX0MM1b3eH1qozYxMn/OXdxzOT/+59wjYIOmIpOpXeW0++SzJURVwo8cwx9Ga68CD4GHYCiSpCGfXVX0deToY9P6sFNkGMgcAw1KKCTHcfDGsoY1RdE3Adqu9FDjuRM4XLMP9fc+AgUAoy+eQ23WYSeTeBuLDWuyrLuAjq4bdPb0cUSi07jefRmHbr/HVY+FVz4d0pEq3PHvdQETxgguSCoEsdx1YsVmDaHz2k061VCP/dXVqPR6cTf4EBcbz8BZTGDgay0+JVLI3FddwNPJGXh/fkbuN4PWosMcGwMH9FNbq4aKHRVwUml8SacxPfMOlR5grsyHKdsDNtjyTzvEZ+sCVi7tXb2kq5ewsJiEbdtYSMxjKZvDnuYAeodeAo9aCwNCofwQO7r76GDtAcTn48hmshgK9rl5XyCM+K3z/wGYecD6T7BfOTx50I9iKggIhyfI729a2ZfSADxBsiSXDjBMgxRZKR0wapqkytt3YGz8hdUWQrwFqXj1mkLre/A3MT7+jYh5GWNFi0VR5E7F71vN1vFTtm0LXMsyZtVTnbf4FAAAAABJRU5ErkJggg==",
	backgroundGradient: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACNUlEQVR42o2TTWgTURDH/7ttk1QIPYiCVI30oiKC2IP4jYceYlR2s2lhcym0oKAoLRVyEcHaCEILemiVmoIoapXuprUYShIv1a3Bk+ipeEpNSxISET9ikuo+30s3Zk1T7PCGB//Z+TEzb5aDySLhmcyGerLx8OMiohLB94KO3zoxohw9HD2c4hYEDyrqikVfhvc+ULX3Nl7HaG4/SEBALUun03ilaeMet1v+B9B58RppO3EQu3dsRevIPBAQLlN52Qg3ULdOPHvil9plpJJJvI7Fxj2iKJcA3T3XyfGjBxCOzuJK7znsGnyHS1YNLxwyhD2bMOTccoF+ZptWng65BAkcX1+qRIu9UbizfTfIkUOt2NbcjCa7HbeG7+F02zGklxIY/dKCj4kMcnekLgZ4NDM3Yv/xCYVfOjwdMtTJSVCAn3R6PbA0WJDOZPE5m8Xs3Fs0WYEPdQ5EUlbogQ4vAxjeyG5C4C8BWAtdPf1Els5gcSmJVCqFxcQCivkCNrf70D/2HLjvFcuJxt1IAYNqMFgZYnfvANnZsh3xhTjyuTzGhgdcVC46fKFI/OZJVznRBLitBtUKoPwS+nIBD+/62Tv/ZAAjZFkXIBSaJk7nKbYv3jUAVS1UAahAREFkADb1fBVg9RCrAYqqELfoZoDzBsC8SDazU8DVVYAJVSWSWKqgbw2A1XAG8CnmV1hpIUhbqP0P1LJgeQ/+ClNTXwnR7bqu/zeZ53laKf+Nq9L3Ua9bdwnU/gAi5e1TilSTEwAAAABJRU5ErkJggg==",
	backgroundGradientWindow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACG0lEQVR42o3SS2gTQRgH8P9uayNCKCIKUjXSi4oIYg/iM3io2PpgXy1uUQoG1INKi9Ae9GJtBUsPHuqDGkEUtYK7aX2EkkYw1W2DJ9GTeEpNQ3ZJRHyEpOqOk8RN1pol/pm9fDPzY2a+ZWDLZGgitaSWLNtxfx5hkeBbzsQvk/yZZehg6GAUgeMklKvFhJ+HNt1RtbeLWRMjmS0gfg6VYhgGXmraqCQI8l9A5+kLpHnPNmxYuwpN197jxZGl/2xOGQmIbTL0ZBKvotFRieflAuDruki8u7YiFJ7C+e4TWD/0BmdcGp55ZHAbl2No38oC8FR9iP2cCIatLZxEi84ozPGzl8jO7U1Y3dCAercbV67exMHm3TAScYx8bsSHeAqZ6+LRPHBvYvqu+/tH5H6akNplqGNjoMAA6eyQULeoDkYqjU/pNKamX6PeBbyr8WBSd8H0t5+yrkEIhiORCLxebxHIF4919RFZPIS5RBK6rmMuPov5bA4r2nrRd+sxcLvjnA0YKAGBQPkRfd39ZF3jGsRmY8hmsvAP9+e7NujpDfbELrcO2oCeMqCWAasT5o8cfIf3FhZQ4MbCTlDgpCMQDD4hLS0HYC2gwIMKgOwI0ALhOd4OBCsArY6AoipE4IUS4BRH4JGqEpEvnqBa8oBi70LxCgF6Ba7qZisB6z8oFcbHvxBiuk3TrLqZZVn6RuxXZkF9M/1q/vsINL8BAdv7UxBD7DUAAAAASUVORK5CYII=",
	backgroundType: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90KBhATCQm6uGoAAAH1SURBVDjLlZJNSNNhHMc/z7O/W6VSEKxRWJKQXYLoULQYFREoXSylgqAOlodqEu0QFRVRejLQIK3ADhkb2dzfRZBsdvEQdKhDQfcMmmNCaaL/vfT/dXCTvWDaB348b3x/r4+iiHhsbHqdIRsPBDOMtwpzaZs/tuRfFSiFUmrkREtLG+WMv4vtOnvpjnT4bwntpixHMpmUcCQSqnBwzn9XXkRi8vHTV+G8KSABkM68BUBuhIeDIiIylUhI2DRDABqg/co9OXJoP2PxCaprakEbdPqv9zT0fO4LvE30AQuA5XJoxM6xyePB5/WejkRHw7oj0C0HfXup27KZq5cv0N37hFfNLhp37qAm/ZOB1+/JO1iYra7jzegI4eEQbrcbsaXVAKGhvh5nlZNEMsXRwz5iEx9Y7wKPw+BL1gVgAZxp8l4E+gHk5GLp+umDm2pw6CW/ZmZIpab5kZhibRXMzafZ13QcO5crZGAVxEuIYAA8672tlNLSuH0rk98nseYtBh/dP8ZDMtuubYh/gwxgVnQeQZVPws6mGXrc1ZaPmil8kQqpQMSMLE6hwKnmPTwf6AJwFlmcf2AUH6x0trBdk19NVkCXpiXFDoKsAr1MS/pXIxZUaQlaqaUGrSq6UqVTMKPRWRG71rbtlcVao5T+rcrudwMO/oO/yMzfb0o4U5cAAAAASUVORK5CYII=",
	backgroundWindow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB80lEQVR42p2STUhUURTH/+9pTgSDiygQLcVNhQShC7G0aOFi+uJ9KTw3QkKuCqVFLdpkKi4M2iihSVBgFr43mjTUOG6sZ0OrqFW0SRtl3mNGRFNmLO/p9hxnVCa1/py7uOee8+N8XAGbNB58HTuQSwfPDK4ipBJ+JBnWGKVeBW4CN8FQJElDxruu0ETw5BPT+rRfZOhbKQc9kpBNjuPgrWUNaYqibwE0Xr9LteercKKkCBW9X4AsgOEXz6DW6bCjUbwLh4c0WdZdQFPLPTpXU4lgaBJ3WptxvPsjbngsvCrWIZUdwn1fgQsYM57joqRCEHPdSqzwe0O4drOTqk9X4EhhIfK9Xjzo6cfl2rNw5iLoWyjF10gMy72qCxh8MwXv8nckfzFo9TrMkRFwQAc1NmjI25cHJxbHfDyOyakPyPcAn3OKMW57sNZfn25DSDVNfLYu4M/laksb6eoVzM5FYds2ZiMzWE0kcbjuFtoGXoIeN2QH+P2ZITa1ttOx0qOYnplGYiWBgZ52N6jkdgDfui78BWBmABubYD+TePqwIx20XTsCAoEx8vkubQn6JwB3kCzJ/w8wTIMUWUkH7aSsgGHTJFWW9wwwNm9hvQU/b0HaPTsl/8Y/SDtGRxeJmJcxtmuyKIq8UnFpe7Gn+MnZcwlcvwHnft5TWRqJHAAAAABJRU5ErkJggg==",
	backgroundWindowGradient: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJklEQVR42o2STUgUYRjH/zOaG8HiIQrCUvFSUUHkIcpKOnhY+2C+lMaLkFBeDCWooC6ZGxEFXZTFD4IC3cKZ0aSl1u2QNbZ0iuoSXXRbZXfZjaiUXct5e2ccZ7fdhfXPOwzzPP/nx/O8zzDI0XTwRXJLOdnaMLqCkEjwO2Ng1SB2lqGHoYdRBI6TkI2uKfQqeOCRqn/czBoYXD4EMsyhmBKJBN7oul8SBPk/QHvXTdJ08gj21u5E/cAXYJhrzC8efzr2WmyREY/F8DYc9ks8L1uAju5bpPH4YQRDM7jRcxF77n3AJZeO5zUyuH3bcN+z45zpm1Ke+E9xIhi23OpED79TmAuXb5NjR+uxq6oKlW43HvQP4UzTCSQWoxj8UYev0SSWBkSrg9GXs3AvfUPmrwGpVYY6MQEK8JL2NgkVmyqQSKbwPZXCzOx7VLqAT2U1mI67sDrU6oxB7/G6+SYEXgtgfpzv7iWyeBYLizHE43EsRCNYSWewveUqekeegTxsywXctQFXVE3LXmJHTx/ZXVeN+cg80stpjPT3+aips/ZaAHN3mnMBPhvQqWpqFrC+CeNPBo993jHbJOdvggKcXAEgEJgiHs9p0xSwTc1FAE6uAEADhOd406TbpoYiACdXAFBUhQi8YJo+o4QoYH8BYFxVichbHUQ2AKhWcrewNoJGR+BK1TrS1v8DJzA5+ZMQw20YRslilmVpp+wvJi9+kD5lG26B6h9UzuxTTr7dBQAAAABJRU5ErkJggg==",
	bar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaklEQVR42t2TUQ6AIAxD2cnWo28nE3GaLAuCTL/sFyPlpSVAZZeIbACoJEQjQNv3c89Dl+kOAPC51j5gluBTQFQ7s1Th8DFsVjGATxAvzcCLAIYZVOQZwFdIAV4n+FGFklTqBw4B8WXO5gr2qr5QBHQHPQAAAABJRU5ErkJggg==",
	barLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAApklEQVR42qWT2xXEIAhEsTKpKakj1oSVsSK6yxLzMnyJwHWGkwQoQUSMiAEmIpwByv1m89Kz7gAy3IpDAGJs5zwGOAXc72YBYCEe4Ows0ndkgZu9HQAjCn4ptSSK/hTYpckL2uQA8jJDokwwBETE2piJmkxOZgd1uOYdYC14wM+rQIIqilq/pUABYkGHvzt4DnBLfGbhAvBaQQfAZEz9gacA/2Ve5R+6ndBQHhOxdwAAAABJRU5ErkJggg==",
	bg: "data:image/gif;base64,R0lGODlhoAMBAJEAAP///+Dg4N/f3wAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6REE3NkYwMTc5RjNBMTFERjkwOTFBMkJCNENGN0UxQkIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6REE3NkYwMTg5RjNBMTFERjkwOTFBMkJCNENGN0UxQkIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpEQTc2RjAxNTlGM0ExMURGOTA5MUEyQkI0Q0Y3RTFCQiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpEQTc2RjAxNjlGM0ExMURGOTA5MUEyQkI0Q0Y3RTFCQiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAAAAAAALAAAAACgAwEAQAIlhI+py+0Po5y02ouz3rz7D4biSJbmiabqyrbuIcRCQM+1bNN0AQA7",
	biggerFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABu0lEQVR42qWSv6uBYRTHv28WJT83sRmkDAaDQRkZZRAbmzKzkIFJyWSwIYWBDMTAH6BMEiULJSElYZA4932fGze3e7tv3aennjo/Ps8533M4/PNwYgP3+z3N53OoVCqYTCbuVwCx+3IyfyaToXQ6jcfjgdPpBIfDgXw+D4PBwP1YwRMiAIrFIgUCAcRiMfh8PsxmM/j9fjidTrTbbe7HCoTE5zsYDGi9XsPj8bxivV4v9Xo9HA6Hd8Az6TuUB1ChUMB2u4VMJkO9XsftdsNisfgC/JZcqVQoGAzCaDSyshUKBcrlMq7XK5bLJffnFPR6PWm1WgyHw1csrwFrgZ/MO2C1WhGf8GZTq9Vks9nQ7XaZvdPpkCCiTqfDdDr9BEwmE4pEIrjf76y3bDYLi8XCfIlEgpLJJMxmMyQSCc7nMxvnbrfD5XL5BFSrVeJ/Bw/hwuEwbTYbNBqNVyW1Wo36/T7kcjlCoZAgHlqtFnK53FcLwrLwY8FoNIJUKhWUFrWlLMjtdpNSqUSpVOLi8TjxLaHZbIoH2O12slqtcLlciEajTKCnaKIA4/GYUqkUNBoNE+t4PAqrKx7wn/MBCr7QEfUMm00AAAAASUVORK5CYII=",
	binData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZklEQVR42q2QQQ6AMAgEd19mn44vw6bxoGgpiKTJhpaZpBC9tB8CxFmZntcLmxZ4e3cFqywLRoqIolCswBGBrmbogKFZz66RufQX7NJDS7TQ1trIXWQu8KCpIArdBF+ghyAL/So4ACnNjAdXAplhAAAAAElFTkSuQmCC",
	blueCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQyLGsfm74AAAI3SURBVDjLhZPPS5RBGMc/z8y877s/lNyI9Q9Igm4eVqqlHwdB61BsRVCWnbsFJaQkSRAd+nWtY+RiF9vdtF/UglGEEdQlCW+7a4gsCgapJO2+0+F11zWNHhgY5pn5zPP9PjPydHx8sVKttljfx9IYFhCUCCIyfyKVirNVPMlm7f+iXC7b0UxmZKvzytrg3kKxRKE4Q7E0Q6E4Q6FYAiA9MkI8Hmd/MnlmNJt9vBmwNjFG4zjrwxgNgCjF/MICra2tHEgmT2dyudFGgGFNuVIGpaSe8P1gfVdbG6/zeazvc66nB2vtyY0AW6tAIbIO0NqyvLJMRyJBRyJRX5e/rDZ1LUrXAUrAKIVTrbD68we/Kj4A22LbaTZsDahpVgKuVoQ9jfTng4be7AQL0jeOCYc2mthYgVaakOMQDntI/xveXewCI2AccBzQ8OFCJ7GhF3YTwGhF2DN4ERe58pKH5w8yNPEdqhZEglGpMpAv8eDUPnZcDyB1CY7ROK5GLj3jRipJ5tsi76ensXeOQeU3YLF3UzgDYzR7iqtdHdxSr+wGE5HAh9mlVSKeEHgqoHRDFyDqKmaXVoPU2i601kGT7h3n/sQXXKPp2duO9OUCgNLI5Rxnk+00hRyGJ78yN3i4Vyml6i8u4IO9nWL44xRNERftrvfNeIZY1GXs8xTla0d6gbQ8SqffRqPRQ761YC1KhJARYp6iezJE1Yfne1YAOPopQrMDc4PdvUC6Jmkn0LLFR9vNvyNdm/wBqxXMUVW3/TgAAAAASUVORK5CYII=",
	boldFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABHElEQVR42mNkoBAwInMMDQ3/41H74f///wuAdMOFCxc+YjVAT08PnwFgADRkw+XLlwOxGqClpUXQAKghCtevX3+IYYCamhqyAQ23bt1qhIqvB1IBSHIOQLmDGAYoKyujGHD37t1GqHg/kCpANgAoh2mAvLw8sgEPoBisATkwmZiYFO7fv/8RwwBpaWliwiDg6dOnG7EGooSEBDEGgKLT4OXLl5iBKCIigmzAAqBTF0BDPQGEkcPnzZs3jRgGCAgIoATihw8fGnHIHQDKOWIYwMvLi2LA58+fwQbw8PD4MzIybkCS2wCUC8QwgJOTk6iEBAQF379/n4hhACsrKzEGXACGjcPPnz8xoxEogdcAoDcWAHHBnz9/sGcmcgAABnt2EUVfzu0AAAAASUVORK5CYII=",
	border: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALUlEQVR42mNkoBAwgoj/DAy/yNTMBjcAxCFFM0zPqAGjBgw3A0jRDANwAygBAC8eNBGnh6k9AAAAAElFTkSuQmCC",
	bottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABAElEQVR42rWSoYqFQBSGf4PgYwhmg0WxCKJgUASzRrGLySq227T5DIIvYDIYDb6JRcTgrGNaFu9l3GV/Jp0z5zvn/DMcblSWJZnnGYIg4DgOJEkCwzC4u7u3QVVViWmaCIIA0zTh9Xqh73tIksQxAc5ikqYpfN+/8rIsk6ZpoOs6G8BxHLKuKxRFwTiOEEURbduyr2BZFjm7wrZtbNuGuq4RhiH1gn2FLMvged6Vr6qKnBNgGAY2ADVR0zS4rotlWVAUBaIoQp7nbADakT4jz/PY952ahziO2T14oo+AruvI+Re4xwBa+DP2DvSW/h3yaYr/WeGJLgC5zq+KuT9P8AUI62ER5SBzowAAAABJRU5ErkJggg==",
	boxplot: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAg0lEQVR42p2SgQ6AIAhE5cu8T8cvM80sIlHpNjfR8wkMCkXMnAFQsJXLGt7TDFDPZTzyUDdZACBe+yQ9d0bLDP4Ccs9OArTqG6sEE4CIFiduAJmBbtpIS0BEMyTmT82nTwNkCRPA01RPCW6AbuLOYE0HaaK9QXIBHI9f8vy6B9A9WcUHvD6hUL877ooAAAAASUVORK5CYII=",
	bpdata: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCBAbI3VHeScAAACASURBVDjLrVNbDsAgCKNmB+Po7mTdz1wIVmLi/CI8SgsCE6/3TuV3d2QfRiYKIFXICmCHgUyoAFagjQUazUgRjjWtYCHtiQEWA3znAohwrJkkhG4MEpiZDGcTkzaxGKTYmYQoY7kFd/+2kDtvbWH3XSg+0z3sRBJ/3sKxBJye8wPlgExQ+gkthAAAAABJRU5ErkJggg==",
	brick: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAKElEQVR42mNkYGAwY0CAUyCCEUnwFEwGJngKSbUZIwMqMIOpRBEAAQDvKAOon+kdXwAAAABJRU5ErkJggg==",
	camera: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACiUlEQVR42q1TXUiTYRR+Xoebzr5tlfv59scG1U34kxbmRNMgFDdJvBfDriIzCDOSkH4MJtltBJo3igXSjdIgMwy0VWTkdjsvBNlfDd2Gbm1rvr3fO6xuww58vO/3cs5znvOccwgOaOS/ALS1uahWq8fU1DPS2uqkOp0e0WgECwseMj4xSZlB+nhAURF+5nJIp39gdzcNcmf4Hi1TKiGoBChLS/G38/7d5erA3t7ebwCTqOP3+w/cBQCn04X6ulr+GInGeNDm5ib8Ph9CoSD/F0UjKquqYLZY/gCMMIDhuyO0vd2JujPV/PHb9y2srCzDt7aGiooKlJdrJS6IxWLw+/2orD4F0WiEcEjA/NwciNlspmq1GoQQqFQqpFIpTvfR2GMsv1vCR6+XA591ONDY3IJbgzexs7MDhUKBRCIBYrPZqCiK3CnHxInH4+jr60eEUf/86QPUGg0ooUhux3G6rh4Wqw1u90NYLFaEw2EQu91ONZITq1MQBAQCAczOvsS1q1cgGgzYPRmGYcaKRHUG0XAUT56Oo6urE1LSdDpdANhnIJfLsbGxgenpGVzq6YbRKEIMaPAiMo/GpgaEQxHW6ufovNgBk8nE2fISJAZScHFxMYLBIAYGBpmIX/Fm8TUOHz3CJKSIb23hfMsF1NTUYnTUDaZdoQSr1cpFlEwCyOfzkMlkzGkMk5MTeOXx8C44Wad6L/di6PYQE2+biVjCTsag//oN2nSuGdlcBnabDUWsG19WV7G+HoDD0YD98qRsXu97HDt+AlqtDqVlZVhafAvS3dNL5SyzUlnCylCwdhZmPJlMsnGO8lMyqcV6vR4qxjaXzSKTySGbyfJdkCYoz3n++x7JDryNvwAS4Q5KE3nGkgAAAABJRU5ErkJggg==",
	cameraToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAD9UlEQVR42u1XWSi1axR+tjlTynAhIiRCLpRkyDxcmDKXGyFTRIQMpYQLlIgLc0oZokwXhsic4UIiFyREkigyJMr+91q19zn7P3uyD+d06jw339r7e79vPe9613rW+gRCEfAvQvA/ga8QeHt7w8rKCl+VwcXFBQ4ODt9HgJb5+/tjbW1NJbJaWlqYn59HYGDg9xAYGBhAWlqaqsFiuLm5YW9vD5qamsoJbG1tISMjA6+vr3zDwsICY2NjsLa2xsvLCxwdHXF9ff0lAoTOzk5kZWUpJkBOU1JSMD09LXXT29ubHZ+fn2N5efnLzglmZmaIjIzkI3F2dkZiYiJvSkJAtCthQEAAjo+PERYWhq6uLo5CUlISDg8P5b5YV1cXnp6esLe3h76+Pm5ubrCzs4OrqyuFhIhIeXk5amtroaGhAYHIkXB0dJRvHhwcwNXVle3x8XEkJCTI3FFVVRXS09NhbGz8l/vr6+uoq6vD3NycQiKZmZno7u6GQE9PTyguq4WFBYSEhLDd1taGwsJCqYcoo0dGRmBubq409H19fcjNzcX7+7vcNTMzMxCIrpIqsLS0REVFBZ6entDQ0IDn52cp57QrbW1t/k0hHxwcxO7uLh+ZjY0N4uLiEBQUJHlmYmIC8fHx+Pz8lEmAjlyKgDxQ2I+OjiQ7p8wuLi6WVMyfERwcjOHhYX6GUFZWhqamJpnvNTAwUI1AS0sLioqKJM5zcnIUrnd3d8fm5iYnJ5UwRef+/l7mWqUEKNtvb2854SjslPWydv47KisrUV9fzzblEuWUWgT8/PywurrKdnNzM0pLS5U6J5CQEWGBQMD6Eh0drR4Bkt/+/n62k5OTIS5ZVXB6ego7OzucnJywoKlFIC8vDx0dHWxHRUVx6agKsa5cXFzA1tZWPQJUWiRKhPz8fAkZZaAG9PDwAENDQ2xvb8PLy0s9AlZWVri8vGR7aWmJy0wVhIaGcjsmtLe3o6CgQD0CBJoBfH192SalXFxcVLie9H5jY4N7BcHHx4fLUm0C4eHhmJ2dZfvu7o5J7O/vy3VOWkG9gkBkxfKuNgFCb2+v5KWkA1TjPT09rBEEOnOSYWpE4p0/Pj7Cw8ODq+FvE9DR0eFGFBsbK/mPZpmzszMmRFlOCScGOY+IiOBBRxEERkZGQmo+qoD6d0lJCWpqaljH5YHCnp2drXDnBJFvCGJiYoSTk5MqERDD1NQUqampfLZOTk4cHVI96oxDQ0NyE+53iHxDIBqzeSL6pz8PSKJpzOOZUFHL/ClQT2lsbPxjKm5tbUV1dbXUEPIToESlShFPW1LfBSSdU1NTPIx+fHx8q2OapKgvUFc0MTGR/P/f+jb8CfwCf1rNSUuRCpcAAAAASUVORK5CYII=",
	cancel: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAx9JREFUeJxVk09om3UYxz/v722ydEmb2HYiS50dWDdT5sS1uoOitTo7LSMFFRHRwnbaSUFBpzgsDHGX1YvgofUg7CIutd2GTIR2A1vcULN2rTYwti7tivRP0vRPkvf9PY+HFmm/1+9feHgcVWUrbr76+BNOMPgFxm1W49aLWKRcykq5dEPLpdMtQ/dubtU7WwPGO59MYdxk8f40Xn4Ja+0GYVzccAQnWgO+3394aLpzW8D02Q9DhevDGW9pvn41e4fA7gZqXkoS3n8QVWFl8i8Wfh3Am72LidXCjlB2ra6+8ciF0SKqyljyYOrPtga9tg+d/LhLvfySirUqXlltqah2fVXX57I6O3heR57fo0OHYjr8TF1KVXHGX29uUZHf87f+oLazi/1ffoeKMNZ7juzoMOXlHAfePUlD61FUhL+//4b7X3+GidXiqD5dIaXimdL8HE5VjEc/OYeK8MNrTzE/kabSQLg6Smz3w6gIiGVvx5vcPv8tVfl/kUDwjHFClQkvv8Su5Hu4kWrG+nqYn0gTdSFSHeXFvktEGxMsTqb57atPQZQHnj1C2SvjqZMwIhq31rIj/giI5faVn6g0EKyK0tp3iVhjgoXJNAPHk+SmxgnsDFPTmGDFKr5I3IhsnkpkY6Yqkert5sHjSfyVPGGj/+uKAiqWCvH9GYwbL87cAbE0tHVQ1fn2hnkizeCJJH4hT8SF+HOvoGJZmLq10WntjHO9be8VL7/4si9Ky+UJAuEIKsLiRJqBExvNEQN1jzXR2nsRbznHha4OQguzhF3zi1E3cMqJ1qAry2TOfoRaAWtZnpnmwX1NJFrbaX7/NK29F0GEkZ5u1uZmqDAGK3LKUVVGX9iT8tfXkn5ugZ3tb9H0QTfBzSWIRUXwlnOM9HST+TlFXcAh5NB/LCOdjqpy9Z22kJn+J2PXVuu1kKMQqibW/gbhh+KgSmH2HpnLP+KvFqgJOAQdsrNlbTx5V4vbnunq4V0pTzRp1lawXpm8VcqbtOs4BFyDK9J/LCPbn2krhg9FD/hKty/a7InWq1iwNuuIveGqfH50Ssa26v8D7vnE690mEL0AAAAASUVORK5CYII=",
	cancel1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAmtJREFUeNqMU0toE2EQ/naTqDSPkoc2pbSlWpAG9ODrkosoLfV1EEUwJ0GwpAQtSEpBvAlCCxIfmKsnb6KCj5ioCKJotVDRSsVqqTUmJtkNyea9u1n//7eJq+nBgW9nmfnm25llhtM0DXqLuq0O4k4R7CLYTmAgmFlBeCgppfV8Ti8QcVsvmixtE517vLBt6oWlrwccz0FaXEaBIP74OeR8YWo4KY23CDxwW686tg4EPCM+cOIS6rk06vkMy/FWJ3ibC1jfh/kbt5Ceng3vT0qjNGekj3sdtguubVsCHt8Qaq/uIHrzIwaP9f/pU8ojFoph8PgANh/ZTSX9pKZw8Gd+nL/bYevizW3n+g95UZp+hLcfTPDFU5iZN0OVVQb6zmJza1B6E8XGfTthtLcHWa2qwd+114vq3EsoVRnDD2Pso9TPfrEx6GNKTUXl/Qt0eneA1vIquAMWCyAXikRAQSp0ptk5LWgUU6M5ypGLZVjtRpDaw7yiwcOVMkRZYci/foLEVAD/Go3RXIOHXAKktp92UCun0pCp8grePf3UIkBjek5FFGkHIAJYKOarUCoyw1K5+6+29ePQXINXzlWJAL7REe5nJTRb0xd/PX+SQS/S4GUljY4QoSOEk4kiamWF/aDPEycYmXrhWYRBH2M/saLg+48iHSHMNjHstE/abcZg7wYD/seW0yqEnHLZL2THmqt8zWm/bjdz/m6nAWT9V7U6ocbFOoRCPRwQsqMtx3TF6Zg0Gbigy6yhfR2w1vg7TnYHuTKQKXGoKdql04J4dtVrpBZyOHqI8xMcJWgcxCLBbXrOY6K4oOf/EmAAfyhg+goYmG4AAAAASUVORK5CYII=",
	candlestick: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVR42o2SYRIAIQSFORlH18nsttWOEcqfXc3z5QnCGyKizIyQh87vpsEK0M9tHmlwiTIAMX//TcRq/o6OHRQArCzoPAcL8NFrMgu67HkAEY28tQGwHfihRXEEeMHWkQdYCwngn3gIqCz4lzkC/BBvFit6hXRtowvKRSqKYQNcFm9xe+s9wM/klD/orqJQOaYIOAAAAABJRU5ErkJggg==",
	canvasXpress: "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==",
	caseSensitive: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABYElEQVR42qXSTShEURjG8XvGR1KymVJshuRrhQ2llIad2YxSspliNSnZ6E4obMxGjGxMFr4jZrKSYiWxYDaKhZXsZDZqJjbi/zbv1MTmzsytX++595zz3HPOvcYq8jJ/HwzZbhelF4+xcPK9kIA6yjGiBGwVEuD7sawVmvd0Bgj5yjdgn9Kltz0EvDkO8NvuRsoy6lGJmXg4eeQogDdLO4g0utGPWyuzjW8nAWWUA9hoxSpk/4MEvOiYFsooynGH09yANlkyxnVAQrumCYjT79GvsyQHjBjmjU4uoSygA/I2+Re8Wq8JCDCmhvaYvFVXfoh1o4dXS9nACIeW8mfOYwKTuopOpNCOYTwhhEg2wCeHxuTsBHnWRDnT21k8YxtTjLuk/4b2jqEh+93FBR2bOQEuPYcqPOAEi5jDB9ZwLgFR3furLImQK55V6BIHUI1P/aTNKMUe+tDw70/M9yo64Bd1Pm0FibtU7QAAAABJRU5ErkJggg==",
	ceil: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR42mNkoBAwjhwD/uNSS44L/iPrZcQmiIPPiGYI3ACckkhskg1A9yLZLmAgxgBiwwDZQoxAJBuMGsDAAAAIyhcRGF+DhQAAAABJRU5ErkJggg==",
	checked: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAVJJREFUOE/Nk01LAlEUhv1vRUX9gFaGJS6jTRTUrlVENAgiVFRIIIFQQpuYikAUyfFrFl6jsRlrYJgYhsScD2fzxr0glNiVcNOFF+7inOd88J5Q6F+8A0HAX/WjcZrc6/V+le/76Pf7cF2XxdD4kYBr8QrDqsgSLh5OsJvZwIv+DMdx+IAakfBdH10ba6eLCMenkJNF1gW3g0FynVTxamgQa1ksxaexnY7BNM3xIzypDZbYVBr4dLpYT4URScygQO6gKAofUCznIaslXBZTsG0beSJiJTmHrXQUnueBEMIHaG0VO5lVVrGpy6ztaHIeOXLDltdSW3xAVa6gbbawnJhllWny5nkEfuAxgK7rY0Z4LMDqvONI3GOA2OECbuUsgiBgAMMw+ACpXGKLejM1HIv7OLsX0HU6bB9UlmXxAQM30mrUedSB9D/s0pE+mOgWJrnoL9c9HmLH1TloAAAAAElFTkSuQmCC",
	circles: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVR42mNkwAIYobQZlD4FEzSDcWBsnIIY2gHrZAYGT+ROTAAAAABJRU5ErkJggg==",
	circular: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAkklEQVR42o1SCQ7AIAij/380izq3ciox8SptUSAudA4RzLHWa6vvGmA8smQi4FulNASCIlktLpLgrByKNCS4U66dwD3aBs9zfI+HPQeSkqBx0hKwepLILhqC1MnawZIVJahkjXRXggUN3aG653CnRPBbPH+jmq9fjYQfwo3kiUzywJYXkkWCQQnoggSi0onEuXsA+SNlAUVDy0YAAAAASUVORK5CYII=",
	citation1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcklEQVR42rWRAQoAIQgEz5fl0/Vl3RkIi5XVQUuQxbaMRiJSn0/MTLbb2WuXe9DnIgyIYccBSICPUNsEVpdSmklV9wIiwSgg0hwT4F0XsEOQBvwiiH0dE4z+O/vGbogr00rTgGw2OPT7BFn/dwlcta25XrDZoA/0ZIQgAAAAAElFTkSuQmCC",
	citationH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZUlEQVR42r2RUQrAMAhD9WTm6HqyDgZiN2yx4Jaf5iOkL8iUSFUHFcUeBnB7f0VkSnH4Ed1m1lzQOgGQ7NMHjak2F/ReAYgQRd9Ms79CtSDDOppQDR4XvKdl/h+Clb4ncA2iLckFmH2KhV0zTwoAAAAASUVORK5CYII=",
	citationS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZUlEQVR42sWRYQ4AEAiFuVlH72aMLQup5Ic3W0xen8qJCRFLiwCQk1NbYjMhA76XzsOALsIEWtWTKM9FoJmGCcI9WAuYBBbRvylMBusfvY/HGE+NsqJIcCt1XBq6afBMwFX6klUBdid+D0VDG2kAAAAASUVORK5CYII=",
	clock: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAqhJREFUeJx1kz1MU1EYhp9z6R8tbYFWQNviT9ABg4kGUCEO6qAjJiRKdGUzmjg4GH+iiYmDi4MOGlcdHCQukkiMicZfjP9ViyLRCooXbK20t/fec46DkbSo7/q933PO9735hNaaSu269nRNna/muFeITo8g6SpJoexm52x3tGC7x0Z29z6v9ItKwODwy6taun03n71m1jRRVhGAunCYmrooHctTOIihG3s27agCvM8VA2ceT4zdTb9PZjJvEf4gRjTGikX1nNnazv5Lw7zLW2inTHNqKa3Ni7JrQ3rl6f7Nlgfg1P3xy0/GPiQzr9MYi5dhRGMAbGtvpactSVMkxLg/jnZsvk6MI6VKFmKNl4Ednn0j6S4t3b5M5m1VM0BvogGl4c+Uf2rm5CcaIuG+deeudxn5snvy5rM389+u1Op4HQuXbERjCH+Q7LRJSaqTRoO/pn3W/IZY0NwaqSUZDqCAagSIaAyrkMOQbrshlU4oq4jw+qpMPYl6lNYorelpS1UDvD60VcKVMmG4SvIvrY6H5+c/sH0jR3pX/eVxpaKmY+fg4Jvslwi+ACIQnC+OfZ/j49QUpWKJeDhE99ImtiQi3P78g3wuB04ZbzD02fOtZKcjjY2JfG4GKvaQLVhcnLW58HgcXbxFd0uE9cuXcLCjhb2vnuIJhbEx0qL/yr3OOct+dOfBQ4ym1F9JVEoXC6jZafRcnuDiVlylu4wr/RtGHcRQc2oZamoClZ/5P8Cx0T9zeGPNuIgh8+jAqAdgS9w3MCLjY1KqpDn5EZ2fQURj88lox0bnZ9DlIt54C8Lry9qTEwOw4Ji6z9+4Kh2nLzttYhVyaKv0OzZ/LZ5QGG+g9vfLh3dWH1NVfGeHO1DyhJayU0o36UqFrcg6Wo+6Whw1D/W/qPT/AkFjRsBfYQQQAAAAAElFTkSuQmCC",
	close: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAOCAYAAAD9lDaoAAAAcUlEQVR42mM8e/bsfwYCgBGkSE9PD6eCS5cuIRSxsrIy/P79Gy4J42MoAgGQBDIbRRFMNwzATMVQhGwNVjehm/T582cwfevWLfxu+vTpO8Pt29ew++7Hjx8MvLy8mIpgAKTg/38WOB+uiGCIE1JAXUUA5WZpcWW3WYkAAAAASUVORK5CYII=",
	cluster: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXklEQVR42qWTQRLAIAgDzf8fTXvoQceAa+Gmk4QFR41mCepi9ryH0OcVNKXaU4BMWEmAulaCrOviORHQxW4EYe7caIjA4aNXmAMcHSIoOyKsDoEzXO0gq19/AVU74AENwCIRDRpuzgAAAABJRU5ErkJggg==",
	clusterSamples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY0lEQVR42qWTSwoAMQhDm5t7835gBBliidZVCyZ5KGI8FpQmM5vhjf2Z+LRQRC4sERwDF8kEampKkKX+Ta8ESiol8ERmUJrBaWD40haiQRS0tqDOgja1CZigNIOsWreg1rPBAuwxXhH250nfAAAAAElFTkSuQmCC",
	clusterVariables: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWklEQVR42mNkoBAw0tyAhoaG/0DMSJIBIE14DGQkygBstmITZ0RXgM9GogzApQHdcJg4SQZgY1PPAGQngiSx8bGJY9hGKk09A8gFcAOAHvsP5DCSStM+MxECALpLmhHlv+W/AAAAAElFTkSuQmCC",
	cog: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAGSSURBVCjPVVFNSwJhEF78Ad79Cf6PvXQRsotUlzKICosuRYmR2RJR0KE6lBFFZVEbpFBSqKu2rum6llFS9HHI4iUhT153n6ZtIWMOM+/MM88z7wwH7s9Ub16SJcnbmrNcxVm2q7Z8/QPvEOtntpj92NkCqITLepEpjix7xQtiLOoQ2b6+E7YAN/5nfOEJ2WbKqOIOJ4bYVMEQx4LfBBQDsvFMhUcCVU1/CxVXmDBGA5ZETrhDCQVcYAPbyEJBhvrnBVPiSpNr6cYDNCQwo4zzU/ySckkgDYuNuVpI42T9k4gLKGMPs/xPzzovQiY2hQYe0jlJfyNNhTqiWDYBq/wBMcSRpnyPzu1oS7WtxjVBSthU1vgVksiQ3Dn6Gp5ah2YOKQo5GiuHPA6xT1EKpxQNCNYejgIR457KKio0S56YckjSa9jo//3mrj+BV0QQagqGTOo+Y7gZIf1puP3WHoLhEb2PjTlCTCWGXtbp8DCX3hZuOdaIc9A+aQvWk4ihq95p67a7nP+u+Ws+r0dql9z/zv0NCYhdCPKZ7oYAAAAASUVORK5CYII=",
	collapseFolder: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMklEQVR42mNkQID/DKQDRkYkzYxkGPB/1AAaGUBMdDLiM2DgvTBSDYAZQipgJMdWFAAAgAUdBKIiH2cAAAAASUVORK5CYII=",
	color: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALUAAABlCAIAAACEDzXRAAAKQ0lEQVR42u2d23IjKwxFBeRh5v8/9uQlzXlI2gGELoCEm6pxubp6PI69WoV3C20uIQPAH4A/AH/p41/pDcTxP4BPGDtq3vYJGPpv8craeRdo/fyTI8ZhHnodOGgcV/3rnx8QI0SABO2xfAbiCfVR8Wj+CD8jenbRJNyGOxLoAaH1iLu4EUEHAv1+MsQ4zLE4AiIOcpibv4u9OET6+cP4ASnJ1JH4/G60A9km+GbBxLlpKAkADoR2JnaBrvWD/x1GCZn9EYLEHqVfI6Efx0D7E9tDF/rBSJ54l8FqTUse0J+EvxPrdK0fD4aOLXQi7zyGxMaRvvWjjH2U8o9I44OKnf+wyCpHoR/Phk6d/COq8481YrNI3/qR2B+kMl1Fl6J8o/JrU/GEA6HdiB2ha/0YBVx7rFwNHAj9JuIl6EI/qKyJug4Yvg7xA0QEpB8nQe8itoQu9EOT8M3mTsqUSUzykH6cBO1PbA9d91+ShDzV9xrtcgW21IT6L0yfcS90FKCdw+wS6Q9ISWjVfLTVVT2mdiPGGRduFKWm7dBStWlLmI0j/QExdgp7gT5qCu2BLKiLqtc94hI7PB8auQP4KuyIvSJ960fUqXWcd2F48Khr1bHSj2dDp/afmg7tMrFxpG/9mHMFuqrH3spFw0s0Bgr9OAzamdgFutaPpMuqo6WVEXWJdSL14xhof2J76MKfS2yXWGOVB1WXXGOVdxFSx587CXoLsTE0689RH7VW4RMLeKI9wPpzz4XeS2wDzdbXR52AWStjwiSAA6HdiB2h1f6cqT0whzzuzz0LejuxATTy90Xt40v7CzdGRvKS4O/zQ0AiXaRW5x/dv4vS4A/a308LYR5pFquRRvlHIrKWoCj5woCVId4eR/KPNDjURg2tdEC7rSQN5B9DYR70X5YivVxft7AyrOvrD4V2JnaBJurr+qpemLEywlRhT6qvPx16C7ExdK0fSjcj0maAzsqgBt7rfIxGP46B9iT2gi70I842bNj0U4wd/WAG/L5VP3p0W4iNoYv6Oh6eoJmSMW5laIzF8iT1TtgeV9RZoZ7QvdEUzsQu0CP+HOMKDFoZvDFg6s89CNqf2B5a4e8Hts84W0pgeohBtspBXYp8H3Tk/H23MBtHuvbn5mp7dlU9TUkP+XNJMabzHdCIbnuYDSItzZ+bdgUWrAwNPhwInRxw1/wXuYGj+4vo7flboRpjEQ6EjgojYK9/K04NFfNTauEBypXQWQLAfqQoHl9CfvpQ6C3ExtC9/q2YW2u6X1JWzfsYFPKX3L99LrQ/sT10XR+jKh+UN2AxlDOyXfLQaxxf/fkvT4d2JnaBZv258M6h4IFu2Em7/sezoLcQG0Mjfy6xrqLnVBLGWHw1i69WP5LCCn0TNEL3DLNXpCV/n5oo5jAVLY5Em6i8Pwm6uSNuCrNxpNX+nDira20qqyZriv384xhoZ2IX6Lr/wg8eiwpXYGQqPEgjsBrX+er3X46B9ie2h6bX/4i6IfcLS2mIY++7TfoCuLj6hwgN89CwBJ3Gx8rOVsn0kQ48tDS/4X1L8SzMb3BbkGdtwsD05AbP9YOU8xui+uljZei/P/3qx2HQbsSO0Ar/lveHLZYCVK4GeN1P5N+eAb2R2Aya9ueUY+8dlhLtdhWvgfEfz4AeGf9hR2wcaeTPpacvRdzLTx8J/Qq1Ij995PrJ3/mp0p8LO5YyF0s215g/9yxoZ2IXaLo+FiwtgTlvIAznp4+G3khsBk3Pf5mYvqOwMqZnNnw3i9cRDoT2JPaCZuvreskDuXkHxfQMvfbBgdBbiI2hC/3QLCg6lESZZkrfJ7nSj3gWNEMcRkYJsf5L0BXENBl1WV8/aquMLM9/eSJ0UtxZmFGGg4MigZ75ovHnvsOcUX09zRbzjCrU/K/Rev0gT2i2vu4cZrNI1+sH2e49Yb3lRC6e9fSS9ETohjj7hdkx0rQ/57/rxIrhBQdCv494Hlrtz1lo30Qjz1z+cRh02ndTNIMm1j8NxtmePs+76i+/esJHrH/6dGh/YntoRf9l2RtQWgJXzY4bdtbqx0OhnYldoHv7I79jf4+rOGGaRWr14yToLcTG0Ky/v32rjAsdX9S5vgI4ENqT2Asa7Z/9vq0yStiGNNVHkOe/RGmqwBQ0jEDHFpoJ85BLN+jPaRoHGWl2/2yx3msxVRHjZ0Td4GfV/Bf9bCM1dBiBfrHeJ1HR6dKEedDf5yPdBLilp/efC3Ribb1VxlUHGQe8iTb0598+Hdqf2B6a3b9SOerezsoIBWaJ3IBn1fp0j4PeQmwMzc5/idLK3UZWRkmKX2zA4Vc/DoPeSGwGrdvfY24RpKmVjrLuCQdCuxE7Qkv64TZ3Z44dVPrxUOh3EK9C1/lHGpz7ZzpVsYTF7K8Hyj+Ogd5FbAk9uL9H9LIyYg821sjo13gYtD+xPbRU/9Ds/b1sZTTIr5OStMGHA6GdiV2gUf2UmQcfJdUbXOoe6HoN1A0b2uQD4EBosXJqQTwKnXvXAEX+oZlfGaS9ewetDGCLeV1exH4e9Mr+2TDpv2iggYFW+LdBsTbngv/yUroGH0jleEX7MOgtxMbQ7PzKoMuajKyM8pYIiB194HnQzsQu0Gp/LvpulVHylsgK/TgG2p/YHrqXf6T3bJUBhfxFWUDPg95CbAytm/+ycasM9WOxWu0PnTniLWE2iLRi/4Z3bJXRvY76s0+Arl93I3aMNOHPBce2PdSkL7Kpnwe9l9gGutCPoFgkUtytXAGbex0vKCznSOs00o+ToLcQG0N/QErCrG6jrTIynVUDwo896vCzssPrNnAYtD+xPfR9fwmKeu/CVhm5OAn1STPkvhxBW1KXjeP60Y/DoJ2JXaAL/RCPy+PXc80L9d7OV294dVPbC/fb4EDoLcTG0IV+TCDrrIxMHIFg512BWj9OgvYk9oK+9SMoZG55q/JMiGS40/sLjacu28T3MVfd0Aha+u3QJXr+0Q//MBtHutaPQOzh3H0RBoZS5OJ/MjqJ9x2vQb7qgSuvX0StH0+FLptzrvTDh9gl0oV+iAbi2lAsqNmbK3yBAyLNdbRzW8Y6Btqf2B76A2IURE2zZY16KGfZlwqofJSL4feABka+xCNX+ekx0LuILaFr/Zit7s4ZA7y5Qg2sDr/t4zDodxCvQt/6occctDKGriMPzH85D9qN2BG61g/QwcLSVDSGl78C6LePY6A3EptBf0BKcjWWH/GqyJqoxKnMufEVBLJxAJwJ7U9sDH3fX0CxnIB4orMyuilTyRh6g+0bfDgQ2p/YHrrQD+jV6qb/SdRrMit8TRWwyEabxgFwJrQnsQt0rR+LR3VqFNiGHRBv73ge9EZiM+haPyicuRcVmIxzAMTMl9wfi3sGtBuxF3ShH92C29yJTteU+ohbRrZk3Qe9hdgY+tYPnOqanA+mTN33ZGKE06HQbsQu0LV+MF8+94rU5dK8B8/KyJaI+6D9ie2hC/3Q12QnSnYLn5p9P/6d0D7EltAh5wz/Hv8exON/LUjHOuz5CksAAAAASUVORK5CYII=",
	colorShapeSize: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcUlEQVR42tVSSRLAIAirLye83GI3laXtDJeWgw5CMpJQlmSUdgCoXlHei8qrrl0EBExglnwk2Hqo9zDv9R8RPGrwRsTQhUx8lKBpEs1/6jWJaMEkN7su4LASo40a3HM2uxASaPAdiRkh2gP1O1eTtAsrkPt0EQ6Mk/cAAAAASUVORK5CYII=",
	colors: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAT0lEQVR42mNkoBAwgoiGhob/2CSB4gTl4QrqGxpQJBuBfGQDGhrq0TQ3DjsDKApEiqORYgOokg4a6lEDsaERNRDr0eQbofLDyQCKApESAADMNJARz8XIQgAAAABJRU5ErkJggg==",
	communities: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAsUlEQVR42qWT0Q2EMAiG8RIncgk7SWdiknYJJzLRo5ZWFJIruT40QuGDH+IEf56pXPsH1vfDfEBW0Qs+47aYJSBxYrGDCauAxO5gAsoDJSTygbCHAMCJrXrviJMDt53EdwX8ksEdnJQIsnofoiVDDdJoXwGkBGMLZ2+d238AelDzoVhtpMpI4KhX+wZUCLL+mnjrdgFaVal7CIB6mD4JEhAv2ykB1X/hlGBD2jYGAY7zBUChYRGjnbjbAAAAAElFTkSuQmCC",
	communitiesOff: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAfElEQVR42q2QYQ6AIAiFn22dqEN5Jg/lidoiTdvIoUT2/jARPng4TMr9BtgXUI7roYC3cNUhetcD5BylN9hbB1TRnWs24rXE+x4AxQal6eDTRwD5Bs36QwuCxL+3gC5YKyZU2/B2QImh3MUCgNBkssAB+GJB28YIUDQNOAGPeDMRd2gLMgAAAABJRU5ErkJggg==",
	communitiesOn: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAsUlEQVR42qWT0Q2EMAiG8RIncgk7SWdiknYJJzLRo5ZWFJIruT40QuGDH+IEf56pXPsH1vfDfEBW0Qs+47aYJSBxYrGDCauAxO5gAsoDJSTygbCHAMCJrXrviJMDt53EdwX8ksEdnJQIsnofoiVDDdJoXwGkBGMLZ2+d238AelDzoVhtpMpI4KhX+wZUCLL+mnjrdgFaVal7CIB6mD4JEhAv2ykB1X/hlGBD2jYGAY7zBUChYRGjnbjbAAAAAElFTkSuQmCC",
	configure: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADA0lEQVR42oVSa0jTcRQ9/23qdLDle482S/vgykzLVhJGvobPpYKRQmgmJjNFtIdmfTEJLEMMB/bJrMZ8ZA81S60tcm0jTYQsDDVNnTqV0cNsztm/rQgsVp1vv3vPOb97LpdobbndSaNRxQeTk+kALLAPxzOnTrXExSdITCsmfFn+cjElOaXM1iA2CwQXX715U9ra0jyXcTSLY08tk8k0Uqk0VK/X44Q0ry04KDB1aXnZ+3LVlQXCRhDwuKeLioorY8RRCv/tO9LXi0UiUXhXV5eSTqejrq4OFFDHeFyu34JxoU+pVDYQv4jbuGxeWnb2dIJEUhsUIsr/VY+Li8uUy+X1ZrMZ4+MTmNLPYtY6iVR63NbLIdb/FrjRm5569NjXhMTEimBR6Hlbzddvy76e7i61VqtFZGQk1tbWwGAwMDIyYhKLxXsIe5nLy0rI4vCIQkaUuKYyOZc82VILRWMjCIKAVQSDwYDS0tKa9vb2QrsGNsxXXiLNGjX6+/oRPzqGQ2n57VP66Qmh0JOj0+m6rRPcsNJW/mrw2seH5FdX4VFeAYxmi66EX/b+w2Dh4T95dg1cMobI1Oa9OMlxxaarMqiyc20Hcj9lbibpvwY+eYOkg7sXRtV6FEQ7m+Jroul7qiqxdPsOOjQasF2o1KSJ2W92DfjSQdLJwxNjOgOEEXws3pQ9r168dpdBQVWsuheLZ89BoXyCAD4jJGZg4uVvBt5ZAyTLh4uR3hn4W8XjnT1NJnX6j8wNbPZ5FoVSHqvRwnihAk1t97AzgCXYrxqd+nmJua+XXDZ6MIafTGKreBPePVQ9NT07FL5+ultsNunLZGJXdzeM5RV43NmBI3NzBOGU+FLlFyo4MKyahH+4AKM92n6zSrLb3nIVHA4pdHWFsOOBNc5ZLBmm7xM0L3Gmm6Sunu3PxNvrNcaVoQvu+AcKWayPxWFhTBqPhxK53OtHBEeqYw4cNvAJ03yr9cmkUeG8SmDVQoHlm21NFCcqQHPEGvWzg+XTrBtBpBhJsneVJF98BwuhK7qE1LMYAAAAAElFTkSuQmCC",
	configureShow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACGUlEQVR42mOMm3SukAEC5IHYBoiNGRj+/2f4z8DI8O8/AxMTIwMQMfz794/h31+GD6ws/++oy/CZgORAgBFkwMJcwz4GMkD3mhtgA2YDDUhxm+bI8B9o6j+g5XtzDzLcf/YRRbGiFD8DuprOVdfBBtwAGqDuMcOZQUVNhuHmtYcMu3MOgA3g5WIDa/787RfYAHQ1iT3HfjLGTTj7YWG+Eb/3bDcGRWVJhls3HjPsytqH1QB0NREtB/8zxvaf+bWowJg1ZLEfg4S0IMODu88ZtqTuwmoAuprwxn0MjDG9p/8tLjJhDFsawCAmyc/w8P4rhs3J27EagK4mtG4PA2N096n/S0pMGSKXBzEIi/MyPH7wimFjEnYD0NWE1OxkYIzqPPF/aZk5Q9TKYAYhUR6GJw9fM2xI3IbVAHQ1wRXbGBgj24//X1ZhwRC9MpTh1+9fDL9//4YbgB6N6GoCyzYBXdB65P/SKmty0hFDQNEaoAtaD/9fVmUDNh2YRMAJ5S8o2QIxExMTmP779y8QA+l/f8FskNiurP0M/oUrGBjDGw/+W1Fnxxi6xJ9BXEqAKJthCckvf/l/xpD6/fdWNzgoBsz3Akv+//8fnE/+A21jZGIG0/9AyRfkKlAeg9KgpOybt+wdY0jN3v7VzU4F5IQB0ICjYAOgNqsBsSXQKsF///6AnAC2/T+Y/RdsM8h14KzO8O8zAwPTZZA+AF9OX8yipJioAAAAAElFTkSuQmCC",
	connect: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB3klEQVR42mNkwAIuvvr0/+effwy///0H4n8Mf/7+Z2BhZmRwkBNmRFfLiK7x8wI/MPuJ7zKGP0ADYICFCaJUgIOFwUNRjBHDgHMvPv7/tsifQUTdgUHdr57haLcjwwPvpRiu+/sfaCgQxevKMMINANn85tsvBvZVIWADQODNzQNYDQCB73/+MghxsDIEq0sygg049ezD/1vvvzIobI1GUZi7ZT9D8fRnWA159uUHQ5m5MiMjyOlPgJxPP/+AJWCGwGzvzZQCGwKjYeDLrz8M7CxMDIwg2+99/AYPMHSFuMRA4N6HrwyMR5+8/38faAAuxch8dNede/mJgfHAo7f/n3z+ARY4u1SK4cARBgYHGwYG42hUG0Ga0WPo5LMPDIx7H7z5//zrT4LOhRkAi6G7nksYLr/5DHHBC6ABsDBAdyayAcjgpMM8BmZg4gJH44rrz/6DDMDmTGyGgMSPPX3PMM1NB5IOdtx/9f/l118MyttiiEpIt4FpRoiDjSHfRIERnpQXXnnyH2QAMsBmAEjzhx9/GCa6aCGSMgysvfn8v/jGSDD7rtcSBmao+X+B3nvz/RfD3Q/fGNSFeMA2w/RgZE8QWHL16f+Hn34wvAVqAmnmYmVikOblYMgxUsBQDwAu7QTZ3H8hggAAAABJRU5ErkJggg==",
	connections: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42uVTRw4AIAgrP+Pp/KyeHCGuiBdjj9A2DUMAEBWCPbAVkFW5bZA1ciNBgZlRVacmniMrwqo3I/oaesajuGSf+I1BaIihNZ4e0uPPlACo/0YLzqjjLwAAAABJRU5ErkJggg==",
	connects: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAP0lEQVR42mNkoBAwgogDBw78R5dwcHBgRObjUgM3AFkDOh+fGnQDMGzB5XJcBpDvAorCgOJYGAYGjCakAU5IAC/wchHTLzdWAAAAAElFTkSuQmCC",
	controlForwardBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACz0lEQVR42mWTe0hTURzHv/fePVtmMsmSUIOSSBiUmGngA0yrDYf9oUmJJWGa0kMkqdTQDUQLRdNe0EMjQiHLMQ3FaJaZDxSKEixCjR5iCpmm27q7t3Mmm24duHDO9/5+n/N7nB8DrxVT9qzhr0PIEgRR4dJYlrFKOfbuy8sH8rztGdcm3tCZuGTnO3MTdkAfHgJf1YrR3B+gbXgCN7pHoZRJkl6UJHV5AKgzy6KzMScOnFyGoW9WzCzybgO1SoKIQAV4qx3HbllAoiOQ/V1uwJ6SdrHl7D5YOSne/rBBFAQIogCWYcARMrWyO0RoApRQwYbDtc/Rb9A6fRma8/G47af0USEofTSCobGvMGQfhJ13OAEdve+dWhnRrHYeUZsVaB8ax33L2HVaEya61Gx9WqSVjy8Ap2tNOJSSgNYn3biSr4MoAucbzG6tIlcLKQko1JdDSlW7ra9cp2Aii80iCQe9UwIKr5nBrPdDSny40+FmYTJyrpo8tMo8LWIDOZo2Bow6xgl4QwDDM0B+jQkbt24h+YvuDkx/nvhPa8vSIGo1oI8ARueAE1UmhEXshL9Kih7LIB4WJ+OI0VOjUWn8gGgXILrEbGsu0socEiCtfKUG1JneedS4ojVdIpoDUDIi0qs67H0GnZyJLGhsztLHpKbHhOBi03IXmkuTScXJCySNqmv11NRrgMe947hnetUyUJ2ZRnsZRAoyeedMAgLUMkzPCZCTUvPC8iORksgWrQ4o5RwUZD/zy4bsum70G3XB5PcX52MIS72Qt0kTV199MhaB/nIskZscBEBToFFwpHVyKfD9pw0Ft3sw9c6S/6GlomH1LKwjkAyf0L31GWQWEncFY4MP6wRQg+l5AV0jk3hAZmH+42vq/IDIvz2GiULIt233ucYiyVq1XhAhcwFIFHZ+YbZtsCazkhw/uZy9Aa4VROeH+q3SSEKYpTl7G/8DtjE4IMaQs40AAAAASUVORK5CYII=",
	controlPlayBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC/UlEQVR42l2TeUgUcRTHv3PsjqtrinaYkBp00EFUHolaGomWbVlCWpDYAUXZQXaXFrZBWKBkWugfXRKmf0iWWmtGHiladhAdVoSlYRYZmLrurDM7vRlbU4f5DTNv3vv83vu+32Mw7lqWeT9/SHZsczgUF6eNZRmbjmOv1p9elTren3G+LDdbYgbtkmVX9FzEBwbAw+2/U+8AUP78C67UvINBz8c+zoitHgNYbn4QQ7tYru+MBCcIaO2yoccqjQC8XDkE+xogiyK2FNSBsiPIyuoRQGhGpXJ7/wr0K3q8+m6FjmXAcywY+is7FEiyA7ICLJzqCiNjx8aLj9BsXq3FMmrNW6Jm744Lmo6GDis4Mgs6Dnfq3qC1rRNZqSaIdgmkC4iFCD9XVLW243rth8uqJkzYqQpb2ZE44f1vCX02CRzt7qLncexKFU4mBcJc3IrsvSYM/oMYBR5zvHgknK8Sm86YXJgl6RUKpQPLF5tWjwowCDoczK0EPD2RFOSLW5Y3uJS2BlbaYIjSiA0Q1LLRctbEaIBGAtR3DhFA0QBuBEjNuYcpMwJUwSDR+tb2GQWH4iFKDiydpkP4aMATAjzrJtUVRe05AXhsP38X80MWYZKbDg9rmnHzxDoMiLImarAPjwgnICyjQiw+HKfvk4HBIVkDGAQOm813kLQhBsUlFpRmrodVHO6GC8/CnQM2XaiyN5lNArMk7UbJ1rVLExPCp+NHv0NNgrrA4nL5S9Q8b0fluYR/wYrW1ilGFmWN7bh2t6G0JTslSdXNLzS94mvhvmh4ewgYsENz5GmXAZtMHeEo7eEDZdQDPb0iduTWoPmsyZ9MHdphmJd4PNVnQVRe9o5I+E4UqBRNDnpoN5UFGHRA1y8RaYV16H5du+dt6bn80bMwgSDJ7rPC85JpFmIW+2OyO6sFqw4/+xyofvEVRTQLfR8b1eAiMv8ZM0wqhNbMkAM3jvJG73gSW+8EkK52qb+n/GlOShZ9fnIGjwc4Lz9a3mrcKJuqQo9a83jnv4gWQiC554IcAAAAAElFTkSuQmCC",
	controlRewindBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC0UlEQVR42mWTe0hTcRTHv/fetV1NM9DEHvggSrAomPjILCeJko5ZBkqE2gN6WYpSiuCUnBWG2IOZJmGFhekfyWSrNMEHpJlYMDDCgjTCMhxmtva+t9+9ueXWD35w7/d3zuf8zvmdQ8Fn7b30rMnh4o5zHM+6NZqmrKsYum24Zn+Rrz3l/kjV9KZb7M7eM2kxyI6NRNDqf0aLZkA3MY3m/nfwk0oyBtQZfV6AVM3zdBKl9/4pBSSsFOOzVpjMTvDLRiH+EsRtZOGy2VHYMgiOgwciAhLVBv5xyT6YIYNxzgIpQ2Ti7SKWHM+DpmhQNI2d62VgXQ7k3niBV5os0ZcScj6qiD6bFReF0S9WsFIJalqfIi56EzKTt4sAqYSBelmrPSyHbnQa9wbf3xZqQiVV663d5VmyqUUXHBxQ2WxAzsE0POnux7UiJSgS56JW79FulagQFQAcqDfYRmqVLJVQpefJdTA060JF01/n7oEJ8D8W0HJBhdMNPV5aw3klksNoIW2M1SkpETBKANltRk/VaRL228dPCN0c+Z+mLVUhNgTYtRIwQgDGBYjRUhTxmDc7MDn+Fo+qVDhS563dLVchJghIcgOS1HpbR3mm1MJToBig4HKPJ9+HBCCUWoC4tc5qFRgnkFdvsI9olDIqoexB5zHVntxDyVEw/QZ5BXJY2yNWvDhHTl7BW7tSIEfH8DTadMNdY42FeUKA8MQq/UxrcRpC1spgJXSLzQV/loHDKbYDJDRgI08UGkRjzmTHiZv9Qh9EkKPPYjNsy60sCtuh0DaeTMGGdTJiLDQRxOiCAUMAfuQWs/M2lN0Zwlfj4LnJrqtNK2dhDYHkB27drc0ns5Auj0BoIC1GFwy+L3HoezODdjILS1MvBed2Iv/0GiYBQvaW+NIHFZKA4GwSXeoG0BTszl8m3evrhfXk94Pb2RfgXuFkBwt+KzSSEExCzr7GfwAmmzUg2PWC2gAAAABJRU5ErkJggg==",
	controlStopBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC7UlEQVR42mWTfUxNYRzHv8899633JcWKEqmN1kZ0U9GNXqjI2MIf7WJLlJfVhrHKdBvDVkNF2tD6A21M3KJudKMXRWwWW4kUNUpaerv3du85nnPr3nI927Od85zf73O+39/v+RFYrQ1nnxROGdn9LMtJzWcCAdGKGMHNF2e2pFnHE/NDhLI6elJvqD4UuQIJgUvgZDcbNDIOVLR9xbXaj7ARC2PqsmJq/gFEKJ9G079Ul6bIwUjFeNOvxdCE0QJwsWWwxl0Ko1YPRbEGVB2FbK6xAIKzKrm7xyIxQcRoH9BCJBBAQGa+cgBL9xTLwt9NCltOj92Xa/FKGWfKJbznvXK/1Li13mjp16Givh2dfb+trcLXYx4Swv0hc5eg8nU3bms6iviakJBslfbBiVhJx7ARehbIKa1D8qZlM8WZlkAFoOTZZ2QrIiAWAH7ODHZcrNI15cRLiSxTxVE5UPfoYCMR4nTJcyTJfVDc2AuGEBg5DimhnijTdOFc8kZM6gyI8pLwttGSG09MgEYKaPhugB0FZFxXY+s6H9R3j4ChhTDSAoR7O+FxcxfyDkZhnALCFgkROhfQQAFtP42wlTBIu6qGPMgX38Y4ULWgrrDYnkDT2onCI1GY0BkRuIBBmBkQkqXS3TkeKx7nqF+akZKvhkwWAIik0y2gdXC0YaBWN6M4PcpEtCMc9lyq0jcp4yVEllF6b9+29Yk7w7wxrAWKHr5D25df/3UhcOl8pG5fBWfKvd/QjVuPXpa35Cl28WX2DM5U9ZQcjYSrs8TUCf4OEDKbzM3cBb4Dg8M6JF+h9yA33ot+6jWFrUw8lbYwQF6QdyAcHq4SaKdoAms2wM8CIBUBfYM6ZNyox4/3msMfys8Xzp0FRwpJcvANLUiisxC92gtuDgILYGCURc3bHpTRWRjtbOSTy+jxn3+GiYfQvTwovfSk0N4lgUoWWxQQ6A1jQxWt+YoL9PWTOdkaYF6e/PzA1BPL4rs5xHu2Dv4L7iIjIOH9LMEAAAAASUVORK5CYII=",
	convert: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnUlEQVR42mNkgIBEIJ4BxMlAvISBBMAIpY8BsSUQHwJie1IN0AbiK0DcD8QFQKwBxLdIMaAPiLOhmidCcSkpBrwB4udA/BiI5YBYDIqJNuA/1Nk3gVgLiK8ihQ3RgYgBZkIMBoN0POqQJZig/L/IBqQTcA1eF4A0o9NEG4DNO2QZQCgsiA5tJPCfARF7jKQa8B9dgOouYMShgXYuAAC9qCgP+MlNhQAAAABJRU5ErkJggg==",
	convertNumberString: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnElEQVR42mNkgIBEIJ4BxMlAvISBBMAIpY8BsSUQHwJie1IN0AbiK0DcD8QFQKwBxLdIMaAPiLOhmidCcSkpBrwB4udA/BiI5YBYDIqJNuA/1Nk3gVgLiK8ihQ3RgYgBZkIMBoN0POqQJZig/L/IBqQTcA1eF4A0w2iSDcBmGNkG4DOEaAOQwH8GROwxkmrAf3QBqruAEYcG2rkAAPjsJg8sltUGAAAAAElFTkSuQmCC",
	convertStringNumber: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAmklEQVR42mNkgIBEIJ4BxMlAvISBBMAIpY8BsSUQHwJie1IN0AbiK0DcD8QFQKwBxLdIMaAPiLOhmidCcSkpBrwB4udA/BiI5YBYDIqJNuA/1Nk3gVgLiK8ihQ3RgYgBZgINTifCIGQFTFD+X1IMIWgDzBBchhHl15mQcGIgywCYZrINwAL+MyBij5FUA/6jC1DdBYw4NNDOBQDg7CYPDuLnvAAAAABJRU5ErkJggg==",
	copy: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAmVJREFUeJxlU89LVFEU/u6d93SGkawWUjiLhgrKSIhUggiqfyADqaSWtWjROpAwDKQWFbWoRftQCFJsM6irNv3wGVEpkpgiY/4YU8fpOTPv3XNOizfznJkOnMXlnPN953znHiUiqLRrI19bG+oifbZSbZZCwjAhVzRp1zNOzjP3x6+f/VaZryoBbqV+DNladTorWSzm8vAoiNlaoSlmIRm3kTc0PHbj3OUqgLmtnejzyYXZuc2dxJOLx2GY4bPAJ0FqPoNnzkJIkoxb2GshfSouRx93XShoAHj08dfA3OZO4sPvLXjEmFjOwlnJYnI1i/0xG93JxhBg3jXIFCjxfsMMAIC6MzbVblg+D84sAwBGr7Tjy+o2brYmwCJgAVgEPzf+4vzgRAh0uI5AzB06WzT9zko2DPgsMMylYgEzg1kQr7Px7lJrmLdmFPLE/XpffaRlMZcPAx4xfAaIJXAJHAAONDZgpATisoIm06KJpbmsdhmgqoOS12tgzS1g0TXg5QUwFAxRs2WYqv6BxwK/xMwsoQ7RiMaRxhiSe6Lg7B/og4dgiKGLPi3ZWtV0UFksYAk6otK7tH/4xEs6k/emm2LWfyOUZ6eaUZgDAIs8eNDTOqrRk4zbIcDt0Sk8ff02TOaymBWiAoAuuDC+36PfdJ1x8oaGk/HdLqxjp4PCWvaS25EIfJbh9d5uR4kIHqY+RcdX87OZAiXSxd2NmJlJ1JodiUBEYJhj2y/vFqqOqePV2JAwd64ZBZcVGCoUzCIPuuAGzPeuVh9TpZ14kToJpgdC1EZkEoYYHiPtizhGVO96T9f3yvx/4x7QnhAe7rEAAAAASUVORK5CYII=",
	correlation: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAk0lEQVR42q2TWQ7AIAhE4WRydDiZrdFp1WJDF35MRniyyfTR+DeAqmYRGYARjSEmETJVwmVUY4iwclksohUIZ6LcpxgFQB8yqNTUajVCuilVzcxo9N0zQG3lRPDZMDuCj1d3SPVtPRi7GwNcpuBBViXMY70sEsrxmjgHu4B+3vPIPN/lKntL8whw9kRuff77TG9tAxJwhVCGm0qWAAAAAElFTkSuQmCC",
	correlationConfidence: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeElEQVR42p2SUQ7AIAhD5WTb0fVkWyQjIbUEmNmPi++1EmU01qPfuN2vKU3B5eEt+yuY1qQkYMm26QoMrjX4QAattAFMHGsvO9NpoCKBUAmgaGALzzOBVVeYQVQQJB+VDwF7nlltFNA7ZyATtJJR4OH03tkMyul7vYinNAX9Fi/ZAAAAAElFTkSuQmCC",
	cross: "data:image/gif;base64,R0lGODlhDwAPAKEBAAAAAP///////////yH5BAEKAAIALAAAAAAPAA8AAAIklB8Qx53b4otSUWcvyiz4/4AeQJbmKY4p1HHapBlwPL/uVRsFADs=",
	crossHatch: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAI0lEQVR42mNkYGAwA+JTDAhgxghjQCXANCOyCpgOnCoxzAQAcr8HcqyWFmgAAAAASUVORK5CYII=",
	crossStripe: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAG0lEQVR42mNkQAAzID4FYjDiEjRjQAOMRGsHAM12BDzp9IEBAAAAAElFTkSuQmCC",
	ctrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAg0lEQVR42u3X0QrAIAgFUMP//+TYkBAkNm0b5h7ufatVHloENRo5qCatafHe+9bKzDwEAthd3CIAAAAAAFyA3lYaO06/efhojAuYJ0ftGSz9rwF3E6XfLnxVLBXwZIc+/QIAojOQDlgpkA6wC2i8nUoBZAcAAAAA4D8AaVQ+TokKn+cnUgXvA0CKYtIAAAAASUVORK5CYII=",
	ctrlToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABMElEQVR42u2XsY5EUBSG/xszr6JQT6KkUk5DoVFJlBIPoFJPJFNKVBoFhVannMQTeBXDXSQmViS7O3HHFvdv3HPI+T8HNw6hg57PJ+73O+I4RtM0GGMWOp1OEEURtm3Ddd0pJm3b0uv1iqqq4DgOZFnG+XxmAjB44fF4IIoiqKqKoihAbrcb9X1/ArhcLkyM16rrGoqiIAgCEEmSqKZpCMPwI+azPM9DWZYgw3OgSZLANM2PAqRpCsuyQIY1zbIMuq5/FCDPcxiGwQE4wD8G6Pt+OgqC8C3fdd1rPZ9b5taarxl2/L8DrA1+itfAY/5tAELI5t2NBZeFt8yYAmy19zcd4QC7vwPMAd75CnYHWBaYtdWROb8rAGtxAA7AAV4Ah/+WHz6YHD6aHT6cHj2efwFZV5tOVqxNlgAAAABJRU5ErkJggg==",
	ctrlZero: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAjElEQVR42u3X3QqAIAwFYPeAgo868AGrCYMhNfth2sU5F4Wm7sMikNIRZt7SgpRSiLR4znlq8VpruzfA7OIWAQAAAADgAvRvpbHj9JmHH41xAf3kUbsHS/9rwNVE6bcLnxULBTzZoU+vAIDRNxAOuFMgHGAX0Hg7FQKIDgAAAADAfwDSWHY4lcvK4/kOJewy8tE81EwAAAAASUVORK5CYII=",
	ctrlZeroToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABK0lEQVR42u2XP8tGYBTGL8VXMZifMjIZlRgsJmVUPoDJLGVUJouBZLUZlU/gqxAvypNX6n168ucdXIv7HHfn+jmo+xDDqK7r4Ps+wjBE0zSY4jNEkiRomoau6zBNc46Jtm0HURRRliUMwwDLsqAo6hSA0QtVVSEIAvA8jzzPQbiuO9i2PQO8Xq9TjLeq6xocx8FxHBAMwwyCIMDzvEvMF1mWhaIoQIzvYYiiCKqqXgoQxzE0TQMxrockSSDL8qUAaZpCUZQH4AH4xwB938/XLMt+5SVJeq+Xe+vcVsuebf2PALYGf8Vb4Cn/NcC0Ye/ppoLrwntmpwLstfeTjjwAh38DpwN88xccDrAusGivI0v+UICz9QA8AA/AG+D2Y/ntg8nto9ntw+nd4/kPBtSbTs3WXOsAAAAASUVORK5CYII=",
	cx: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAYCAYAAABXysXfAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wDFw8bHwwk4lAAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAK/UlEQVRYw62Xa4xd1XmGn2/ttffZ5zL3Gc+M73cc20ALKhCJFqshBRESqU1SYlVtVUVKVKlSubSpKiUSP4sCTVXaSEVqm5AEp6HItZRYCQFqQh2IMWAcDLbBY+IrHubiuZzLvqz19cc6M+Om7b8c6eicvdY+Z3+X9/3ed8kzEwCgsBf4ArCHX8FLAJXuJwaI8U4wkeKd4LyixuHUoV5RBK+K8+AVVAXvwS2vCajifLgv7HHIK08o7FMFowIqPCrCUyLsEYFfxVtZLhLWwtTEAE8+HENnhGM/7uE/Ho+pJg1kOfVuEeT/L5Dq/yrYHuAp4FEFLLBXhIeMiUgSi3eK94q1BmMMRV7gFeI4AgQjkOcOMWCtkGcemwjegYjBWoPznryTIyLESUwUG3p6K7ywf4o9d1/Hj79zibH1deJ4lqqkOK8458hzJU4s3itOlSz3xEZIjKHTcXggtoJiyPMSr0ISWUpfPpRl/rXovvt5PIrijcX8EP91wNKcrhGbGj/9geHEz4RGtZcksRz7zyqX3m3w88PK6rX9nHsn4dXnHTt2jvGzHxrKdpUPJmq8eCAnm+9j7eaEop3y8g9iTr8ec+Ntdc68JZx+M+fYkWk+/9dDzE63eftwytnjMa3ZGuMbYo7+EJqTQ1w4rQwO17nwdpU3X4DR8X6qNcvpwzXeOQz9/X24ToXXD0Jnqs7A2nIo+twD5htFs4fvfrXGc08XrN88wPBYg5OvWn5+GF5+NmPrdf089uAsk+83eO6ZNrgGjXSYRx64wO0fW883HykYGavgsh7OnYz5t8fn2bazn4kTCU99LWP16iHGt3YYHunh24+f5yM3jPLpPxMOfqvJ9/7OMX2uxosHmtz1mbX801dmeGm/ozXdoFHr5af7hQsnEhYuNbBxzDe+MsfataPUalVeenqB6fd66evtYfi6hREjErE41cuPnp7ms39a5bf3LjA43iIyEWdOzTFxapHpSwmVNOJjn065455hDj87w0fvjkkqFY693CQvFrn+tipJWnJ+Imd6apETRyzNmZgrl5pcf1uFsfURWebJs5Isy0hriolgfFPM3vuH6HRanHkjoVIVjFXue7CX08fnOH92mjVbLQefOkd7us7U5CKr1lu23VRj8pyj1cy48eMJxkrdCAIupSwL1m2NGBr3PPlok6MvzfDHf74GVyqlg0olYWQ8om8wpswdNl1k96/3M3E8ZdU6WJhOePJrk/zuHw1gDIgKd94n3PGJIR770gUunKxy6MAcH793F6femmRyYhATGeo9lvGNlrQmLMwpirJp2yBjW3I67YKsGYGr8Rt3rGPLrW3+4IFN7Pvb9zn67CJ/+OVxFuZbfPPLs2gWYxSPSWdoNHp47nsZV8+t4uRrHcZWN6g1KqiCdKdNGJmKAoVv82u3pzx/8D123tTDB5enaM4pqzf2LE+xOG5w854YwXHskOGtowt86k+qDA7XOfCvU9TqlvMT8xz8zizTVzyj6zwCiIGomrNmU4q1hq23LvB7DybUag223mzZ+JE6J4+0GVrV4Ja7+jl/qklnwWBUHX2jGV98uMpPvj/Pd7+e8fm/3MKxI9O8/qKnWhcwik08nhbGltjYU2qTW+6MSOueDTs8H73Hsv3GKn9z/wTbdo7gvGf/v0zy9381w023D3J1rkWa1hjcNMlv3lvjlednKNspWlZ49flF7vn9LazedRVjHSbydIo5bvidjA27LF//0iSv7K/w2guzfPWLF4GE3b8V888Pv89z317g9s80SPoK5N8nUGMslSTBSIVOuyRJHfgYYwxlKZRlThQZnHNEkaEowNgciQzGxZS+wFhHbCvgLBhoN0vSOvjColGJ90qRGTQqsdZQNBs88w8Z776R8Bf/OEDUd5Esz8EkdFoOH4XRnsQpZW7JywITC760eO/xUQkuwrsIF3Vod3KsAt6XtDMH0kYE2plikCB8AhjBKyBBjcUGZaYAMR3UBF6Vvgz4EkVjpZWZ8L0A74EowLTIDWJKan0xaT2iVcxgixal86grwAat8x7y0uFVUPW4jqB4vBdcDp6uc8hDPFa7+EZ1WbZFwYmuSDgr0vtLl6hfuXDqV/YFVH3gmQ/71gSJj7xSULD7DmXtTgcVh2oQ4qIMSXhd4qgP17BsY7wqqiscDp9gvV9xE/I/47wm+l/yXNcmY7q3+O66QDEjFFchHlEkBQzkBbxzVnjztLBpDdy43TO4MaN/I8zNw/tnhbwQbtjhl/3Z0gPFgCu7nqybBMsJrsRjXbcTywVdMod+xQ+JCQGF8l/juwqhmOkOiCFFImieguJKt9ERmArYAeHoafj+C3DxvNIzIJw8J3zubrg6Dwd/AidOgXfKGycM994J9dQzvwgfXjXMz8OOrbrs+QTwshLj0qS1S+gSwHUE3wkLtreLcQfFpJBPgTGQbgBTVVxTmD8KGCUeAldCPALFApRtRVLBl6F6Wiq2ArfcKrw7DHMt5WpHyUuhlcPwOIzNC1emlItz8OFc8H1H3oZXXlHaLdi8WfjsJ8FGGty4gInAuaXOSEgGhSKD1ttQTkPUgHQzJKvA58L8CUVKIV4FnUlIRiGfCUGbFDQSyhaYvGvdUURDIvjQeRMJ1ZqyakRoXdRgWAtoZkpcgdHVSt49Bgz2wlxTiRvChm3CxBnl/KRy/DRsXmfY/yPl/ASMjQmfuMszNBi4Y0oHTiGfhoXTsHhZUGsoF4R8XmhfBm0DFUUq4ArFOchmwnnFC2AVNeBNmCplF/Olk4B/T3c6CXoNCbMCWnlARbMdKlyrKPUKXJ4N+K/VPEOrlIFh2LEJJiaV9RshSeDCWc/rx4UsC6Q3zoPzYIYhXi9oqSycUZyCJtCagE5TyNshMI0FnwSCexXUCk7BGXDI8kHKXUPWpeTUB9hql4t5Ca0sJNtuQ+mU0WGh6JI7z+DqnJBlcN0miC2sHoDIKmu2KmPbIW2E//NIGABo4Ed9t5KMC75UzKCgRmHQkP1CyebAx9BzPbgCsqvgCzAeqIMdAd/VIe8C/0wGUgv3OCfLI1d9wDpANRFmF8B5pZbC+tHQqS2j0GkJvXUY6BV2bQZFGeiBsT6QEuxaYftGSOJQOOvcNee8VInXrYwHp1DfqZiGUi5C1AOkQulCku1Tiv8QnDU0RsOByhloTYHLhM48pJsgHQRjQqLOQ1FCpScksmnUg0LNCv09sGYkJBZFsGsz7N4CcQR5GX4PsGUdbN0QoFt2JUGVpi0dh8Swp9ur/+Mwr8QbIOk2MJxEoX6TJxoJ6mv7FU2VooB4DVQ8dC4o0g/SHzo2PgBpRShzGOqDDWMghHG7ZS0Y0S7PoCxXnq0C2RI0u8uFX5GIa6bxq9YpT+DYs6QtS7Nboq5gQbAOXVhEUYCkeNAhRb2QeyUqIRIoEihHFU3BV4WyrkQKnVmhcxlq81CtKHYRdBCa88LMJcjbQdWrvTC0LvCoOQd5Kzw77QndFHPNOJYgF109fMI6xz7gZpSH8gzydtiMK1CpQZnDwkzAvABpj1Lrhdac0JwP/VWg1oD6AHRa0JwTVBXaSqFgU5i5DFfOhtq2feBD3zhMX4DL74WATQRj28PEW5wVPngXikIxBgbXCXFDKZvCh79Q8g7EKQyugUqDx0RknzxyJIi7wl5V+QLoniVjI9eq7JKydgnmXEjUe4iicDo0UYBI3gbvBBHFJmAr0FoQFqeh01aSRKj0KY2BkERRhEobK4jRrudbsTRLXcB0YeVkKaRDIjwhwj5V5b8BaBgDJ/+dmrAAAAAASUVORK5CYII=",
	cxn: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAYCAYAAABXysXfAAAAAXNSR0IArs4c6QAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wDFw8dM2imKTUAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAALFklEQVRYw62Xe4xc5XnGf+/3feecuezurHfX69heG3sNXoOJY8C4Drc4GEjrRCIkTQpJS9NWStWkiZQ4qFH+qJCKVCUllKqqqljqXcVNU1KpJYgkNDItUoAIWoJt8HVtL+u9eO87lzPn8r3948zuumn7X0YazZzLzHkvz/s8zyvPXgCAZw7pI8BngYP8HF4KiHY+8UCKsYrPBWMVawTxFisWMYKgGBGsASMgohgDdvWcggjWFPcV1zhuhKPhN+WYKhgVeOZefVKVZ1Q5qAo/j7d0khIgy2BgeJ5HH0+hdJW99y/z0S+ktJI6upp6pwj6/xdI5H8V7CDwTHpEn1TAHfugPqLKEe9zkiTDWMEYIcs83nuCMMAIpGkOKF4hDC3qIcuUMDJkiWIsqHqyzGONISyFqCppkpKnnuWlNvc+NMDxF05z/6c3MXm5QZquo6Ux1gjWWsJQSJMMYwQrQhQaUq8k3lMqWQyQZorgCUOHESXJM5xxR6LH8tftjb2P/2nu021hzyx3P5hR7W+R+RZ3fNiz+4DSaC2RJjm3fLDFphsa7LlLmBhf5LobU/bf5zh9apJf+EWPq8Rs3NHkAw9GRD1LvHshIajE3PHhjJ23pbz5SpMd74WRvSF79/fzl384x7qBMrvvarN9T0a1r8nk5ZTbfwmqG2YZGjHMzzYY2t3ifYeEqYkFWq2ckTtb3HQnLC4u4coJtx6G8kCDhXHXb3fVfv+vg2qdhx9rcf8nAy6PLjAzVWfX7TnvvUt4/wMR508v8pWn+hjc1uC+X66Aa1CPZ/i9p4d4+UdjfOarITNTbVypztZdKQ9/ocbZtxcYvjnlU18uMTExy+T5MrMzdX7ti1t4+61pvvtnyuFHu/iVL1kGrmty8KNd/ODZcX77D/q4+2OOykCdRnOZOz6mDN2c0rOpQZalfOaJGuPjUzRbMfd8opv+65dYXKoze7p7vVHN6RpY4kOf6Oc7f97iR8e6mZuokPucHSM1hke66N+U0I5z/u3ZmJeen+HOB/r48QspSbvN3vdXCYMu3nqlRRI7tgyH9A90sXt/RrUvZcOmKm+90mbyck4UGcLIEUURcVPwOUyMphx7epZSqcKOWxLaLcVnwrefWmLnnhpbtvczfi7j8Ke2Uu5vMDDYxfTljLNvNBncaqlUI978YYLPtGoUBRvjXMDYuZzZCcOjX6my7+4+/uZPxrFOcBba7YSrEzmLcykutGRxFyf+c4HhPTHTY9Ddn/Dolwb557+dx3tQUV78tvLS92Y58o0hhna1OPhgjR8+d5KRmwcZHJ7D557GcsbExYy4qXTXBEEYPTvH5PmQUjkgquZgm/zkpTHOv1rm7/94lEe+vI19D3Txd09M0N1T4defWIdEKUYw+LiPen2Z+z4Z0bt1ml23lZi8UqdZbyMC2mGbgjIFAQJT5r9ejjl0+HpOvbHMezYOUK0JVy4ur7JYmtZ5/XiKYtl70HPzvm7+5a9azM00ePA3Bmg2MrYM93D40+vo32CYGjMooB7yVsj4aEyWec692s13n0poNuucez3j4tsNdu0vMztd57XvL7BlpEqp22NELItTEd96vMU9H+nh4c9F/MUfnWfv/n5u/YCh1VDwQpYYDBV85shSg5Mqr72YEzcMl94x/Pj5jDNvtvjq08OcPXUVawwP/eYgX/x6H2+8PEdvrUIcN5kbHeQ/nmty4FAfrhwjrs3th7p4/h/Pc+VkLz6z+NxQCmr89AcRl05mfO4bgxx4qM1t967jsW9tBhJO/HvKbz2+jft+tZuX/6lOshggH9+u6n1GO0nw2qZUdiSxBZPivcc5xbmQPPdYa8lzTxCAz0I093ib4kyAzyxp1gabgYdy1RE3wAQZkjuMEYLII7kjyzxBtc7HfzfihlsSnvz8PPniZqIwBJ9QqlhMXlB7ksa4MCN0AT5VjMswxmByBzbH2ByblyiXQpwAxjjKkQUtowrlSPBoIXwKeMUIoIUaa1YoMwGoLyG+mCtnXIEvFSQVKpEvvgdgDJAXMA1Cj3pHczElbuRUgj6yoIKzBrEBZIXWGQOhsxhRRAy2pAgGYxQbgqHjHMIiHicdfCOyKtsqYFXWJJw16f2ZQ8SsHVgxa9cVREwxZ6a4nvlC4nMjBASceEl495SFtkWkEOLAFUkYWZlRUxzDqo0xIoiszXDxCc6YNTeh/zPOa6L/Gc91bTK+c4vpnFcI+pSgF9KrgsaAhzCAG7cr79upjI7Dm2cMcxcjFi5CrQe2bVfCQPnpO2bVn608UD1Y1/FknSRYTXAtHmc7nVgt6Io5NGt+SH0RUFH+a3xXoAR9HYKYFTSH6ggEGzqNzsG3IZtX9u2Ej9wLm7cIy/PKrq3KP7wAvT1w+B7YPQLGCrfs9jz3IjRiQ08XrO/19PTAO+dk1fMpYHQtxhWmdSvoUsCWFFMqTmRLHYxbCAaVcAC8h/gS+JZgq0rPPsAL6SxYB+lVCLrBlQWNFeOK6okTsja89qpywwzUKkJvSQidUglhZgIme5QNA8LmGqyvFb5v/01w4IBQrsCFC8p3/hWyXAo3ruBzsHalM1okg0AQQeUmcP2Q1yG+AMk0mFDp2S2oU9JpKA1CMgVhXxG0j0FyxVXAhx3rjqBSJIIpOu9zpdUUpq8qlc1SGNYAqpGQtmHqihB21oC5JahVhbSuXDqrDO8QtgwKe3bChTHPQx8StgzD5KTyve8bZuc6s+MsWIGwH7p3QtdGRTKP61bCHqW8EaQMtAVtgw0EayHqK/YVo0AmiAfjO6zSwbyzWuDf0GEnRa4ZwiiASligolouKtxsC402bFxX4L/ZNMxOC/Mz8M4oDA8Kly9CksDQdsOte5Qo6oi6NWAN+BlILyvihO4dghWQBCrDUKoqYbkITFLFJMWAG1EkU6yA9WDR1UXKXjOsK8mJKWArnVkMHVSiItlyGZwVpmaUoDPcYQS9NSWK4PQopBlcmYc8E8bPCZNnIK4X/2fQggCQYj4aJ4RkQjFO8HOKeIE5T3SdENXApLD8FtgAol4wAXgDNCC7Wmx61oCxxfz5CLRZ3GOtrlKumALrAK1EWdcN1gjNGC5PFZ06PwWlirLUgPkl5eQFEIT5ZZhcBHWQvaucuQhJKh0k2Gv2vFhIx9bowQo0Tgm+LrguyJeBWHG2SLI8Ipj1YDNPfapYqKyHygDYSCn1QDwK8Rx4XyRqDQQO2stFIqNTBgSambKwDONXi8TyHE5egBPnIc0hdMXvAc6PwblLBXRdRxJEaDhnOa6eg51e/R/LvJBegqTTwGIThcYbhvxqob7ZgiCxEASQjkPbQGlI0AXQhaJjE/MQtxUXwuwiXJoEpaDb8++C15XqgnNrzxaFaAWandOBWZOIa9j4J84KR7EcXNGWFe7WvCNYUFiHDizyvICkGpBZQYwSGiF3kCsECbgpQWIwLcU1hFygtE4pbYRmD7TaQtYFMgfVHqVvE4TlQtVbSzA7VsxRtQZhpXh2vFx0U/01dKyFXHT08KgbOirHJn5Hb0M4EkYQlouLaRvaTXAhdPcVmFcgXhaaS1CpKdWeor8CNOvQmIdSBao1RUSgLAQCWQx9G2HD9qK2ZVPMw+IE9A/BxuuLgH0Ok2cKxutap7znBggCwXuYG1PSuuCqyvrrhLAEaQxz49Cu883pr5lj8vXXCnRNf14fEdHPghxcMTZ6rcquKGtnwKwtEjUG8rzYDn1eQCQsg7GKqpAlkLWh0q109UOpLCSJ0l4U6vNFEkFQVNpninrpeL41S7PSBXwHVlZXQjquytHpr9ljqsp/A4WDAPFjwayWAAAAAElFTkSuQmCC",
	dashed: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAKklEQVR42mNkoBAwjhowWAz4D0YMv5EE2YACv9AUYhWjjgEDHwajBlAGAAbTDhE8Ag75AAAAAElFTkSuQmCC",
	data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADf0lEQVR42m3TW2xTdRwH8O/petqe0572nN5b6GFbu05BUpbgNrNh1EgWRGIgJMsCySTxshfZxTDkYQ4SfdiLq09ovEQfNCJqjCGbMi8hLrhAFmIAzS4wttl27Tl0vZ+W04v/LWHy4C855//0+/zy/53voUDqwqXLbiPDdOcVpVNP002g4KzWoFdKD0q1GmRVVRc5lrmaLSgXThx9cRWPFHXl2o2n88XSZJ1GxzY3+mDjOZBG3E/nIKfzSJBTWs8gIcnwCGzJv8195Ln2lokt4N1Pvh7o6mgd11AUeI6FidFDVStIZgvkIc0EkVM55AtF+FwCOMZw9sBTu89tAa29w/0WszG8v60FuxpFeG0CWMYAjQaoVGqgCPywbi5FsBSVzp7q6foP2HNs6HWWYT7gzSY4LDycBHDbrfBvc+Ix0Y0dHhsyOQVRKYW5f+JYjklvnT7+wtgWcHLsvIHMmbkTk0IOwf6/QEJKYnF5FemiurCyGtk70Hs0swVcnr5+4vPvLn06e3sOjNEIq8CDN5shcCbscJjR6LLiyuwt9HTtw/mLkzjUEfpNisf6ht48Nb8JHB95r791ZyCMShkxMqmkljdltahAdAp4pfsl/Dj1K55oDuDW3CLqUK7G12JtqfX0ysjoaIJqOTbUzzBM2OeyY+/OIHxOGxgt4NBXUSpXEfQ3oEgwkgUoigJZlnME+JPMsCzMz++h2l8ePqjR0j+QJWoeLtHBmyFyFJ5pCyGXy2MtIaNC0dDTGmhRxb27d/Nr8bW+ZHL9C2rs46+cJVX9eWL6+m6Xy41GnwjRVNu8f3PAj3KlglSphunZm3DyxkyowWtOyImyLElLkdXIO9S3U9MDFyemxpej8a3vHar3oMnnwcHn94FEAX3n3keZnAJLY+TVHtxPyrlYNPpNNBb7knq2b6S/fVcwLLps4FgDCsUSctksOM0D+Ld7EGgKYIXgC/dW8Hi9CJOJgVJQKjMzVz+6s7D4BlniIFkiG94IkpMX0CR64bXzMJdTsNsdBKXBcRbodDS0Wi0ikWjm779uf5heTwVODg4eoTp7hzop2vATZ+bYR5PY4CXNlRyUbBJWAtWL2zH5y++V7sOH6sLj44ffHh39fjMHG68Dr51203pDN8eZOgTOErRaOKfHyeutjK6k5lIyhZpiMeqCf1y7sd+gpZ4kv/xnw2fOKBu9/wInnGoZdAhekAAAAABJRU5ErkJggg==",
	databaseSearchToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAFt0lEQVR42r1XW0xUVxRdFxNFUASsiiICitooatKCqDUQxUA0KlIHYkGwQYxCm7boRy1GQkKKrUlLCaagTrFFIPIqShXwgUajgIKJvJQWERKjKFHxAb7h9qyTDHJnoCJIV2Yykzt37l5nn7XX3kdRBdAHHj9+jEuXLqGmpgYNDQ1oaWnBw4cP5XXCysoK1tbWmDhxIqZPn445c+Zg/vz58np/oRgTaGtrw8GDB5GdnY3y8nJ0dnb2+2HEsGHDsGDBAgQGBiIkJAQ2Njb9I/D8+XPEx8cjISEB7e3t7xS0L4waNQpRUVGIjo6Gubl53wRu3bqF5cuXy1QPBVxdXVFcXAx7e3tTAl1dXaqHhwcqKiqGJLgB7u7uuHjxIhRF0RI4d+6c6unpOaTBDTh79iyMYymFhYXqihUr/hcCx44dg3Es5cGDB+qMGTNw7969IQ0+duxYWcrGVaHU19erTU1N8Pf3l5UwFGAF5Ofnw9nZGTNnztQSOHz4sPrixQu4uLggLCwMVVVV7zX4vHnzkJqaiuvXr2PEiBHw8/MzJRAUFIRDhw5h5cqVyM3NRXJyshSMqJABBTUzM4OXlxciIiKg0+lw9OhRrFu3DpmZmb0TWLNmjSyP4OBgxMbGYtq0aWhtbcWpU6dQWloq/YEruHPnjgkpBrOzs5MZpBUvWrQIy5Ytw/jx49HY2Cifl5GRAfqdiGVKoKCgQF29erXmgTQlWqmvry8mTJig+cOjR4/Q0dEhv1taWmLMmDGa3+/evYvjx48jKytLmk9PwiIWVq1apSUgVqVSHM+ePes1nVOnTsXcuXNls2HTsbW1lYEJEhFVJJsUFV5dXY0bN270+pyRI0eCYjdekNLc3KyWlJQgPDwc/9EYBwVur16vh7e3NxwdHbW/HTlyROWqmLrIyEi594OF8ULy8vLkypmtntstCVCEmzdvlvvm5OSEpKQk7Nu3Dzdv3hxwYH5yS1++fClnA2bAuAdoCLAKaBY7duyQ7dPCwkKq/8SJEygrK5N7ywy9LTjf58+fR75YMSuAsBB6WSjmg/ViNrAVbtgnAQNomaGhobIK2CUNzDkjsG1zYKFxETQWWivdjcF/F4aTJ3wECl+Khpy1uC9+1y5MMdaAUKbKGu5t8qE2SIJuRm9wcHCQARmYIBESYrmWXriAOFHzipkCXUAgPtWtxejRVrh29Sp+FdvKCnAS1bZHmBynpm4CIrVqYmKinIYGCtb6tm++Rm11DXQic5u2bNHsOUlu3BCK9iftiBNxPBYufENA2KTK1dGlYmJi8OrVqwER8PVeis7Xr5GRlQ074RfG+khM+BkFIkZQ8HqEC9FrNMCZ7fTp03LijYuLQ05OjlTwuxBYsvgTEagLxSVnpOkYE9DvTUF6WhrWBgTgq6itpiKky3ErAsQNTBkzwtJkNbytJEkg0N8PLbdv4/sfd8NryVITAuFiC/6uv4Zt326H/1qdKQEDKDgaEokYhgf6P62Wzej+/fuaKmDVsIum7NmDPw78hg/GjUNScgocnZy7gx/Q74c+JVncb47cgr/kPd0ERI2r9HpjUKlubm6yuxmqYNKkSbIyDCM2Bxi6G/tF+5MnCFsfjObmJgwfPhyLPb3koaXqyhU0NvwjibBx7f4lER+5ub8hwLGcB4j09PR3Fl/PFBOtwqxior9DRXlZr/fwPVo4Y2p6JlxEc+smQOWzGaUJkQyWBD/ramtQKUZwbpX95MlwmOKI8JBgKWxBQ/iJI9JzcmEjsqk5mhUVFWHnzp24fPnyoIkYX/szJxux0duhdqmSxMfiDKlPyzA9GxKVlZXybMheUFtb2+/zIXXDU5CPj4+0cmqoJ4mfftiF1L3JsmpoVJsiv+ydQE+wB9TV1cnmwl5A0RmmZ4qRouSRiyKdPXu2PA/2BQaO2Pg5zpw8KQl9OGvW2wm8bzx92oGtX0TiZFEhPgvdgH8BIrr3hiQMM2cAAAAASUVORK5CYII=",
	datatable: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAHISURBVDjLpVPNK0RRFP+9D98syMwUspHkm9I0YkFZWBFKkZ0s7a3Ewh+ilChK7FgoZCJFKYlYKB8zk2+Z5t0P577He29kQU7dd+6575zf+d1zztWklPiPmOozt/U4SThjXIoyIQS4AJjSXO0lGGlvcXAm6Vzsz4xUhm0AIeX4QLig+C+ZpxbOG1wGhGYHr1zMUmZGWRgs0ha3PE1nX/8mWmdgWTzLB+DUYbhm9FfZ35IEyrhXA3VXJfPbsV8B9LQUIeUHYJ8ASobag1jcucNgW8g9W4reYSDi2YnnZDoDiwCokDANct6NwTB0LEdj0HRA/wxa2SN25JNBEdWluUhZ366gqmAaGvrCAXKOozccTGPgt8+vn8GYSGcgyTYp3dpBnBg42nbQPRBTo5bTvqYkmxL6AQhNTWQGBXY3B7BxlEBXozcW64dxRKoKUZBju+P06gl5WaaviMJBM3TNDlbypemIZgHYOnlwASsCmW7nHADGnBoQ3c76YmweJ9BR5zFYjsbRHwm4tmJg6PhWA7pCXXk+bu7fURHKweXtq/sWaksz7SC/CCGFrwtyZ3r+rCnFRZ7qr1qc6mLZj4f9OEyPL8lVpbX/PucPv5QPKHB1TdEAAAAASUVORK5CYII=",
	decorationArea: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAhElEQVR42pWRUQ7AIAhD7cn06HoyN7KQOGkn88eItn0gSmL13mdrDewOXwLb66McyhzqYpZS1/O43RhFKHj6bqAoKIGJLdHwTxTSQKQNUostsGQ1zGCg0lMtsPRTG78IGAWYWP2A11YKrGImPLXyMsgI9x9Bdng7HSXItOBvfJjIoqt1ARvjaE9SPeI5AAAAAElFTkSuQmCC",
	decorationLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY0lEQVR42q1SMQ4AIQiz9zKezr8cNA4mDpYrahdMSloKohzA3ZuZYbzBCBWp5p0Bss6zd1YpQmSAyEXhwgiKkHwFxr2JoGyd8ahfaX8iEeiYo673TglkYtDTqb/zfomsUZ2gA3Lfag2wICqCAAAAAElFTkSuQmCC",
	decorationLines: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAd0lEQVR42mNkQAK/mRj+s/5jYGTAA0Bqju47wODg4ABWx0iOAchqSDLgwIED/62dHBgwDABJgJxEigtgeohyAUwx0V5A1kBUGODyAjaDyPICPkuo4wV8LkA3jKJ0QFIsgPggm6niApLSASyj4ApI2gUiekYh1gUA5m2oEQdDgmkAAAAASUVORK5CYII=",
	"delete": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAp9JREFUeJxVk8tr1FcUxz/3/n55VFMT8gCtQ6uLUBqqCCbiSgqFgpa2mVIEQUo2QnFZioj0QQVduOhf0FXBnTQDpVJ3RkTETqXkYTudjRknhj6m6TiTYfL73XNOF7+ZMHM253Lvh/M9j3ucmdFry2feOOoGB7/GR7Pmo5yqoMlOVZOdoiU7X83dfbbcy7veAKv5Y4v4aL69WSGtbyEi2YOPiPaO4EbHIYTCybuVfF+Ayo3Phhs/L5XTrX9y29WniMHUhwtMX/4GQylf/5Q/C98RAX5sAoaGq63J3PQ73z9sOzNjNX9sMTTq883qU4JBMHjrUY2fzhyhFuDs7cfcOrGfAzHEDtzLY7g4Lpx6+HferX40O2eqj+prj0kNpvILzFz/FtTAFFMFU1Bl5YtP+OuHmww4kNEJnNkJrzvta+3NCtJRPnzxcxDFVDAR6HhT5bULl9hMM863mlhIr8Vu+KWZtL6FAAK8WPqRRhRlHeo2uOM1BJqacT4kpPHQjFe1gyKCkWUdHXqdqfwCmDH5wcdMvncegIl3z5G+cpghl3GYEVQPetVsVN1h1n/7tVO3ZWWo7J5rv6/gHLu8qeA1hA18ROee1sY6dOcvWQDDQJXGxjqDXRCHimx4bTWfRHtHcIB30Cgt96miCgYmQq20RuwyLjhHrPLEWzRwxY2OEwER0Cqt9KmaSJawCrXyGkMu49rmENUrfu5OqUgIBT82QeyA7Rf8W7zPyJtzu2McPPAqz395QNJssMdD4jxOtfB+WYvOzLh3/u1hXymVpbWds8Z/BIPNAA3p2zP2RTA+4EnUqs8Tm764bu2+Zbp3cmoxVZvPPkmS9aHTsOAcbXNd5f5l6rWl46NHgnE1qM2majlTAZGqUylGpl+e/kNXevn/AT0JpV86x3yxAAAAAElFTkSuQmCC",
	deleteSaved: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACi0lEQVR42p2TbUhTURjH/8fFRtlkotvSqc1tbmuVer2VRokiKb0QGVjQCMtIVxYSvTGIKCgqM2KIZJpEGWlaBvlCoqRZX8QaDA2TfCvzgySI3stkbrp1d8x98sPowOH8n3PO8zvP+R8OOWj98BDAaaEjzSRfgyBa7+D04j9ZQw5c6eQ0yXqpPyo3xwWTj5K6CTqOOX7wZN/Fdk7HbvovwIj9O09ySto4LWuigEf5aoxOL2Dkz8KqiTqFBFq5BMW1P2k8ah/kSVbxO07DbqGAJ6c0QVVQ+HRs+Qr2bzzJKGziNrJbKeC5JSGoCk5UDdP4l32AJ7tONnCxbCIF1J83BlXBsYohOv629/Mk1fySU7FJFHBmTzSyE8MDG4ft/YhoqINXq0Okhb40Zh39WNf0BpcdTvSFsTxhjzzjNqQkS1c76W31YYgVCiA0FLxaA2feUSjK7iHEUgS0tODQkNhFknJrODnDrApoK02H2GQCNIK58/PwTUyAWK0Aw8DX2oqC6i432bz/MRfBpAQAZeZoaJViqiev34axvhYSvR6IjwdiYgQndfAtLmLAVglzdJ6TGLIruHCGDQBar2qRdbaD6q7KHIwdLwD7pRchCQmAWg0olZhpbobNbEVjn4cnukwbF8ZsCwA6rumRYWmnuqdqL9yqOER53DSRAoRKlubm8GrSiZvhuTxR735AP5OU2UEh3TeMSC9cBrzovgB2doZqn0gEl0yGtQYDhXjGx5ExJXcR/2JsWimFrGdSpZ9vmQImTipVSFrywCfozqgojKTthLnnI2SCD17B1MwZhZusbFZtv0Mh5/JZycrcVGejKPNTc8i4LBILl2we/9z7u/d9llmH+KtI6n1tLCr/C8Ut4ia21HG2AAAAAElFTkSuQmCC",
	disk: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAU9JREFUeNpi9K3Y28fAwJACxAwWWqIsDESAE9de/4Ey57D8+/svRclAjRfEq4qSI0Y/Q96yR2D63oVbKUz//v5lIBeA9LL8/fOX4c+ff3DBu69/Mtx59ROrBhUxdgZlUXa4epBelj9//jD8RjIApACE8QGYepBelr+//zD8+v2XJBfA1IP0svxBM4AYF8DUg/Qy/fkFNODXXzDefek9wYADqYGpB+kFuuA3w89fkGiduO0RGBMLQHrBXvj5i7yo/AMOA6gXYKA7SopBWZwNq4a7L38xxGWtYBC3sYMY8AtbIAI1O2XuArP3TXdDMQBmMHIgYkQjOHr+/SMqFv6CY+HPnznvTp/4DEocsAQC0o/PDJhaUEJiun+4uAiYJOd8OH38MyyJHp7tAcY4Aw+s+R8kKUMzRRGI/nTmWMqs5T/xpqIv3379ZDhzDMadAxBgALae7bsNa2kaAAAAAElFTkSuQmCC",
	distributeHorizontal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARklEQVR42mNkoBAwUs2A/2CEIUnQAtobYOj3H0P8/CZGxsFnAIYiIgAjnDhw4ADJBjg4OCAMGBRhQDsDiApJqhhALqDYAAB9FDERg324LAAAAABJRU5ErkJggg==",
	distributeVertical: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATklEQVR42mNkoBAwEpD/f+DAAQYHBwdGggb8ByNMSZAB9g4O2DQyjhqAZgDFsQADhn7/4S45v4kR7ILCPnsGJDHGUQMIGEBxLJAKKDYAAJe2UhEjPBXbAAAAAElFTkSuQmCC",
	doe: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MEgIpMDyPrG0AAAEXSURBVDjLjZGxSgNBEIa/OQJpRVJYiQTBR7DMCZYpBLVLKaa28xEsElLbJAgBMS/h5gHsDYi1VZ5AHYvL7O1e9s4MDOzOzv//M/9CEAqqoCiqQRGF6wVcvVAfBjYCFA0JLC+f/wFHBEZTyYt5AzhBkCTpzwp8ix3DNgIQhN+fzVkJXgCJrxu0SEgiiDUjWnqdBCsi1uSWzjfkvVwQyEy4Dlyt9fLcq0ceKCISfX8JDpUj+xE/gQdZVj3xypXIpsHl/uCEYIi0ofZ281Ss8A08Ah+dY8bndzwAaDGDc8tahtfBkTJwZENgtd9ldHqLzoflOkrj6FZvAUzWn/D1bt/RqLzlgT+9TaG9B4dnjcpbXqSKzrmdJ/gD9HKQM0jUN9YAAAAASUVORK5CYII=",
	dotplot: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY0lEQVR42r2QWQ7AIAhE5WYcnZtRrEuqUkmEOD8uE54zQhIRESMipEXMZQXFq44bkIfzRgfYGhIIievlB7ZP4QeEVnjfU1O0MMUTB+IA4RVMTSn8gPsV/gAnwx3g0QKY/8Q6P6ObW1BNWDGgAAAAAElFTkSuQmCC",
	dotplotLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVR42q2SWxKAIAhFZWeuKdeha3JnhJPRyEObjJ8UvKcLCoGi1ooxRggqMF9fSMEJ2AY0cVvYgId0/2zqgE7lnkyjGAtlDwuyAnQxt6GczFrwbA95NcTmghamXSrmruK6dQtIkCLmIAFcky2403av0XAwD+FiH/DyIf3Yggf4ImbATiiAnMlqfwI5aWNQRTjQ1gAAAABJRU5ErkJggg==",
	dotted: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAJUlEQVR42mNkoBAwjhowWAz4z8DwC8phI5VNHQMGPgxGDaAMAADuwBQRkqnajgAAAABJRU5ErkJggg==",
	edges: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAIFJREFUOE+tU0kOgCAM5OirPfpU3uANbHUimDKMUZJeKLN0IaW/Ts65IF5zArhvKyUZiljCwIjDQWnCDVERkmyJOhHDdKVeF15C1AO1zBAMwpmIvYNlNggqMiNRBFw8UpHBixE8lkoG+7yNAEsl9uXu2WCp9O1W500ZP30s3ev5sgLi+dtLomkSqwAAAABJRU5ErkJggg==",
	edit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAqFJREFUeJx9009o03cYx/H395tf1iZpqFJxpA1bwxZkageKFVR2UPCgp3YTKrMMPXj04mVQ/IOibIgwJkzF26biQKH1zyFbPOlhKhFqZ2UuVmyobTUhtk3T3y+/3/fPDmKXUPFzfZ7XA88Dj7DWUp/dN4a/bPkodCwsxAZHkFRGU6mpiaqvchVfHb29Z8tIfb+oH7A/83gwLEVPbnqWQsXF129rYSlYGXFIxcK4Sg9l+7/qbRgwNrPQ/PPDF/mxNwvJvyZn+FBSMYdlDhPrYjZ9etdWTwL8eO/5lQ/hfYXrZM5t59eLexBjjyl6OnmnrK4AiAPZ0W5l7IPf/5l6L76cHmb58Ajyt4sAzDsRvu49T7r9Y7QxG+VsTZ3MTc++F19bm6Va7aR5x0Em+74DoEW5mNIUr2oGV5uTzvKm0OpCxV2CL627yrZUnELpOW6ki9iWftyFe9x9Fgeg6gfEw3a1o43teHftdznT9Qc7U3GYy/CJHmVkqsj4+CrKiS84Nb+JUKIT2xRFBXMdUhm9BPenLcxlwB1lpgJO8TTlyi1+yncTSnQiWtsAUNoga4F+GZYCgHgoYHPrmwY8WYRsuZsT+U14ic8XsbCWQJuXsuj6T1ZGHADWx19jPcmfYx0N+PCjb5Ar2hcxgKN9fOQT2SwZSMXCAEQf3iR75wWftX1Kvtz+P25tQ65INKwqvSoqCAaEtZbtl+4Olmu6xzuzlx3fbuNfkyQ3HWE+kG9xorMBO948xq8NlQ719QprLT9k7jfffuXmi55OjuefQiiEaIoioi2IaHwprrkT/lQhPXf2e6/hmTZeyA5aY3peK0HVCAxi8WCO9pFelcDYodKhvsZnqs+aXzJdGH3car1Ba5VU2uAbJgJrc8qKI6WBXX/X9/8HJzReCr+o8qIAAAAASUVORK5CYII=",
	editNumber: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAALZJREFUeNpi/P//PwMlgImBQkCxAQwgL4AwIyMjOtYG4jVQGoUP0wPC+FxgCsS/gPgqDj5BL3gC8R48fDBghMUCExPYLD0gbifk7X///nkTCoM0IN6Ii09MGPgD8Q48fJxeOExExOUBvXAenxfygXgfHj52LyAl6Qgg3opkI5wP04QMWJDYzEBJOyAtC8S3gVgKGiswvggQfwTi31jDAOg0ZiDFB8ScOPz+C2YAsisYBzw3AgQYAPe7bHJIc8toAAAAAElFTkSuQmCC",
	ellipses: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAkElEQVR42p1SURYAEQisk21Hd7NWyBaP2PlJXjNNgiklhgwiQtiCuUZ0dSURkbXASPQ57h1Ise1o83oOHNhuSvZxcpATxjbatQMlzyIHb/AQwUcanRxsQQTaRXGgZwhw4WAhYB3Y+Z0AAy/YGDsQMprotlxqgi1Y4igmAvt/8HVajrD/iTG6wB9yF1Cok5v4AjrtoIs4vdJTAAAAAElFTkSuQmCC",
	errorBars: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXElEQVR42u2OUQrAMAhDm5Pp0fVkHQwmxdmi7T4X/BASX0Q7FFZmv8eCKAMeCBY5jMGoLQ3wYRHpo8fMiEpKgOgjW/yBVwpARHagqt8CZh+lAd77ARNAK+gF2NUFRjVkEbh0R9oAAAAASUVORK5CYII=",
	esc: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAh0lEQVR42u3X0QqAIAwF0In//8mjGGKIuKRc1x7u3srpDssEk5Q4ZE+kVIurKrRyzrkIDIAu3iIIIIAAAv4JqMekF1HgKeDrziwD+k61+XdjIQDLGRW0d/18b71Xe2C26AgH/wQwgDcHAniyB7yuLJ0Do5ywvwAVBBBAAAEXwB52Xk5FNl7PT0iaywNJapmrAAAAAElFTkSuQmCC",
	escToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABN0lEQVR42u2Xu4qDQBiFz6h5lRTWgZRaWdpokcYqYBnwAaysRbAMWNlYaGGbzlLwCXwVLxMNuCyDu6whjlt4Kn/ncj7mDOhP6KC2bRGGIaIoQl3XGOs1JEkSjscjrtcrbrfbqyZN01Bd11EUBWzbxvl8xuFwWAVg8EJZlrjf71BVFXmeg/i+T13XfQGcTqdVjFlVVQVFUeB5Hogsy1TTNARBwMV8kuM4eDweIEMONI5jXC4XrgBJksCyLJDhmaZpCsMwuAJkWQbTNHeAHeAfAvR9D1EUf13cdd1bpoIgLAN414gbAHtS3+fPjX0UYJwzZzi+Y9dP9fDhXQYwJ3bTOUgWjnsE3ADmYKYIVgdYcgem8Y/cAdZkLoKf4vnTCfDSDrAD7ABfAJv/lm/emGzemm3enG7dnj8BzVqGTrFYhBgAAAAASUVORK5CYII=",
	exactValue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgElEQVR42p2T2w2AIAxFbyeDgVzACVzAgcpkyEOMYGza8kFoCKf3QCAAGX2QZV2msxQbwTiYOYcYH9ogqkELgFSAeuhdrwl0XUNo65QSzAoC4F/hE1tIoOtqVVACZgUxtkZB7KpRcAC6QiHsbZP58CSoEfINgEth3JwDML2C61tfAfWYBg2hAqkAAAAASUVORK5CYII=",
	exp10: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQ0lEQVR42mNkoBAwjhoAN+A/Ev8/Ek3QImQNDGiaCdEoBmBzEVEGobuAAYsBeA0mJgwY8RhMMBb+E1JDcwMIgmFgAABCAB4N7Oxl4AAAAABJRU5ErkJggg==",
	exp2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARklEQVR42mNkoBAwjhoAN+A/Ev8/Eo1LHVwMWQMDmmZsNAOaOrw24TIIrwsYsBiAzWCSwgDd6RguwAf+E1JDcwMIgmFgAABJFxkREs6UWAAAAABJRU5ErkJggg==",
	expandFolder: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOUlEQVR42mNkQID/DKQDRkYkzYxkGPCfLgbglRumBhATnYz4DBh4Lww+A/AB6hkAM4RUwEiOrSgAAKjkJQQcORDoAAAAAElFTkSuQmCC",
	eye: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAvVJREFUeJyNk09oXFUYxX/3zXszGTKpCZ0kxBnapklBElsMTVtrUFQUI25SCMZiNy6kbsSNG6VYtQhZKFKsGykipVBBJEGpJKaCpkpqm0KtCa2tk0qYSWpnSDJO5s977977uWhsUxfi2X7n/PgW5ygRYb1e+OrSjkQ08o6nVK+rSGtrKPk6Ww70dCnQh8+82Hd5vV+tB7w8NjPiOWpg+maR+VKVwNy+eY6iJe7SXu9R1WZ04sCj++4BZFYqdUcv/nE9s1xJTy2s8F9qr3dpdMn21Mu29wefqDkAw+fmTv2fMMCNsiZfM+nJJX0KQL06MbtLWzn/+dVFADZtiNOXaqI7maArmcBYYcUPGZsr8OW1m3dAHVGDsXZ35IGhg59dzpc6jAiH+zo53r+dZ7cmKeQLnPjhAh+eniThCEee6WWgs5nzi0UK1RAtoKzZ4jTFIl3zpSrHnurmlYc2YUUYn5ljJpenpz1Na3OS8avzvPf1JG0NcT7t76LNE8pW4Rjd5RgrqcAIz3U0I4AVODpxDtfzOH1smOyJD9jc1srZzAJWoD4W4+297ZgwRBuTcrU1ABR9TSIawYowm8uTD4TstQzxuhiNDQkqlTJWBCvCzi33Yxe/Rbe04PihyXmO4o3J37By+4Pn9zxIpebT89oRHn59mJXSKo91ptcAcPKnS0ilRGhsLpIeeKk/tNIxtVDkm19+Z2uDx4FHdrCwVORKLk/Nr7F3cysHH99Jsepz/PtpPhqfwm3cCLH4z2rwi6leX9sLP96qACB+lTZ/mT2pJlJNGxABK0J2+S++m82wGhqcplbidTFCbXYpEeHpk2dHlnwzcKOs7zYmDJBKCQmDu733oqiGRtygig380cKhoX0uwJPJ6P4zf1avp2MqnfXXtuFFUfdtRP2riW5tFetXs8Hi/P47W/hHuz+ZGBFrB25pRdkq7FpcieCaAKdWJrQyWjg0dO+Y1qv747HtWPOuGNNrjE5rYwks2VBkWot6q/Dm4K/r/X8Dq3ySEVvXjw0AAAAASUVORK5CYII=",
	eyeMinusIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgdJREFUeNrEU89rE1EQns3a/EDq2lgE0QQ2LQRJSA9NIIVFtOg2ggheQg+heDEnD976H+Qf6EEkILTklEMEL8bAipDASsBL7HqSBEMhRNBDShKzdPP8Zk1EevGQgwMf772d+b5582ZWEkLQIuahBW1hAQnmbmalXAJuAzoQAYKzuB9AG6gB74HBnDcXkCDw0OfzPdF1fT2Xy121LOtio9HwslPTNDsWiw1LpdK3Wq32ZTKZFMF7zXm5BD/wLJVK7dfrda1SqUQdx1kJhULe4XBEDJC8/I19HMOxzHG5sixnkPVdv9+fjEYjwTAMQ7AViy+Fpt0Ruv5A4FZi7udY5jD3AlR20+l0ENf32rbt1lUoFJDZoYOD5+55bS1OJyefae7nWOYg0S4LHDabzZXBYBD1wzhAVVUyDJO2tu65BL/fR0tL6h+BnzBwvjJX9ng8vU6nMzVN00kmk6uKoiyjXrKsTxSJbJCiBJHdou3tW65wu93u5fP5N3iLV9wVtwUQ4W6kA4HATiaTiWez2Xi3273WarWW2Z9IJE7D4XCvXC4fV6vVY3U8fntTiA+PplPBAjJwGbgCkSDErmMN46zMOkRPHWcnKsQq6rUZaJ0D0hnWJr8BT9AY+I6HP8X1u9ibf0/bOtH9x3t7N85P4eHRkSP9a1Tv/h7NF2dEm+d9yP5R+u9/4y8BBgAeV+c/GRjpjAAAAABJRU5ErkJggg==",
	eyePlusIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAkVJREFUeNqkU89rE1EQns1udhOCrk2KlxIhaaGHFPfQBFJYxFbc+gtvkQq5+uPoQfAPEHJQemnFIAFFzCFYycGLGEgVElgMRhG7OTRiKiaVKCkYSTTbbF5nYuJBDxYy8LFv3sw384b5lmOMwShmgxFt5AIcWv8wGOUg4jhCQ/gR7kHeDuIjIoN4iWgOecMCHBY4L0nSJU3TpqLR6GHDMFz5fF6koKqqZiAQaCWTya+ZTOZDp9NJIO8p9aURHIhroVDoRi6XU9Pp9LRlWWNer1dstdpAQJJIdxSjHMolTp/L8/wp7Lper9c77XabEbLZLCNLJO4zVZ1nmnaO4avYME65xCGugFWWwuGwG58vmqbZnysWi2FnC1ZX431/cnIGqtUSDOOUSxxstEQFHhYKhbFmszntQKMEn88H2awOc3Mn+wSHQwK73fenwC805HwiLm+z2b5UKpWerutWMBgcl2X5AM4LhvEe/H4FZNmN3Q1YWDgG8e4juLm5vLvyPP7ZePD2Dm2Fx1EtPGzUarXtVCr1vVwuNxRF4Z1Ou1gqvRIbjS1QlMAPj8ezdbt6Vzhz+qwrV9W/Iedq77qrSzvkEYcQHlyNG180gd8j6MuDDYF12bnIpvhxEDgzcjHiX3uyZgDPdVGGBW6gRkp0Imjv3D9yW5GfzUdOHP37+kV6/Q33X60uSqhL6R4wmCV35oIyu/H4XfG3DKEo7EvwDK5AF6W+y17vWKjqnz0AOxfEkUDY919TxxV2WXH71iYgsUhkmJBgT4ABAOtC+bduhTyuAAAAAElFTkSuQmCC",
	file: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAXhJREFUOI2dk71q1UEQR89vZiMWShJDKhWujS9goWKVRh/Dx0jro6T3KbSwuSBYRUzjB15CQItoBO9+jMVu/lyiIXin2Z3dncMZdlesxNHHw+A/I11c2Lo1o7ZGbUFtgZlIydhwI7mTkuEmJPH50/u/AW4CjKARQGtBrYF6hgTCMLvEwK0fdQQBCGptAL24jkJ1gg5fP3pO08FF0M3ZPte2n1JGK0GQ3EhubKTezvHiiETjxY3NO+zefoBwkHPydc7Z4oDrO8/wASwtqLUhhNTbAUi1ttnm9i4tf0NKIGdr5y6n319xMt8DXXELJRdMv2jlN5KDEibn3v3HIO/QYXa+D33+4d1LUl5mov4ARGAgmw5MRaQVQM8lJ+dMyrkMmQAqRAUyEeer1q9igvlklpdlFXBZtEGqE7TbipIzqSzzFYB/RQBBzsNg/uYtkmEmzAyZMI3RDEloPF9bmY8WMk/2Hq5hAYsvx6RosbZByaX/hZ+nZ2sZAPwBqhiaxc42syQAAAAASUVORK5CYII=",
	find: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAjFJREFUeNqUkk2IUlEUx//6dPxOtHhp0ZCjpEgRFD4opSD6EHdCq5mdweBrM21atGsztG71ZBChRWHUSssksha10ZhIhEQaUfAjSZB0VNQ+7N7XOEyOE9MfzrvnnXPv755775GMx2NMFIlErpNhmdjZrdA6sbVAIPAUe0hCAaFQyE78FYvFwtvtdhiNRjHZarVQKBRQKpUE8rsaDAZr0wAZ/YxGoxW32807HA50Oh00Gg0xqdPp4PF4oNfr+UwmQ0M3pwGMRqNZtNls91wuFyqVirjrYDDAcDhEt9sVfZJHtVp1JZPJz2Sj3E6AlEzknU4n2u02rQQMw0Aul4tGfQrq9XrgOI76/K4jkB04lmXRbDahUChmXhQFGAwGWs2pWYA/jkwGqVQ6E0AroTkyl5kFyNRqNY/JZMIENi21Wo16vU7zH6dzUhIUUqmUOEmpVIrH2GkqlQpzc3OIxWIUIOwChMPhR+l0WkgkEtBqtSCvsr2Y+tTi8Tjy+fxX8lIP9+qD1Wg0imw2y/t8PlitVjFZLBZBweVyuSmRSL44zxvZW/evjgej/oXQ7XdvtztxIr/f7yUDfSpuK0S7R/B6vS++HXgN06F5HDt4Gk9erqE/6F56cPfDm78A/9LinZPj4wtHYGbnccLsxuPnArr9zmUp9qnNzua5T7kNFEo5vN94Bv+1G/j5/derfVdAdSXAcqQf0uYFI0yHj6JVGeK/AFQXl/RnyIWuyxUMRoMfS78FGAD3+u24CjYfQAAAAABJRU5ErkJggg==",
	firstAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZklEQVR42u3OQQ7AIAgEwOVl+nR4mS0kNqYlCJ674aSyDg3gHoBs8mHmuWcN46Sg904UCeYvGn1cFuwKXMG6tCYt0IvWmj0SERwJvIK3pixYz2ZBSeAV/IJAgE1CQTYfgTBX9h/JBTbMswmbgKoPAAAAAElFTkSuQmCC",
	firstAxisTitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAV0lEQVR42mNkoBAwUmzAfwaG/1CTMAw7cODAfxjbwcGBEZsc9Q1A1oQMSDLA3t4erOjgwYPUMwDdNSQbgCw2agCaAfgSDy6AHKWU5wVsgvhcgZ6gKDYAAIvMjIdmoEiUAAAAAElFTkSuQmCC",
	floor: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOElEQVR42mNkoBAwjhoAN+A/uYYyQjUjG0QVA/4jyTPg46MrJlojPheQbQCxLvmPbgBFYNQABgYAWmAVEXFss5sAAAAASUVORK5CYII=",
	fontSizeStyle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABo0lEQVR42r3TvauBURwH8O8pYlNWZhaDQREGGWSkzJSXhUESBgYyWKQsykuKAQMpJZv8C5RBoZQiAymTt999HrfuTYZ7b/d2z3Q6ffuc5/t7Ogy/XOzPgcViQZPJBHa7/Vv4S8jv91OhUMBoNILJZPoSeQkolUpaLpfw+XzgoJ8BjUaDQqEQXC4X6vU6ttvtzwCLxUJCoRD9fp8JBAJqtVpwOBxPmfV6TXK5nL0Aq9WKFAoFyuUynE4nMxqNJJVK0ev1HpnpdEqRSAS32w2XywW5XA5qtZp9APl8nlKpFPb7/eOsVCpRMBjEfD6HTCZjzWaTuNvBISwQCBBXD51O5xMwm800HA7BfR6u1yvu9zt2ux2q1Srcbvcjl81m6XA4YDweQywWo91ufwJ852Qyyf8FnM9niEQiZDIZSCQScDCz2WzE72u1GkskEsRVQrfbfQfC4TAVi0WcTqengVUqFfJ6vZjNZvB4PNBoNLBarYhGo3wtDAaDd0Cr1ZJOp+Pn8ARsNhsyGAyIxWLQ6/VIp9PgB6tSqXA8HhGPx9nfv4V/B94A9QizEV+4wUYAAAAASUVORK5CYII=",
	format: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42mNkoBAwUsOA/zCD/kPYIA6cz4iw5D8Wi/8Ta8B/Buyu/Y9TEovtOA3ACog0gIE2BqBpppoBWPUQCjzSXTCwBiBrRktUdDKAHECxAQB26DIOz80UywAAAABJRU5ErkJggg==",
	fullScreen: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABeSURBVDhPtYxBCgAgCAT9/6v8mSkUWK1lRQN7KJyhHCLx0iBZx8yyWy0oTwEg2/qjCCC27QNA8v/rgJfaPPqOA6Noo/keB7BsJAKxbFwEeg4DM4nAmn+B01X9NUBUANHihzxFW9B2AAAAAElFTkSuQmCC",
	funnel: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB7klEQVR42mNkoBAwwhgb5gpFASk/IFaBCgkBsSKU/QiIX0PZd4B4U0Dyu2VwA5ZNEdwtLsrkIinOxMDLzQRWxcHOwMDFCTH/2/f/DD9+QnR//vqP4fnLfwwvX//bE5Xz3hWsYvEkgf8/gQp0NVkYRIUhBvByM6IY8PnrfzD79dt/DJev/2FgZWVgiC/4wAhzwX8mZgaGW3f/gBWD2D9/ImwFGSQkwMTw799/BhEhJgYDbVaGuw/+MgBdADFg4QSBaawsjJkfPv9jYGZiAHuDh4cR7AopcWawJpCXQAaCvHDj9h+Gl2/+TQe6IAseiDM7+XuBhhRB/M+I1QCQ646e/g3U/HdievnHApRYAIEpLfx1QL818vMxwcMAZgDI+TsO/GT4+Ol/d07NxzKMaISBnjq+IqA3ehVlWYD+ZmQQF2UGB9juQz9BAVlT0vSpFWs6QAat5bzhQGqFvSU7g7gIE8P67T8Yfv/5n1Xd+Xk6zoSEDmoLeP77u3OAQ3/+ym8MzRO+YFWL04DSTJ7/4X4cYP9PXfCNoXs6iQbkJXH/jwvlBBvQN/Mrw6R5X0kzIDOO639aNDcDKwsDw9SFX19MX/RNkiQDEsO5LsUEcepu3v2D4ePn//XAcGgiyQCg5kx2dsZpwCSdtWTd9+m41AEAxqy3EaxL75cAAAAASUVORK5CYII=",
	funnelCross: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACAklEQVR42mP8z8Dwn5GBAYhIB2C9/8E0A8PGuULRQMoPiFWg8kJArAhlPwLi11D2HSDe5J/8bimIwwgzCURfPyDKwMvNBFbFwc7AwMUJcdi37/8ZfvyE6P789R+DpgPELJDLwSoWTxL4H5P3ASx4/7gYmOblZkQx4PNXsB0MipavwPSiCQIM8QUfIAYsmyL4n4mZgSE88z1YsjqPh+HnT4StIIOEBJgYKto/gfmntogw3H3wlyEq5z3EgIUTBKaxsjBmfvj8jyGz8iNY0eYFQmBXSIkzM4gIMTEI6bwAiz88KcZw4/Yfhpdv/k0HuiALHvozO/l7gYYUgdiJxRDvHFgtDDZAzQ7i7DeXxBmOnv4N1Px3Ynr5xwJ4IMLAlBb+OlZWhkZ+Pia4d2AApHnHgZ8MHz/9786p+VgGE8eI/546viJmJoZeRVkWBmBUwQN296GfoICsKWn61IqsHmsCai3nDa/q/LwCWaytnDeruvPzdHS1WA2ApYuz20XAoQ+LOmwplhGX5rJMHoZwPw5wDExd8I2ha/oXrIYwYtMMUpSXxP0/LpQTbEDfzK8Mk+Z9ZUSWxzAAXTIzjut/WjQ3AysLA8PUhV9fTF/0TRKbOkZsguC0EM51KSaIU3fz7h8MHz//r5+/8lsTNsuwOgsEgJoz2dkZpwGTdNaSdd8xQh+mDwBKqMUL3B5gSQAAAABJRU5ErkJggg==",
	general: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACLElEQVR42qWT0WtSURzHvydTYTa9Iuium1aLVq21O6+yVVtB0V5iUAQVCFEPo7da9K8UvUdEW26MiGlPtb05mTW2wunDdJF6t9qupKbX6T0d79NEC1qHA4cD5/v58ft+z49QgO39L1IHEHbuR6xp9wIURaE7OzJ4voMsRT9SaXMLlYqCG9evEUnapEajEVYrR1oCCsUiXVyMQJIkOJ1OJJMp9AsClpc/oZPd05lsXYyR4fNw2O2kCZBOp+mbt3PwDHiwW92FxWLG960fMJvboVIVtVoN6+tJnDrZA5/XS1q2MBcMUUoOsAoO5GSZiVT2SIWV41BWFCQSa7g/Pt66hfcf5mk8kYDoEVEqlbH6eRV6/UFUlArc7sPoPtaNhYV5nOnrw4DQD47jSAPg+YuXVBRF5At5lBng68YG7t29Q4Khd7TMIDzPw2g0YHtbhpO343RvbyPgydNntFqr4uzQOdYz1czziR58icXQ4eDh7HQiHA6DqirGxq7C1dVFmjx4HZim7WYOR4+4kf6Wxq9SCQa9QRMXCkVEImFMPHxA6nGzSBsBmUyWzszOwiv6NHtsNpvmvE6ng5zLsQpE8+XCyDBO9BxvTiGbzdLJqQDaTCbk8z8hsxT8fj9CwRAU9pnaTIfAesPlSxchCELrGFdWVmhsLY7bt26SV5NT1GyxIh6P4fGjCRKYnqGcxYLR0Svkj19570qmUjS6FIXL7cLQ4GDLWfkr4J+G6X/G+TfnJiAAMYYfXgAAAABJRU5ErkJggg==",
	general1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAU0lEQVR42mP8z8AAROQDRpABjECaHM1gvTQz4MCBAyhec3BwYKStAega0AFRBtjb28MlDx48SF0DsLmIJAPQ5UYNwGEAAwkAwwBSNGOkA3I0wwAAZwGL8Tu4vJsAAAAASUVORK5CYII=",
	generalH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaUlEQVR42rWSUQoAIQhE9WTO0fVk7hJsGsRSSUMf/cxzBmUqip3Ij83vawBu/z19vg5Q1eUkAHgKEJGUL4XyYJvZRUC5AiCzoUMaU70IqG8BiKHpvnKa/y1UAaUKq+aeKgN2zVFzOLczPepcfBGjCFiyAAAAAElFTkSuQmCC",
	generalS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAa0lEQVR42rWRCwrAIAxD7c169N7MqaC4rZ9YMAhCNeGRUi2lnbyoB1C7M+bhnQEiMkiY+RfW37T5K+D70TLtc5jAInEJEKJ7HSBdQARRkcdbcEvcCTzssINolVAAIrUDbRPWrRKcagVkzFMP3pSz8SclsIYAAAAASUVORK5CYII=",
	genome: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeElEQVR42rVRQQ7AIAiD/z+6ZmZIBfWAmzFGqpa2qlwOhQj6pk8fOzyeMcEgfe6ACsbFlgWBegPZ4knBdQau1si4jmdTEogEpHSyzEkQiJICOBti+OUMks6jBw7hIwUYaejLe669PyJBNrCqzRrqCsDvfv+FtQnCG6oQSgOzCH4DAAAAAElFTkSuQmCC",
	gradientDiagonal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAvElEQVR42p2OrRICMQyEe73+wXOhsFjsWSwWi8VisWgkiueCJpMyO5n2bnpiJ7ub5psOxnx3xpiQtenQNivR3ZABewAk9XApewIcBJDgQWpk7RlwJKOOimKjL2LABIAIR3MzIuAkgLhCjgBnAQQpW7PWMeBCRkp8UJPeMeAKAA/LlsfMgJsAPCy8Umj4kQB3AbjKYa3DngEPMmrhZjx2DHgKwHVoRMArG4tlx2TAu4QVsgT4wA/+i4VcOvsD4g0dlXTiNAIAAAAASUVORK5CYII=",
	gradientHorizontal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIklEQVR42mNkYPivyMDAwI+E+QjwUcQYRw0YNWDUgOFiAADKFh/xdBCOQQAAAABJRU5ErkJggg==",
	gradientOrientation: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY0lEQVR42mNkYPgfw8DAwI+E+RBsRm8GAoCRLgYcOHDgv4ODAyNZBoA0o2tCNoxkF6C7huQwoMgAZO/ADMEaMPgAFhdQBog0AOxNigzIptSAKkoN6KTUgOmUGrCMUgO24pIBAO9ENMZmhtGfAAAAAElFTkSuQmCC",
	gradientRadial: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAl0lEQVR42q2TsQ6DIBRFH4lF+WsHp05unTo5+YUgNalgn83N1e1pcsJbzokoOJHvLCIZWGBe5fc0Ba+0MHtXAhNIvH408CD5v9bAW4UrMNBeUQOvMiQVEsiJAh2Ix9zVwAgCwwFmf4MnSRHmrAEPUsBIDQwgRghECgQIHOyBnmSEAyduCZi3YP6I5t9oPkjmo2y+TKbrvAHE8Ik9k/2dRQAAAABJRU5ErkJggg==",
	gradientToggle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdUlEQVR42mNkYPj/nwEnYGRkIAAY6WLAgQMH/js4ODCSZQBIM7oosmEkuwDdNSSHAUUGIHsHZgjBUCbCBZQBIg34HwAkfkE5bEDMCcQcIJpYA7ywGMBJVwMo9kIkmgEcpBqQCCR+QzmsSAZwEGtAFhYD2EEYANRJOxMTsUqnAAAAAElFTkSuQmCC",
	gradientType: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeUlEQVR42mNkYPgfw8DAwI+E+RBsRm8GAoCRLgYcOHDgv4ODAyNZBoA0o2tCNoxkF6C7huQwoMgAZO/ADMEaMPgAFhdQBog04H8mkPgBxL+hAqxAzAHCxBqQCDXgF1SAjVQDIoHEdzQDOEkxIBiHAZx0M4BiL+AMRAAy50HHRG0GngAAAABJRU5ErkJggg==",
	gradientVertical: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVR42mNkYPivyEABYAQaYECpAfaUGuBHqQExlBqQTakBVZQa0EmpAdMpNWAZpQZspdSAI5QacJlSAx5SasAHSg34T4kBAK30GQIan/m2AAAAAElFTkSuQmCC",
	graphOrientation: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90KBhI6B6nA3ugAAACaSURBVDjLtZNRDoQgEENfjfeSow8nqx+KITpBdjfbhGQ+oLSlyGCBIgLAAKUUMYkVICLMl1jasG3baJ+HCu5oik4rTkj0UNCjqfGxdM5yd3BI8LgGpLcMJkhQYuciqLWSzX2KnYWLVx4krJtn8wxBLwXwJxazk65HQ1OUUrTOtC0rWa2ViGCKIAu1CV34F85nc0S4x/3j/WqBHcw6SJbtGdSxAAAAAElFTkSuQmCC",
	graphOrientationHorizontal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90KBhI6DtAcZkwAAABpSURBVDjLzZI7DsAgDEOdinvB0Z2TuUs/QagfYGi9BAYHPwsTKgmA9UzTaRxS2g9OvjaVUiwuOF7POT+a3b26LxsLZhC6+RlwU2i1iXcjRQTNIEx38H0CCJAAkdSVSOq/HYz+g7aD0QQrWJJFRWqNZSEAAAAASUVORK5CYII=",
	graphOrientationVertical: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90KBhI6FsNw/hoAAABuSURBVDjLzVM5DsAwCLOj/is8HV5GF4SiKANJhtYLEojDYOiAAwABIqCqQPhHiAhnX8OQeIK26rSDJyZwVfXTApnYe8+AmZUp8JZCefSZpogwd1ApsKJ4fYXvdfAjJVbEs4oz2vsNhfjm3MWWfQEXtyLyxFk7CQAAAABJRU5ErkJggg==",
	graphType: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAn0lEQVR42qWTaxKFIAiFOSvTpcPKKOJKaTe0iX4405zz8VIws9ZaQRGqfiL+3TVn4BtANQC76zCClDKA6WCyIxHwCtDMJ+TSwg2gPz9cU2qla+YGWQZ4C26OCZhqHVC6trotUBIGzzSgj4HHHev+wROkFYwr+idqWxBmKqWQiJDNhFmebiIwVjAFzCp4MYN+11HBkLlVhOylLQMy8+webGQ5ygXpKrTcAAAAAElFTkSuQmCC",
	greenCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQuBLjdbhkAAAIWSURBVDjLhZO9T5NRFIefc+59+wGIrZiyK3nRzaEY02BcmHSQSEyUyODk4NY/pIkhxBA30+AgUgybYTBOxjgYxsbY8uGAkIAIRmh7r8PblhYwnuQkN+fe89zz++Veebu0tFNvNFLeOTyd4QFBRRCRrXvj4xnOijelkv9fbG5u+vmFhbmz+tX76N5KdZVKdY3q6hqV6hqV6ioAxbk5MpkMo7ncw/lS6dVpQHNhrSEIjtNaA4CosrW9zeDgIDdzuQcLi4vznQBLU7mqRVXaG85F9XBoiHfLy3jneDQ5ifd+ohvgWxMoIscAYzwHvw8YyWYZyWbbdTlhtW1rUdMGqIBVJWjUOfy1y5+6A+B8+gLnLGcDWppVIGaUZNwQTqcAKD/dAQ9hIUBOALRzAqOGRBCQTMYJp1NcvGuiEzaAIACFgTuG4RnrTwGsUZJxS7wnRvisj4HbyuG6BweIROngcN2THlOGn0eQNiCwhiBmCQs9pMeU2jbsrzjK+aMI4jzlfI39FUftB6RGlSsvrO8yEYl88EedaAE1XbrFgq+3JDSdN8YAQjlfY/eDQxT6rythIYgAaggLAf03FLHw86NjY6YxparafnEQwcr5GnufHJqgy3WxoDHY++z4PtuY2v/ii/KyWHzf29t7y3kP3qMiJKyQjiuPv07gHcxeeg3Ak2/30QRszETNTYFcBlInP0nfNbnKP6LVDPAXG4PRfNQ1H3kAAAAASUVORK5CYII=",
	grid: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAV0lEQVR42mNkoBAwgoj/YESWZka4AYxQw7Dx8amhngHozjt44AAK397BgTQvYDMArwvQNaADogywt7dHeOHgQdK8QMgAXC4i3gVocqMG4DCAFIBiACUAACUIcxEomAXNAAAAAElFTkSuQmCC",
	gridS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAKUlEQVR42mNkoBAwUs2A/2BEsmZGFAMY0Qwkhk9dA0a9MOqFgfcCuQAActNKEaLwWqoAAAAASUVORK5CYII=",
	groupSamples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAe0lEQVR42mP08/ObxsDAkAnE0zdt2pTFQARA1sPo4ODwf/LkyQy5ubkMBw4cYCTGAGQ9jLq6umDTlJSUrm7cuFGHGANgesAuQJb4D0YMDIxgRBwgyQBs8oPcAEL8UQOoZQA5mckzyPoK6x9hbQaqZiaQaZcvXybKBch6AN9MZ8kuIDQPAAAAAElFTkSuQmCC",
	groups: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdElEQVR42sWT0Q3AIAhEjxnq/hPSGTTSatBQpdqkfAH6LghC2DTSQQQOB3CWe9knA+YBH9SdUAVumB1QkxeBCfwkILA8I0oBUxidyL8CTc4jMOrPqwrYOludQu3DZwLA6kfKXrcDnmquBupdMIRMK/NX8Z4l0MwyMzDpAGsAAAAASUVORK5CYII=",
	handle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAUElEQVR42u3SwQnAMAwDQGlZeyZ7J8/k1KEpJCHQT38VGH3uJxN3RCSxxN1ZzQHMbDVQ1Q55ApWIKIQJkURmPv2jr9FxljHwdRsq0Ad+8yoNvcu0XQDURfEAAAAASUVORK5CYII=",
	hash: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVR42mNkoBAw0tKA/2jy/7GpH3wG/CfV27hcQJTtw9QAqgQi0bYPXgNIAhQbAAADoxYRtMnqwwAAAABJRU5ErkJggg==",
	hatchForward: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAI0lEQVR42mNkYGAwA+JTDEiAEUqjSDAiKYBLIAvCJdAFwRIA8zoEPFWA5lIAAAAASUVORK5CYII=",
	hatchReverse: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVR42mNkwARmjOgCQHyKEV0AxGBEF4AJogiAAACw8gQ8ix85NQAAAABJRU5ErkJggg==",
	heatmap: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAYUlEQVR42q2QQQ4AIQgD4WX06fCy3XBYJe5BY+FiGsLYVoUcrcLdnytAHgLQfM1sLCNCDJjaXdZ9D6BGoAF0B4AVYMjOUQ+gRqABdAfrDztHPYAagQZcdcDMD/C5yE5O9AtM259EnSM6xAAAAABJRU5ErkJggg==",
	heatmapHighlight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAjElEQVR42q2SQRKAIAhFYd9tag9Hh33dpr1pjUXWpEVsHAZ8fj4iOANtIiLhEyBdZGZMJxHtRVUFYj5yESjr/wDsCG6AzaljKENnOXsQRlgv4QC4jXK8EEa8AGAwsKioDdDHlgkdgCcFbg8uayxct4pEtOEffAHYEdwAeBlYa8hbypuqArKK5MkdoKwvKfGeRBaxMNAAAAAASUVORK5CYII=",
	heatmapSeparate: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAc0lEQVR42t2SUQqAMAxDt5M1R29PpsuwWqeCrH6ZHwmkwTxWS1I1GlVdoheRYmaPfi/gIYDKL0MUg34gQDHVw4fMNwXpCa6laQpinJCGCMg2x06bRyadQePyRwZxnx+Qy8ikZ+7eQbogBXFGlwL/CzJ541fgdr6+KO9gOAAAAABJRU5ErkJggg==",
	heightSpace: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARklEQVR42mNkoBAwDogB/8FoUBtw4MCB/w4ODoy4+HgNACkG0egGIIvhNACmEB8AGUI7F5AVBjAOIwkxMtwMIFYTLkCxAQDaH0P5mgJrvgAAAABJRU5ErkJggg==",
	help: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAmBJREFUeJx9k09IVGEUxc/33pvJMZ2mxiCY2WolFANjQtDCKIIIQcOVtBDatTJo5aIyENoUroKEtrr0rXLTnxFbhIwyGg3+KZiccRQsnfHNjPNm3r23hfScl9HZfd/9nXsuF64SETTq4teBy37lG9VF69KhRYkJNtdyNteTNteeZOMzy428amwQSw9O60rr27C3sUcWCAQA0KGhBQGEJYg6O+ZG90y/p8Gj3HjTrLW4/tMpRDO1PP6nMLUiQP5cpHym/fPNqaoBAO/256eKVHLNfaEexJo7EAucR6aWh1lIIGEtAAB+6RZC3Bz93rQ9BaBfdaXvXWHI/GJlxU2RePJY8vjWJB7mX7rvtnILmLlbq3JtbMPe9sBP8xOIJQYQensV5tYHAMBQWy9QcFym5K+irmhMC6gTnXtkeRqMbk1gyfmGYshGitcBAIW6BZTIZWyDoOrSaYhI5M+2PTptYCjci+Fzg4dTrbwCtKOyKAETRwzif5gBfOx4jZ7WOFLlVQwvPcfsThII6h6GhKE5TJt6Y+u/ZGbfY3ZvAQj7gKDh/isBiGnTKHEl3YJApIiyxzicfYFQKYBMMQc0a0DAG6KqABmc1nysj4QleCw51TmJRPcbDF24C5zUj9U1i8B1GtFW42ayzo4ZplYPkLAWkNhNIrOTBXYdr3mfQWCT7ywnlYjgxtz9pjUjt15SB9GCr3JEFhygLoBPASHDNUuFcvLjoF0erFU9x3T20/VpsPSV/FXYBkGUuAtT1cOxCWzy7SXvMTXq1Ny1SyB5JiRd4nCUhEGgHClOspLHfCv1pZH/DQCsPJc3oUS/AAAAAElFTkSuQmCC",
	help1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAopJREFUeNp0k19IU1Ecx3/nur9KluafkKVLA4WQUbaI6MkejLAIqgchsH8vKSbMiBUY0kNImBlaFhgUBD1ED5Eklr301F/dFGEiOp06mzp1c/fPzr13p3NuOra5fvC5v8vv/r7f87uHcxAhBAbHw7AVT17/yqHpMqWKcpDCUVyb9DVePLwCCYESDbpf/WgzGXUtleUF+sK8rIz83Vkcoj3Lq4K6HBRUtycgi5Lc1VR/pDXJYGAsBN0vv3VYLbsaqo/vNwU2VLQuqBAWVSC0KducATspRdk68vX7tDTpDT5runTUETeoaf7YWlaSe9tuLzO7fALIKoGfM9OJk4LdWgo6Oo+tOBPcLq84MbXy8MaVY62ouuF9kcmonzh10pblXpCoIcCwzwu/204kGVS1fYFDxfu0d5vFTD4PjfIRPlrOqbJytbJij8E1J6AoVgHLqiaufz4ZhwWrsW+MkVkeVZQVGJhWp8hKjWow6yIRJb5aXY8H0gUTa5k9sjOZ9rROwUpFUAIOYzWt6J3jgJbPdY4n1QORDI5qS6mLLC+vSYQghFLF/U6blmvb3dunwQpQLbAxpkReKEAGE4L/RDTNdATjGNXOs18YVNbW7SQn35DaZG3u13LJjsJtBigUUqh2iKMuL9bm/TgalcnWLm8x87hWI7XOxl/1zWGq7eM8nxr9Qpjvinino6mNibufSNjrlcQw/9TRcsajncTeAR88uP+2U5+bd92412pEHJd+P2IxkBZ8kryy1HvrzgXtKHP/6gRuOs87pKVAx8boMC/4FzDmxZiixIAhC2JMXPTj8JiLl/4sPmK9TMPQJujpn4kv0n7vjYWma5SzlNLN8izlA7vOzrt1SZfkrwADADHTjb87FtdzAAAAAElFTkSuQmCC",
	hideSelected: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcUlEQVR42rWQ3Q3AIAiEYTRHYhJGYjT6a4NUEy5p70VB7wsc0yWnUUxFHR994S5BKoDnWVVJRBgFnDIzb629+ugKPgNUQvQJjMtBhfF7TXtdB0RINEOAlSDAPQXDgG7MJ5xBv0MZZGOu/5/gswwiKPY2EsdSEZXS9kkAAAAASUVORK5CYII=",
	highlightSampleLabels1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbklEQVR42sWSUQ7AMASG52QcnZO1s+xB0FaXLfNClT9fFRzGmLmpJyLI8tkd+CY9PxbIYm9lAvWIeBWJSE3Ax5mAp9kmsLkgUCGYCvxD4AezTTDaxNEehF9YFa1sKGBpzqDdxWHo3wm89oTZANV3nUa0EcV8D7YAAAAASUVORK5CYII=",
	highlightSampleLabelsH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcElEQVR42r2RUQ6AIAhA5WRwM9fN4GRUmwZrVDhdfDEGz4dAmQyIisysacDZTETQh3qOiJt1uXfU2CJS1wGmVzgmtH1Kq5mBepyzEea6DrD+CkSXARTjeZv3K2QBkdbQCtnGYcB9pSj/x+ApPg2ygB0TwY6HFKPU9gAAAABJRU5ErkJggg==",
	highlightVariableLabelsH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR42rWR0Q2AMAhE28m4zRo3g8nQGBGSVtNG5AfSXB53pZaPVUePzKzTABMDOGfrRLS5KuxRZ4tIywWkRgDcgUZccCPMLReQewXgdlCL86Kb9yvMAka2liLMCpcBMdox6CXuPv0/QFqEpzIHO/h1loekiAvfAAAAAElFTkSuQmCC",
	histogram: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAa0lEQVR42qWSSw7AIAhE4WTl6HiytmkyC8n4GctGE+H5RDwzb3sjItxK4AzBchyJI8AV8e1bJgesDJYAxYA9RzJgNpIBBVSD2nnZYHbrtoEEODUYzsEuAHupcRSAYqWIGvwG2GF004ffUNYHLMPhxoq1/LQAAAAASUVORK5CYII=",
	histogramStagger: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCQEIHumY2oYAAACPSURBVDjLtVNBEoQgDAsO/yJPjy+LB4VRt4vgzuZCYaBN0pIkGQBIJgCo+xNSDUgixPmRJBuwAR8xvJ+Hb5eg4hQyydRLsl7ZfcjJTwzKcXHdJfjuzVLNGwFZQJarhMrgrReNQSEb3RFIsiTnt5WrlCkP/jIHAwzcuudbH4fmoJe2wyCqFSP9MgNff+XMugHLQ24FNoCMXQAAAABJRU5ErkJggg==",
	hoverToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABK0lEQVR42u3W6QqDMAwA4NQT//sIvv8D6UP4RxAVdGaQkXWxlxcDA2NX23xNj00ta8CNoThAtyilPq/LsoR5nqFtW/Ax87Z8PC8APusDuSIOAeR5DsMwPIAHsBsgIYIBUuAxtSEPA9hmJqFOBURRJCbDdtM0QZIkdsBWuACqqoK6rt8QU1V+JnkkoGmar6RZlsE4jsZ+pwKKooC+7/0Aetnw68sB+uWBpeQAKbAdbkId0HUdxHEcDqAlwIFoJ0vJbSuJbR6A1ybEj/GB7y8DUEKO4LGV5FAABd1oVAleHZ/gfb0AhNgL4BWQclgB1G4948tegPjzbAIQAi8i3IRpml4P4KcgBIBj8v0UBNhaP9eZm/o6AUwltIX0R8ULwKvwlwBbPy9AaDgD7ogXvqXxsLZTSnwAAAAASUVORK5CYII=",
	"in": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAcRJREFUeNpi/P//P8PO8wu2nb6zy9NUxW27u2GCV8vqKAZsoCZ0GYZali2n5mw7eWObZ5ZPI8O0LfWev3//2fbz+w9PkIbmuHWMILp2UdB/EA1Uux1dLUPhVLf/91+c+r/1VCuYhvFBNMh1IIwshq6WxVTVbXvb/DxPSyMThpfvFzGk+FQx7L+4iOHLp09wp4PYIDGYHAhs2JvH4Ggcsp0RZMP8Ta3bdh5b5qlvoA7XdPHCTYYVHVfBXoio0P6PLuduFbU90a/ai8knS5Zh7Y4ZnlnR9UAXPIdjdBcgy4HUgvSA5BgdYgVB9H9sob5/0TuwCxzjhHDLN6+KZIAFFjmYiYFCwAIigAnnP46Ew0hIngWYaMAcUOJABsCEAmeD1OCSZwGmNoZ1h6du715R4uliag9X8PXLVxT2+bub4fw9pw8y2Oj6bQcbsHx377b9Z9d4FkR1MJy8sQYl6tCjEQZACWrCsgrPnz9+bGPauHeeZ1pQDcPGYxMZXrx7yrBz3z4w/ekDwgAQG1kOpBasB6iXycEoaHvDhAywDUcPnWYA8UE0uguQ5UBqQXpAfHBcTlxUtg2YoP6DaBAflLiwYWxqAQIMAAUBf8O6iYXaAAAAAElFTkSuQmCC",
	indicator: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATUlEQVR42mNkoBAwUsGA//9VVBgYVFUZGLDRYHDnDgPD7dtY6eFhAHVi4T+OWCEoTjUDKPYCVQz4j8NAXOI4DUD2NzobXYy6BgxMIAIASGlSCRR+hPkAAAAASUVORK5CYII=",
	indicatorCenter: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVklEQVR42mNkoBAwDj4D/oMRXg2MBA1gxOEybHJAzv//KioMDKqqDAwgetJkRobt2/7D+WBw5w4Dw+3bDAxeXgwMubkIPpAeHgZQHIhUjkZSwagBDAwALepQCVgJvXkAAAAASUVORK5CYII=",
	indicatorCenterRainbow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAKklEQVR42mNkoBAwUs2A/2DEACORTEYV+A/XyMg4asCoAcPRAHIBxQYAAOItPBEiAomCAAAAAElFTkSuQmCC",
	indicatorHistogram: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAk0lEQVR42q3SOw6AIBAE0JlTaWNj56kMp7KzoYFTrSKgUcEfUpCwCy9hgCgc/BEQcXPTAG0LdB1QVaFlLTAMwDgCWseDvASU2lpizDdA5hLJ94DWDBUPrDt88xlgjOwyYF2XA8uuLf00EEtHwGVApZ4BfS/JZ/wFiNfIAH6ZA9wzMoSIM4AQotz+RKaB4q/8bRQDEwJvgBGspLx3AAAAAElFTkSuQmCC",
	infoToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAHP0lEQVR42q1XCUxUVxQ9H8EFWRQRBlCwVlGjiEs7qEWLCloB0bqhxKQWNLGpIiYNbomNKy4Y11rjUptotGjTiGJFoVqUuOA6oLigaSyL7CgqAiLTe+/wx2Gcwdb0JZOZ+fPn/fPuPffccxW9YcHS4utv3rxBbW0tCgoKcOVKFjIzM5GTk4PHj/9GZWUF+K+dOrnAx8cHfn5+CAwMRECAFl26dEHbtm3RqlUrKIoiL/O9eSmNjY0Wn/769WtUVFTgxo2bSElJwdmz51BUVETXG+R3dWNToLzs7Gzh6emJUaNGIjw8HIMGDSSAnei6XTMQVgHQd7x8+VJOmZx8HKdPn6HTPgbf1r69PVxcOsLLy0teHTp0kP88ffqUwBVSlAopKlX0/xrY2CgSlbFjQxARMUGi4+joQNdtrAPgh/OpMzIycOTIUVy+nCVgNBo3+Pv7Y9iwofKu0WjQpk2bppM3wta2Ferq6lBSUoJbt27h4sVL0Ol09L0U9vb2lJIATJs2FUFBn8PV1VVAvANAfXhqaioOHTpMG+nQrl1bDB48GMHBwdBqP5W8Ojk5yQb5+QW4f/8e8aMOPXp8jJ49e0qIq6urhS9Xr15FWlo6rl27LhwaMMAfUVFRFJGx6NzZ1ZgOI4Dnz59TuE9j376fcPOmTm4KDh6NceO+kFO7uLhIHhkon3Tnzh+Rnp4unODN4+Li0KuXr9zT0NAgh+EonDqVSvf9gfLyMrpvAKKjowWEk5PjWwBMOEa8ZctWXLiQKaQZPz4cEyZEoG/fvnBwcDAirq+vF37Mnj0H2dm3JZTe3l2xfn0CQkNDJUJqjvlQd+7cwfHjx3HixEkCUS5VEhe3QCIqxCT26vlEmzdvweHDScRuG3lwZGQk+vf3I+K1l83MAURHx+D27Vz5rWvXLgIgLCysGQBeNTU1BDQbSUlHcOxYslTLjBmRWLhwIdzd3aHQhvozZ9KwdOkyyevIkUGYMyeGCDeMWOto3EwFwBsUFxdjx44fcP78BQk3A50371v06dNHyGle7xyJS5cuYc+evTh37k/h0tq1azBmTAgUIo0+Pn4Rnf4XeHh4YMGCWIkAo1OXuYhwFPLy8igSt4kD9fD19UW/fv0kWub3qiA4ysnJydi6dRuV7BOKwnRs2LAeSm5urn7ixEl48qSYcjgO8fHfyWacH/P16tUrFBYWSt1zJLhE+d3JyRnduvlIidna2lpUVeYZA05MTCRh+50Oq6GU/AZl//6f9fPnxwrRFi9ehOnTI+Hm5mZxk/z8fBw4cED0ob6+TsSJT8ep4rSNGDFC9rEm62VlZaQvRyj8CZSWF9i+fRuUmJjZ+oMHD6F794+wa9dOYqfWKDKmUsufHzx4QGRbj5MnT6Gq6ildb5RewOqYkLAWkydPMqqjpcVilZWVhblzv8GjR39h5swoKFptgF6ny8Hw4Z8RsXaQoPSwmEdeHP6jR48KkVhkWGCIIejYsaNUwZQpU+izdQB8kLy8h0TYeUTgTNIXPygajYe+uvo5pk6dghUrVkhNW1ucb1a67OwcIlGUVIMKYN26tbIHf25pcRqXL/+eUvGr9AbFzq6NvnXr1iQs0UTAeOlkLS0uOxaX0NBw6Y4qgISENaL37wPAFcBE3L17L/Go9sMAUOUQgDBKiQqgg9R1ZOS0fwGgCBs3JpIm7CNOEAB3dw89CwWHb+VKToH3BwJYLer531LQ/l0S+vr2tEpCFcDdu3epSYUaATDzGQCXcEsAmIQPHxpImJHRRELzMuTebS6nlgGESVWoANasWS0a3xIAi2X4rhBNJyHqbDUKBgD3miJgCmCV/Jc1wdrpWYiSkpIoWuvw4kWTEFmSYrZPlqRY9X737t0XAGw8VACrVq0QfWffwMv8AAYpzhECspAZpdhSM5o4cYLFZsTaz01Ip8uWiiktLZfrHL1Zs74iJfySTOggkWb+j6nbttqMuB2npaVhyRK1HX9Ouj5H/J/pRvzO5pRSRiqWQe31itgxXtyA2JKFhIxGbOx84lN3I/D3tuOWDIm/f38xlWoEWEY3bdpEDD5vlGHDT4qA0Go/wbJlS9G7d2/jw00NCUeAU8jVYjQkLVmyiIgIas1syRzFZpeWlkoP4DSoc4ABnCLAfXy8xe+xa+bV3JKlkCWroHIPlDRz0xNLpk5G5qbU1bVTkykdJ6aUv/N9VVVVcipzfvA7ly+XIbvm5qY0nSqgHAMHsin9usmUGqybos5l7HbZNKamniZbfkhsOY9WbMtDQt7acmdnZ7B0Wxq12Ck9e/ZMqiMr66o8+Pr162RkVFs+Qx6uzgbNAJiCsDaYDB06RKw1dVABxwOJQRsM82NJSXGzwaS4uFSmqSFDAkTqg4KC3h1MzCdTBsEiYRjNkiktaRZHM09PL2PvZ3PCoxkLk/loxkxnUrO2cLnyTKlGTABYG045nJWVlf/LcMrixGmztKwCMN3Y2njORGMM/ID3jefW1j+sgs5kfup9mwAAAABJRU5ErkJggg==",
	information: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAfpJREFUeJydk0trU0EUx/9n5ia9SbwI2lBsaUTsItbqTsGFIjbgVxBd+A1cdVNwXwi4cCGIrt121ZWYLqrdVAUfIGpbKUlqqolJSe773jnjwqp5XAp6VsP8zvmfx8whrTX67elO62LGkEuC6BwB+YgZbsRNL1bvfaUWb56Z3Oj3p36BF7udiinFtYYTwA4V+IARACkIBMBTvHr77NT8sID5aq9b7YZRvmEHOMyU1vBjbn53w8LdS6d9cZB5JSl42jIxbZkDd5IIgpC30nIFAOh5vX3ZlGLtU9sZyXZrdhIA8PBNDVZaDrCGEyBUfMVgrcsNJ7nstVobdTvAru2jeCw3wKyUxA/FZZGWYsYOVaJAreejG8SYOmKOsGxKwg7VjMGMcR56SgCYyI2hdPI4AODJh68jXBAhUDwuIubE7N/62vqYMB8AiBRDeDG3KBEfboo1Yq1bwo3UlhT/LtHyQpiG3BIh88L/VLC976IXxgviRvHEuqe4ooYGOZEb+3M+dTQzwDY7DkBUeXx9bp201nj0tmYCqApCPmP8/TBupFDt+QCAgmUim5LY7Dio94Lm8ue9QvtOyR9Ypvuvd55FrOetlEQ2JSHoV3OKNVpeiO19FyCqPCjNln7H0PA6lze+XAiVXvJjPu/FKh8pBghNInpnCFq8d7X4st//J3JK/Ibf2DGRAAAAAElFTkSuQmCC",
	italicFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnklEQVR42mNkoBAwEpCXB+IDQKwAxB+AWJBUA/KBeAI+9YQMiAfiBVD2BiAOJNUAmDcEgPgiOWHwHqoZBBKAeCEpBugD8QUkvgMQHyTFAGT/41SLz4B+IC6AskEuMSTVgP1QZzNAXZJIqgHIAdgAxI2kGACKugeEAhCfAf4MkIQDAyCXfCTFgHqosxmgLlHE5U9cBiAHINYkTEwgEgUALgQZEX/jz9wAAAAASUVORK5CYII=",
	jitter: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWElEQVR42mNkoBAw/mdg+A9mgBHxAK6PYgMGxAvIenAacODAgf8ODg6M6GwMA7DZANIAopENQObj9QJMMS4AMwRvLBDjAoKxgC8M6BMLRBtArCZcYBjkBQCVkUwFt2LOsgAAAABJRU5ErkJggg==",
	kaplanMeier: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeklEQVR42rXRAQ6AIAgFUP/NPLo3I62hwMTQFnNrFXuDLyilekbhPvGqzdQBqq/oHkKQarLTRCZyfrapgAZ+Bt6mWQDmi5NPOHGe5kEOAEb+AUoplHOG97RryFBdgJskYG9IAbI5CqgVLDBbQQJHGQxA5bAL6Nq6xlldZE17DbdAwpAAAAAASUVORK5CYII=",
	kernelHistogram: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAlUlEQVR42p2SYRqAIAhD5WR5dDyZYZ/UUCGLH2UGr7lFzFyTVM6Z0lDtnezj1tRD0OgCqp00fRQpkKp6Kcypq7GASEGbrX0BgNZ/f/BVAQIOAdAI+KJAAah+UgDPjwkAABPWCjA6hiEXsFKg0ZUYcC1dBREAE1mlYLL3AGrotnHuccZh3hia/Ng9dwhIP8v8fZrGl/sJnWvSh/A7SCwAAAAASUVORK5CYII=",
	keyAltIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJElEQVR42pWSUUhTURjH/+fuIXFZMHKJg7uVBqUPmcKGQlgRBBF7iIKol5DaZIOIHgxSUEF7SApJ7lpzmWVZYyVjmxERJYQTtagoMlY23HQw0Dti8/He071H1ooiu3849/Cd7zu/832XPwmFo05Jlr2yJAOgWF+EfTkdBx3HtZJHYyHa1GjF5rJNUEDrXlcusf17LofY1DRIIDhGy7cYsH9f83+8XtSLlxNYFrMgDwJBus3Cw2a1YiGZAiFrLVI2zZ8jUSVhMfOYjMWQWkyDjNx/SGtrdmJP3W6srIhKizrIVIYkSZDVkQoMUgRUVGzF9MwsvnxNgNwZGaUN9XWordnFkna7nRWGw2E4HA50dXezuLenB1f6+pDP5Rng7bv3+PDxE8jQ8F26t6kR1TuqsZROs0JV7R0d6OrshM/n+wktgFXNzX3GzOs3IP6hYXrwQDPMZgtcLhcEQWAFF9vakF9dhcfjYbGaU6GmykoWx+NxvJqcAvH6btEjhw/BZDKxooI26vX/BCQSCTx7PgEi3Bikx47aYTQaf+vA7XYjm81iQ0kJbDYbnoyPs/NIJML21NIiotGnIAOCl548cRwGg0GTDzKZDIKPQyD91z205fQplClO1CJRFHFvNABytX+AOs+2QF9aqgmg/p9B/22Qawqg1XkG8/PfNAGqqrbDe9MPcu78hV6eN1+S17xbMNxf9auxOcXyyeTCZbW+XFm8pueLSv4ARhjggP4/qOUAAAAASUVORK5CYII=",
	keyCtrlIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACLElEQVR42pVSX2jSURg9Vx8aixVIszHxz9KgtoeWgbFBrCIIInoog6iXGG4OHyIiJvTiU4FaMRpzv9SmtVqJNSRcREQNYg5dWVG0NJdMVyA0I9eexN/teoczKFoeuP+/73znuxwSehg2l0RREEsiAIq1QfgskUoglUj6yP3xEO3sMGBjwwYwojXTWRJffywtITIdBQkEx2njJhn27e36j+pVPHs+iW/57yB3A0HaolFht8GA+UwWhKxIpLybP1ui7EGjVmEqEkF24SvI6J17tK11G3a278DiYp5JlEKkIkqlEsRySxUOUiVoatqMaGwGn1JpkJujY3SXvh1trdsxLAhIJJM8sIVVSSSScDidnKiirFAoQNHcjNdv3uLd+w8gI/5bdE9nB3RbdTjf34/LDgfi8ThsNtuq7GNGI2LRKIrFItxuN7+bnf2I2MtXIN4RPz2wvwtqtWaVoAKLxYKe3l54WJLL5eLn8lpGkil9MTUNIrhv0MOHDkKhUMBqtcJut3MFer3+nwTpdBpPnk6CDA17qPHoEcjlcv4Hc6kUD9DqdHg0McH3SqUSJpMJTvYf6+rq4Pf5kP2ygHD4McjgkEBPnjgOmUxWkw9yuRyCD0IgA9dctPv0KTQwJ9aCfD6P22MBkCsDg9Tc04319fU1EfxcXobH6wO5ygj6zCbMzX2uiUCr3QLhuhfkzNlzF1Uq9QVxxbsVw/0VvxtbwoyVycxfKsc3sqGqqXwVmV+hMumAGuivtgAAAABJRU5ErkJggg==",
	keyEscape: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAedJREFUeNqUUjtPG0EQ/m5v945HEldpXADm6N1FSpqEzhKK8gNAUPH4AYaCBgQSEjYKAgti0kDnNuD8hkBCCxYCBLbpuAojQXO7x+zad5AiAY9kaea88z1mxvqx93NSKlVUUgEI8XxYYDaDzdjUl89DWzwIguKH9++QeP0GBPRsOzXi5vYWv/Z/F6nc4pKYT05OMfjpI14aB38OYzKulERXV6cpavUrWJZl8tC4+dtSSB/7envgug6UlE2AIJBwHNcUr7q7SaINFSpIeqA0SxhbNwCmiQsEQaxAEYBjioXFBVjkMUUs4xOTBkC1pGpljUbD5Pq9Vm4ApAzgCmEKQX+s5HKGdH5uTnchlUohnU5jc2ODpLsoFApwnwAwzSAcborqxQVmpqdRvazB930a7CCGR0ZQ3t3F+toavq6uGiWc28aiAdAz0J50eJ6HXD5PrL1YJ6Zr/xr55WXc3d/DJpWcN4mEeDIDvUbRslCpVJDNZuENDOD87AyJRALJZBKZTAZjo6NwOzqws70N7ojHGegkQi6Xy//cfalUinOHFMcWmgo42gmtONoOk6SA2e0BOLSNSAHXd8do90fHlRcDeF5/nPNq9XJp89v3WdW6Mus/jdFRMlplvV5bit6/pV8P2o86nbb/IMAAm5HMuq9efzYAAAAASUVORK5CYII=",
	keyShiftIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACV0lEQVR42o2SUUhTYRiG32/eGRaMNEHYnDMsvcgKFgphRRCEExlHVspQh+ZYmENSSCGvCtxMhuKaucyyLNmS0XYRESWEE62oKAxWc3NaINNFmBde7PydneGqmzwf/By+n/d7/u89vOR94m9J8LyTT/AAGHYugixDhgyZzFRdVTlMnikvKy/TYE/WbgigHceFQfzc2EBgdg6crppo0j3FsvfKcfJEhYTXU/Xi5TTW4j+g53REDyfdTJWvwDGNBkvRZRCRKGKim38tMeEyX6nATCCA5ZXvOK+vIRp/8IiVFB/A4dJDWF+PCytmgGc8EokE+KSlbQalALm5+zA3/xpfvoZhqNMT3R2fYEePlKKk+CDaLBaQ4HElGoXH40n33Ve60NNzFQ6HQ2S9e/8BHz8toN5QSzQ6do8dLy9D4f5CXO7sRJ/Vis6ODlhttnSv1WrTNnw+HxYWPmP+zVs01huIXKNj7PSpCiiV+eA4DgUqlShcDIfFb7JPwsxmc3qDYDCIVzOzaDI2EDlv3WaVZ88gLy8Psdga+vpsoigUCkGtVqO3t1fs/waEBfiz59MwXTASDd0cYZyuCjk5OeKqRUVFoigSiWBra0tcOQk2GhvTFpa/rcDvfwqzqZlocMjJas/VQC6XS87B6uoq3I+9aL1oIrIPOJixoQ5ZQhKlVjwex/2JSbS1molu2AdZS7MRuzIzJQN+bW5ixHUH7ZZWon4BYGppEn7aomSAWl0A57ArBbhkab+mUCi7+FR2Qf8Z3A6lTIh7NLp0fcDe353UZwtHIfn5PxUVTuw3P9n0EUA079AAAAAASUVORK5CYII=",
	kmeansSamples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZ0lEQVR42qWRUQrAMAxC581z86yDFMIaQalfLa3mYfBcCsqniMh2xrpkmQHFtI0WwRewTTKBOpUSsKlnaNYbQANUoZsZ9r+D1UCWeyaY8KUt9IBusAicDRwErEyZYDJYHTDZBI6uA17l+V4RsehpQAAAAABJRU5ErkJggg==",
	kmeansVariables: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAYElEQVR42rWPUQ7AIAhD7c25Oasfm4urRpRBFCnyUJRDw+8AM3MuhAC1aQLEEkBNVTr6C7OJS4BRQw+/9RBAnfMA7yfWosqV/pkWjXmAXWsAp4M+isX5d4CbM3liImDTLudeqBF988IgAAAAAElFTkSuQmCC",
	labels: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATklEQVR42mNkoBAw4pI4cODAf2S+g4MDI20NQNeADogywN7eHi5x8OBB6hqAy0VEG4AuN2oADgMYSAAYBpALUAz4D0ZgQUZi+NQ3gBwAABjcXBHyAqQ9AAAAAElFTkSuQmCC",
	left: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAo0lEQVR42t3Suw3DIBAG4KPJLmzBCszikjVcIFwaCeOGwiUIufVKFoLkCltuEqNQJX/Bo7hPpwMCjSG4FID9dXj8MdD3fRnHEbZtI1XAuq47Y+y8D8NQ5nkG7/09gMW4XwGlVJmmCWKMn4Gj+BqEsANjzD3wrgMErLUQQvhuBlLKorWGruvOQs45qX4F51wRQgClFHLOkFKCZVnqgeZ/8ANAS56xeWcReLNUrQAAAABJRU5ErkJggg==",
	legend: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAALGPC/xhBQAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB9IMEww6K5Rx3KkAAAE4SURBVHjanZCxSwJhGMZ/vu/3Ibo4ODn5pzgJLoo5ySEULU03BeJ+UBCtbY0dKC3tYWPtN0WjSdgglBxXchw1qUkI3j3bA+/z43mfXK/X80XEWSwWZNBxrtls/nieh7UWa22qdL/fx6gqxWKRcrmcpQEGQEQQkeyAfD5PoVDg8uwWgM+PCO/icD9AkiSoKsaYdXg+f8cYg+M4hGGI67r4vk+lUsEYg+d5G4CqIiKoKq+TN76+Q+J4iaoyGo3Wh41GY/cLAEmScHV9yl+/jwQgjmOyar0BwNPgCIDZdMLBzcN+AFXdqjubTphHSwC63S5RFFGtVqnX64zHYzqdDkEQ4LruZoNVg+D5ZYs+HA63fKvVAqBWq/0fEeDk7jH1BpJm8Z2A1Qtppark2u32OTBIG7bWUiqV7n8BNFhkNoDWY+MAAAAASUVORK5CYII=",
	legendInside: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABoSURBVDhPxY5RDsAgCEO5/6m4mQOUpTA+HFu2l1Rjhab0P8w8VOvZ41EANpBjVLLBgNoABpgBXD3PXeQGZs47e8JZCiTsNaiWRR82cGBRyQ0q2WBAbcADWmCDNq8E3NFai/jH7j0hOgD5ptCBL+GpPgAAAABJRU5ErkJggg==",
	legendInsideBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABKSURBVDhPYwCBAwcO/AczyAEgzRQZAAKjLhjWLgAK/kfHUClUgM8AKBMMsBpAyAUIJg4DQICmLkDHUClUADOEHAw1AuEN0mgGBgDTFax1Zs+x4wAAAABJRU5ErkJggg==",
	legendInsideBottomLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABLSURBVDhPYwCBAwcO/AczyAEgzRQZAAKjLhg2LgCagIGhSggDmAFQLhgQbQCyC6BCYJpoA0CAai5Ax1AlhAHMEHIw1AiIIaTTDAwAZK6sde813NAAAAAASUVORK5CYII=",
	legendInsideBottomRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABGSURBVDhPYwCBAwcO/AczyAEgzRQZAAKjLhhRLgAq+o+OwRKkGABlggGYT6oLEEwkPl1dgI7BEjBDyMFgA0AAxiGNZmAAAMUHrHXPVrkiAAAAAElFTkSuQmCC",
	legendInsideLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABVSURBVDhP3Y9BCgAgCAT9/6v8WbWyUdShtA7RgKhRwyZAVZMNEfD4SAA+SVAMU/HKmirgamwL+gQ8sr4tANcSjMUrayDg6Kcm4BrjjQTRoqJ9w9dFMskZrHXNWcFoAAAAAElFTkSuQmCC",
	legendInsidePosition: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACMSURBVDhPpY8JEsAgCAP9/6v8WdtwGMSj184gDoaABdRaD7lMOTZvF2heG6DZY8PcIDZvTPYbgEVjZGZgI4ewZzJuAJ0oBzFrqmnQwAdFseRUoy5s4EUNHCLQLHet9TrU7zZosJaaaQBoMAuRyDXQG2SSODNu4HSDLRasN3jY/OsLwE2+hFnwG+9yKSdWsQcpOGs75gAAAABJRU5ErkJggg==",
	legendInsideRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABMSURBVDhPYwCBAwcO/AczyAEgzRQZAAIjyAVARf/RMViCFAOgTDAA80l1AYKJxKerC9AxWIJYA7ACUlyAEwwOF5CLoUYgvEEazcAAACmBrHX6cMj/AAAAAElFTkSuQmCC",
	legendInsideTop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABLSURBVDhPYwCBAwcO/Acz0ABQ8D86hkohAEgzPgOgTDDAagAIEGEAmEbiIwDNXYCOoVIIgM8FRAOKDBh1wbByAbkYagTCG6TRDAwA9RGsdfKyFBQAAAAASUVORK5CYII=",
	legendInsideTopLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABJSURBVDhPYwCBAwcO/P/PwICBwZKEAEgzzACoEBgQbQAIoBkApok2gKouQMdQafwA5gIolzxAkQGjLhhWLiAXQ41AeIM0moEBAIaqrHVTc81FAAAAAElFTkSuQmCC",
	legendInsideTopRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABBSURBVDhPYwCBAwcO/AczCACgov/oGKyZFAOgTDCA88kwAEyD+XR3ATomyQU4AUUGjLpgWLmAXAw1AuEN0mgGBgDnA6x1eX3XUgAAAABJRU5ErkJggg==",
	legendLocation: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABvSURBVDhPtY5LEsAgCEO5/6m4mS0/weJGsG+GOg0xBtog4qDR3xqtgN8avMLYja6d3IB87Exm18Qz8QB7KJr5/GjuCw1MlKEPGwKirT5eXGpgpICJa3rZWAMEMu9G105uUKAVcK1BZfS6YMLZCfAAv3XcwFXfqxQAAAAASUVORK5CYII=",
	legendOutside: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABsSURBVDhPxY4JDgAhCAP5/6v4GSssR1DU7JE4EY1NrYXzICLx6PUddQAlrV1YGGbRwDw3Yu5wLQekD3TaLkvgM7SxQRVAsqnBce3nBkY8ZsTc4do8IGBzNYsGD/gUcL4BYy12o/YaM+zODMAFQTLGxNIHZcYAAAAASUVORK5CYII=",
	legendS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaElEQVR42sWQAQrAIAwDzc/69P7MoczRbS6pICwIVTTXWBSi2hcXFADkzXmvAQEUE+ECuHs1M3wBaINmbgcGWEoQ9/8k2D6DInRL8KzK3AEswRADTmewNYGCIfMoNcQVU2z2+ne2Dt8BbiiI/18f4/YAAAAASUVORK5CYII=",
	legends: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVR42uXQXQqAMAwD4OVk7dHbkykUlSoscY9i2Mv+voVhkGw1eKAAkDPHvgYa1BvhNfChBhFxveDuWG4wA2iDfqnnBIZIAWZWk8y8AeoyBZ5tloG+9gdA/TQDdgTobv92RRE8AAAAAElFTkSuQmCC",
	levels: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXklEQVR42mNkoBAw/mdgECZLIwPDW5gB/8nQL4JsALIL3uDThNUFMAGoQXgNgGlCM2jEGgALfLIMQIq5NyQbgKyZZBcgseHqiE1IIjjUiJCblFEMICszwb1AiWYQAACfICtTrJvm7wAAAABJRU5ErkJggg==",
	lightbulb: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAidJREFUeNp0U89rE0EU/ja7kZRWQwOS2sRgEayiRFGp9JBL/oN4EbyJtSG3eFFEpEUvHiMUpPXoteCPP8CbF1FQY6vWom2zCdt00yZx0242u7O+nbVl3awP3sybN9/73puZN4Jt2/DLm9lwjqZp0om/rnekC9nZ3gs/VvASUGCCpvupKzcK8XQOA9Ek9+utKpTyK8jvn88zs/uIiKr7MZKXLSRFHpzNPcnHTpyHbW7D7v3i/sjQAMYyUxgey+SXX94WyXXrIMaT/fqx9NX8cGIUbPcTbKMCmCpXx3Z80XgMI+nclIPtIyApjJyZgLX7GaynBqqzFz91kWODCC6IwjcquwFx6DJsq032lquWBnHwErdFfOXYIALL6qzA2vuJnroI6XCG7kGj4A4RTnKfpVdgapzACrrED53tZvbIUZOYmmDKM0SOz1CKCPS1u7DZb9AAraHtP2tfBU/lpXUwy6KsJpjRoHPX+ZFYb8f10V51eYNj+wjobRc1tTEnl9d4JledHrEP1vKXdWiqOudtKMnXWHeU1aoYkoTC6OmkG+yMFKys1KD8kJ3M9/7pHe+CmPdoeri5uulmhVsBM03UvtccyGPCaN4YfwV4O/5RidVfw6iP4+RgEnV1C+Wla6jokyx87uZG1ocPIUBCUhSxaII+ShhhegXTOIR2hwVjg5yGYaDVanN7p9lEt6vjfyIEfWdHisXivKIo0w5ZKpVaKJVK+SDcHwEGAD5qJSG2+HXsAAAAAElFTkSuQmCC",
	lightbulbOff: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAgtJREFUeNp0k89r02AYx79JWs3mYHM4dROqCCLiYTv5V4jiTfwDJr0VD4LoSRA89iAO9xd4GMjAww6ePBY2XOfGQKfpxmqZbk1q1yx5f/k8iS2lzd70mzzv83yeb9/kTSxjDAbHx039gC7zpDv/UxXS4t3b9odB1uo3WF4XV+jyfHrcLl6dtDExaiV5v2NQO9L4FegFmr66P5vf7zWxQVdLq+HbrbowUmoTC2WiOBXHnOMaM/09dtfofeX40cSIKV6/YCEUEmE8IMpxjRlmu309AyFk8eYlB51IISSdxBqRSMUx57jGDLMZBmLOzZkE/LbfpiYFIXUijr/X0xwzzGatQMUEK60xPenCOzgGz1m1gw4un3chVTpndsggFnL1T0tAkgE9nsSk6vlY22lSfDbJce03McRWhlcg5cK69xeavJWiraWfm3cwcsYB7zTnuFYlhtkhgyf3ri3VDztvvu62obmBTtqkSmNgc68NZojtvVC5/reK7u3phuc7gC7emBkDrTgVNe/QQ6z+DPifn/X32P2TFw9v0XarlxteANtGct98cPTlR5OWrl4T0z7VIFmSYzXcwzV421u4mA9hBzV8/rSCYHtFU213kB8y4HEOLUyN2ZgaNZgZz8GER5DBXiabmYzjGEHQSuKm7yOKTnDasLI+Zx6lUuldo9GYZ7NCobBYLpcfZ3H/BBgAh/F5D+rprGgAAAAASUVORK5CYII=",
	linLogV: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAQCAYAAAArij59AAAARUlEQVR42p3Q2woAIAgD0O3/P3qFD90wWYlg1GFgFCACvfPiCjLM7FLRRcI2LRBR58OcdVlAFXwCcsAK42yD7zWvHzVSG0hxMQMQcjWdAAAAAElFTkSuQmCC",
	line: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAqUlEQVR42qVSCQ7EIAjUl8nT/RkL2LIDatu0xERF5kCtRaL3zkRUSwqWIckpj1F3BGzDCq4JFKwLJEDlOxfgoOl2CVqRnLnUAjNL3a5YzxWDhKmFUQBI4xsAPhxGEXfQiAqqnGCfnRxE2JwsXsFBs5Oh6k3U+RV2ipI/Gg910UFQngn8zNbjTv4EjUqwHUhSa+By+ZEuI93P9is/DSd4A3aCL+EE+S6e7n/HRZuL7+wQfQAAAABJRU5ErkJggg==",
	lineWidth: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAL0lEQVR42mNkoBAwgoj/DAy/yNTMRo4BrEgGMA6ICzANoARQx4CBD4PRQBzqYQAA0IISEdiDpJYAAAAASUVORK5CYII=",
	linear: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAQCAYAAAB+690jAAAAhklEQVR42u2TAQrAIAhF5xE9qUd0a9Bwoi1bVIxJsIj8Pf0OtsUCZgP8QE1AfCwIwBERI2K4mJSX9zJf6t2AasHeAKU8ma+1pnbI0jE7xOfRdQEs4SyoH7AsiRTlApUs1K33vjXW6QKGA1nz8zjUEaCIZRrU7VDvaB367wNF/rIhQD1iOaAdj6C6EYM+H/IAAAAASUVORK5CYII=",
	loading1: "data:image/gif;base64,R0lGODlhZABkAPQAAP///wCQ/47N/mi9/jan/jyp/ly3/hyc/hKX/iyj/lS0/kyw/n7G/obK/iSf/gCQ/3bD/kSt/gqU/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zfMgoDw0csAgSEh/JBEBifucRymYBaaYzpdHjtuhba5cJLXoHDj3HZBykkIpDWAP0YrHsDiV5faB3CB3c8EHuFdisNDlMHTi4NEI2CJwWFewQuAwtBMAIKQZGSJAmVelVGEAaeXKEkEaQSpkUNngYNrCWEpIdGj6C3IpSFfb+CAwkOCbvEy8zNzs/Q0dLT1NUrAgOf1kUMBwjfB8rbOQLe3+C24wxCNwPn7wrjEAv0qzMK7+eX2wb0mzXu8iGIty1TPRvlBKazJgBVnBsN8okbRy6VgoUUM2rcyLGjx48gQ4ocSbKkyZMoJf8JMFCAwAJfKU0gOUDzgAOYHiE8XDGAJoKaalAoObHERFESU0oMFbF06YikKQQsiKCJBYGaNR2ocPr0AQCuQ8F6Fdt1rNeuLSBQjRDB3qSfPm1uPYvUbN2jTO2izQs171e6J9SuxXjCAFaaQYkC9ku2MWCnYR2rkDqV4IoEWG/O5fp3ceS7nuk2Db0YBQS3UVm6xBmztevXsGPLnk27tu3buHOvQU3bgIPflscJ4C3D92/gFNUWgHPj2G+bmhkWWL78xvPjDog/azCdOmsXzrF/dyYgAvUI7Y7bDF5N+QLCM4whM7BxvO77+PPr38+//w4GbhSw0xMQDKCdJAwkcIx2ggMSsQABENLHzALILDhMERAQ0BKE8IUSwYILPjEAhCQ2yMoCClaYmA8NQLhhh5I0oOCCB5rAQI0mGEDiRLfMQhWOI3CXgIYwotBAA/aN09KQCVw4m4wEMElAkTEhIWUCSaL0IJPsySZVlC/5J+aYZJZppgghAAAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zfMhAIw0csAgQDhESCGAiM0NzgsawOolgaQ1ldIobZsAvS7ULE6BW5vDynfUiFsyVgL58rwQLxOCzeKwwHCIQHYCsLbH95Dg+OjgeAKAKDhIUNLA2JVQt4KhGPoYuSJEmWlgYuSBCYLRKhjwikJQqnlgpFsKGzJAa2hLhEuo6yvCKUv549BcOjxgOVhFdFdbAOysYNCgQK2HDMVAXexuTl5ufo6err7O3kAgKs4+48AhEH+ATz9Dj2+P8EWvET0YDBPlX/Eh7i18CAgm42ICT8l2ogAAYPFSyU0WAiPjcDtSkwIHCGAAITE/+UpCeg4EqTKPGptEikpQEGL2nq3Mmzp8+fQIMKHUq0qNGjSJO6E8DA4RyleQw4mOqgk1F4LRo4OEDVwTQUjk48MjGWxC6zD0aEBbBWbdlJBhYsAJlC6lSuDiKoaOuWbdq+fMMG/us37eCsCuRaVWG3q94UfEUIJlz48GHJsND6VaFJ8UEAWrdS/SqWMubNgClP1nz67ebIJQTEnduicdWDZ92aXq17N+G1kV2nwEqnqYGnUJMrX868ufPn0KNLn069Or+N0hksSFCArkWmORgkcJCgvHeWCiIYOB9jAfnx3D+fE5A+woKKNSLAh4+dXYMI9gEonwoKlPeeON8ZAOCgfTc0UB5/OiERwQA5xaCJff3xM6B1HHbo4YcghigiNXFBhEVLGc5yEgEJEKBPFBBEUEAE7M0yAIs44leTjDNGUKEkBrQopDM+NFDAjEf+CMiNQhJAWpE8zqjkG/8JGcGGIjCQIgoMyOhjOkwNMMCWJTTkInJZNYAlPQYU4KKT0xnpopsFTKmUPW8ScOV0N7oJ53TxJAbBmiMWauihiIIYAgAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/8AZo4BAFBjBpI5xKBYPSKWURnA6CdNszGrVeltc5zcoYDReiXDCBSkQCpDxShA52AuCFoQribMKEoGBA3IpdQh2B1h6TQgOfisDgpOQhSMNiYkIZy4CnC0Ek4IFliVMmnYGQAmigWull5mJUT6srRGwJESZrz+SrZWwAgSJDp8/gJOkuaYKwUADCQ4JhMzW19jZ2tvc3d7f4NoCCwgPCAs4AwQODqrhIgIOD/PzBzYDDgfsDgrvAAX0AqKjIW0fuzzhJASk56CGwXwOaH1bGLBGQX0H31Gch6CGgYf93gGkOJCGgYIh3/8JUBjQHg6J/gSMlBABob+bOHPq3Mmzp8+fQIMKHUq0qNEUAiBAOHZ0RYN10p41PZGg6jQHNk/M07q1BD2vX0l0BdB1rIiKKhgoMMD0BANpVqmpMHv2AVm7I7aa1Yu3bl6+YvuuUEDYXdq40qqhoHu38d+wfvf2pRjYcYq1a0FNg5vVBGPAfy03lhwa8mjBJxqs7Yzi6WapgemaPh0b9diythnjSAqB9dTfwIMLH068uPHjyJMrX84cnIABCwz4Hj4uAYEEeHIOMAAbhjrr1lO+g65gQXcX0a5fL/nOwIL3imlAUG/d8DsI7xfAlEFH/SKcEAywHw3b9dbcgQgmqOByggw26KAIDAxwnnAGEGAhe0AIoEAE0mXzlBsWTojDhhFwmE0bFroR3w8RLNAiLtg8ZaGFbfVgwIv2WaOOGzn+IIABCqx4TRk1pkXYgMQNUUAERyhnwJIFFNAjcTdGaWJydCxZ03INBFjkg2CGKeaYCYYAACH5BAkHAAAALAAAAABkAGQAAAX/ICCOZGmeaKqubOu+cCzPdG3feK7vfO//wBnDUCAMBMGkTkA4OA8EpHJKMzyfBqo2VkBcEYWtuNW8HsJjoIDReC2e3kPEJRgojulVPeFIGKQrEGYOgCoMBwiJBwx5KQMOkJBZLQILkAuFKQ2IiYqZjQANfA4HkAltdKgtBp2tA6AlDJGzjD8KrZ0KsCSipJCltT63uAiTuyIGsw66asQHn6ACCpEKqj8DrQevxyVr0D4NCgTV3OXm5+jp6uvs7e7v6gIQEQkFEDgNCxELwfACBRICBtxGQ1QCPgn6uRsgsOE9GgoQ8inwLV2ChgLRzKCHsI9Cdg4wBkxQw9LBPhTh/wG4KHIODQYnDz6Ex1DkTCEL6t189w+jRhsf/Q04WACPyqNIkypdyrSp06dQo0qdSrWqVUcL+NER0MAa1AYOHoh9kKCiiEoE6nl1emDsWAIrcqYlkDKF2BNjTeQl4bbEXRF//47oe8KABLdjg4qAOTcBAcWAH+iVLBjA3cqXJQ/WbDkzX84oFCAey+wEg8Zp136e3Pnz3sitN28mDLsyiQWjxRo7EaFxXRS2W2OmDNqz7NrDY5swkPsB5FC91a6gHRm08OKvYWu3nd1EW8Rw9XA1q1TAd7Flr76wo1W9+/fw48ufT7++/fv48+s/wXUABPLwCWAAAQRiolQD/+FDIKRdBOz0TjgKkGNDAwsSSJBKEESowHOUEFjEY0lJEyGAegyw4G5HNcAAiS0g2ACL+8Uo44w01mjjjTi+wMCKMs5TQAQO+iCPAQme00AEP/4IIw0DZLVAkLA0kGQBBajGQ5MLKIDiMUcmGYGVO0CQZXvnCIAkkFOsYQCH0XQVAwP+sRlgVvssadU8+6Cp3zz66JmfNBFE8EeMKrqZ46GIJqrooi6EAAAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/0Baw2BoBI88g2N5MCCfNgZz6WBArzEl1dHEeluGw9Sh+JpTg+1y8GpABGdWQxFZWF0L7nLhEhAOgBFwcScNCYcOCXctAwsRbC5/gIGEJwuIh3xADJOdg5UjEQmJowlBYZ2AEKAkeZgFQZypB0asIgyYCatBCakEtiQMBQkFu0GGkwSfwGYQBovM0dLT1NXW19jZ2ts+AgYKA8s0As6Q3AADBwjrB9AzogkEytwN6uvs4jAQ8fxO2wr3ApqTMYAfgQSatBEIeK8MjQEHIzrUBpAhgoEyIkSct62BxQP5YAhoZCDktQEB2/+d66ZAQZGVMGPKnEmzps2bOHPq3Mmzp88v5Iz9ZLFAgtGLjCIU8IezqFGjDzCagCBPntQSDx6cyKoVa1avX0mEBRB2rAiuXU00eMoWwQoF8grIW2H2rFazX/HeTUs2Lde+YvmegMCWrVATC+RWpSsYsN6/I/LyHYtWL+ATAwo/PVyCatWrgU1IDm3Zst2+k/eiEKBZgtsVA5SGY1wXcmTVt2v77aq7cSvNoIeOcOo6uPARAhhwPs68ufPn0KNLn069uvXrfQpklSAoRwOT1lhXdgC+BQSlEZZb0175QcJ3Sgt039Y+6+sZDQrI119LW/26MUQQ33zaSFDfATY0kFh2euewV9l748AkwAGVITidAAA9gACE2HXo4YcghijiiN0YEIEC5e3QAAP9RWOiIxMd0xKK0zhSRwRPMNCSAepVYoCNTMnoUopxNDLbEysSuVIDLVLXyALGMSfAAgsosICSP01J5ZXWQUBlj89hSeKYZJZpJoghAAAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/0Bag8FoBI+8RmKZMCKfNQbTkSAIoNgYZElNOBjZcGtLLUPE6JSg601cXQ3IO60SQAzyF9l7bgkMbQNzdCUCC1UJEWAuAgOCLwYOkpIDhCdbBIiVQFIOB5IHVpYlBpmmC0EMk6t9oyIDplUGqZ+ek06uAAwEpqJBCqsOs7kjDAYLCoM/DQa1ycSEEBCL0NXW19jZ2tvc3d7fPwJDAsoz4hC44AIFB+0R5TGwvAbw2Q0E7fnvNQIEBbwEqHVj0A5BvgPpYtzj9W+TNwUHDR4QqBAgr1bdIBzMlzCGgX8EFtTD1sBTPgQFRv/6YTAgDzgAJfP5eslDAAMFDTrS3Mmzp8+fQIMKHUq0qNGjSJMisYNR6YotCBAE9GPAgE6fEKJqnbiiQYQCYCmaePDgBNmyJc6mVUuC7Ai3AOC+ZWuipAStUQusGFDgawQFK+TOjYtWhFvBhwsTnlsWseITDfDibVoCAtivgFUINtxY8VnHiwdz/ty2MwoBkrVSJtEAbNjAjxeDnu25cOLaoU2sSa236wCrKglvpss5t/DHcuEO31z57laxTisniErganQSNldf3869u/fv4MOLH0++vHk/A5YQeISjQfBr6yTIl5/Sxp2/76sNmM9fuwsDESyAHzgJ8DdfbzN4JWCkBBFYd40DBsqXgA0DMIhMfsQUGGEENjRQIR4v7Rehfy9gWE18/DkEnh0RJELieTDGKOOMNAa1DlkS1Bceap894ICJUNjhCJAyFNAjWahAA8ECTKrow5FkIVDNMcgMAwSUzFnCAJMLvHiDBFBKWQ1LLgERAZRJBpVTiQ70eMBQDSigAHSnLYCAj2kCJYCcBjwz3h98EnkUM1adJ2iNiCaq6KKLhgAAIfkECQcAAAAsAAAAAGQAZAAABf8gII5kaZ5oqq5s675wLM90bd94ru987//AoHAYEywShIWAyKwtCMjEokmFCaJQwrLKVTWy0UZ3jCqAC+SfoCF+NQrIQrvFWEQU87RpQOgbYg0MMAwJDoUEeXoiX2Z9iT0LhgmTU4okEH0EZgNCk4WFEZYkX5kEEEJwhoaVoiIGmklDEJOSgq0jDAOnRBBwBba3wcLDxMXGx8jJysvMzUJbzgAGn7s2DQsFEdXLCg4HDt6cNhHZ2dDJAuDqhtbkBe+Pxgze4N8ON+Tu58jp6+A3DPJtU9aNnoM/OBrs4wYuAcJoPYBBnEixosWLGDNq3Mixo8ePIEOKxGHEjIGFKBj/DLyY7oDLA1pYKIgQQcmKBw9O4MxZYmdPnyRwjhAKgOhQoCcWvDyA4IC4FAHtaLvJM2hOo0WvVs3K9ehRrVZZeFsKc0UDmnZW/jQhFOtOt2C9ingLt+uJsU1dolmhwI5NFVjnxhVsl2tdwkgNby0RgSyCpyogqGWbOOvitlvfriVc2LKKli9jjkRhRNPJ0ahTq17NurXr17Bjy55NG0UDBQpOvx6AoHdTiTQgGICsrIFv3wdQvoCwoC9xZAqO+34Ow0DfBQ+VEZDeW4GNOgsWTC4WnTv1QQaAJ2vA9Hhy1wPaN42XWoD1Acpr69/Pv79/ZgN8ch5qBUhgoIF7BSMAfAT07TDAgRCON8ZtuDWYQwIQHpigKAzgpoCEOGCYoQQJKGidARaaYB12LhAwogShKMhAiqMc8JYDNELwIojJ2EjXAS0UCOGAywxA105EjgBBBAlMZdECR+LESmpQRjklagxE+YB6oyVwZImtCUDAW6K51mF6/6Wp5po2hAAAIfkECQcAAAAsAAAAAGQAZAAABf8gII5kaZ5oqq5s675wLM90bd94ru987//AoHAYE0AWC4iAyKwNCFDCoEmFCSJRQmRZ7aoaBWi40PCaUc/o9OwTNMqvhiE84LYYg4GSnWpEChEQMQ0MVlgJWnZ8I36AgHBAT4iIa4uMjo9CC5MECZWWAI2Oij4GnaefoEcFBYVCAlCIBK6gIwwNpEACCgsGubXAwcLDxMXGx8jJysvMZ7/KDAsRC5A1DQO9z8YMCQ4J39UzBhHTCtrDAgXf3gkKNg3S0hHhx9zs3hE3BvLmzOnd6xbcYDCuXzMI677RenfOGAR1CxY26yFxosWLGDNq3Mixo8ePIEOKHEmyZDEBAwz/GGDQcISAlhMFLHBwwIEDXyyOZFvx4MGJnj5LABU6lETPEUcBJEVa9MQAm1Ad0CshE4mCqUaDZlWqlatXpl9FLB26NGyKCFBr3lyxCwk1nl3F+iwLlO7crmPr4r17NqpNAzkXKMCpoqxcs0ftItaaWLFhEk9p2jyAlSrMukTjNs5qOO9hzipkRiVsMgXKwSxLq17NurXr17Bjy55Nu7ZtIoRWwizZIMGB3wR2f4FQuVjv38gLCD8hR8HVg78RIEdQnAUD5woqHjMgPfpv7S92Oa8ujAHy8+TZ3prYgED331tkp0Mef7YbJctv69/Pv7//HOlI0JNyQ+xCwHPACOCAmV4S5AfDAAhEKF0qfCyg14BANCChhAc4CAQCFz6mgwIbSggYKCGKmAOJJSLgDiggXiiBC9cQ5wJ3LVJ4hoUX5rMCPBIEKcFbPx5QYofAHKAXkissIKSQArGgIYfgsaGAki62JMCTT8J0Wh0cQcClkIK8JuaYEpTpGgMIjIlAlSYNMKaOq6HUpgQIgDkbAxBAAOd/gAYqKA0hAAAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/8CgcChrQAYNotImiBQKi+RyCjM4nwOqtmV4Og3bcIpRuDLEaBNDoTjDGg1BWmVQGORDA2GfnZusCxFgQg17BAUEUn4jEYGNQwOHhhCLJFYREQpDEIZ7ipUCVgqfQAt7BYOVYkduqq6vsLGys7S1tre4ubq7UwIDBn04DAOUuwJ7CQQReDUMC8/FuXrJydE0Bs92uwvUBAnBNM7P4LcK3ufkMxDAvMfnBbw9oQsDzPH3+Pn6+/z9/v8AAwocSLCgwYO9IECwh9AEBAcJHCRq0aAOqRMPHmDMaCKjRhIeP47gKIIkyZEeU/8IgMiSABc2mlacRAlgJkebGnGizCmyZk8UAxIIHdoqRR02LGaW5AkyZFOfT5c6pamURFCWES+aCGWgKIqqN3uGfapzqU+xTFEIiChUYo+pO0uM3fnzpMm6VUs8jDixoVoIDBj6HUy4sOHDiBMrXsy4sWMSTSRkLCD4ltcZK0M+QFB5lgIHEFPNWKB5cq7PDg6AFh0DQem8sVaCBn0gQY3XsGExSD0bdI0DryXgks0bYg3SpeHhQj07HQzgIR10lmWAr/MYC1wjWDD9sffv4MOLR3j1m5J1l/0UkMCevXIgDRIcQHCAQHctENrrv55D/oH/B7ynnn7t2fYDAwD+R59zVmEkQCB7BvqgQIIAphdGBA9K4JILcbzQAID0/cfgFvk9aE0KDyFA34kp+AdgBK4MQKCAKEqg4o0sniBAAQBS9goEESQQQY4nJHDjjRGy0EBg/Rx55GFO3ngYAVFuWBiCRx4w4kENFKBiAVuOJ+aYZIoZAgAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/8CgcChrMBoNotImUCwiiuRyCoNErhEIdduCPJ9arhgleEYWgrHaxIBAGDFkep1iGBhzobUQkdJLDAtOYUENEXx8fn8iBguOBkMNiImLJF6CA0MCBYh9lSMCEAYQikAMnBFwn2MCRquvsLGys7S1tre4ubq7vDqtpL5HvAIGBMYDeTTECgrJtwwEBcYEzjIMzKO7A9PGpUUGzN61EMbSBOIxoei0ZdOQvTuhAw3V8Pb3+Pn6+/z9/v8AAwocSBCQo0wFUwhI8KDhgwPrerUSUK8EAYcOD/CTRCABGhUMMGJ8d6JhSZMlHP+mVEkCJQCULkVgVFggQUcCC1QoEOlQQYqYMh+8FDrCZEyjRIMWRdoyaZ2bNhOoOmGAZ8OcKIAO3bqUpdKjSXk25XqiQdSb60JaJWlCK9OlZLeChetVrtMSm85iTXFRpMafdYfefRsUqEuYg7WWkGTTk4qFGB1EHEavIpuDCTNr3sy5s+fPoEOLHk063YCaCZD1mlpjk4TXrwtYjgWh5gLWMiDA3o3wFoQECRwExw2jwG7YCXDlFS58r4wEx187wMUgOHDgEWpEiC4h+a281h34pKE7em9b1YUDn7xiwHHZugKdYc/CSoIss0vr38+/v//RTRAQhRIC4AHLAAcgoCCkAuf50IACDkTYzCcCJLiggvTRAKEDB0TIFh0GXLjgeD4wwGGEESaQIREKiKggiT2YiOKJxI0xgIsIfKgCPS+YFWGHwq2oiYULHpCfCFZE+FELBszoQIN0NEDkATWaIACHB2TpwJEAEGOdaqsIMIACYLKwQJZoHuDcCkZweUsBaCKQJQGfEZBmlgV8ZkCCceqYWXVpUgOamNEYIOR/iCaq6KIAhAAAIfkECQcAAAAsAAAAAGQAZAAABf8gII5kaZ5oqq5s675wLM90bd94ru987//AoHBIExCPOMhiAUE6ZYLl0vissqJSqnWLGiwUA64Y1WiMfwKGmSgwgM+otsKwFhoWkYgBbmIo/gxEeXgLfCUNfwp1QQp4eoaHakdRelqQl5iZmpucnZ6foKGioz8LCA8IC5akOAcPr68Oq6CzMguwuAWjEBEFC4syDriwEqICvcg2w7iiDQXPBRHAMKfLD8bR0RE2t8u6ogzPEU01AsK4ErWdAtMzxxKvBeqs9PX29/j5+vv8/f7/AAMKNAEBwryBJAYgkMCwEMIUAxhKlOBQn4AB0cKsWDiRYTsRr07AMjGSBDOT10D/pgyJkmUXAjAJkEMBoaPEmSRTogTgkue1niGB6hwptAXMAgR8qahpU4JGkTpHBI06bGdRlSdV+lQRE6aCjU3n9dRatCzVoT/NqjCAFCbOExE7VoQ6tqTUtC2jbtW6967eE2wjPFWhUOLchzQNIl7MuLHjx5AjS55MubJlGQ3cKDj4kMEBBKARDKZ1ZwDnFQI+hwb9UZMAAglgb6uhcDXor6EUwN49GoYC26AJiFoQu3jvF7Vt4wZloDjstzBS2z7QWtPuBKpseA594LinAQYU37g45/Tl8+jTq19fmUF4yq8PfE5QPQeEAgkKBLpUQL7/BEJAkMCADiSwHx8NyIeAfH8IHOgDfgUm4MBhY0Dg34V7ACEhgQnMxocACyoon4M9EBfhhJdEcOEBwrkwQAQLeHcCAwNKSEB9VRzjHwHmAbCAA0Ci6AIDeCjiGgQ4jjBAkAcAKSNCCgQZ5HKOGQBkk0Bm+BgDUjZJYmMGYOmAlpFlRgd7aKap5poyhAAAIfkECQcAAAAsAAAAAGQAZAAABf8gII5kaZ5oqq5s675wLM90bd94ru987//AoHBIExCPOIHB0EA6ZUqFwmB8WlkCqbR69S0cD8SCy2JMGd3f4cFmO8irRjPdW7TvEaEAYkDTTwh3bRJCEAoLC35/JIJ3QgaICwaLJYGND0IDkRCUJHaNBXoDAxBwlGt3EqadRwIFEmwFq6y0tba3uLm6u7y9viYQEQkFpb8/AxLJybLGI7MwEMrSA81KEQNzNK/SyQnGWQsREZM1CdzJDsYN4RHh2TIR5xLev1nt4zbR59TqCuOcNVxxY1btXcABBBIkGPCsmcOHECNKnEixosWLGDNq3MjxCIRiHV0wIIAAQQKAIVX/MDhQsqQElBUFNFCAjUWBli0dGGSEyUQbn2xKOOI5IigAo0V/pmBQIEIBgigg4MS5MynQoz1FBEWKtatVrVuzel2h4GlTflGntnzGFexYrErdckXaiGjbEv6aEltxc+qbFHfD2hUr+GvXuIfFmmD6NEJVEg1Y4oQJtC3ixDwtZzWqWfGJBksajmhA0iTllCk+ikbNurXr17Bjy55Nu7bt20HkKGCwOiWDBAeC63S4B1vvFAIIBF+e4DEuAQsISCdHI/Ly5ad1QZBeQLrzMssRLFdgDKF0AgUUybB+/YB6XiO7Sz9+QkAE8cEREPh+y8B5hjbYtxxU6kDQAH3I7XEgnG4MNujggxBGCAVvt2XhwIUK8JfEIX3YYsCFB2CoRwEJJEQAgkM0ANyFLL7HgwElxphdGhCwCKIDLu4QXYwEUEeJAAnc6EACOeowAI8n1TKAjQ74uIIAo9Bnn4kRoDgElEEmQIULNWY54wkMjAKSLQq+IMCQQwZp5UVdZpnkbBC4OeSXqCXnJpG1qahQc7c1wAADGkoo6KCEFrpCCAA7AAAAAAAAAAAA",
	loading2: "data:image/gif;base64,R0lGODlhZABkAPQAAP///6qqqtjY2MzMzLu7u729vcjIyLOzs6+vr7i4uMXFxcPDw9PT09bW1rW1taqqqtHR0cDAwK2trQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zfMgoDw0csAgSEh/JBEBifucRymYBaaYzpdHjtuhba5cJLXoHDj3HZBykkIpDWAP0YrHsDiV5faB3CB3c8EHuFdisNDlMHTi4NEI2CJwWFewQuAwtBMAIKQZGSJAmVelVGEAaeXKEkEaQSpkUNngYNrCWEpIdGj6C3IpSFfb+CAwkOCbvEy8zNzs/Q0dLT1NUrAgOf1kUMBwjfB8rbOQLe3+C24wxCNwPn7wrjEAv0qzMK7+eX2wb0mzXu8iGIty1TPRvlBKazJgBVnBsN8okbRy6VgoUUM2rcyLGjx48gQ4ocSbKkyZMoJf8JMFCAwAJfKU0gOUDzgAOYHiE8XDGAJoKaalAoObHERFESU0oMFbF06YikKQQsiKCJBYGaNR2ocPr0AQCuQ8F6Fdt1rNeuLSBQjRDB3qSfPm1uPYvUbN2jTO2izQs171e6J9SuxXjCAFaaQYkC9ku2MWCnYR2rkDqV4IoEWG/O5fp3ceS7nuk2Db0YBQS3UVm6xBmztevXsGPLnk27tu3buHOvQU3bgIPflscJ4C3D92/gFNUWgHPj2G+bmhkWWL78xvPjDog/azCdOmsXzrF/dyYgAvUI7Y7bDF5N+QLCM4whM7BxvO77+PPr38+//w4GbhSw0xMQDKCdJAwkcIx2ggMSsQABENLHzALILDhMERAQ0BKE8IUSwYILPjEAhCQ2yMoCClaYmA8NQLhhh5I0oOCCB5rAQI0mGEDiRLfMQhWOI3CXgIYwotBAA/aN09KQCVw4m4wEMElAkTEhIWUCSaL0IJPsySZVlC/5J+aYZJZppgghAAAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zfMhAIw0csAgQDhESCGAiM0NzgsawOolgaQ1ldIobZsAvS7ULE6BW5vDynfUiFsyVgL58rwQLxOCzeKwwHCIQHYCsLbH95Dg+OjgeAKAKDhIUNLA2JVQt4KhGPoYuSJEmWlgYuSBCYLRKhjwikJQqnlgpFsKGzJAa2hLhEuo6yvCKUv549BcOjxgOVhFdFdbAOysYNCgQK2HDMVAXexuTl5ufo6err7O3kAgKs4+48AhEH+ATz9Dj2+P8EWvET0YDBPlX/Eh7i18CAgm42ICT8l2ogAAYPFSyU0WAiPjcDtSkwIHCGAAITE/+UpCeg4EqTKPGptEikpQEGL2nq3Mmzp8+fQIMKHUq0qNGjSJO6E8DA4RyleQw4mOqgk1F4LRo4OEDVwTQUjk48MjGWxC6zD0aEBbBWbdlJBhYsAJlC6lSuDiKoaOuWbdq+fMMG/us37eCsCuRaVWG3q94UfEUIJlz48GHJsND6VaFJ8UEAWrdS/SqWMubNgClP1nz67ebIJQTEnduicdWDZ92aXq17N+G1kV2nwEqnqYGnUJMrX868ufPn0KNLn069Or+N0hksSFCArkWmORgkcJCgvHeWCiIYOB9jAfnx3D+fE5A+woKKNSLAh4+dXYMI9gEonwoKlPeeON8ZAOCgfTc0UB5/OiERwQA5xaCJff3xM6B1HHbo4YcghigiNXFBhEVLGc5yEgEJEKBPFBBEUEAE7M0yAIs44leTjDNGUKEkBrQopDM+NFDAjEf+CMiNQhJAWpE8zqjkG/8JGcGGIjCQIgoMyOhjOkwNMMCWJTTkInJZNYAlPQYU4KKT0xnpopsFTKmUPW8ScOV0N7oJ53TxJAbBmiMWauihiIIYAgAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/8AZo4BAFBjBpI5xKBYPSKWURnA6CdNszGrVeltc5zcoYDReiXDCBSkQCpDxShA52AuCFoQribMKEoGBA3IpdQh2B1h6TQgOfisDgpOQhSMNiYkIZy4CnC0Ek4IFliVMmnYGQAmigWull5mJUT6srRGwJESZrz+SrZWwAgSJDp8/gJOkuaYKwUADCQ4JhMzW19jZ2tvc3d7f4NoCCwgPCAs4AwQODqrhIgIOD/PzBzYDDgfsDgrvAAX0AqKjIW0fuzzhJASk56CGwXwOaH1bGLBGQX0H31Gch6CGgYf93gGkOJCGgYIh3/8JUBjQHg6J/gSMlBABob+bOHPq3Mmzp8+fQIMKHUq0qNEUAiBAOHZ0RYN10p41PZGg6jQHNk/M07q1BD2vX0l0BdB1rIiKKhgoMMD0BANpVqmpMHv2AVm7I7aa1Yu3bl6+YvuuUEDYXdq40qqhoHu38d+wfvf2pRjYcYq1a0FNg5vVBGPAfy03lhwa8mjBJxqs7Yzi6WapgemaPh0b9diythnjSAqB9dTfwIMLH068uPHjyJMrX84cnIABCwz4Hj4uAYEEeHIOMAAbhjrr1lO+g65gQXcX0a5fL/nOwIL3imlAUG/d8DsI7xfAlEFH/SKcEAywHw3b9dbcgQgmqOByggw26KAIDAxwnnAGEGAhe0AIoEAE0mXzlBsWTojDhhFwmE0bFroR3w8RLNAiLtg8ZaGFbfVgwIv2WaOOGzn+IIABCqx4TRk1pkXYgMQNUUAERyhnwJIFFNAjcTdGaWJydCxZ03INBFjkg2CGKeaYCYYAACH5BAkHAAAALAAAAABkAGQAAAX/ICCOZGmeaKqubOu+cCzPdG3feK7vfO//wBnDUCAMBMGkTkA4OA8EpHJKMzyfBqo2VkBcEYWtuNW8HsJjoIDReC2e3kPEJRgojulVPeFIGKQrEGYOgCoMBwiJBwx5KQMOkJBZLQILkAuFKQ2IiYqZjQANfA4HkAltdKgtBp2tA6AlDJGzjD8KrZ0KsCSipJCltT63uAiTuyIGsw66asQHn6ACCpEKqj8DrQevxyVr0D4NCgTV3OXm5+jp6uvs7e7v6gIQEQkFEDgNCxELwfACBRICBtxGQ1QCPgn6uRsgsOE9GgoQ8inwLV2ChgLRzKCHsI9Cdg4wBkxQw9LBPhTh/wG4KHIODQYnDz6Ex1DkTCEL6t189w+jRhsf/Q04WACPyqNIkypdyrSp06dQo0qdSrWqVUcL+NER0MAa1AYOHoh9kKCiiEoE6nl1emDsWAIrcqYlkDKF2BNjTeQl4bbEXRF//47oe8KABLdjg4qAOTcBAcWAH+iVLBjA3cqXJQ/WbDkzX84oFCAey+wEg8Zp136e3Pnz3sitN28mDLsyiQWjxRo7EaFxXRS2W2OmDNqz7NrDY5swkPsB5FC91a6gHRm08OKvYWu3nd1EW8Rw9XA1q1TAd7Flr76wo1W9+/fw48ufT7++/fv48+s/wXUABPLwCWAAAQRiolQD/+FDIKRdBOz0TjgKkGNDAwsSSJBKEESowHOUEFjEY0lJEyGAegyw4G5HNcAAiS0g2ACL+8Uo44w01mjjjTi+wMCKMs5TQAQO+iCPAQme00AEP/4IIw0DZLVAkLA0kGQBBajGQ5MLKIDiMUcmGYGVO0CQZXvnCIAkkFOsYQCH0XQVAwP+sRlgVvssadU8+6Cp3zz66JmfNBFE8EeMKrqZ46GIJqrooi6EAAAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/0Baw2BoBI88g2N5MCCfNgZz6WBArzEl1dHEeluGw9Sh+JpTg+1y8GpABGdWQxFZWF0L7nLhEhAOgBFwcScNCYcOCXctAwsRbC5/gIGEJwuIh3xADJOdg5UjEQmJowlBYZ2AEKAkeZgFQZypB0asIgyYCatBCakEtiQMBQkFu0GGkwSfwGYQBovM0dLT1NXW19jZ2ts+AgYKA8s0As6Q3AADBwjrB9AzogkEytwN6uvs4jAQ8fxO2wr3ApqTMYAfgQSatBEIeK8MjQEHIzrUBpAhgoEyIkSct62BxQP5YAhoZCDktQEB2/+d66ZAQZGVMGPKnEmzps2bOHPq3Mmzp88v5Iz9ZLFAgtGLjCIU8IezqFGjDzCagCBPntQSDx6cyKoVa1avX0mEBRB2rAiuXU00eMoWwQoF8grIW2H2rFazX/HeTUs2Lde+YvmegMCWrVATC+RWpSsYsN6/I/LyHYtWL+ATAwo/PVyCatWrgU1IDm3Zst2+k/eiEKBZgtsVA5SGY1wXcmTVt2v77aq7cSvNoIeOcOo6uPARAhhwPs68ufPn0KNLn069uvXrfQpklSAoRwOT1lhXdgC+BQSlEZZb0175QcJ3Sgt039Y+6+sZDQrI119LW/26MUQQ33zaSFDfATY0kFh2euewV9l748AkwAGVITidAAA9gACE2HXo4YcghijiiN0YEIEC5e3QAAP9RWOiIxMd0xKK0zhSRwRPMNCSAepVYoCNTMnoUopxNDLbEysSuVIDLVLXyALGMSfAAgsosICSP01J5ZXWQUBlj89hSeKYZJZpJoghAAAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/0Bag8FoBI+8RmKZMCKfNQbTkSAIoNgYZElNOBjZcGtLLUPE6JSg601cXQ3IO60SQAzyF9l7bgkMbQNzdCUCC1UJEWAuAgOCLwYOkpIDhCdbBIiVQFIOB5IHVpYlBpmmC0EMk6t9oyIDplUGqZ+ek06uAAwEpqJBCqsOs7kjDAYLCoM/DQa1ycSEEBCL0NXW19jZ2tvc3d7fPwJDAsoz4hC44AIFB+0R5TGwvAbw2Q0E7fnvNQIEBbwEqHVj0A5BvgPpYtzj9W+TNwUHDR4QqBAgr1bdIBzMlzCGgX8EFtTD1sBTPgQFRv/6YTAgDzgAJfP5eslDAAMFDTrS3Mmzp8+fQIMKHUq0qNGjSJMisYNR6YotCBAE9GPAgE6fEKJqnbiiQYQCYCmaePDgBNmyJc6mVUuC7Ai3AOC+ZWuipAStUQusGFDgawQFK+TOjYtWhFvBhwsTnlsWseITDfDibVoCAtivgFUINtxY8VnHiwdz/ty2MwoBkrVSJtEAbNjAjxeDnu25cOLaoU2sSa236wCrKglvpss5t/DHcuEO31z57laxTisniErganQSNldf3869u/fv4MOLH0++vHk/A5YQeISjQfBr6yTIl5/Sxp2/76sNmM9fuwsDESyAHzgJ8DdfbzN4JWCkBBFYd40DBsqXgA0DMIhMfsQUGGEENjRQIR4v7Rehfy9gWE18/DkEnh0RJELieTDGKOOMNAa1DlkS1Bceap894ICJUNjhCJAyFNAjWahAA8ECTKrow5FkIVDNMcgMAwSUzFnCAJMLvHiDBFBKWQ1LLgERAZRJBpVTiQ70eMBQDSigAHSnLYCAj2kCJYCcBjwz3h98EnkUM1adJ2iNiCaq6KKLhgAAIfkECQcAAAAsAAAAAGQAZAAABf8gII5kaZ5oqq5s675wLM90bd94ru987//AoHAYEywShIWAyKwtCMjEokmFCaJQwrLKVTWy0UZ3jCqAC+SfoCF+NQrIQrvFWEQU87RpQOgbYg0MMAwJDoUEeXoiX2Z9iT0LhgmTU4okEH0EZgNCk4WFEZYkX5kEEEJwhoaVoiIGmklDEJOSgq0jDAOnRBBwBba3wcLDxMXGx8jJysvMzUJbzgAGn7s2DQsFEdXLCg4HDt6cNhHZ2dDJAuDqhtbkBe+Pxgze4N8ON+Tu58jp6+A3DPJtU9aNnoM/OBrs4wYuAcJoPYBBnEixosWLGDNq3Mixo8ePIEOKxGHEjIGFKBj/DLyY7oDLA1pYKIgQQcmKBw9O4MxZYmdPnyRwjhAKgOhQoCcWvDyA4IC4FAHtaLvJM2hOo0WvVs3K9ehRrVZZeFsKc0UDmnZW/jQhFOtOt2C9ingLt+uJsU1dolmhwI5NFVjnxhVsl2tdwkgNby0RgSyCpyogqGWbOOvitlvfriVc2LKKli9jjkRhRNPJ0ahTq17NurXr17Bjy55NG0UDBQpOvx6AoHdTiTQgGICsrIFv3wdQvoCwoC9xZAqO+34Ow0DfBQ+VEZDeW4GNOgsWTC4WnTv1QQaAJ2vA9Hhy1wPaN42XWoD1Acpr69/Pv79/ZgN8ch5qBUhgoIF7BSMAfAT07TDAgRCON8ZtuDWYQwIQHpigKAzgpoCEOGCYoQQJKGidARaaYB12LhAwogShKMhAiqMc8JYDNELwIojJ2EjXAS0UCOGAywxA105EjgBBBAlMZdECR+LESmpQRjklagxE+YB6oyVwZImtCUDAW6K51mF6/6Wp5po2hAAAIfkECQcAAAAsAAAAAGQAZAAABf8gII5kaZ5oqq5s675wLM90bd94ru987//AoHAYE0AWC4iAyKwNCFDCoEmFCSJRQmRZ7aoaBWi40PCaUc/o9OwTNMqvhiE84LYYg4GSnWpEChEQMQ0MVlgJWnZ8I36AgHBAT4iIa4uMjo9CC5MECZWWAI2Oij4GnaefoEcFBYVCAlCIBK6gIwwNpEACCgsGubXAwcLDxMXGx8jJysvMZ7/KDAsRC5A1DQO9z8YMCQ4J39UzBhHTCtrDAgXf3gkKNg3S0hHhx9zs3hE3BvLmzOnd6xbcYDCuXzMI677RenfOGAR1CxY26yFxosWLGDNq3Mixo8ePIEOKHEmyZDEBAwz/GGDQcISAlhMFLHBwwIEDXyyOZFvx4MGJnj5LABU6lETPEUcBJEVa9MQAm1Ad0CshE4mCqUaDZlWqlatXpl9FLB26NGyKCFBr3lyxCwk1nl3F+iwLlO7crmPr4r17NqpNAzkXKMCpoqxcs0ftItaaWLFhEk9p2jyAlSrMukTjNs5qOO9hzipkRiVsMgXKwSxLq17NurXr17Bjy55Nu7ZtIoRWwizZIMGB3wR2f4FQuVjv38gLCD8hR8HVg78RIEdQnAUD5woqHjMgPfpv7S92Oa8ujAHy8+TZ3prYgED331tkp0Mef7YbJctv69/Pv7//HOlI0JNyQ+xCwHPACOCAmV4S5AfDAAhEKF0qfCyg14BANCChhAc4CAQCFz6mgwIbSggYKCGKmAOJJSLgDiggXiiBC9cQ5wJ3LVJ4hoUX5rMCPBIEKcFbPx5QYofAHKAXkissIKSQArGgIYfgsaGAki62JMCTT8J0Wh0cQcClkIK8JuaYEpTpGgMIjIlAlSYNMKaOq6HUpgQIgDkbAxBAAOd/gAYqKA0hAAAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/8CgcChrQAYNotImiBQKi+RyCjM4nwOqtmV4Og3bcIpRuDLEaBNDoTjDGg1BWmVQGORDA2GfnZusCxFgQg17BAUEUn4jEYGNQwOHhhCLJFYREQpDEIZ7ipUCVgqfQAt7BYOVYkduqq6vsLGys7S1tre4ubq7UwIDBn04DAOUuwJ7CQQReDUMC8/FuXrJydE0Bs92uwvUBAnBNM7P4LcK3ufkMxDAvMfnBbw9oQsDzPH3+Pn6+/z9/v8AAwocSLCgwYO9IECwh9AEBAcJHCRq0aAOqRMPHmDMaCKjRhIeP47gKIIkyZEeU/8IgMiSABc2mlacRAlgJkebGnGizCmyZk8UAxIIHdoqRR02LGaW5AkyZFOfT5c6pamURFCWES+aCGWgKIqqN3uGfapzqU+xTFEIiChUYo+pO0uM3fnzpMm6VUs8jDixoVoIDBj6HUy4sOHDiBMrXsy4sWMSTSRkLCD4ltcZK0M+QFB5lgIHEFPNWKB5cq7PDg6AFh0DQem8sVaCBn0gQY3XsGExSD0bdI0DryXgks0bYg3SpeHhQj07HQzgIR10lmWAr/MYC1wjWDD9sffv4MOLR3j1m5J1l/0UkMCevXIgDRIcQHCAQHctENrrv55D/oH/B7ynnn7t2fYDAwD+R59zVmEkQCB7BvqgQIIAphdGBA9K4JILcbzQAID0/cfgFvk9aE0KDyFA34kp+AdgBK4MQKCAKEqg4o0sniBAAQBS9goEESQQQY4nJHDjjRGy0EBg/Rx55GFO3ngYAVFuWBiCRx4w4kENFKBiAVuOJ+aYZIoZAgAh+QQJBwAAACwAAAAAZABkAAAF/yAgjmRpnmiqrmzrvnAsz3Rt33iu73zv/8CgcChrMBoNotImUCwiiuRyCoNErhEIdduCPJ9arhgleEYWgrHaxIBAGDFkep1iGBhzobUQkdJLDAtOYUENEXx8fn8iBguOBkMNiImLJF6CA0MCBYh9lSMCEAYQikAMnBFwn2MCRquvsLGys7S1tre4ubq7vDqtpL5HvAIGBMYDeTTECgrJtwwEBcYEzjIMzKO7A9PGpUUGzN61EMbSBOIxoei0ZdOQvTuhAw3V8Pb3+Pn6+/z9/v8AAwocSBCQo0wFUwhI8KDhgwPrerUSUK8EAYcOD/CTRCABGhUMMGJ8d6JhSZMlHP+mVEkCJQCULkVgVFggQUcCC1QoEOlQQYqYMh+8FDrCZEyjRIMWRdoyaZ2bNhOoOmGAZ8OcKIAO3bqUpdKjSXk25XqiQdSb60JaJWlCK9OlZLeChetVrtMSm85iTXFRpMafdYfefRsUqEuYg7WWkGTTk4qFGB1EHEavIpuDCTNr3sy5s+fPoEOLHk063YCaCZD1mlpjk4TXrwtYjgWh5gLWMiDA3o3wFoQECRwExw2jwG7YCXDlFS58r4wEx187wMUgOHDgEWpEiC4h+a281h34pKE7em9b1YUDn7xiwHHZugKdYc/CSoIss0vr38+/v//RTRAQhRIC4AHLAAcgoCCkAuf50IACDkTYzCcCJLiggvTRAKEDB0TIFh0GXLjgeD4wwGGEESaQIREKiKggiT2YiOKJxI0xgIsIfKgCPS+YFWGHwq2oiYULHpCfCFZE+FELBszoQIN0NEDkATWaIACHB2TpwJEAEGOdaqsIMIACYLKwQJZoHuDcCkZweUsBaCKQJQGfEZBmlgV8ZkCCceqYWXVpUgOamNEYIOR/iCaq6KIAhAAAIfkECQcAAAAsAAAAAGQAZAAABf8gII5kaZ5oqq5s675wLM90bd94ru987//AoHBIExCPOMhiAUE6ZYLl0vissqJSqnWLGiwUA64Y1WiMfwKGmSgwgM+otsKwFhoWkYgBbmIo/gxEeXgLfCUNfwp1QQp4eoaHakdRelqQl5iZmpucnZ6foKGioz8LCA8IC5akOAcPr68Oq6CzMguwuAWjEBEFC4syDriwEqICvcg2w7iiDQXPBRHAMKfLD8bR0RE2t8u6ogzPEU01AsK4ErWdAtMzxxKvBeqs9PX29/j5+vv8/f7/AAMKNAEBwryBJAYgkMCwEMIUAxhKlOBQn4AB0cKsWDiRYTsRr07AMjGSBDOT10D/pgyJkmUXAjAJkEMBoaPEmSRTogTgkue1niGB6hwptAXMAgR8qahpU4JGkTpHBI06bGdRlSdV+lQRE6aCjU3n9dRatCzVoT/NqjCAFCbOExE7VoQ6tqTUtC2jbtW6967eE2wjPFWhUOLchzQNIl7MuLHjx5AjS55MubJlGQ3cKDj4kMEBBKARDKZ1ZwDnFQI+hwb9UZMAAglgb6uhcDXor6EUwN49GoYC26AJiFoQu3jvF7Vt4wZloDjstzBS2z7QWtPuBKpseA594LinAQYU37g45/Tl8+jTq19fmUF4yq8PfE5QPQeEAgkKBLpUQL7/BEJAkMCADiSwHx8NyIeAfH8IHOgDfgUm4MBhY0Dg34V7ACEhgQnMxocACyoon4M9EBfhhJdEcOEBwrkwQAQLeHcCAwNKSEB9VRzjHwHmAbCAA0Ci6AIDeCjiGgQ4jjBAkAcAKSNCCgQZ5HKOGQBkk0Bm+BgDUjZJYmMGYOmAlpFlRgd7aKap5poyhAAAIfkECQcAAAAsAAAAAGQAZAAABf8gII5kaZ5oqq5s675wLM90bd94ru987//AoHBIExCPOIHB0EA6ZUqFwmB8WlkCqbR69S0cD8SCy2JMGd3f4cFmO8irRjPdW7TvEaEAYkDTTwh3bRJCEAoLC35/JIJ3QgaICwaLJYGND0IDkRCUJHaNBXoDAxBwlGt3EqadRwIFEmwFq6y0tba3uLm6u7y9viYQEQkFpb8/AxLJybLGI7MwEMrSA81KEQNzNK/SyQnGWQsREZM1CdzJDsYN4RHh2TIR5xLev1nt4zbR59TqCuOcNVxxY1btXcABBBIkGPCsmcOHECNKnEixosWLGDNq3MjxCIRiHV0wIIAAQQKAIVX/MDhQsqQElBUFNFCAjUWBli0dGGSEyUQbn2xKOOI5IigAo0V/pmBQIEIBgigg4MS5MynQoz1FBEWKtatVrVuzel2h4GlTflGntnzGFexYrErdckXaiGjbEv6aEltxc+qbFHfD2hUr+GvXuIfFmmD6NEJVEg1Y4oQJtC3ixDwtZzWqWfGJBksajmhA0iTllCk+ikbNurXr17Bjy55Nu7bt20HkKGCwOiWDBAeC63S4B1vvFAIIBF+e4DEuAQsISCdHI/Ly5ad1QZBeQLrzMssRLFdgDKF0AgUUybB+/YB6XiO7Sz9+QkAE8cEREPh+y8B5hjbYtxxU6kDQAH3I7XEgnG4MNujggxBGCAVvt2XhwIUK8JfEIX3YYsCFB2CoRwEJJEQAgkM0ANyFLL7HgwElxphdGhCwCKIDLu4QXYwEUEeJAAnc6EACOeowAI8n1TKAjQ74uIIAo9Bnn4kRoDgElEEmQIULNWY54wkMjAKSLQq+IMCQQwZp5UVdZpnkbBC4OeSXqCXnJpG1qahQc7c1wAADGkoo6KCEFrpCCAA7AAAAAAAAAAAA",
	log: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAQCAYAAAB+690jAAAAhElEQVR42u2TYQ6AIAiF44ic1CNattXsJQbk1LWYm+gP38cDaZksaDTAD+QCCiFEZlbDxW2Ro5ikc+S5Xq5/AdKCvQFCHdQc6lBJt+iQZC0CxT09H7qdNW7hvQhUa2EOVNs1rcPCuwOV5udxqC1Alpbhe6JDrcM79N8HsvyyLkAtYjqgFdwatBFoz6IkAAAAAElFTkSuQmCC",
	log10: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkoBAwjhoANuA/JYbBNP2nlgH/sYjjdR0uhf/xWIBsEUEDGAgZhO5skl2CL+D+M5DgBXyGEBWIZIOBNwAANecaDc1X2zcAAAAASUVORK5CYII=",
	log2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAR0lEQVR42mNkoBAwjhoANuA/JYbBNP2nlgH/sYhj48PFCCnE5cL/xBrAgEccbgCyZlJdgjfg/jPgDiOMMMBnCF51gyMlUgQAxRQVERNPpYQAAAAASUVORK5CYII=",
	margin: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACO0lEQVR42o2TTWgTQRTH/7ObRFvTNlUQkVIQFRElYq0gCNaPQwta02ySgxK86EFUFBQPxbP0IAqKige9SKiHdjeNVWgPflQQBGvFoIhoEUoREbRpG1tNdnZ8s3U/aCL4lscMf2Z+7+17bxj+Wm5wcIpzHhFCgDGAFsg9LWDSSXR0uVdVtRDr7GxkDsAYGBDxWMzeD7/6jPZta7DY/Ho2l4PW1cVcgJ7NChLw7esX3Hn8Ccf2rYfJLfdyQFVw+9FHHN27DitXrZYBkYjHmS+DrKht2oKxDxMIBVRwS5Bb7i+oikLOUDI5WjY0Y27yDWUQ92dgUAZxzEx9x63hdzjRsRll7gGClMHNobc43r4J9Y0rZEDKQPMA/YYuSMB04QduPMzj1IEoyqaFhaIyBAMKrj/I4+T+KBoiy2VAJLWEB+jTdZHUNMzOTOPa/dc4c3ArpWvBIoBCx0IEuEr6adLr6hsooIFUogpg7ucsrhijOJdoRansAwQVXNZHcVZrRe2yun8Dfv+ax6W+Fzif2kEA7gOorr5kaU0VANUgSTXgZgk9956j+9BOG+DUQAIcXQ2E0E81SPlr4HQBsNDT+wzdh9toy53RAxQC9I6QvovOKJVdkHNQ0xTF2PsJu+JyiEy7jZQBfXKQpMvOtGxsxvxkfvEcLEyitIuZJ7iQ3lMxyn69yiR6b2Ho5Tg6tq+tAPj1irdwN5N5Gg6H27zXKGBZwr2sKMwupvMai8XiyJF0ejfzBZDoCP7fCuTjfwBA/B8gavi6XgAAAABJRU5ErkJggg==",
	marginBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJElEQVR42o2TTWgTURDH/+9tErWmbaogIiKIigelolYQBFv10ILWdDfJQQm96EFUFBQPxbP0IBYqKh70IqEe2t1trEJ78KOCIFgVix5EiyAiImjTNtaa5O1zXup+0ETowLDDn/d+MztvhuGfZYeGJoUQMSklGAPoAxXTB0w5ia6uYk3TcvH29gbmAqzBQanH4+V45OUntO5cj4UW1O1sFkZHB/MApm1LEvD921fcfvQRxw9sQkk43uWQxnHr4Qcc278Rq1avUQmR0HUWqMCWNWu34dX7z4iENAhHkjveL2ickzMUSgI7Nq/D7Jc3VIEerMCiCnRMT/7AzZF3ONm2FUXhA8JUwY3htzjRugV1DStVQqrA8AEDlilJwFTuJ64/GMfpQ40olhzMN5UhHOK4dn8cpw42oj62QiVE0kj4gH7TlEnDwMz0FK7ee42zh7dTuQ4cAnA6FiFAL+lnSK+tq6eEFlKJKoDZXzPoscZwPtGEQjEACHNcMcdwzmhCzfLa/wP+zP3G5f7nuJDaTQARAGievmTpsioA6kGSeiBKBXTffYauI3vKALcHCuDqWiiCAepBKtgD9xUAB919T9F1tJlC4Y4ewAnQN0r6XjrDK19BzYFeBizObAIsmIP5SVR2KfMYF9P7Ki4F9SqT6O/C8IsJtO3aUAEI6hW7cCeTeRKNRpv9bZRwHOld5pyVm+luYz6fH+1Mp1tYIIFCxxbdBCBHPvEXXlgRIH5MDbwAAAAASUVORK5CYII=",
	marginLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACPUlEQVR42o2TTWgTURDH/+9t0piYr1YpfpSCWBARKlYFQdDWSwWp6W6Sgxq9eBEED4KH6FkKigdBPHmSYA9tksZ6qAfRCoKgViyCiBShFBHFNknTxHy8XeclbnaJUftgmJfh7W8mM/9h+H0y09MrQoigYRhgDCAHeScHJo2CZlzeFUXJhkZGOpkJSE1NGWoo1Phhvmw5j998xvD+HfV7OpOBNjrKmoBkOm1QAN++fkH31u34Tr4m9ObHDoXj3pNPOH+sD91btsmECKsqs1WQNjw9ezH3cRHxM4O4Mf4cQtebf0HhnIyhUhMY2NWL4tI7qkC1V5CiClTkV37A37UZBfJVYQGcVMHdmfe4MLwH/s5NMiFVoFmAyVTSoABy2WUE6EE+S4CajkZTGZwOjjuP5nHxRD8CwS6ZEBEtbAEmkkkjomlYzefgCwRRyGWpXB06ATg96yDA7YdvcenkPvj8AUqYQjTcBlBcW4XH60dpLY9K1QZwctxKvsZl7QA8G31/B5R/luBye1AuFQkgbAAFNyde4kr0EFwb3G0A1IMI9UDUKlCcLohquQ4weyABY+MvED91GIqjA5PUg6i9B+YUAJo9U0hI5HVhSg/gBHgwi/jpI/SG/zkFqQN3Tz/mPizi6tkhjCWe1oUkxUwirgtJmpzMwO5elJbmW3XQUOK/pHydoNdiQ6b0W5X4/12YebWA4wd3tt+F+4nEM6/Xe9TaRgO6bkE4Z/VmmttYKBRmz8Vig8yWQKKDWP/Jki38AjkvGyBaGj6zAAAAAElFTkSuQmCC",
	marginRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACP0lEQVR42pWTTWgTURDH//s2HybdJluLIlIKIiKCVKwKgmAVD/ZgTXeTHCrBkycRPEgLwbPmIHgQBC9eNOqhzaaxCPZiqyAIasWCiGARSv2gaJsvE/Ox+5zdutnFRtFZHjM7vP3N7Lz/E/DLclNTq7quy5xzCAJADmZMDoK5KGnnzVgUxXxkaKhLsAHa5CRXIhErnn75Acf3bcM6swlk2VwO6vCw0AJksllOCSx/+YSbj97jzLEdaOpG61uPyLBpy1Ysf/6IzeSpIKKKIrg6yPJgzx7MvVuEzyNCNzgto/ULImMYGzmM1J1Z9O/sRWXpNXWguDvQqAMFxdVvuDH9BmcHd6OhOwAvdSB1daO48hUh8lSQOlAdwISW4ZRAIb+C6w/mce5EHxpNA2tDFeD1MITkbhSoQFjeaBZETI06gPFMhsdUFaViAdfuv8L5k3tRJ4BBAEbbfASQwjJKhTw6Q2EqqCEebQOofC/hqvYCF6L7UW+4AF6GQEcIlXIRwY7OPwNqP6q4Mv4Mo/GDBNBdABH+QBC1agX+DYE2AJpBjGagN+tI3XuK5MghC2DPwASIXj/0Rg2ix4cJmkHcPQP7FAADqbtPkDw1QKFuSw9gInlG75QDW38Kpg4CPX2Ye7toTdwUUdM6RuqAHlNIycRRXL49g/5dvaguzf+ugzUlmnYpPYOLtPlvUm6jROcuPHy+gMED2//vLtxKp2clSRpwbiOHYfDWt4wJ1jDt21gulx+fTiSOCC6+WVLGv1ue1sJPmS8bIKJDEyUAAAAASUVORK5CYII=",
	marginTop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACJ0lEQVR42o2TT2gTQRTGv9lNqq1pm1aQIkUQ9SBKQFuhULD+ObRQa7Kb5KAEL/UgKgoWD8Wz9CAWFBUPepHQHtrdTVqF9uCfCoJgVQiKBy2CiIigTdtoNcnu+GbrJkMToW8ZZvjY+b3HN+8x/Iv05OS8bdtBzjkYA2iDONMGJhaJni7Oqqpmw319TcwDmKkU18Jh9zz98iO627Zidci6lU5Dj0RYCWBYFicB375+wd1HH3Dy8A4Ubad02acquPPwPfoPbcemls0iIaKaxqQKLK5FNKw1rJRFFWhyBSZVoGFx/jtuT7/F6Z7dKFAFngd+quDW1Buc6t6FhqaNIiFVoJcB46bBScBC9gduPsjg7JEQCkUHK6Yy+H0KbtzP4ExvCI3BZpEQMT1aBowZBo/pOpYWF3B94jXOH92DPAEcAij0Ww0BrpF+jvT6hkZKaCIerQL49XMJw+YsBqLtyBckgF/BVWMWF/R21G2o/z/gz+9lXBl7jovxDgLYEkAt6evW11YBkAcx8sAu5jE0+gyDxzpdgOeBAHi66qvBOHkQlz3wXgFwMDTyFIPHu+hoe60HKAQYmSF9P/2jVL6C6IPa1hBevfvkOi6aqOg+I1VAn2gkscTL7N25BcufM6v7YKUTRVxOPsalxMGK5pH1Kp1YnoWpF3Po2betAiDrFbNwL5l8EggEusrTyOE4vHRZUZhrpjeNuVxu5kQicYBJCQQ6uOZhALK05v4CFbESILw1AS4AAAAASUVORK5CYII=",
	maximizeToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABx0lEQVR42tWXr8vCQBjHvwf6R2gwGAw2YWB0qCxaNFhMwjCI4JZNZhXEIILJYtBgFRWMwsBuMBj0j1DYu+fAFxXF7Xzn8X7Ldvtx38/uee72HLMdXS4XdLtdDIdD7HY7UNsPBQIBxGIxlMtl1Go13mbn89nO5XJYr9fQdR3JZBLBYNAXAMcLm80Gg8EAqqpiNpuBtVotu9FocABFUXwxfpRlWUilUmg2m2DxeNzWNA2dTucr5lfV63XM53MwJw72aDRCsVjkN8LhME6n092D7XZbyMQwjLsPC4VCOB6P/Hw8HqNUKoE55/ZkMkE+n+c3GGP8mM1mUalUkEgkEI1GhQD2+z222y36/T4WiwW/5uQ8P06nUxQKhecAmUwGq9UKTn7wEfhENAKmaSKdTmO5XLoDoPbhcOAvfgJxNac+IpEIN3wLQHGrVqt82G878Arx+C6Fo9fr/ebTS4B3HYmYP5NrAK8Qbp/1BOC2Yy+gngHeGXgNlRDAKyORPBEGeDQkicyUjwBuIUgi0/R/A0gNgdQklDoNpS5EUpfir/+MpP+OpRckBED1IJVPf1mSUZlHdaErANLXilLpZbn0jYn0rZn0zans7fkPPSZSXV87MrsAAAAASUVORK5CYII=",
	maximumValue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVUlEQVR42r3O0QkAIAgEUJtMd6yBdLKiIDCi0CD98j7ucQmcVwGyzskLMHNFohlLDNBLOj8BiDh+EQkCttkvwFIKAa6zrcCx9A0wz74BptJXAJyngQZ/cJQx6aOL7QAAAABJRU5ErkJggg==",
	menu: "data:image/gif;base64,R0lGODlh+gABAIcAAOLj4/Dw8P///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAP8ALAAAAAD6AAEAAAgfAAMIHEiwoMGBAAQcXMiwocOHECNKnEixosWLGCMGBAA7",
	menuDropdown: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTM5jWRgMAAAAVdEVYdENyZWF0aW9uIFRpbWUAMi8xNy8wOCCcqlgAAAQRdEVYdFhNTDpjb20uYWRvYmUueG1wADw/eHBhY2tldCBiZWdpbj0iICAgIiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDQuMS1jMDM0IDQ2LjI3Mjk3NiwgU2F0IEphbiAyNyAyMDA3IDIyOjExOjQxICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4YXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPgogICAgICAgICA8eGFwOkNyZWF0b3JUb29sPkFkb2JlIEZpcmV3b3JrcyBDUzM8L3hhcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhhcDpDcmVhdGVEYXRlPjIwMDgtMDItMTdUMDI6MzY6NDVaPC94YXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhhcDpNb2RpZnlEYXRlPjIwMDgtMDMtMjRUMTk6MDA6NDJaPC94YXA6TW9kaWZ5RGF0ZT4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUdUmQAAADQSURBVDiNxVMxCoNAEJyVgB/yFaKIYpHOVMmfbKJVLEQQbf1BfEryA/dSefGyGo5YZOCKZXaGmYUjpRT2wNmlBnAAgLIsN2NkWUZfDYgIRVEgSRJBNk1jlwAAfr2FNqiqSpCu69obpGkqyK7rAAB0GWW86QlMDzhzdGZGXdf6MfN7OfdoTayuRzJuEMcxlrOB3COc72opNiowM9q21ftRFMnCuUc43dQsFgZhGGI5b6Qx6hgV+r7XRBAEMsEKjAS+768msDIYhsFK8An6+298ATGNZjD6ZVlzAAAAAElFTkSuQmCC",
	met: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABdCAYAAADdTYpNAAAAAXNSR0ICQMB9xQAAAAlwSFlzAAAXEgAAFxIBZ5/SUgAAABl0RVh0U29mdHdhcmUATWljcm9zb2Z0IE9mZmljZX/tNXEAAAhXSURBVHja7V1LbBxFEM2RY44cOXJEQrDeWI4cxSTmnyNRdtfGCibil/BPEB9bQvLuOGCFvxDI4o+IkGUhIAIhH3OMxIUjxxxzg+PQr3fXu1NTPdPT353Fh5Ki2J7ZeVNdVa9ede+h9fX1QwdmZ8FvuLDava3R7j420+mtSWsne+PWbG9u4f+b7WT57tXu7QcgDgxgNNvdc/e2e78KoNJK1kmuN5aSi7Mrb9/xvwRReN1heFWjlfxbGTzWutuT6J3eLiw870Kj1bvlBryR4YWIpb6BsDC1IML7Gu1kpwiI2ZX30uPPfpHe9/y36f0XdzN24oXv0+Pnv0rnzn5QuswnxSudXmx25fKdAsC/uIc+svSOBOeh139OH13/Q8sefvNaeuLFH9Ijy1s8kK3ezcbp7szUgIjAj4fKe8xl6XWPvPWbNng5W/tdei1ehGJ5z9ceRLmEW70b9AHnnvhIepMxeMTwIo6ufswA2bsVM3s7uQhXuhx7Zlt6kCsAxw2enQNShBG8zFqCiCxMH2j+qc+8gDduCxe+YUug2oGI7EjjIJawLw+khpeVy/ynu3fVCkRJ0cYzsMiiLmOgTsLBSyNA7tUGRFnO7DOR3sALP5SBf2jwFJQ1WHoPvvaTFyBxXeqNIsScmngQkQkbZ3rXmp1qbGP28SsyKbgGdP7cp5n7INFNLIjIfqBcLrjw0Sc/cQYmCnhaO4bM1NWyMFdMWxpKIatCfGCgktklnSxPDIg6XBjxD7Fv8ZUfs1z41R35/zKLCuZSxKWr0EG2dhT3yV63991EgChjH8NEhg+OZoF2NhaZ9ORLV5WNBVA6AG8K4gOXdqNl6cLsyy1fPCx4rI3XAEy2qSC8Fd5rFBff+CV7rTPJ31FBlM1U8SFyXFh4kbM6UHjmsac/Zz3SdGnT5BIVRI4LSyrngYnAq7lQYZJsqHdHA5HjwvAYn8yDA9KEf9NrRAERXJi29ENxYW5pV6kjEWYmIiZSLoxAH4wLgweTzA0mYkz/Osn14CD2vTDLREDRgjUThKHONPVGlFukv7gTHERou7QjE6qlVcSDdWMj7XjfI4rtUAMC+/8Y3GD/Q9jWgq6KZvGg6cL5r2UdqB0PAw8IjOpCcuGiD+3bVOoekg+N0SiF0IJzx+erDwgMEkqyTIvqWABymVosv6x6+NyXhQpg6AGBIYgbmYQiyHxMELkEk2M2y++mkzIgMIiH3e3xPwa3jQki7Q82O5taHhRrQIBNKjbdFFf6Mq0Uipdu3AGBfnlDRj9iJpV9Ckf6j0XivWxaOPrMJgMCfU8kHZtJAJF6RJl4b9q0cDEgwC5n1GpRQRRLi9JPHfHedaNEd0BgAKKo7sd+EdkxamIhDVaohLrivXMlUWNAgG08xGIrQ0N3m2o4uuK98nc9DgiwPUTImTFBpKJT0TLlxHvXK6lsQGCkp9AYFKH5MDRaBJfVrbRp4cMJigYERg0IkqFjFdw5wUm80LKsS4tznb9xOSCgbMjG4s+0tNCNcVS8Bwtx/dlUAwIjiVRkHN+xRavFT4ps8FyTOOpjRlI1IJCpd+ikQ+jGLEZKTO9P+5DOs/S6ekAgK9gz3ijHhgMAyCl+VVaCbm3pNF4PxLAcD6SFd5UlZVwXXtzNLWOTmFzGcpxwemZAQLUT4B/6gXxla9RgtA3VNGQe9Dohuu7a4v1+sxYdZdfNV8W0mAvx3rcnsiBy4j03nGnb5UEWpkmEMxvx3kdMVA0IlIj3m7ynDHZJVRX2UQDLMkHhfbNkqdiI93Jyw0Po4QYESsV7LmbRUgKJR9WSh9ei8KW0ib4U/I5L8b7KC9A11YCAlngPILhur8qYrkeB4LSVkSM48R73RwkEL0YzgtuhMLtyJZ1pjf4OvUDXIFIMgFll8R4tKkp9TA2da/mgpJjmxHuT6598+arfeCi76X25wEi8h1uXyo1FUqbwnKJ4WhQ+qhhWhKsufU4uGBuYshLvh8sMbq5awrjWcDBeV8osFO8NDCHCZrqN4/TDpVwr8R6lldUOBVHymEoHudnJVu/muKhfC/F+7uz7lV6AMgkaMC/uhYKQ1FK8N/FmVRLU7TXKupB6t/BCOqNTK/HeSUIYbvUocRQkJJrgVJMQtRTvqxqWMH0pAEj1nLKoZuKraqtbbcV7F8mKUsMiTo/kWzLQVE/xvqpxEw14VoAnl70qu3d6axrziTUV702omyiVdMf20NHS2YBee/HeuhOjAlAkW+jx2pOydRfvq1p+vmYzU8JU3Ss9FeK99T36S/dPHE9ocpDb1Ij3tt5us1N/asR727hrs1N/asT7quZyp/7UiPfWcdFiV+pUifc28qfNTn29owsCi/c2RxhU4ueOduprHGEVXrwPldBc7dQvOkzoVAzxPlRX3eVO/cIf4lBx9kgrT+J9yE3qLnfqlx+uhoxdcLyVS/E+ZE3qcqe+9il1tOfoS7wPZbSbM67eeT21TlCjRdUR0FWt2fZ77mxp05eEFN2OjbPzE0HUVWeIVdWDY/DzXGFvefyL1QESWOaDXuQeArOisXmj//PeWnMpueR7G5mOFzJDpRvRQKxq/a8RyYYDX10a3S4Rqg/bE0mCgqiqP0PJEbLpQGKhrRdGAVHWnzSeaujALorr3KAUI8TXBsQ+rcyONYMv+5JqASA3xQYyEeQ4VH/LOll0MStj0uBwtYyjg8hN545Px1of9CaysIpiuj5HLCqI3FgfPUSoskg1PFVEMSgKAF1/q1B0EAsbHWOdIy1+XjKjCDHO+/mJMU02OphzbF3wcyQxV0lkokEcFuMuvyBs7Myvwz4/90SBmJEo8FV1ps0OOcWwuRXqi8AmEkRaU+ryc3hd7b6P5cD69h81irgXv80P0QAAAABJRU5ErkJggg==",
	minimizeToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABrUlEQVR42u2XIasCQRSFz4D7IzSIbDDYBMG4omK0aLCYFsQgLutmk1llxSCCyWLQYJVdwSgIdoOIQX+EwrozoIjvraxP1uGBJ82EmfNx73DvXGLZOp/P6HQ6GAwG2Gw2oHsv5PP5EA6HIcsyqtUq25PT6WRls1ksFguUSiXE43EIguAJgO2F5XKJfr+PRCKB6XQK0mw2rXq9zgBisZgnxo9arVaQJAmNRgMkEolYmUwG7Xb7I+ZXqaqK2WwGYufBGg6HKBQKHwUYjUYoFosg9toaj8fI5XIfBZhMJsjn884AoVAIiqKwUL0jmlpd17Hb7V4DoAc1TYP9SBnEdrtFt9tFq9V6alir1VCpVCCK4o87XgJ4hAgGg+yAXTaeAhBCQO/b7/eO5q4B7iFSqRQMw3AFkE6nYZqmo7lrABr29XqNXq/HzKncAFBRiHK5jGg0ytLxJwCaz/v64Pf7cTgcngIEAgEcj8fbnkbgt3fjOgVe6QvwBfgC/A8A7oWIeymmujajZDLJGowbANq45vP5+82Iazvm/iHh/iXzWjcA7t9y7oMJ99GM+3DKezy/APbIzk7bm681AAAAAElFTkSuQmCC",
	minimumValue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVElEQVR42mNkIBEcOHDgPzKfkRwD7O3tweyDBw/SyQB0Z5NlALIm+hiAz9lEG4BLE+0MINbZeA0gRhN1DQC6uQJmwMEDB9rJNaAdagBRmmhrAKkAAHwSqgHvmpTtAAAAAElFTkSuQmCC",
	minus: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZklEQVR42mNkoBAwjhrAwJg/2XkakM4kU/90xswe2//54a1k6Z64spqBMaXN/L+5oSFZBpw8f56BMa7e8L+JoR5ZBpw5f4mBMaJC+7+hoRZZBpw/f42BMbhIlbJAJFMjHIwawMAAAD+TGcQ3EsqiAAAAAElFTkSuQmCC",
	mobileHandle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAgCAYAAAAmG5mqAAAD7ElEQVR42m1UVyj3fxR+vmZmRkLeIhfGjTKSVaQoQraSkmyyR3b23nuvEhcoIkqZF1IupKwbI8SFvWX8/r9z/P/e983/U258f885z3me5xzh4+NDhH/f4+MjoqOjsby8DBsbG4SEhMDJyQl/PuFPwPX1NYqLi9HV1QVNTU2EhoYiODgY2trafwPEf5CUlMTFxQWGh4dRWFiIq6sreHp6IikpCXZ2dn8D7u/voaSkxP/Y3NxEQUEBpqamoKOjA39/f5SXl/8GLCwsiPb29qCvrw9bW1u8vr5ifX0dfn5+eHl5gbW1NfLy8mBvb/8FEPMVjY+PQ1dXF8nJydDS0sLNzQ3Cw8MxPz8PPT09xMTEIDIyErKyshByc3NF1dXVkJeXx+DgIKysrJheW1sbMjMzISUlxbRKS0uhrq4OoaioSDQwMID9/X04OzvzwObm5nh+foajoyPTI4mzs7P5uzA3NyeiakSL5CsrK2N1JCQkIC6GmpoaqKmpoaGhAR4eHhAODw9FPT09aGpqYu6pqalIT09nimNjY4iLi8Pd3R2INvnCsk5MTHAFcpjozMzMcNWlpSWkpaVhY2MDAQEB6Ozs/AKcnZ0x96GhIcjJyaGlpQW+vr7Y3d1FbGwsFhcXYWlpid7e3i/A09MTGhsbUVVVhc/PT+Tn57OUFBWiNDo6ChMTE6bNAPoRRYL4Ezg+Ph4ZGRksaUpKCjo6OmBoaIju7u4vwPv7O7f38vKCWASuThSlpaV5NuqooqICEue7w+rqKqtAfri7u/NHRUVFNozkpQSQ/AwQP6ysrCAiIgIHBwdwc3P7BpAv1I08om7fgLW1NQQFBeHk5IRzVFJSAhkZGdTX1zMlVVVV9PX1/QZQjmjQ29tbjgHtAblNeSIqv379Qn9//xeAloWcpA80T0VFBc9DK0sCkOMU/+8OpJA4tZienmbe7e3t8Pb2Znq0ojSfkZERKKQMoAoUgePjYxgYGLBRxsbG7DDNc3R0xGs6MjICYWdnR9Ta2spo4kxUaBZlZWU2MzExkTePHKd5hNnZWRHtMOWedpg0pxw9PDygrq4OtbW1UFBQYHkDAwMhiDMkIvvJbQsLC1A3MzMzbG9vcyzEO8/r29zczDdKEF8HkY+PDxwcHNggChlliKoTBTpB5DwpR3kStra2eIFoWFdXV2hoaHA86KDRkORwQkICwsLCOE/C5eWl6PT0lE8IXQiqSDepsrIS4mK8Bzk5OXBxcfl5KukRd6pIJ4auIclKd4lO5w8A7QKta1ZWFs7Pz/lKUExMTU056j8Ab29v7AetKJ3PqKgokCBEVRCE/6c0OTnJhtGloOtBDhO1/94/a9tQuQRAQJMAAAAASUVORK5CYII=",
	more: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXElEQVR42rWTUQ4AEAxD9azO5awEEZZMGVk/rX3pBIRPQT/OeWPHBaCGQcByBmpIoTeJq096wOg6QHpBa/sBZkYCRuCkBnQBfK/wfokbiA2gQGwPiTQhM4/PZFMBl8ZIEY1jPdoAAAAASUVORK5CYII=",
	motion: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAd0lEQVR42mNkoBAwEqnuPy71pBpwFYh1yDEgFIhXQdmrgTiMVANAoAGI66HsRigfbEAo1FQGItiroGwGqCtWM0L9BRK8RgJbC2qINswL/5G8QywbJQwoMoBiL1AciMSCeljUoUcjMYDihAQLNFAYaCNL0C0z4QQA05w2Y3KoEb0AAAAASUVORK5CYII=",
	mouse: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEH0lEQVR42sWXWSimbRjH//bBGIz9wDKSA2tJlik1CiHClBlki4iQA6Uky3DkQJQZGjvJFpLlREwUcyBESY2aoSxNtoSEsXzf/5rMwXxjbN/LVU/v+z49z33/7mv5X9erhJ92gccxJaXLzc/Ozh50ZxUVlZ8EBLhq893dXbS3t2NwcBA6OjpITU2Fu7s71NXV/zeIvwIMDAzg48eP2N7exunpKbS1tZGVlYVXr17h6dOnigdobGxEU1MTTExMoK+vj7m5OWhpaSE+Ph6BgYF4/vy5YgEaGhrQ3NwMJycnJCQkiEf6+/slHK9fv0ZYWBhMTU0V7wEC5OXl4fz8HC0tLejp6cGTJ0/g7++Pt2/fwtzc/GEADA0NsbW1hd7eXvGMsrIyvL29ERcXBysrq4cBuLi4wN7enlRGTU0Nfvz4gZcvX0qFvHjxQjEAjo6OyM/PF4BLOz4+xsjICKqrq/H9+3fY29sjMzMTdnZ2UFVVVTwAjacfHR2VZ75+/Qpra2tkZGTA1dX1RhDXAnBhQlwFQKM+fP78WXJiYWEBZmZmSE9Ph5eX17UQNwZwcHBAQUHBHwFofH9mZkaen56eFt1ITEyEr6+vVIvCAWgs0S9fvqCurg7j4+MC8ebNG4SGhoqCKhyAxgpZX1/Hhw8fMDw8LM8TICIiAs+ePbs9AONaX18vAIWFhdcCXBq1orKyUlRTV1cXISEhiI6OFjl/EACGg1pB1WxraxPBSkpKQmRkJNTU1G4HwH7A2n737t2VAOyWOzs7ODk5kevw8FBa+erqKj59+oRv375JPhBCT0/v/gCMNcuPn5wNGO+Ojg7ZcH9/X0Tq0pT+nXmMjY1lc3bQO3uAITAyMpJNeWLWvqWlJZydnUWESkpKMDs7K+2a95j5/M7OaWtrCzc3NxgYGNw+B34HYILV1tZKqbEb8mRciLnC6YnqWFpaKh2SGqCpqQkNDQ3xxO92awAqG086MTGBo6MjuLi4/NJ/eiE3N1fiTTmOiYm5NllvBcBF379/j6mpKclyxpJXcnKy1DlDU1FRge7ubskVvkv33wugtbVVlI21zOze2NgQhYuKipJkYyg8PT0FzsbGBisrK/J9c3NTwGJjY//o+hsDjI2NoaqqStxKs7CwQFpamgwh1Pzi4mIcHBxIGAICAiREZWVl6OzslM5YXl4ueXNnAC4+NDSEyclJcXdQUJCM5TQmIxOvq6tLkpEDCTvh0tKSnJ5rpqSkSP3fGYB2qWqsd2b0pUt5nyLDUzL+OTk58PDwkOEkOzsby8vL8PHxQVFR0f0A/mZra2u/Go+fn594YHFxEfPz81KOHFgZMoUBUA37+vpkNqT80itUQcptcHAwwsPD/zq23xuAxh5AAWLno/LRE0xIqt5Vc8B/APjjMf+cAo/49/wfSfqZIRoYg74AAAAASUVORK5CYII=",
	mouseLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAl9JREFUeNpsk09oE0EUxr+dpBHBGmptEwK1EBURvFjxIAUPglDqwaNUEDxIL4IKHgqKHiwevbRUT4IUpSBBSCNCD0qJSJUQhSgISaVpjUmaNn93kzY7uzu+CU3ZhB328XZn5/3mzffmKUIIyKEoSstfebj4xKVYj4YG+/A7U8GNERNNUwFjbHpy4upjuaYdg/ZHe+Ly1GLu6UJcfEzkxNfkthi9FxJyGJyL8FJUvJh/l7PHSGNt0NiDyN1zp3z+s6cDqHML5R1jH+xyuzF+6QJ8A33+5/OhO7CNfQCz+K2TQT9KDQMqFwhHU5S2C58+r8AyTViWheHAAHRuTDkCFIWdEbSTqgtoOpBMb2F2cgQr8Z8QFCwBgcF+glkBO8DdfjnSfxg1Q4FpMjChQGEM2c0CajUNFC5PTiDRKaAdUCjWEXn/jQAW5BJLMKQ3MgieCGLudRi1ShWa1oDfd9QZMHZsG9fGL8Lr9VIwQWhTgzKx9jakMqJareHth6gzYJeEU3c5OOpSD5kw9p7WHZE6NHmTMjSdAU1dz2fyJb8UqsfT03FWCeA6R7ZQoiroeccq1NXq8laxjEajAc4NMrPDy/lKVUW9Vl12BCS+x2bSmU3S24RW1yhVo1U66TVVJS1MpNL/kPgRm3EELEVCcRIptbqWo3R1lCtlFEullucGx2o6J0VMyXWOABr6m5ez138l17G2kQejczPqL+nlt5yX/+U6O0Dp6kYWGBoenbh5+5nHc+B876GDULUd6HoztvBq7n727/qX1hWxC9zdzrJ3yI6T9do2Usn+kJnd7fxfgAEAVD9r0kV/tGAAAAAASUVORK5CYII=",
	mouseLeft2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACkUlEQVR42n2Sa0iTURjH/+d93ZyZSFRrzcuCJXQRs+milMQIUZQIL1AGRkEI4QcriVxhNwMJFCXoQh8s6IPVBymXQ6k0m1o0P4SNDGSlpXNp1rzOXd6dzvsuL9ns4X3gOed9nt/5P885BAGjWDQyH+RcaLrKE39FjHIN+oacKNIJcAsEHMdVFhcevDifTJcULcQZ55pG0hOjVLu3qxGukKHs1it01uZD8PnQ3PYG9u8/HCeP5m0k+NskQNZ5Y2niZmVdmi4WPsEPWQiPynozuuoKpCQfgxhfdMIxNl5KlheLQXZ544f8rKT4UDkHwhGYLV9g/TyGK7kqpKfsYlAB1k/9MPdY7f9Il3o3PKG5OXp4fYLYLx49fYeaEzo0t7SivOQ4vAzgdDrRYGxfmMFSI0XVbXRn8hYITD7HFJhMFpzJUaOjw4xrhhJp/9dPBnjWjuUzkCzTYKQer09KFOl+yuGIjoLnCVxuDyadE5ienoVqw7rggNrb9+ih7DRERkayYgbxs8FRwuLAf7GtiYlJPDa9Dg6oulFP8zJToFCEgRCOqaD487E1YUA/5twuNLZ0Bwdcrr4zslefoFIr10Iml4HSxTGJAK/HC/voOLudXkdQwNlL1xuSdsQfjtOosSo8HIH6wEWxeszOzGBgeBRve94/DD7EAwV79mVkd+9PTRA7hiJUEZDOSHMuF+NQvOzuRftzU0pQADO5obLOmrBVG6eJWi89HFGFeHoIz2NweAy9fbb+qopT8SsBELtJm1xUfNqyTRsNTbRSOl1UMTg0io+2ITy4W6v/OmDrWREgalfHaFILj5XUyOWh+ojVYZiadsHjcVsa7t8ss38b7BKfyP8AovHMtcwjluxNMbcxF8TFb6vUC9IlQ2juAAAAAElFTkSuQmCC",
	mouseLeftToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABkklEQVR42u2XYY+CMAyGCwISRYma+P9/HwZDIBoE4e7e5ZbgwkpnOO8u8f3igmv3rCuj9T6+RL8oTwrgeZ7I4W63o/P5PC/A4XCwOjXNfd9XEHmezwOAnR+PR8qyjAXouo4Wi4UaY/7pdCJJcFkALB6GIbVta3WgzfE7PKYoipTdFMQowP1+VwtLxC0QBIGKDEAwFgP0fU/L5VKBPAugI4KN3G43lRtiABjiPEFvarvdUlmWD8/SNKWiKNgo2EBHAZIkocvlMmqw2WyoqqoHh2NQQ63Xa6u/UQA4xCLS0CNiXC5oaDEAzmsqe10A4A95JQaQ3HomgMt8EQC3I/N/1/lvgFkATL0UwFVvgP8HwN1cLwGI45jqup4NAJ92fJLFAKhmmqaZDYCrqv5mDuiLZg6IKV/WolRTm8WmVNpu8lblAFCWIXl0ue0ilGFIPq4cYwGg1WpF1+tVjfFa2gpLc2ENPLR/CgBRQFHJ9QU2IfNRVT/VFwyFtgxCaybqdL7zZb/fi9oz5+ZUcke4vD1igJ/SJ0ySn7BBDep+AAAAAElFTkSuQmCC",
	mouseRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAmtJREFUeNp0k0toU0EUhv+ZPMRqX5ZqiEoXbrrQhQsXogtduHHhwp260IU7RQsuCgVdKF0WfGCFgg8qNQpVqEFFUSmVolCqUtRFrDR9JqbN4+amt8mdO3c8E01JwnWGw7kzc+ebc/4zw5RS0I0xVvYDkZGrynUvBzgw9IWjc0cL5lNZSMWvveg9dkX/U9mDyqAycWfwWWLkzZiSQtCUVAe7nqpPsRX1biqheh9PqiPdzxPVe7T5K6D+weEL29pbQ0cP7wf3+9fh2TUHjnSxtzOMZaMU8vVEL9LSjco+XvmwhdPdEW4HhQ9H2Lj+8BU457gX/Yq05RBIYk/ndnBXnEVVWwe40g2Ht7ZBEgCUUbPfQqTnENK5NSysWDBtCpkiY4zvrgb4q8T4p4WCSz2TzmFuKVUWtyiBgmTgimFLWxM8AZQC+gYiaGhoQEtLMza1tuHtx+8oOQwfxn9oPnw+jmDA7w1g1M+fPo7mpia4Og2KxEeV7aIkOdNl5jAMA09ejnkDpHRQskvImwUwEk+nw/6Sy3ClXBSLAkWh/peCnVxMZkJayEAwUHNZtA7CFlhKZegQO+lZhdW8MZozTFiWBUF6CCFrvJ5fTmexahqjnoDF+dmhWHwRrpIorBbKKWkttC+YJtVFIr7wG1OfJ256Ah7d73+fN/Kx6XiCwrWRzWWRzmTKXjgC0zMJEjH/83V0eNITQM0aunvr1LfYLGbmkqQ8K6uvvR7reVo/qeWqBrC618jDOzsOnDhzri8Y3LCvcfNGmIU12HZpIvLg9qWl+dlxfWlrBK5/ztR8ZLvIGqsOMsl+6WrXP+c/AgwAPQVgQ80KvJAAAAAASUVORK5CYII=",
	mouseScroll: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAj9JREFUeNpsU01oU0EQ/l7+TDRtKTZNDEgFr4J48CDePIqgHqsgHqSXgh48eNKD9iZ6qLQFS0FLSlWKUEqF3krRgwYViqe20lRN06hN8vJeou9n9zmzkvoS3y7D7MzOfjv7zazmeR54aJqm9OPZ+btCyNu8DofDEELg7zp0b2jw/B1et86gZbQcE9MvS/NLK55jOx6P+xM5pdlmP+/7z7CEWkDj03M30v29mbNnTiESjSjfz7KKVzb706neDMVdh2/sAfy2nGtHDqUgXBeQLkZm8ijGT2Akl1e2JyUGsinYjnsrEIDyOZZMJqCY8AQW3xYwdOE4Ft8VlM0A2f6DkEJm/QCRf+clkvEEPEimFFEicK0mlaYUyE9Teu0E+gH2J+J4OPkMfXRL94EEXC+Mp89fkwbGcgvYregwzSYy6b5gAL3ewPCVi+jp6VYpXz5H76P30KUQnkZlDqGm1/Hi1UowgKR6W7aFumFCCzE1/lQ1xYHlWHt98R+A7dg7xXIlw0RFY9G2t3KTUS9g+3tFxQVWoWHoyz92q2g2m3Acl0S0afbXdAONur4cCLD6IT9a+FYmvgXMhkmpupCUNmvTMIgLgfVCEasf86OBAEsLc+91vb6+sVmidG1Ua1VivqK04zrYKJTA+xwX3EhEw8zUo0uf1raw+WWHKqCpKrBmm/28z3F+AK3jN4ayhwdOD14dfhCL7TvZRZ1pmL9g21Z+9snYze2vW2+4YG0Ed35n/rkkR0m6fBcZJJ9JROd3/iPAAPBKWGT4TirwAAAAAElFTkSuQmCC",
	mouseToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABjUlEQVR42u2XW4+CMBCFB+RiBEmUxP//94yBB25BQNw9TWoIS8vUrWs28TxBaTsf06GcOvdv0RvlcAEcx2FNeDgcKM9zuwBpmopJ510BNW9zXVdAZFlmBwBBTqcTnc9ncX+73Wiz2fwAmLaj/+VyIU5ytQAI4Ps+dV33aEN3uRxTgGk7FAQB9X2/CrEIMAyDCCwn1gHqnnueJzIDEFyzAcZxpDAMH2+gKkAdgByHF7ler6I22AAYiPVEJlSBlwLqsqB6vggQxzFVVcVO/dpSRFFEdV3zAZIkoaIorAHs93sqy5IPgPVCHdgC0M2nrIE1zQFM+rMATD4/0/4fACsAc/0pgKk+AP8PYG0nfDnAdrultm2tAeDXjl8yGwBuZuqCfit4AngLNsDba0BuNDYg1uZSmlJJrbNkOslxq7uqDgC2DMUj7baJYMNQfDo7pgWAdrsdNU0jrvFZqozlPLAEno5/CgBZgKlUVbBOqHyY2qfOBVPhWAYtHc1U0NDxeGQdz4wPp5w9wuTrYQO8Sl+iDqiwSnW5CgAAAABJRU5ErkJggg==",
	mouseWheelToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABiUlEQVR42u2XW4+CMBCFB5BLUEiUhP//94iBB28BBN09TWoIS4fBrTEmnicobedjOpRT5/4reqMcKYDjOKIJt9stVVVlFyDLMjXpuCugxm2u6yqIsiztACBInudUFIW67/uePM/7AzBsR//9fk+S5LIACOD7PrVt+2hDd70cQ4BhOxQEAV2v11mISYCu61RgPTEHyD1frVYqMwDBtRjgdrtRGIaPNzAVIAegx+FFmqZRtSEGwECsJzJhCjwVkMuC6fkkwGazodPpxKZeCgCt12s6n89ygDRN6XA4WANIkoSOx6McAOuFOrAFwM1nrAHbWlQDc5/X0gxw830BPhNgqb4AnwcwtxO+HCCKIqrr2hoAfu34JYsB4GaGLui/gieAtxADvL0G9EZjA2JuLqMp1dScJeOkx83uqhwAbBmKR9vtJYINQ/FxdowFgOI4psvloq7xWZqM5TiwBh6OfwoAWYCpNFUwJ1Q+TO1T54KhcCyDpo5mJmhot9uJjmeLD6eSPWLJ1yMGeJV+AB9Tk7A1B0YCAAAAAElFTkSuQmCC",
	moveBack: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABEElEQVR42mNcuHDhNAYGhkwGTDA9Pj4+i4EAYJwzZ87/2NhYhn///sEFmZiYGBYvXsyQkpLCSNCAKVOm/A8LC2P4+fMnXJCdnZ1h1apVDDk5OYQN6O7u/u/v78/w+fNnuCAvLy/Dxo0bGUpKS7FrAiMou6mpCWzAhw8f4AoEBATABtTW1TVi0V+PYkBlZSXYgLdv38JVCAsLgw1oa2+fjMWAXBQDioqKsMaClDIrQ3F251IsBkSjGIAs8x+MGLYTCDdPQgacJGCAOSED7qDrmLa4ToXnnzI2w6ZjM+Aduqq5c+YI4Ups2AzAAFOnTGHAldiIMqCnu5sBV2IjmFRBAF9iI8oAfImNKANwJTZQLAAATrR8kyon97UAAAAASUVORK5CYII=",
	moveBackwards: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABLElEQVR42qXSsWqDQBzH8d9lyBBEJK6lL9An6BN0UkOgm5DBIbQgpAlCI4Xe0ggNUmigxcFBcCtIolOfoE/QN+hqCCIOGbyCa/+2Qv/c9v3fZ7ljURS9ALjC7/M6mUyuqcDCMBSmaaKua/Jmr9dDHMewLIuRQBAEYjwe43g8kkC/30eSJJhOpzSw2WyEpmmoqooEBoMBsiyDbds04Pu+0HUdZVmSgCRJSNMU88WC7MzzvAYoioJckGW5AW6XS05kzjjnwjAMHA4HElAUBbvdDvecPxH5hrmuK0ajEfb7PQkMh0Nst1s8rFYhkS3mOE4D5HlOAqqqNsDjev1G5Es2m83+/EjqaY27+fM7kS5+PI1oDj7Qbc7bgM+OwFkb8NUROGkDio6A3AZ0nn8D36Egbvmf8Kq/AAAAAElFTkSuQmCC",
	moveForwards: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA5UlEQVR42mP8z8AARMQDRjBC4kMNaCBSfwMuA/qJNKAQlwFziTQgGZcBq4k0IBSXATuJNMAdlwHHiTTActHChcj86TADrhJpgPaP79/BDCYmJoYlS5bAXfCESANknj19CmawsbExrFu3Dm7AJyIN4Lt+7RqYwcXFxbB582a4AUSDC+fPg2keHh6GTZs2kW7AieOQ8Obj44MYgEthQ0PDf39/f4YPHz5glRcQEGDYuHEjbgOqqqr+BwQEMLx79w6rvJCQEMOGDRtwG1BaWgo24O3bt1jlhYWF8RtQUFAwDUhlEgiS6QDlDVdMRRvQrwAAAABJRU5ErkJggg==",
	moveFront: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABB0lEQVR42mNcuHDhNAYGhkwGTDA9Pj4+i4EAYJwzZ87/2NhYhn///sEFmZiYGBYvXsyQkpLCSNCAKVOm/A8LC2P4+fMnXJCdnZ1h1apVDDk5OYQN6O7u/u/v78/w+fNnBiNjY0LqIZrACMpuamoCG/DhwwcGO3t7kFgjAf31KAZUVlaCDXj79i2Dl7c3SGwyAQNyUQwoKiqCx0JvXx+IWkrAgGgUA5Bl/oMRw3YCBngSMuAkAQPMCRlwh4ABKosWLoSxp2Mz4B0BA4R+fP8OT2zYDCAInjx+DE9sZBlw7uxZBl5eXoaNGzcyEEyqIICc2GBAQECAeAOQExsMCAsLE28AcmJDA9MBIP5pkzSIo3MAAAAASUVORK5CYII=",
	network: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAv0lEQVR42mNkoBAw4pL4pyDz/y8TE8Ovf/8Y3v7+zyD39CkjSQb8VJL7/z85nuHvuw8Md5auZdB/8Yw0Az7KSv9niQxh+P/1O8OF1VsYbF6RaMB9aen/r/8yMHz995/hNQsnQ9izu6QZgAHqz/xnaDRhhNMkGwAzBATIMgCmmWwDGLBHLUkGYIta4gwAOv9/gzHDJzkZBvSoZcTlNGSNjIwQddiilhGr09I3MSBrxAfACohNdTgNIDbV4TSAEgAAF2KSES1gCxcAAAAASUVORK5CYII=",
	network2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgElEQVR42p2TAQ7AIAgD6f8fzRKHimiRjZgsEnpQdRALbUsEbWWh+n4Bq5/iHgbRoMQUjxQyQNI9AIoWdJ3CWTgXXnPiAaFg6ULFBLD7PMyopkYV0HMY4g8Wzt0TgHIwt/DrBuYEjkjqImTst0NhkPDQrgCfQ/bUSxbugEKwf+UBzJJDDZsByN4AAAAASUVORK5CYII=",
	nodes: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAALJJREFUOE9jYKAW+M3E8B+GSTbzPwPDfxD+0VaH1xCcloAkQJphGMTfu3fv/H379vXv37/fAOQivJbATEZ2AVCjAhAXAA06D8T7sVmC4lVCYYDNEoywgjpZAFcgErKEAejkBJDfcRkAlOcAWjIdbywBDdgOVOiBTRHIcJAleA0AKpAAKjyOroiQ6/AGKFCzBig2QF4gmMiwxTfUWxoENYMUEIxvQqYQFd/EGgIyjJBaiuUBDOrRYmwTjMEAAAAASUVORK5CYII=",
	nonlinearFit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdElEQVR42rWTUQrAMAhD9WTz6O5k3VooE1tr/Jj0p2BegihTsdp4XzEiUtUmItzFr4DnHwZMZ970/w/ocS8R8tFLCSJ3CHASHwF28rcq+ehQgswdApzcQ4CdfDajsAGJvwD8ymbiMEEZYDesIh6AzXnC4l4PMllCD2yRNZAAAAAASUVORK5CYII=",
	normalDistribution: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR42p1TgQnAMAjTy+bp7rINB47SJdquFFokTWKoKsW6ni1yuouZKcLAortfh9n7MIiUYGEx1fNR3JmLTyHUZ9VtB0iRuaAEsyJzAVuIAEcwqv1y0LaAAtxuocsgRSgBs8pyWAJVznQFVLnTLrwu4PanIaJx0DRHVovBYu3EeQNpdHwPZPim9QAAAABJRU5ErkJggg==",
	normalFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB4klEQVR42qWSO2sqURSF14iCaCVoFRsVfKCmSRMtFFKIhdiJjfjAWv+AWNiIlYWSykZsBRERKxFfIHa+GkEULXyRdBbxeTJzLvdyAxNv4K5qzuw53+y99mLwn2LuFZfLJZFKpZDL5cyPAfP5nLy+vqJarWK324EDmEwmRCIRuFwu5i5gOp0Sj8eD0WgElUoFg8GA1WqFyWQCoVCIXC6HUCjEfAtwu92kUqnA6/UinU7j4eGB2e/3tKNEIsGdMRgMoFAoGF4A+wfCjgCfzwej0fin9vb2RpRKJU6nE7rdLqxWKz/gb72/vxOG+VX++PiARqPB+XymgOfn5+8B5XKZlEolDIdDCAQC+u52u2E8HlMfWq0WLBYLPyAej5NkMonr9QqHw4GnpyeIRCIcj0fqCad2u80PYFsjLy8vEIvFyGazCAQCX+ASiYRwIG4EXkAmkyHRaBQcpNFofLnMrpJotVpcLhd0Oh1+QKFQIH6/H4+Pj6jVamBdp7XFYkHC4TAHpd01m01+E2ezGbHZbFiv1zR5TqcTm80GxWIRMpkMh8OBrrFer8Nut/ObyMaXxGIxuoHf4kCpVArBYJCGKJ/Pc8/3c9Dr9QibQKjVapjNZvpNv98n2+0Wer0eOp3u30H6qT4B/tLUEeubKNIAAAAASUVORK5CYII=",
	out: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAddJREFUeNpibF4VOY2BgSGTARVMB+IsNLH/DFgAy8/vPzKzfBpRBKdtqc/EYgADFnUMLF+/fGU4f3czXHDP6YMMNrp+24Nss1EUrzs8dXv3ihJPF1N7uBhIL9OXT58YXr5/DscpPlUMO44u8Vy+u3cbTCGIDRIDySGrBell+vThE8OLd08Zdu7bB6Y3HpvIkBZUw7Bx7zxPmAEgNlgMKIesFqQX5ILpRw+dZnAwCtoOokEmN0zIAPNhBoDYIDGQHLJakAsYHGIFwfj///8MExeVbQOy/4NoEB8Z45JjtAzhZCAHHFv9DUwzMVAKgAkJjEHO2XFu/jYg+z+IRvcCLjlQQgKnxC2n5mw/eWObJyixABOI5+/ff7b5mKV4gSwBym1DlwPxwS4onOr2//6LU/9h9NZTrXA+zBZscjCaWddWtOEP02sGP6t0hiNXlzN8/fGFYfn2uQzWOr7bdZWtloIseffhlfnibb2qgoJ8DA9eXoSrvffgPgOzqglfAw8/G8PNxycZvnz/zHD0+BlgPAdvj/Uq94KFE8igN+9emu88tEkVWe2jB88YGL0zZf6r6MrAAzXIppCha3oxiMmInhvLMnsZ1h3phwvcufyEgRGYOCjKzgABBgA0OmrABy5b7QAAAABJRU5ErkJggg==",
	overlays: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUUlEQVR42r3SUQoAIAgDUHf/QxtESoFFskyiD5EXkyBk4Qmg/YjdAtzDW8B76zD+Ackl6gBgXR6IIkSR6oBUBHsN6lvkgTkCDj+2DkhFYIoGGo3vNBHRIGvIAAAAAElFTkSuQmCC",
	overlaysSamples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVklEQVR42r3RUQoAIQgEUOdmHt2bGUQuy2KQTK5EHxIPZoKQgyuAzyNxC3AObwEz8+9jVcV/QLFEXwBiywNZhCxSH1CKECXCnxZ54B0h+75+oBSBGRoY0d9AES0899gAAAAASUVORK5CYII=",
	overlaysSamples1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWUlEQVR42u3OUQ6AMAgDUHoyODqcjP2YRetIpvJp/5auL0CKuHue32aG1T+0ATzgbAGqOouI6AWqi7YB7n6gAORBbsDbTCBTclnM0IEAmgFhIGl+JXFsPwMDGtVgEWwXfGcAAAAASUVORK5CYII=",
	overlaysSamples1Edit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABNElEQVR42mNkwAEOHDjwH5nv4ODAiE0dI9UMQNeADogywN7eHi5x8OBB6hqAy0VEG4AuRxsDGIgAGlfDGX5wODMwf17GIFvAwMhIjCYYeN3M+p/Bpp+BXcmK4ffDPQwvt9S/hBvw/z8DigvQTX5bz8DAEd7D8G1dJQO7dQMDM78sw8u9/T8QBjCgG4Dgni9mZVCrmMfA9aaJ4dtLboavh68xfGGRe6tUeVeEoBeOpjL/N2ibBdRcysDA/oPh9wcTho9bj/8Xrf3NhM2lGJp5nLIY5OXnM/BL/GP48caS4duWvQzCTQh9OA3Y1cL/3yJmB8O3xZ4MH39/YJDzs2P4svUQg2g9qh58Lvj/Z1MSAwPzb4b7OxczCAhzAjV/x1CP14CFcQx/tCX5gMH/7ZhJ4x97bIoAlJWL3qbhLiQAAAAASUVORK5CYII=",
	overlaysSamplesH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZklEQVR42t3SSwrAMAgE0JmT6dHHk9mST2mhKYFsQl0Z0bcYQiwWl4EEsnTZBgQl5cyxu3MImFl5RwTMvfYS7vNNgPOyAeyxFsC9LkqBEfYXoIfIvFKsIT4W37HNgemvPLP4VcvAAU8yshEIxWWTAAAAAElFTkSuQmCC",
	overlaysSamplesHEdit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABUElEQVR42mNkoBAwUsWA/yAEJBgZGRgPHDjwH5diBwcHRqIMsLe3Zzh48CCDvYMDw8EDBxhg/EFsAFA/0ABGEA9sgIODPcOBAwcZ0A2iigEvpor//8HhzMD8eRmDbAHI0SQYoH3YlYHBpp+BXcmK4ffDPQwvt9S/JNqAd3UMDBzhPQzf1lUysFs3MDDzyzK83Nv/Ax6IjP/BoQgJRLiTIQbxb3ZhUKuYx8D1ponh20tuhq+HrzF8YZF7q1R5V4SgAUdTWRgM2mYBNZcyMLD/YPj9wYTh49bj/0VrfzOhRCM2A1iXOjPwOGUxyMvPZ+CX+Mfw440lw7ctexmEmxBZAKsBILFfR/wZLGJ2MHxb7Mnw8fcHBjk/O4YvWw8xiNaj5h98men/n01JDAzMvxnu71zMICDMCdT8HVc6wG7AwjiGP9qSfMDg/3bMpPGPPTZFAObt7t7qkTlXAAAAAElFTkSuQmCC",
	overlaysVariables: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaUlEQVR42q2RUQ7AIAhD5WT26HAytmWLC3VfK3yYGNPXVmyIY9fh7vlHDMAWYM5JaKv3rB4R0QyQKwA1QTKSEoV7M0DfAlANR2Vyon0LKkCqoMwCnBHz8+EtQcrbvBEwGECfSEh7tDLgAKu5WBFpPfWqAAAAAElFTkSuQmCC",
	overlaysVariablesEdit: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABRElEQVR42mNkoBAwgogDBw78J0ezg4MDI9wAe3t7NKMZUfn/Ue04ePAgqgEUu8DBAdUF/9GNRHPRwQMHqOwCewcHtNBFNRPdRWSHgcbVcIYfHM4MzJ+XMcgWYAQ1fvC6mfU/g00/A7uSFcPvh3sYXm6pfwk3AOhEFFegm/y2noGBI7yH4du6SgZ26wYGZn5Zhpd7+38gDGBANwDBPV/MyqBWMY+B600Tw7eX3AxfD19j+MIi91ap8q4IQS8cTWX+b9A2C6i5lIGB/QfD7w8mDB+3Hv8vWvubCZtLMTTzOGUxyMvPZ+CX+Mfw440lw7ctexmEmxD6cBqwq4X/v0XMDoZviz0ZPv7+wCDnZ8fwZeshBtF6VD34XPD/z6YkBgbm3wz3dy5mEBDmBGr+jqEerwEL4xj+aEvyAYP/2zGTxj/22BQBAAjrhd47ppvjAAAAAElFTkSuQmCC",
	palette: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACt0lEQVR42o2SfUhTURjGn3Pv8mtoLpwfhc7CUktHGcRMsmmlFSvUiEz9x6S0tAhNySKwklKIamRFijVMUakkiSQoktLEAkulWiqIWmYRbfkxnXP3ns6ExjQKn8OBc9773t+97/u8BA7KS0JARjwOB/pgKwgULERAMTRiRMuDFugKbqMT80T+HNou4WC4P69lR1fwAjr47ahwvoLdlqvYab1lS6EmM2rzK5F9txm/5gCeFCElMgTV5kdRRBx1h0tiM+qkWaglx6CmD5HH1iK5HFQQMGMw6E9XIeZ6E77PArYo4XwvH0NUJN4GnQqUIWX7OjDq5oEBuhJhpANOnAWuIStmv2fuG4RgsbZpihHd3guB5O5CVGESWm00q4UH4UXwPMVftco9IZpnQMZNs/e3/ciMP49ykh5Dgi/spx8JAYcFqMU/ENIZCyJGvn7wPcR+0BasP84diAwSyyQca+B/ZJbwKNy0GdMSCQpet9Py8jF/uws5cSQ0Jw41Uie67l8AC8dBqwyDE2tmhr4Hd5qsauKYkKwiniV7qa27Tgsp59ozxM4BVKYjQR2CBsf5cJT+hxQ33iiwXDaJ3I0DKGpEkD0xbBlI41H0CSKWfjZy1XJ3GsHKWe8IqOn0Qm2XHArZNLSa/qHgU1DYAWkqBJ9NwKfuL+RkYhkt3baGuN1Mo9+YO+6UuWoVY2CYHEfXSC+UfpMwTghnNFpabAekqhB+LgHdw0aURJeiMEsNnxPxGGAAl4mpVIyaSlhdInyXhEKgU/1HqqF8rqcmO2BtACT1WRhkVvra7GZ7Fdt+tmeGsT34acyG5+IqyDx0Bt0rLvbiY7EL85t1OZnboVGKDTwHF8e4rQTbbE5bSWfFS6Ron1K9fULndzpTTVYnbyC53h40mo2mF3txzGQh7170oE7XKt5/PwzBMf83oVT6gpyjkXcAAAAASUVORK5CYII=",
	patterns: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVR42mNkoBAwHjhw4D+6oIODA05xoGAbhgH2Dg4MjAwgxMAA4sMMANEwhTA+1IBKFANgCoGS/w8eOAB3AchgGICJ4zQApJkRiU+SC0a9MOoFqniBoszEQCEAAMs98wMavdMDAAAAAElFTkSuQmCC",
	pause: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAddJREFUeJyNk81rE1EUxX/vTSyBgtCd0OBCFKSom6a6E6v9A9KNtP+AH4j+BRpR6Fpw5cKdYN0li7pTQRClWhdqKUI3JkxA/OjU1jSZzNx7XaQtM/GrZ3e455x37ns8Z2ZkcerBqxNDgbvloRxgJVGlJxr2UlmKRW8uXzj7Pqt32YDTDxdrgacSbnRZj1NkexY4GC44RgqQiNWXL01N5wJuvFgtvmxFq987vVJzo8u/MBIYRSQ8QPfI0yuVrgd43lyb34sZIBJHW12pIfvmAdzko8UJM3v97svmf825JtpFVU/6ONW5cODktWtTfL16bpc3L0/y6eKZnKZNgdSY88XAja3HaW6oZqgZ6ce3u1wyHCDxAaTJmDfVURl4SjEQzQRqPzALw6Eqo15UGcROg1yg/SZD1fCi2gpcfiBqZFsNBvYrGKLa8u1EVoYL+YS+IbtSPhDAJzHigxU3fv9ZWVTfNDp5wc6FFY6O/5G7H99QkQlnZhy796TWEatEMrDLX+C2NtFeXI+qM9Me4NBQOltEwv1O9mbuboXyuTELA5/p8N3HNVOrtCmQ+ABju5EZPomxzk/UqEfVmfxnyuLgnYXjiNxWlbJJWlI1xAgFlhRXja6f/5DV/wJ0gjOMaq0XogAAAABJRU5ErkJggg==",
	pcx: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAKElEQVR42mNkYGAwY4CAU1CagREqCBdAFmRAUm3GyIAKwLoY0QVANAAEuwVyeXz5hwAAAABJRU5ErkJggg==",
	pencil: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAhpJREFUeNpiPDo5i8EqZyoDseB+qc51no8PZRn//7sN5Kaw/P/3Fyzx+Qgjw7UL/hgalC/uZhCZ/RXMXjGr77+MjB2DxoeFIK4BEM+BG4ALwDQvB2qW0zZn+PfPlOHG72cMGjd3M/xnZFJl+ff3D07N5jkbwPThOVX/f7AoMggLCzPIyckxnGUoZrj0m5dB9t2Fr0z/cRgA03xqdsF/swBPBmeVJQzHDm9lePToEQM7OzvDEyFDBtXuy+JAF/zGqfnkzNz/BkFhDL8fpDEIMt1gsBT/x3DkABsDG8MvhriMYkaQGpZ/f35j1Xx8auZ/o7Aoht8P0xj+/7jB8OWrKsO3l6IMqv8uMNhnzWWEqWdCdgFM89EpqUDNkSianz3SYfjzixmu+U0qN9QAqAt4bf5DNE9I/G8cHgvUnI6i+fcPoAXZq1E0Y3jhcE/Mf7P4NAzNv779ZbDM3wjWfHJKAAODviskioGY8f9/iM0HuyP+mydkMfxB0/zzyy8Gq8ItCM1o4cUEYmwutDpjElXA8PdZM4rm759+4NQM98LGPFNjRXN3Yy4JI4bf/ysY3r/9AtQsyfDtwxcG29JdeDWDAxGYkMKVnSIZ/ry9B+TyM/DIpDN8e/+ZKM2QQPz7x4Pp9xuGb++eMbx/cofhxv5tDB4dxxnRoxanAe9//NLd1pJ5Gci+A8RbgXjHrydnGDY3xWHVEDzrGgofIMAAtJUTgspUaikAAAAASUVORK5CYII=",
	percent: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAQCAYAAAB+690jAAAAg0lEQVR42u2TAQrAIAhF5xE9qUdsNHA4yZktZoxJUMkPH1+DbbGAbIAfaAiIiAoidsNF9RzlWGdhkHm+X4B6Cz0BqoUlgDynO6RhTIfqzoJWYUvnvWu5pfMm0F0LPb3noGyddCwFqDU/7lBHgCIt020yHZodo0P/faDIL3sFaEYsB7QDJT3CEaCc/7sAAAAASUVORK5CYII=",
	percent2: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkoBAwDkoD/mOR/4/LMlwGMKJpItkAZHmcmokNA4oM+E9IDSMlmok14D8+9YwENKMbRLYBJLuAaDAMDAAA8VAREbrTaDwAAAAASUVORK5CYII=",
	pie: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABbElEQVR42mNkQAL7GBg4GRkYHBwYGLaB+Iwg9B8IgSB0NYPX//8MB9aEM3xH1sMIY+xlYFByYmC4iyYJNwAGglcwKK+NZLiHYsAuoGZXNM24DACBgKUMyhtiIIYwAt3K6cnA8I0BC8BlAAj4LGDg2pLI8J1xCwODpzfUz6QY4DWXwWtbCsN2RqAsVgWEDIAqYKSdAU3SWib1T6+dZSAAsBpQL6Vp0hxQ+/P/tMjLBLRjuqBGUsOkzafqx//ZsVcI2Q42YC4wFpKgsVAhoW7S5VH24/+CJIKaGVMW+v2fk7CZcSYwHQCdUH5HRGVzr0fJj/9L0omwGWhA/Fyu/wtTvoNTYqGQEmO/ZYYWw9ZS4jRHTFP5vyL7LiQiYMA4SYnh7Ny7BHUbJ6swnJ0HVwcygBmIhYFYhIGdn49B3FCX4dH+WRga5RzTGF6ev8jw8+NrIA+Ev8AMYAJiTiDmAmJWAvaDYuwHEH8F4l8gAQAZU3oREAfNfQAAAABJRU5ErkJggg==",
	pin: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAADK0lEQVR42oVTe0hTURg/59zdmc6sNg1XWD5KKkuthWVRUGmWklTaS6woZmmFaQuCKCoiKK2UgaYxCpVCSiRNK3totdJmrVJnTej6ysdwm2654bZ777ltSoL2OvDx/XHO9/t+Dw4E/zv8vch9ncSH5QGTozrDDjflIe7JUfzrGv5tLiitElE34rHvvtJLQ0MWmd1hpyAE15zDt3gxuZCpyeD+CbBd3kqUp4ewK09Wl6ApXsn16g4aMCYSIJQFao6dAhvlEDxN5/4IIEpUIGOZFPvEXZqLHbYX66I3BulH+IyysQlgxsEjSP4qtupQA4otQBMAUFwhxNWHR6kFXtBNFVip59DxI8JqGsAenl7QMEKwJrOZx9hte+iHKaVkvIL4jQEZneNNd+hAZEpqgZ9YlGBjENNFaVFvcy0aNhlecjPDspkfulf4mcw67gERfwuylQc5FHfzBN/N7WJAUDATFbnEk4UkaGrXw4Gur3CQem+3GTojraqbnzzXZCKLMgf/ZuKM3SUNEaHBKwPnzGbn+M2Cyi96RFEUa/ymIqwDHbkj9fJM983XyJHHMnpCjJGnalDDlRgcIL0n27I2/KpAIGBadTSvvXcQG6iPyNyj6bMZu8M5bbl+suRJHvgSq07fub9gXsA2sw3Qn79QUKd9y2MAv4cLjAl1bNh02flI4iw12KU/PAHg7oNaImnrerbmhfJkaaMxWzPsTdsxjzQMmrFl2IQs5qEVOOlMvjT2gETx6LYaJBuWjwMYjIPIWyTEDMtFvHvzWqWqfy2XPfOt8BS5neUAsXSh4LjHh9WcBiAO74hPlNyvLFOPbuWAepxBd4/Ow2YxqWvr6tjUtDQXum3F3PlQJUzwEm7L/xaWEuU9WX9dea0afu/sJPz8/dnW5pbr2jZtZkVVVXhxUVFTukKB5FLp2Kc5IigEgYRLO1i8M0yiudc0xqCdHWOQnZXlJRIKm1s0muyc3Nw8sVg8rb+/n3Eq5AApAADTGLB2DM4LGmft9w/rK+78BM5Zl/3ygAhZtCgYITTfCdBGkuR0mqadw4B1lqu7MneM9kOkMwVuCeBBNcinXSkwPwHqBXK/LIqBlgAAAABJRU5ErkJggg==",
	pivot: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeUlEQVR42s2RAQrAIAhF53aPztLRO45naAyXQZuIiKMNJhEZ+vr+YJkM4K2UQuMi5wwy94JrfwJ43YNPAa2Q4O5bHwGor+tl9grCANksIVMjuB6wvHYm3cD5XuuGiJBSOlwFQ7YGhBRYM8vZQ99oKTBgvolasgmYiRNiV2WU1yoyowAAAABJRU5ErkJggg==",
	play: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAjJJREFUeJyNU01rE1EUPe/NJG1q2zQGNya6UIoYUARbIWAFQSoBhRTcVPFHiK66UKx0oy78CUIX3QjJRrqoi0q1aCliI0ZBRIlTqdKQmq/OZObe62JonSRVPPA2755z7nn3cZWIIIjj76+cDKvQXUP0iAGdJCY43LIcdlcdbt35dnq+EOSroMGp4tWcoXS25GygQjUQCABgQKMfEcRlEC57+dKZ+Yk2g1vWo97ntTefNr2t5NfWd/wLcRpAhMJWorF/+NWFOVsDwLPqytz/iAGgbNRQV9vJz70bcwCgRz9cHzWUznaKc0cfYsgY2NNkK9QEWLLxxXOj2ubWTMnZ6CJdio7hY+oJLg+O7WlSD9twFc3oiOpJVajWRXDFwz6zD7NH7mH20DSiRn9b3TEJypWUFpHEzrSD8ITgiQdPCOOxNF4fe4yLA+nduigBEydM4m7xTgICg4VBQvCYwJUW4DIQ0QAAEobpMa0b0AkCdyUgEEgY8z+WcLPwADVuALEQAEAJQEzrZp2bxX5EEr/Q6DDwUHGruFG4j4Wfy37XWA/gN4eyATK5qENsTMVlsOsJT6svkV68hoXNZSAe8o/+U9c1Ars0pUQEh1cyuSbsbNno+I2y60fW7de6yhCb8pxZm9AAMOwcnIxQ2Bpy+9qZ8b+Im2TJl+1JfxaBZTrw4nwOLNl62IZjEkTJ7sCU7ccmcJ4za+3LFER06ewJkEwLyYh4nCRhEMgixaus5DaPv30X5P8Gpk4xsL5m6uUAAAAASUVORK5CYII=",
	playButton: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAD9ElEQVR42q2WW28bRRiG35092K4PcRw7rtMmassFQi3gFFqBOAghJCQkJC56D2mTCsqV/0HzAwAXJAQqIAshJIRAuUOAAAOlkIq0aUoILapwYwN2fFqvnd31ruNh9uCYNJQmbUcazcr2PM9833wzaw5u23/kkwt+vy/ZUFazHMdN/PbpkRzuQON6D4ef/4weOHA3ZLmF3PKfUDV9monSSx8/J98ZwQuf03137YPS6iAyIKG4UkWxVM51u93Urx89O3P7gokv6NjYHlwravCIBJGwFzwB/i6VoCgNO22LHz6z7bT1BUe/pLtH9yBfVJ1POQ5+n4jADg9UVUWtXpZN0zi1+MHTJ29R8BXdtXsMhRXNYtsC61tCCLweEQIvMpGMVrNupW3il/efym5LcOjY1zQxMopiVbPhnE3n1mU8y5fPKzERh4ZcYaKmtS+pS5knc1sUfEPjiVGs1K0IGJhwjsiNhCPOs0cSEPCLMA0dlXJV1vX2qUvvPXHy5oLJb2ksvgvVhu7AegIXzLnRdClA2TSfV0AoIKJarkGRFTttC+8+nr2h4MHJ72h0eARyq+3AWSeuxFwDOl1grevMsIVsFFm1RcMSRL6LSqmKpqLOgNIUE+U2C6a+p5HoCJpa24Zbq9RNakMtIWF7wLlSOxp3NmURhfw84kMSNFVD4VpZNtpmauGdxzIbBA9MnaHhSAKqYdhgq/MCsbsFJ7wDt0VuFL1GKbVBQwMCwkEBvy/loWnG3oXTj+bWf3Vw6gcaDO9EuaGBWlXjwnsCZ/xXBNcJrEMZj4iQCMXlxQJYFHsvnn6kL0hOnqWQomzlBniRt4GCJWB5Jj2ZG8n6xltw1iNBHgMBglq5hXyuInfMzsTFtx+e2ZCi+4+dpbwvBr1jOnCROCLRFV2XLkvi8xAMhwW0NQO5qxU0G1qa0u70/JuH5U2bnJz6kYr+GNsD04YLPTgb12WuRJIIYgzsFYHlP+r4q9DIWtVz/o3x+RuW6fjxn6gnGMNq2+yDJQfujM5zdFDEYEiAXNNwZclOR2oufV/mpgft4Iuz1BeKoql3NkLZKLIeCAhIRCVYBXzlchWNup5m+Z+ee3X//74v+mX60izdEY5BUc3+6ln3+QTEox52PRCslFaRX1bYaeVSP79yzzy20PqCE7M0ODiM+qppn1ALHhvyIBqR2C1qoJBXZL29lmIrzmwFvPkknzhHQ0Mx1JomS4eIkbiXVQ9QKLArumVmWNWk5l67d9uvz/5l9/I5OhgbBsdKMBjg2VtMRbncnOcISZ1/fTy7XfB/ChKjO9kJbKNaVWSzY9XzofStgjcJksfPXBBFKWmYnYy16vm3HrqtfxO99g+9n58oEoYjNgAAAABJRU5ErkJggg==",
	plotArea: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASklEQVR42mNkoBAwgoj/YESWZkbaGXDwwAEUvr2DA40NQNeADogywN7eHuGCgwepawA2F5HmAjS5UQNwGEAKwDCAJN1QADeAEgAASfVhEZG1w5kAAAAASUVORK5CYII=",
	plus: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVR42mNkwAIYkdhmQHwKWdAMSfIUXpUoAACO3AMGVNEkkQAAAABJRU5ErkJggg==",
	polkaDot: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAIklEQVR42mNkYGAwA+JTDEiAEYkNl0QWhEsyoqvCphIsCQDSFgQ8ykWsRAAAAABJRU5ErkJggg==",
	positionLeftRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVR42mNkoBAwgoj/QMQIZRMLYHpGDcBhwPr16/8HBgaiGIguhtMAkEIQjc0AZHGsBsAUEQIgQ2jjAqqEweCIRvobQAkAAJKCXBFioznAAAAAAElFTkSuQmCC",
	positionRightBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZUlEQVR42r3RMQ7AIAgFUP7iuTg657KDhcQOJaYBiWUxMfAkX1CxsDs4iLoOt/8AEenM3EqAnQ8SAnRI++jy94ac3cBe1kZ4IJzBCkj9wjYwQ/OBIQx45GuLsxlkClMbySG8gErdVDpHEStOWvsAAAAASUVORK5CYII=",
	positionTopBottom: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkoBAwgoj/YESWZkZGqrgAF1i/fv3/wMBARrIMAGmGsfEZwkhIMyFDaOeFIW4AVQKRomikWhgQAwY+MwEATx4sEd7ezfEAAAAASUVORK5CYII=",
	prcnt: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42q2SQQ4AIAjD2P8frXfdYItyMpE2A0U9Fn4LVirGAYOcS/TEAip1BSqRJZCws8QWrumSJLkYBDBNBQOOBdMTtgLnA1kjqLGiJVr1LNgwox4Rcow0WgAAAABJRU5ErkJggg==",
	print: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAmFJREFUeJx9U01IVFEU/u7zvXFkJItEohnIIaRQCkJzUxEKSosCBcGgtm2s1pJYUSEVtGmRSOvANqG1EnSVQX8zIP2IJKYMM85zlHQc37x57917TovJNzNgfnDgwj3nO993DkcwM8px9d3c6dpA1QNDiDZdICJJIefIpOXKWM6V92eunftWni/KCW5M/ZgwNNETM7NI5Gy4qvhnaAINNTqiIQO2VJPT1y/0VhAsbeWDz+Mri0ub+cjH1S3sh2hIx0EdyTMhbnrW11HQAeDJp9/jqzsFvzhzqxPEADGDmDGXyeHymzgAYNmSiFSLyHuHxgH0itvTP89K4i+vF9J+F/NmB4jYJ1mzPZjZHVx5W7J/PKCgiNq1rCNHYma2QqYihuJSSKWQLhAoveLnZKSArWhEP1Rd1ZzI2QCA1iN1uBSt96XvKqivMXAxXIeBzrP4uukibmZhkUAtyWZNEYd3pz3W3YJM3i0qKAvaVRQIYqy7BZzPgSAglQrrklTJu+Vgx5W4M7v43y2YlgOV+AX9ZCukIuiOp1KGJsIeMUzLQeexw/uu0bQcAIBghqcopa/b7nxDjR5OWR7SlrtvcTl05cKFNq8HNQxFQ0ZXyvKw9o/90fmmPYvufihZ0woWPKmGBDOj69XsxB9H9SxbEnIhju3RwT0JDgw89d+Bo42TG8P9vYKZ8Xjqc3BmzV5cL6hI0iluRC7E9yQJNp4AOXbSTSeatkcHCxXH1P5yeoKJejJSwCIBgvAHpiu3KJt4cmO4v/KYytHyYuoUSD1kpdqUkhGpCC4h6THHJIt7G0N938vz/wJ5d32GTG29wQAAAABJRU5ErkJggg==",
	purpleCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQsLchZlPcAAAIxSURBVDjLhZNBS5RBGMd/zzPz+roukXZYP0Dr1koU5Cq4FVHXLlKQJfkNOvQF1st7rIMfwEPEYgi2aygdykOXEDpEgZnowq6igSgkxEqLu+902HXdVaM/DAzPML95/v+Zkbfz87+qtVq3C0McrXKAoCKIyO79kZEYZ+lNPu/+p52dHTeby02ftV+dq59bLG1QLG1S2tikWNqkWNoAIDs9TSwW42Y6/Xg2n399GtCYWGvwvONhrQFAVNnd26O3t5db6fSj3NzcbCvA0nCualGV5kIY1uuJeJz3i4u4MOTJ2BjOuQftAHfUgSJyDDDGUT4oM5hKMZhKNetyImrb9KKmCVABq4pXq1L5vc+fagjA+Z4LnLOcDTjyrAIdRon4hiC5AEDm+z1wEMRn8MRvD7G1A6OGTs8jEvEJkgsM3x1CsWA98DwUS+rONZ73LbhTAGuUiG/xuzoILs0xNDzI/nqFkCqIgAghVfbXK1y9keRF3zvXBvCsweuwBPEcAwMDHOwcUthaJVN4CCEQOjKFUQpbq5S3D+m/nmAy8cG1hYjUc6hVXAtaQE27b08Ia43rp5G8MQYQMoVRvi5/QY2QTPQTxGfqADUE8RmSl/tRT1j9ts7U9sS4qmrzxUEdlimM8mNtBdulbal74mM7lbWVAi9/BuPL5aWsvMpmP0aj0duhc+AcKkKnFXp85dNTQ0jI0GQNgM/PDL5EmNqeGF8uL2UbBrkIdJ/8JFeiw0n+oaPNAH8BdcfZHCX/PaMAAAAASUVORK5CYII=",
	radioOff: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA9ElEQVR42q3TQQqCQBQG4DczPrWWEhjhJpJEWkQHaBFdSDtIdpQWQYuoFh0joo0gbly7K2fAwWhUKB+4EOb//icqgT+HdA5so+hVd3gThqQR4OEwCGrbot3uCyGq8OG0lwcY08DEHqyWayVCVGHHcSSgMQSNIiRJokQ+gGqYACvaKehoCIBDj+ddIK1A2aoV6+toAhb3lFLIsgx8328G3PFUBo2iHRHl46Rp2gwcLwfwJj709L4I8os3lxPHcTNwvZ1h6npi/RJgjEkgz3OwLKse4MOR+WwhgtX1y7DyLaiQ4WAkw7ZtK8PdfolVpA5o/Rd+mTftdoURxG/ARwAAAABJRU5ErkJggg==",
	radioOn: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAzUlEQVR42mNkoBAwUt2Avv7+/7gUFxUWMuI1AKS5sKAAp239EyZgGMKITfOW3RvgCpiZWRg4WDkZHG2dsRrCiE3zhjuzMWyP1inCagiKAVg0/0XGQEN4QIYQa8AvJBqMix16JDQ1NYkyANnmb0D8HYSBBqjiNWD7vi0Ma29OR7b1J5T+AsJAAwzxGrD/8F6GpVf6GGA2ItsOxB+6whfbCQkJ4TYABKCGfIHa+hlGwzRjjQVshkiISMGjQlxcnAGbZuqmRGRDcBlAMC+QAwB3Z6QRz6fzNAAAAABJRU5ErkJggg==",
	range: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAdklEQVR42r2SSw7AIAhE4WR6dDgZtiZNp2CtmlTiwg/zMiBMnbBjMRHjnYgYnrknhiRGQEqp7lW1DUCxhwwBfAne9hIARXsAVZQzqUiwPQUgsyD6DxC6vQJ4JG4B9IZkGBAeudFbswnAGQix2+RnCf4XrkF6iwJmQ8IBoMAIeQAAAABJRU5ErkJggg==",
	ratio: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAS0lEQVR42mNkoBAwDgoD/hNh6H9cljGiSf7HYwBWw0kxAK8L8IkhW/IfXR6Zg89mdBfAxRlxKCLGBRgGMOBTSI4BRIcBRWDUAAYGAA+fJwy2cgT4AAAAAElFTkSuQmCC",
	redCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQxCHwxLKwAAAITSURBVDjLhZNPT1NBFMV/M29e/wCWIkkJOxMJiRJ2ZdNoTBBwYYioGyW4YceCD8CnYMneNHUBtJhiYoASY+I3cOWClu4IGE0IWqB9x8VrS8EaTzLJyZ3MufecmTHvi8Uf9UYjqSBAdEKAwRqDMeb4xdxcim7YLBT0PxwdHWkjn891O2+lsG+5cki5UqVyWKVcqVKuHAKQzeVIpVI8yGRebxQK7/4WaBLnPHz/ajnnAWCs5fjkhKGhIR5mMq/yW1sbnQKOpnNrHdaa9kYQhPXRkRF29vZQELAwP4+kl9cF1JrAYsyVgOeJs19nTKTTTKTT7bq5EbVre7FeW8AacNbiN+qcn/6kVg8A6B+4zS1Hd4GWZ2sg4lniUY/dSB8A07VTEJSMof9miJ0TeNYj5vvE41F2I31Mb28TAXA++D4OmCiV+MqVj7aA8yzxqCPaE6HkYkytrsLSEnUAY8AYLgAWF7m/tsa3lsj65qYk6bz2Wwou9BGk5WVpbEyfQVIgXZ5LlzVJCmvj49LKig5A10LEhDmoWsUkEs2ADFjvuudkEqrVkK/n85KkoNEIu0naA2lyUpqaCnkTOyDNzCiYnVXTwoK11rZfHITX+Fjiy/4+Ghwk1pF4D8DwMAfFIqPwBsiat9nsp97e3keBBBLWGGLOMBC1JJ48IwC+fygAMPj0OQngTvNw0yB3gWSXj3aPfyPbIn8A8iAATPG95vgAAAAASUVORK5CYII=",
	redo: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACS0lEQVR42oVTb0hTURT/3ZS35dRtzVgf0pgsVjQh/VKGFQRJ9aEI6oMZI7DIwhEkRSU0lP6hKMVChJJCQr9EUVBEUIFfooFES4uh8ArcWpFPVzp9znU6b69atqUXfpx7f/ee3z3n3HMFFhjNfWRm08po9NWIyWxnxEIC5+/QcqOELzOzGOFlbctBEVhU4NxtcrE5w9i9VMKytSWAOQ94EUSSuSsM36VDIplV4PQNamBztcqNHNdKIDcXUL4DiTnAVgAEQsBbGVoUntYjIjRP4GQnHXM70FlWCqgJYGIKmEumxXOWcCQmYGQUGJRxn6n9HcdFMiXgvUZONkM7KyEl2IlzzhhKDIiOsf0Gn/+EaJmXQn0b+TevR4NkAOKqvjE2AXz+CtiLOCIW/BiBohWy65R4klHEuos0XL0Jzti0To5+AsJRPOJph82CZyw2oIXc3STkrK/g8ZFatQHS79CDg8BsAjaealVo17LsaRbT/+2DmrOkVlRAItLJ9++4DipsfZeFgkVGSmBfIwXXrEOZwaCTRr731Rs85OlRhsS4ydj+j698t12UpgT2eOlCcQmazEX6jquYCxgBXg/pz1fuBjaWpz1fckX6A7j+wC+8KYFd9bSCzfAqJ/JNhWkRhx34wWl9iPJmROfj/CPkELR6rH7cJcJ/Gqm6jvZarLiXZwEKrdnzneRemBoHxhXUPu0WvRmtvM1DW9ncstrhKGARo0nnZ+LszI5KFGFeHn7ek+6FjM+05QDla53N2MGo/EVrfaA5tfX3itjf538Cg4bAEV0yOX4AAAAASUVORK5CYII=",
	refresh: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAttJREFUeJx9k81rXFUYxn/nzL1z78ydTJp0migZho5FiU2VVpMgiAsFXbhqYzAG3Yrd+A8EaaurLkpBxEVFxF0KUhuC0kgKFaXY6ig1ja01NjFDmg8TzAzT6czcez5cTDNMEHzhrM77/M77PpxHWGtprzembzydisfed4UYdARZZTSVhlqphqpQCdXJy28+P9feL9oBb8/MX3SlOFpYL1Os1Ah1886Vgp6EQz5wqSk9NfvWC8d2Ae6WHvgf/vzXwt3tB9kfVkv8X+UDhz0OK0cC+/iZ0RfrDsDpa4uTq/frLXGn53D8cI7jh3OkPYflco3J22uc+7XIUlWR9UT2u4aZBI6Jd2d/G1LG/nj+9zUAcukE0yPPkEsnMNZiLFhrMcD8+jaj0zcoR5YDcY02ZjjWP/bO53OblQP/1CMApkeepSeI89GVXzj7zXVm5hdxnRj5zB72Bj5Hujwu/LFBhEAYvd/p8mIHi5UaAK8+to+BTAevffoV1xaK6I5ujO/w9cxNzicTDOV6Gcz1sl9dZVl2kzLqoNTG9u24fSiTYm6jxPU7S0T7sqjODKl0GpPoYK4ctVbq82NYpVBa90lldMthA1xdWsfEfYyXBODcK4dIxx1GnuhFW4u2lpTvIXSE0gbZiPQ9VwoAiuU65XrYEgMMP9rJlbEhAifWAtxZ30JoTaTNPblZC2/1JBwALi1t0t/bxZOP7G0BtLUEntsUG/hpcZW10n1kTBIib0lfMpEPXAAqoeLScon+7iQyrD8ENCHm4Tk19S3GTyKjBiqKJuQXo88VakpP5YPmFBcWNvjyz01E1Gj6YprCHdDp118m2Z0hMnZq68R4wQF4KRMfv7xRW8h6IrvSsOigs7XCwGff4xdv7/rOxvWqYXl7/D9hGv5k9qI15ujfSlA1AoPYCQyODpH1avPl98Z2h6m9Bj6eeQqjP7BaD2qtskobQsNKZG1BWXFia2L0Znv/vx0EgHzd5IKmAAAAAElFTkSuQmCC",
	refreshForm: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACiElEQVR42o2TS2gTYRDHZ7/NbrKPbDebhj4CKrWgXgRtFB+tWC+KRy2VouhBLQoBLz7io01KWl/nUnxcFBRRihcPKqj0SQvVi5QWFVSq2GJJNNndJPv83LQ20tItDnwwfDPz+4Zv5k+Ai21vl98YJpx4e9X/GVYwwhUQl1XTnAvHMMbdDgivAKiSAKbTRa8ulj5AIs8pJ7tBFP2+XF7PGobxwbZxkwOZcgNU1Z1/LxPI84ikqAaW5cpoCgCR8wkVFQATk6pmWfiIA+ldDrAmEhvv8TL8nmCQ9jIMQCqFbQ9JoFA5wNcpTS0UzD5NM44JHEENdYgziwCVB5+3rl6/40ZltSBms0ZByeZTCBFiddjPfv+h/gIMp8e6+CfF3N2dyitT05qHksF0CRCJpV6IAWlvLqcoum49AIyjtJf6aZj4HcZw2Gl7duHFxq7cILbMj33twvESoO7C7DTLC8FCTr0zdk2Kzk2hLRsfSQodSz+tsUv9ZJsG2R8Xa0qATWenv3kZThtNCrVLC3YmlLvDCf5k0d+VyHQzHNdaUOVUfyJQVQJsPPPlMSuUh0eT/vqFwq1X5BCJ0EMEeLNtWxU+xnOb57yHbCB5JSO/7I8L+/5Nofbchm0tbT1OB43zxUozQtDDsoyYV3MKSYASDPFSOAzM5IT62zSMo4MdgWeLFilycZzWDWT4fPR9iiLrA5K3rBixLDA9JHhCIYB0CvT0bOb1QELcv+wqRy7JTQRB3JMkjvExgOYunZXUdefktaym6QPYNluGk5LiqgUHsookUS9NU+t4PyVk0mra0YIzTuvWaKf49L/EtOWy7DRCRAkE1xGGmZEkv9ZNdK5q/AuqIRHcdKbT5JbzB/xnByAabFsSAAAAAElFTkSuQmCC",
	regressionLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAYElEQVR42p2OWw7AMAjD4GYcnZtRbRqV2vURkv/YViHm7mFmGiKhDODZd9YSYDK/33JBnhMGAVbmHFwwmyHAyQwX7MxHAGK+FtzMS0DFvC1AzQOAMf8KquYBwJg7gDXnGr6zWA9Os9seAAAAAElFTkSuQmCC",
	removeDoe: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MEhcPMZK7fkQAAAFHSURBVDjLdZI9SgRBEIW/GhZMRQyMDEQw0WQnMNw2MzAR9QaiHkDEQyjGJoogiObmvQeYAyiLR/AG+gyme7amZy1YlnlU1fupBmhIJZBACMmBCE7e4PiVshqAMWnQL0DIL8i/oxf86rFlZksIgKnHYgNeQxmvlOa0sLNjyoPbGDNg5+CxhUZl5z9LwBgnz4fA5+9PEVznv82vgNthSSh1ZV3ZrubWvHUhzAwaRB2nsWsIk2AYVLm7Pzw3ZO2WOqOTEHrRjubtZubOD1bnO3vmkqAI0cwZaJSUhWASMI1xsKZ6cB/Xa1sgYW1ydbYVYxxcx06f2v/7JGa2usnt/iV6vpAkM4MYp/Le82PzSqpz4GNlg5vds26Y9LZ7oRVKMj4CuPv+gvcrwZB5YXQhdDerepEuLcP63oC5LK/EFr3gGOO/CnyFEPgDQeGnEO6lkuUAAAAASUVORK5CYII=",
	removeHistogram: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCBUFLtl8+K4AAACpSURBVDjLlZNLEsMgDEMF03uhoysncxcJjENEQ73JD+QXyRQAIQkkC6aSFPnZrInHzSwQQMTZJNzmKikkLUUWFQAKANSEVd5ELoreEIMgrfkpQvLxsRpjrIjb7AjgPCnne0vlCNCubiRfjakmnr/KEmTskZdJRFJ8HEHHPnLok4mNvBN0xZXbkizJ8KCRILl0+zZ+zoOyOcs9nfy7mMdzpzJtzMd39wogvje5h32/0K0vAAAAAElFTkSuQmCC",
	removeRegressionLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MChUsK0dZW0EAAABpSURBVDjLpZJBDsAgCAT5/6v42fSiplIUNuVk4rIDG8z2wurC3RniVH8z4fWgFJ3+aExK1TzXaBkMMfQySk3oktO0TSTHKWSyBfIv+gpQIvMlo2AJAdYmyW0jXmjZfDehvy/HZiHtTfMASPJevSlK6REAAAAASUVORK5CYII=",
	reset: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAgUlEQVR42s3QSwqAIBAG4L9SKjpHmxbe/xLeJtB8ZCj0IHsZLfpXI8zHOJNxzh1eJPOQMZaEhDAfQkpp1Ki1fg7n5v37h/Box8EWIBBQKr+euJ9mzYCClOlflVKG2jlyD61VqKom1FL00MYdw208Wvccl/oUemBQh0NsQQTbtkNqJlogm4czJ+pqAAAAAElFTkSuQmCC",
	resizeL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAR0lEQVR42pXPQQoAIAhEUb25nrwyKIpMndkJz8VnAtbGGMGqSqWHhW3pw4lFhBnBYYOHvw0/7DZE+GnI8NVQwbuhimcDgu3uM5KV++8QfCcAAAAASUVORK5CYII=",
	resizeW: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAR0lEQVR42pXPQQoAIAhEUb25nrwyKIpMndkJz8VnAtbGGMGqSqWHhW3pw4lFhBnBYYOHvw0/7DZE+GnI8NVQwbuhimcDgu3uM5KV++8QfCcAAAAASUVORK5CYII=",
	right: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABB0lEQVR42uWSMYqDYBSE529yBr2DZwhWnsET2HkAAwkWIoiNoCAI6QKBdFpbWFgIYqediFaiN9DmrQpZNuwWstlup3kM/PPxmP8xvCn22yAB8xI+/A2gLEvKsgzTNIExhuPxCEEQ2G7A5XKh2+0GRVEwjiPCMITv+5Akie0CnM9nGoYBQRBsXtM0qqoKURR9ApIkmUVRPPwI0HWdiqKAaZqY53mby2OoqvoCWOcT8gKwLItc191Cfd+jbVukaQqe59kz+FUr5FsHTdNg6WHzsiwTx3FwHGffBqfTieq6xuPx2LxhGJTn+Vrmvg5s26au6+B53uav1yvFcYz7/b7vF94+pH8KeOoDAZOWEeU1jXoAAAAASUVORK5CYII=",
	rotateAnticlockwise: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACD0lEQVR4nKWTS0iUcRTFf/d7zIzj2Eap7CUYafSgjIIsraRNmYsoBJuY7OGmRUbRC4TEZdQiKsgiqVWbKCuwGokQozaRUEYwSBOKkRtrGopovm/+t02K2uiizvJc+HHvOVz4T8lUo8l1ls+2rWjGsMIWDapvkmlMl5fVxx1gpgUcDbjBkMjVctveb4kIgK2qET8rkazHgKGvWzV2H95PBDgAzQHXmSt2d7FjbRrIZj/ezWSupY0+DcP3QpFl60Wa9qipXQK9o1DzHPonrXE84LbdzA9rUzDwshDK6l130mkHwK4XOf0O9Bb0bYfQ+PCw64baw3np8+G8L3OgYqbAWkXu9EKqHErGPCtfqA6KFPRkvPgG1+mfCTCiuvcIrG6ET+MATykFGDbmTafn+zMBSmFxq8iFGmGgDuYDOEZNJmgMwT+B5tJlKA4L52qUaFjVygfJg93AJctH3xb4WSpEKhvFsnIBFkDLViWWhl8u4IBWwbaTYHFILOkQK/HEIrMOqnIBjsHCNdDcA8Oj4CUgNQhfq6EIgJ3Crleg92C4DtZOBVyBWXHh0Q8wp+BBC1wfgvRKKBvv+yC0nYCzPnhd0OnBMwM/S2BVJexbBEW34fVFaNgMg3GYt2NCG5wB2QLRh/DhM+gI6CjoN9AEpGNwY+mE/sf01zPVQiQFGyNQ4UIoCUM2vKiCZDt40zX1z/oNVVuwItdCCvMAAAAASUVORK5CYII=",
	rotateAnticlockwiseCont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACVUlEQVR42pWTS0hVURiFv33U8FU0MMxMJcmoQYRoUHmhcpKYghaVOCgo6EH2JHJgFnYzMqKSDKpBUIFZUAraxSZGYC9SRBokSJaWmuAgyheZZ7e8htxuGbThcGCf8397r/Wv3/CXtRfCmiF5AjKSIXEcxoagbS4888FQ4L8muHgpJK2E0hOwdT7M/qE9AbB6XkPXRX1bBXfPTW1NARaraAP0PdX7MNQUQloPDL6A293Q7kBEGGRuhPxQ3e4CnL4Jp/yAtTDvDry7rkKdFKvd3GZDY6eloAi+Bt4uB9J3Ql0CxJcbNtdZHprlsKQBXo0JFgNRb2DgKJwXuPYSfAyWKHker0NTr3XeP5div4RK8O2GrBH8FaMyK7INruZDUTBgh3GccMfU5zhOts9OpPsBW+CgNFUOyxhB3CeG6hFL8QHoDyzeA7NewoJt8OkeLGyHD+aXtvgSQ3M/prXT2tJieMsMqwKWpRjjjcOmlVs80208C6GTVLWoT4Z+Dy68AnGRhor1lsJIcKLkmQw95AfsC3XSsk1IS4Pr+sZcm3vLum4woBaqUmH/FxhRFyIE4QY0+gG7jGPWQEe8cReVumQqMM3BgCOQoJzkK0jH1bnYQRgOl2fTEvIMm0osD9SFXhmap9a2BAKqYE6KocZjySqDegVrQKYW/BZlaSo7BicV3/FHurWC1SQto0mwYjVsT4SYami9rELlpPuxOvLHLKyDQgXJq8AkT37USSi+fIZvZ+C+5Hk7VDzjME2ubIiWWRnRkCpAeBf0hGgSPRqma1OzxT8B/7N+AnHBsnKLclM3AAAAAElFTkSuQmCC",
	rotateClockwise: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACRUlEQVR42qWTXUiUQRSGn5n9dv1JJUgq0IoESwKJyqKwCCos0yAxS7oJDMqgH4lCIU1U+iHEMOgikpIMrZsSKglCpTANKkzMIoSiopaibmIz3dlvp8NG0s8qRAfm5pw5zzm874ziP0NFS+4E7fWo3CR0nnJ0mmvVmE/z9KMbbm0yoaFJAZthQY5SLemaxQGPl4Djsa5SkXtha+0L120etXZPY9CM/QVYBZlHoTsRprVp3fHA2qbP1j4bgYQkrdYV+ny70z2euf5Q+J7fumvPBE1oHJALsdugNwsW1ShVkWBt/UVwf9aLvF7VZUx6QYyvOdtxVgwaU9sQNNXjgPkw5zwMdCp1p8baoolEmyEDDsXHdcqWzoAJTR8HHJfEVUhdDu/PQXAiQIHXcYKWli0xvuIhY3IigHxIOaLo8aMeD1tbVQ7PJ7NuodYVZXGxJ54ETWkEIPvuvwCNX8GKYOFuReuIpXwf+KMBlmldWRbjq+szpkQdFs9T4eYu2CDNvIVvUyG+H84WwN4/m3corWO1upGv9cYO62YpsS75MgyPiqXJMGUQPhyEU6vh+ukI7/dYCivrNF3vrH7VCxkqE+bdgkci3BUjIlfDph7F7WFLsYz/8muzaJVVAu2zRLNjisJ2yzV1QNQXQMp6Uf+uWFkmoO2w5A186oNLr8VaDXFeWJMnJjjgrYda0aw66lPOEIisWVUJW2dCYkhyshlWzkN42SA1sbrt5I9U9M9UKlN6IE2eYXYazBbAaAD6Rdz7HRCY9DP9a3wHTdrDDipUP8kAAAAASUVORK5CYII=",
	rotateClockwiseCont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACWklEQVR42p2TS0iVQRiGn/nVMLVoIZgeLyUYtggRDbqciNwkppBFZS4KCrrQxYrKyE5iJmREFyqoFkERZkEpaKIbI9AKUiRaJAgnsswCF1HeKP2n95xATkfd9MG/mJl/nvnmfd8xzFAFEPcdVsdBdhRE+6E/Ajq94L8Fv0P/NaGDUxq/hu3HoHo5pAcWBSBS31f4eR4ev9FaL3ycEbALqo7D2Qmd8gwadFS7C2NpkLUSdqRCfB10X4WStYK0QdIUYKNhU4XlyScYuKthM3SFwm/A/AxDvdeSXwVN6uzbXoGCgN3GMaug12PcxT6XPLXZEa7LUUh5AcWX4eQySBiCkWiwQcD+SCenwER0Nbtuy7hri+5Z1w0HNKiJbDggcUdTYG6M5u5A69QVsmDRNvj8CJJXwJfb8CsUcB0SYwy16yyl2uzESj9pVhYEFIKnwtAxiOnus9ZXDu+ZpWphaYYx1YnYnBqLNwjYAocl3LUR3WkU3OeGulFL+SEYDAdIuDmyOinQ7WmYMCfUTjI074F8bUYujC2AmB64WQwHwwE7jeNEO6ap0HEKWuxkrlkjbx9A37juFA+x72SPgnRRPjdcCfL+LQXMW+3QPmCdDy8h08iSJQpNl0SrV3ASKqGow9DaZynR8T9CN0urXAnXKBc8NYbNjZanpkxJFcCzXsrL57QjApVCTj8MvYL7yuxbR7YpOHkblAPFOuoSnJNmldOiHKhMQdSm7wxsXQjzFOvg67H6FDC/guSTzQ8v/J2aDgjUPp2iKKZP6kWmQ6oA48PQI3E7W2B41tf4P/UHCCa0cqUWC/kAAAAASUVORK5CYII=",
	sampleLabels1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbUlEQVR42sWSAQrAIAhF58n06HqyhsIgTKdtjEmgmT1+JhyTMfNQT0QQ5aMz8Jd0/xgQxd7aCtQjohWJSA/g4wjg1WwrmHMLoKPgFvCPAt+YbQXZJGZzsPxCVVRZChi2rACy+FvA6ydUTbzm5gTMzKwRcHHjEwAAAABJRU5ErkJggg==",
	sampleLabelsH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcElEQVR42r2RQQ6AMAgE5WXdnzX+DF6G1qhwaJVGIqeGLNMh0PKxqNdkZg0DWhgA7RN6Eo9eKWW1lPtHjS0iNQ+QvgJgBupxzkaYax4g/wrAbUCL8bzN8xWigJ7W1ArR4DTgsmjrjd7/GIzq1SAK2AAqZoaHl47u/AAAAABJRU5ErkJggg==",
	sampleTitle1: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAa0lEQVR42sWSAQrAIAhF58n06HqywmAQpmljYxJopp+HCddkzNzUExF4ee8NbJPeHwt4sbUygXpEHEUiUhOwsSdgaY4J5twiUCHYCvxDYAdzTBBtYrQHyy9kRZmFAtmG3kP/jqCNs22EVwQ62tKsEQGCzckAAAAASUVORK5CYII=",
	sampleTitleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcElEQVR42r2RSw7AIAgF5WS+m5neDE5GP6mFhW0xJWWjMTjMC1Q+Fo0emVnDgK1TTxLtHwEcZ611sS43R40tIi0XkBoBMAP1OGcjzC0XkLsF4DKgYjxv87yFKGCkNRUh2jgN6BY90uj+j8FdvRpEASvPmoKH79744gAAAABJRU5ErkJggg==",
	samples: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAA00lEQVR42qWTvQrCQBCEc2jSKYgRPFKIrfj+TyJYaiFGUSvBwhRxFidy/1FcGJJsbr/c7uRU9meoULLNsmlsPQquSQCLayiPQDSKTkEAi3fQyEiXUAEdjVyBwsYCRL4sizTvc76XqBSBLsDqjyHbXTt937wWEoAu7tAKBYfgEAk4Q4MeyNLchTvEMS57aJKANHTCBgS830KzCKQMATStMicvsYHm3wDEpicfH9Dinf44MUy2QIj8NDUXS3FFaOdOeogG5NLXu2djANI6ae8gRQG/xAvi9joRllkWpAAAAABJRU5ErkJggg==",
	save: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAkhJREFUeJx9U01rU1EQPfe+9zS1VYpNFFssCpHEb1RUKBSsqXQZxY246T9w1U0Xbq1EBDcuxJW/oAS6EqOiLZRqwbZ28aSRflgj5qsfSV/y3r0zLtKG16bxwOUu5pyZMzOMYGb48XYxd6PFNEakEBcFEPKIUPZ01lE0V9V6+OHZzik/X/gTjK8WUwFD3s6Uqyi5GrQdEwAMKSAAOJreD57viu1NEPj6Z2N5w/VCmVIV/4NmhqMo+7dc7X7cE66Y25XHXE2hxIdZTKZXsBYfbJqgPfkGz+73hQ4fNMcA9Jvjq8XegCFjS+sOgh1HIdc1cI1BzPCIoYjhEW3/DDnxGR9XCrhy/EjsyWS61yTmRKbcaPvTj2VoYmiuJdEMXD3dWY+3WQYKmhLmAUOGS67eJSZm9IRP7utgB62WgaWNStgkQpD2rLJYUfi2+BuaCZoYigFNjDNdx+ocKQRcrYOmR9Rg/+7oNAZOBUFcmzoxgxh4Ovd9F8/VDNNRlBNA0O9hPlfCfK7UdBMAoGrt5cyypxcMKYLK19/oZQu2bSMSiTQI7814AIC846LFNBakRzQk9qmQTCZh2zai0Wj9+ZFe28Kmp4bkg+iJCUdTSjPjVncHbna2AwDi8XiDaAd5xwUgUq8HLkwIZsarmZUAgGUJhA5ZBn5tVjCb3WwqXq+qLbtQ7ig86q/sOqYX04vvFHGszTLQahmQQtQHlndcpNe2AIjUyzvn+nc0Yu85J6Z+Xnc1j1QUXXKUCrmaASArhZg1pRh+3hf94uf/A8l2VQYGIFQOAAAAAElFTkSuQmCC",
	saveAs: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACDElEQVR42mP0rdjbx8DAkALEDBZaoiwMBMCJa6//QJlzNnc4FzF6l+7+pGSgxgsSmRQlR0g/Q96yR2D63oVbn7d2u/Ixehbt+KRirEmyAXfOXv+8vc+Dj9Etb+snZWMtsAHT4hQY7r7+yXDn1U8MjSpi7AzKouwMWYsegPl3z177vGuSNx+jU9bGT0rGOmADZicpEXRB6rx7EC+cvfJ53zR/Pkb71LWf5I11wQYsTFcl6IL4mbfB/IdnL38+ODuYj9E6YeUnWWM9sAHLczQIuiByyg0w/fjspc9HF4TzMZpHLf0kbawPNiDDRYrBVU8Qp+bdl94zzNjzDMx+evbi55PLovkYjUMXfJIwMuAlaDUaeHHuwuezqxP4GPUD5nwSNTQk2YDX589/vrghhY9R22vGJ2FDI7gB3VFSDMribBga7r78xRCXtYJB3MYOzH97/tznq9sy+BhVHCZ84jM0gRuwq1qNwT59B4OimjSDhaYokhH/wSQjEMLAjoM3GBgVbHrAeYHX0AxsyP56DQbb1B0MkhK8DDYi5xjc3D0YZGRkgdr/o7hIkJ+PwTN/O8Q4WYtOsCE8hua8h5u1wAqCKg4yZLn8ZQgOCWb49es3hpfYWFkYrGJXINwjbdoGNiQ7zpgdxN96+h2bi8J1hpCQEAYdXV2sAWkUMg/JQ2hAyaHvf3KSC96YWLH2BAMA5+ex+TA3+7wAAAAASUVORK5CYII=",
	scatter2d: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAfElEQVR42qWSURKAIAgF4WRxdG9GVmBgQyHx44zK+lzF1hpDLyJCKNTZdECWAAws3YgjwUaKFBCzTOArYCRYAdgrZB0wXKcigNuXdhAC5gTRxvQrPABGWM3BFyDrwBDd64QJYhcTwCe4F7MypwS5z/PTQQCoNA+AliZZGXdUkHaPFrbwnwAAAABJRU5ErkJggg==",
	scatter3d: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAkUlEQVR42p2SCxKAIAhE4WRxdG9Gpml8QhyZZrR0X+sKllIYahERgiluD0BdQLlPzpvo+ZAB5D45frSLugrBgYZYOpiASVYA5vcFLSR2oI7gAUcZ7JRzYINzP+C+PrJyDqLkxdVowKoPptiI1BGiDGLbOuBfB+tQDcAKVnmkt9DF11jCLYBtkqgLtwAnlfZ6Nt7cXMJM2yxC4gAAAABJRU5ErkJggg==",
	scatterBubble2d: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVR42p2RYRYAEQiEm5s5upu1ZENrCf3xpPnemBBjZEoVQgCdFJPoRJQhAnibVF7SG6c7sAQYBwNAZ1sfRAboOLDiPwi8DFyAcXAD+DpQQT+0n8EEsCo3Awm2boS775T1uhl0JB57gO/AA1gHOgTkLGwOWw4awHdxnMFkCwq4EVeAljo5OR/g7IKL69CFuAAAAABJRU5ErkJggg==",
	secondAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaElEQVR42u2PUQoAIQgF9WR5dD1Zm0Igu2La9z76CO0NEzLzhBUiQmhk2gGwkkJuAKuAmBnsXbQvGZwAoYEv+ZQN9D7GsEciAlcGEeBt0zbwsw1oGUSA3yAxgENSg2o+Bp2yfYlIy/gAeZq4AZtXqz8AAAAASUVORK5CYII=",
	secondAxisTitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVElEQVR42mNkoBAwUmzAgQMH/oMYDg4OGIbB5LDJ/wcjWhiArAkZkGSAvb09WNHBgwepZwC6a0g2AFls1AA0A/AlHlwAOUopzwvYBPG5Aj1BUWwAAP+jk/0+0qb4AAAAAElFTkSuQmCC",
	segregate: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaElEQVR42r2SUQrAIAxDm5v16L1ZxkDRdS12A+2PoOSZhEKKY2ZUVfh7bAd0YT8pwibEEjD/mgLe1shmDhFsH2A8UDKAj3jryoBszgFGV8+OEGWbMy4BFZu/AdEifXbgV/lsBA+ISr4ASBWIEZkwgZIAAAAASUVORK5CYII=",
	selectAll: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABWElEQVR42mNsXB7+nwEIfE3TGDafnsWAj10fuZKRAQ0w1i0J+R9gkclACGw4MZ2hKWYNpgHn7uz9T1A3FBipOGMaEFSk+r8mawZBzS3TMhjW9d3GNMA3W/5/Y+E8ggbU9ycxbJ76kAZecE4Q+d9ds5Kg5nOHHoPplKQEFEMY7aMFwC7ob1zLUFgfzICLHes8gUFVTYXh9q07KIYwErQaCqZOn/k/JTmB4eLFSwyXLl+FG0K0ARMmT/0fGR7G8PnzZ4a3b94wXL56DWwI0Qb0TZj039/Pj+HTp48MvLx8DC9evmS4ceMG8S7o6Zvw39PDg4GNjY3h9OnTDE+fPWNgZmb+QLQB3b39//V0dRkePXrM4OzsyDBt+vR5PV2dk4g2oL6heR8nF5fj169fzsVGRxmtWrP2SU1VhSzRBgCBMhALAPHnSVOm3/z8+QtDdWUp8YGIBoyh9FkAkdmNuM38c64AAAAASUVORK5CYII=",
	shadow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAV0lEQVR42mNkoBAw4hD/j0XMDIhvAfFHogw4cOAAnOPg4DAEDMDwMx4DsAbifyBACDIy4jIAHdwixQB0YEaSAejyowZgMYCBdIBigCkZBjAgG8BPpgEMAKpwZLa/jK2kAAAAAElFTkSuQmCC",
	shapes: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVR42mNkoBAwgoiGhob/2CSB4oxEG1BfX48i0djYOBwNQA4rmBzRgYhuCcwCgk4cPAbgDQN8GgjFBCM+zSAnE4pORnya0f1LlAHY0gQ+Q3AmFDxeY8RpADkAAKJSXhFNrWAkAAAAAElFTkSuQmCC",
	shift: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAkElEQVR42u3X0QqAIAwF0In//8lSiBg25karXMH1zVnuOEswUWsbxbSUevJSytLMOecmqIDVyUcEAAAAAMAJ0E8n3vi4BJbGeEzqH4DZ5GNcA3hBJkCa1KoOf06LuQBaUm271ArMVmjt4aMAreRWklcAV5LcBnj+gt99A9I73zoJAQAAAADCALUTeTklCrye74KNFhLsjdcFAAAAAElFTkSuQmCC",
	shiftToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABP0lEQVR42u2Xv4qDQBDGv0V9FYvUQkpTWQqihY2VYCnkAaysRbAMpLKxUMTWzlLwCfIqKp4RBM8Tc/HOmOOcZndm1/1+zP7BIU1rVVXB8zxcr1fcbjfc/TWMpmmwLAtd12GaZueTsiwbURSRZRkMw8DxeATDMKsAtFrI8xyXywWn0wlJkoA4jtNYltUBcBy3ivDYiqIAz/OwbRvkcDg0giDAdd2XiPd2Pp+RpilIuw+N7/tQVfWlAEEQQNM0kLbfhGEIWZZfChBFERRF2QF2gDcCkCQJFEVNTq7rumv78d4f2tTYODb04zj+DHB3phYffjQH8CzQtwGmFn2UnfG8qVivuQhgTnRuu2YzsOQM/DrAXMofiawC8IzIjwGW3II/dwaG8S+3YPOXcAfYAf4vwOa/5ZsXJpuXZpsXp1uX5x82oLBONRRgDQAAAABJRU5ErkJggg==",
	shiftZero: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAmUlEQVR42u3XYQqAIAwGUD2g4FEFD1gpGDXmRlau4PNH4Sz30hT0bisppcUZlBij9y15CGFq8pxzvVfA7ORHBAAAAADACdB2J1poOwfm2miMq++AXufHuAQYBakArlNtdOhzUmwIICWVpkscgd4XanP4KEAaci3JK4ArSW4DRlbB7/4B7p1v7YQAAAAAAGaAUjE7nJaL5fF8BZhDWfLStDLUAAAAAElFTkSuQmCC",
	shiftZeroToolbar: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABNklEQVR42u2XMatFYBjH/4qvYjArI5NRicFiUkblA5jMUkZlshhIVptR+QS+CuVySp0rx7nn3ItT1396n/d5e/+/nudNHmIY1fc9giBAFEVo2xZTvIdIkgRN0zAMA5Zl3WKi67pBkiRUVQXTNMFxHCiK2gVg9EJd1wjDEIIgoCgKEJ7nDY7j3ABYlt3FeKmmacDzPFzXBcEwzCCKInzfP8R8lm3bKMsSxNiHIY5jaJp2KECSJNB1HcS4HtI0haIohwJkWQZVVS+AC+CDAGRZRp7nq4en3KQ5P8f3Wsst9+7jaf0NYGm2dskWwKtAPwZYu/RZdZbnHlX3bYAt0612bVbgnTfw5wBbJX9msgvAKya/Bnj0Bg4DOOINLNv6WV/CC+AC+L8Ap/+Wnz6YnD6anT6cnj2efwE7V6ROPOOEaAAAAABJRU5ErkJggg==",
	showSelected: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbklEQVR42uWR0QnAMAhEdTRHchJHcjRbSg0mMaD97f0YA/c4FSFIVY2IEBrCaFxrGeAQf3dS4GpMQKMXEWDmCV5O8I41eb7swFJA4QqW/OEGOCnE936MWd62Q6K5BTipA7DMWwVY6r7LjwAPJGNc45VSEVlc9M4AAAAASUVORK5CYII=",
	sizes: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXklEQVR42mNkoBAw0s2AhoaG/1CaEacBIEXoCmDi9fX1YHZjYyOKIYzoitAVEG0APhcQ7QWaBiJBA2BOxOZMZDl0eUb0QEIPKHQ5dPlBYgC+MCDaAHyAYCBSJRrJBQBmo2YRZDBVxwAAAABJRU5ErkJggg==",
	smallerFont: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABuUlEQVR42qWSv6u5cRTH358sSn5uYjNIGQwGgzIyyiA2NmVmIQOTkslgQwoDGYiBP0CZJEoWSkJKwiBx7vM8917363sHT93TM53POa/nvN/nMPwxmNjC/X5P8/kcKpUKJpOJvQUQ97Gv90wmQ+l0Go/HA6fTCQ6HA/l8HgaDgbF3zcVikQKBAGKxGHw+H2azGfx+P5xOJ9rt9g/gu+nfZj4GgwGt12t4PJ5nzuv1Uq/Xw+FweAV8afo1FQegQqGA7XYLmUyGer2O2+2GxWLxG/A/pFKpUDAYhNFoFMZWKBQol8u4Xq9YLpfs7Rb0ej1ptVoMh8NnLeeBIIHbzCtgtVoR1/CSU6vVZLPZ0O12hXyn0yHeRJ1Oh+l0+gmYTCYUiURwv98FbdlsFhaLRXhLJBKUTCZhNpshkUhwPp+Fde52O1wul09AtVol7u/gICwcDtNms0Gj0XhOUqvVqN/vQy6XIxQK8eah1Wohl8v9SOCPhVsLRqMRpFIp77SoKxWK3G43KZVKlEolFo/HiZOEZrMpHmC328lqtcLlciEajQoGfZsmCjAejymVSkGj0QhmHY9H/nTFA/4SHyK+0BHbAaTZAAAAAElFTkSuQmCC",
	solid: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAKklEQVR42mNkoBAwjhowWAz4z8DwC8pnBeLfxLKBmtmoY8DAh8GoAZQBAMGQDBFxscZKAAAAAElFTkSuQmCC",
	sortAsc: "data:image/gif;base64,R0lGODlhDQAFAIcAAGGQzUD/QOPu+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAEALAAAAAANAAUAAAgbAAMIDABgoEGDABIeRJhQ4cKGEA8KmEiRosGAADs=",
	sortAsciiAsc: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABj0lEQVR42mNkQAIq07T+38m6xsiAH/wHYrgaOMN9nu//y+9OM7gzezLML5zPSLIBatNU/v//yczw/dknhifdz0k3QLFL+f/9sruMAhUC/z90fCDNAP1+/f/fGH4waP6VZzj38jKDpIAgw+lqnGGBaQDMdpggAVegGmA6zfT/40e3GQLFAxmmAwNPplTy/xfm7wyKvyUYzvfeYCTKBSQCTAN2FSz7/+3bdwZ+QQGGj+8/MPCfWcHAHJXDYFfiT5wL9ieU/Hdc0ANmHxLW+M/KcoPB8iUD8YEIA+fjp/5nOpLN8LxtB4NHuAeKXFR29X9FRS2G1pJohuopWxmO71vHsG/dXEYURccZRP7/MJJjcDx3DsP2KUuP/c+JtoLzi3u2MvSWeCMM2OXe9J/3Qh0+pzMYWnr9P398G4OmoSXD9fPHGeFeOF6/9T9rozfDt56N8IA74p/032bjPEZsrgB5oTXHG2HARWDAPFRnYGA2CGfgun2bgevzOYY3RuEM3itXYrgmKLn6/7q5rRSlAxQAABkZoxGHfMLfAAAAAElFTkSuQmCC",
	sortAsciiDesc: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABjElEQVR42mNkAIJdBcv+f/v2nYFfUIDh4/sPDPxnVjAwR+Uw2JX4MzJggv9ADBcHM/YnlPx3XNADZh8S1vjPynKDwfIlAzbN2A2AgfPxU/8zHclmeN62g8Ej3IN0A44ziPz/YSTH4HjuHC7NuA3Y5d70n/dCHT6n4zbgeP3W/6yN3gzfejbCA+6If9J/m43ziAvEi0DBh+oMDMwG4Qxct28zcH0+x/DGKJzBe+VK4gwgEeA3QLVB+//thqukByIIuPTY/7/57RmDPb8lw5L8RaRHo26r1n+mz6wM715+YXg8/y6KXFR29X9FRS2G1pJohuopWxmO71vHsG/dXEYURTDnS8TI/X+x5BGK3JS1x/7nBFvB+cU9Wxl6S7wRBhh0mf3//+4ngyy/FMPFW7cYhMR5GC52XEQxxNDS6//549sYNA0tGa6fP86I4gX0wMPqiqVAV0Rbgb3QmuONMMCqy+b/rYe3GXxVvBjmF85nlE1U/v/7928GIX5BhmtTUV0RlFz9f93cVorSAQoAAKl0ohGYMVbuAAAAAElFTkSuQmCC",
	spaceCloser: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkQAP/gYiRgYGRAQdAl2fEpgAqQZQcI7IEOkBWiEcNFVxA1TAgFYANOHDgANx/Dg4OjKTwRw0YNYAqBgAALTushTpA2asAAAAASUVORK5CYII=",
	spaceFarther: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAR0lEQVR42mNkQAL/gYiRgYGRgQBAVseILAgVIMoAmFpGZAFkgM0gHOqo4AKqhAG5AGzAgQMH4H5zcHCAG0qM+KgBowZQxQAAZMaEhWR+B8cAAAAASUVORK5CYII=",
	spaceWidth: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAPklEQVR42mNkQAIHDhz47+DgwMhAACCrY0QWBNHEGgBTy4gsQA6gjguoEgYUeeE/GMEFGEnkjxowagDlBgAAKXdzPLooT1UAAAAASUVORK5CYII=",
	squares: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVR42mNkgAAzID4FoxmhDAYkQQZGBiwAr0oUMwE+RwZy2K6eDQAAAABJRU5ErkJggg==",
	squigles: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAIElEQVR42mNkQAAzID4FYjBCOTAAF8QAjGjasQqCtQMArjADPAqVoe4AAAAASUVORK5CYII=",
	stacked: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeklEQVR42q2TURKAIAhE5WTu0fFklVozthEa0/4IDjwXRyUdUtUNgKSAxAPU/TG3auQqegNkoMVF1QbMHPwKYNWe6QhAPuPSVnZ0c8CX1sEfAWyZAWP+GCEEYAdeQ8tzP0CLLgKGBhPAI3gNaw6igBRU6Ae6AH6Zs3wH9qq+UAzL0sAAAAAASUVORK5CYII=",
	stackedLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAoklEQVR42p2TYRaEIAiE8WRypvYc65nwZO2Qa4/UqAe/BORrxjQRQkR2Zk4UiOQBUP/aHHs+E0CH/80lIDMf6yqyBjwpUAAaG9YlBEB9g8TSIaMl1wICvb00WKUOs5YuCuyh6eYmO1MH9LpCbgHWcxsYAZqn80wuFqxn/cI94LQ0K/AGjjy33ypVXgLMwBIwWXAG3imIAigYoRfoAsab+ZT/APYuzVCdp3edAAAAAElFTkSuQmCC",
	stackedPercent: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbklEQVR42r2QUQoAIQhE9WTN0aeT7W5FENWGurD+iMR7jao8RfICoKWLowqjsyAB9TGTtZ/mKui/hgXeBECSxmSbYAS2gnmFE2BK8L/AvUJqN2KmMcEA2AQHYCtYVvAKPifoAgmWRsFXwXgTy3wDpsjjUIn1UagAAAAASUVORK5CYII=",
	stackedPercentLine: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAnUlEQVR42qWT0Q2AIAxE6WR0JpxDZiqTaSkSUKEpyoflgHv0SATHg4gORASuu1sY7NngCfCIspmIpGpaANl80QTANfBCNANGHfBi4HkcARA9f0H21QgVUgz5TKq5g3NHzHoSoRnqYUW/O5jd2Nq+XWABtMxNdwAtwtMg2pc3okTGDjqDDaAYhoBXhFXA7w4qYOUn6gd8NU4B/ZtY9AkZN/JQjd2WywAAAABJRU5ErkJggg==",
	stop: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAACB0RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgTVi7kSokAAAAFnRFWHRDcmVhdGlvbiBUaW1lADExLzA1LzA33bqJ2wAAAh1JREFUeJyNk79PVEEQxz+77+44AwYCWnExscBEEo3Rw1BakWBBILHh/7DWaELjP0InVFYWYKMBYoFI4cVI4KEWkAM9zru3uzMWb99xBAsn+WZe3nzn96xRVfpl+/Htu6ZSeYFN6mqTmkhAsm4qWXdLs+7zqbWD7X6+6Q+ws3BvBZvMd37s406bhBByg01IBocww6Pg/er02v7ChQD7r55Wf2+uN1zzqHaW7hEUAqARJiIB7MgYDFTT9rXaxMzrDx0L8Ov922XXPKq10j2cQhbRFcgk6vjPnxwT2me16vevywBm50l9SkU2Tj9/xCk4Ba/gAdHzCqyBElAyUDYQhscwqg9L0u0sdY9+EgpHhdmGgioafA6f6zf3R/O+gaTdQsqVJWuqVybdaZNA3rePw9EQeiAidbk9AOoznJrJkoiOhxDQWLIovcwEDyGg4vNABQdAFS8ybkVyQ7FMjdmRogLf05d4ErDi/SE2wRR7Beg59bURExU8MEgIh1bard1kcKg3aWs4zyxFG75XQcHxxlCSsGs2Zm7VQ3Cb2cE3srhGp5A6/ik3K/kaz0yCEZkyqsqHRzdW/J/2vD85/q87cMbiRVfnGrJgAbLaxCID1dRcHaEcD6USMdD3XY7OmWiaZrp46TG9m76+4kTnbbuF+iw/pjgwbwwdNRiR1bmGXHxM/bL+YPiOV1560boTrakECCE1ErYSlWezX+RTP/8vCdeMdxoMTC0AAAAASUVORK5CYII=",
	stripeHorizontal: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAFElEQVR42mNkQAAzID4FYjDSQBAA8NwFBu0RPdYAAAAASUVORK5CYII=",
	stripeVertical: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAFElEQVR42mNkwAIYcQmaEa0SAwAADhYAPA65+CQAAAAASUVORK5CYII=",
	style: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAv9JREFUeNp0U01IVFEU/u59Y/5XOhJjaEapVDaLFlFRlBFIYYqLwoWbaBFtXLWIWrRoFeVO2mRGCwVN+tEUBLMspFIqHdMpHQVNLcvSaSZ/xnn3ns59mkTYg3l33nnnO+c73/keiAhKRWFOrTWuP/vmaWwbeEean0nBNnGTY5OT8+9PgpOkhAMWQmEHBQe7fF/2XLqMFPBrwXEoficV1rqkqQK4OEFC8fnW/2X9QkRj/4mPdYKxJi4ty8J/LimkC5qhpn5zq78mGLT5n0Zv/48CMKPHHSN0o/qVLcjCWhykuQklYMoMTYTKjh3InNYkMBsM48GTTxdu1b5Gc8cgqlq7c/+mYXiTGd+UVZbAg7axC+6UJIx2/cqLj7cgYMHX+7ni8+w8QvMReOLcfgNgSR00OZoJLiDN5IRgcKYiLXHdRMZB99mtmalcQONl3yhc5IKlYlBV320JscJBwBGemKnU3Knh7rR3JrgAEUeJLjV3OT05eWIxQpiLLPECotyJ8HUqhKa2oT7T888KHQaSpQ4nTvblbEmpL8zPTS06unND8fFtmeHFRbg3JSMpORaK29iuGDQ/D3jZFODGcNjwKLLpxQi9D8xi8lu0tPHp5EUTbGoPtA8OBZGRloB090YnWTCwp38K91omSgTpVTEFKbNsYQaClo51cLuul8an57C7/JDrFGlVdP4+Tc3MwOKEwvwcXCk/IlZHYCdgWOTEEp+mclW7L7emeYCtsIRQg8+urvdRamIMhM2ykmRfBFBZOZxhwGrZBxrZCESM6oaqx07o8WyKQ8bm9VBkw7aiOLxvGztyhTavL84THjc+sBjD/jGK8H4ZfOfmh6wWX3/CmbJdI8WH87KJBWaiuM9mPvm102569tFYF7UP/aCkse3nCkpG5LISpj8fqZHR0e8hjAWm801YMViy5Kf5i/N63Ve1Kcj9wpEI6GfWMIvCPhHLjr5W2UmPOj6YrwNdA6HxrLaBN8UFeXuNuI1PA3UNLf5SyY5lsrBYCxYaLq3ptwADADgQi9wCmSZlAAAAAElFTkSuQmCC",
	subtitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42mNkoBAwInMOHDjwnxhNDg4OjFgNgIH/YITVNkYsYlT0Aj7vIDubNgYQCkCiDLC3t4dLHDx4kLoG4HIR0Qagy40agMMABhIAhgHkAgDJMlYRAtEIXQAAAABJRU5ErkJggg==",
	subtitleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcUlEQVR42sWTUQrAIAxD15OZm8lu1p6sw4EzH8UNiywIYqHPhKocSQkfVNW/NAGQENDl9wpvk6D2QwSOIb2xFdpeSjkHnvg+2GZW9wHSEYDhwBlHbky17gPkpwA8DoTeE7uZT2EF0LUcIaMQ8OaEf+MFAGx4EV8yaBwAAAAASUVORK5CYII=",
	subtitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWklEQVR42mNkoBAwogscOHDgPzEaHRwcGLEaAAP/wQirjYxofIitMBNJ9gLMyWQbgO4CUl1DfRcMbBig01RzAT4DsYYBVV1AyDDKYwFmACmakC3D8DexNEwfAHGXZhE3FEh+AAAAAElFTkSuQmCC",
	"switch": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAsZJREFUeNqck1lIVGEUx393thaXCm0qtdJrm4FlONGkWESbtthDUA9F9dDyFhTRghI9WJpgPgSBD/UWQRvZrg6CSFk5FuJDD+nYTFCmmaDV2Cz3dr7LBEIv0oE/937nfP/DOed/Pm1XPZMyU2AYNBom5TYNzWYDTXw2KyhRCVjff4iJWDwOv2OU1+5tYDyKqc7qui1u8EACpnJGYtyVsxVQUP8Zs3QzHMH8JfDq0Nl3jIrycyqZKRWhldZiXt1XQSQeo6PPj/9jP6HhgKbKm5+mmx5dx5tbKFVoAged/VXYpe7Zyfu45ruJQ93sDF4kHAXvovOkp6zmec9tq5kdBfvJmeugI3AeK6Mq2SGQBCPhkHW2L97IoXchZqYmwc9oG0vmFZAydSHBbwE2r9LpDF0iOAhdfeAUonuWkH/o3HvVTdNpPPZeH74+Hzdc+ZTNSGbGOG/IdS9jqtPNrVfXZdzwoptg40k2TVnF0bSZTlreDtN8Bk95PV12kXFo6Va+PDtDiy2fw0nTscftPeS4c0hx5fL4dW+ktZL1O+vojoYpDQ4ZWU2KfIUu1ZZNNdt4wmRzNfcPbNzuGh7RCQxA/+gTFmT8ZE9JkUtidx6elJtOvHUHG9hUjf+vWjYjTuuWGs3cXVK8OCtzjOKiAP2SIPgVPofbUb7t3uV5G6o0c+1KGfiQyLhHZIwmZCy7jHn8QB7x2DSGwm8JfYIvId2a8NzMANlZkOpaRMwYs6Qc+z2AbCJuh8j4SGRU+zhivCcm9QQ/w8sOBpsrA9tUgi0XeSJDnKNn92IkFktLyPg9IaNWWoVfc1GoVjYe5nXLBY7IYHuwZkN+WQ2twktX5OI1IHvFyIDO07YAzWfxqPVYIkhJrP6okD9MfAuSZAVqfGLSrn9diYu29gjPEzJqk32NysZHaXUmseHxKTzC6+I/LFdQONHxR4ABANuzKntCBWfVAAAAAElFTkSuQmCC",
	switchb: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCwMANFN3hb0AAAKASURBVDjLlZNLSFRxFMZ//+s4k72gUpvMUecmhEhQWGSJhqWlWLoIajFhy3aBUpgoEuFgSuYiENy1yBbiQu3hI0t8kKCSUGAUOepIOmA25Gue9/5bXB8QEfatzuHjg3O+7xxR1MC2IAFdB12CIkBRQAAKgJQGIeVfhOucpkEgDHXXm/CHjF4CiqbTFggj/SFkMEyrphuEBDQd4vap+IKwFoR0FUYnb1FRWE4gbEwk8uqQTxwVBLUww5NjjE1P4V50CQHYDqicVFXSj6ShS4EuTYxOVROhQMxuB429zZiEgNEZJ74QpCdXEb3nFF2fWiQgLh+/gd1qYthVhRDGSorJ2N/rcxs9GtNPB8HthZGZB9hiVjiXkgMgEw+tMOKuwv0D3n6E2QWwWODXmsqzwUE67xpGApDrxJ2Rii3BCkdjHXz5HqD/ayt2K2JoHHor4VItZJ+IpG88RHcZFDaAKGownO4ohfNOAmdSMatxYN9fwOScxvOBrmBfJZYr9eBfBcWC7C5DFD4GIUCRQHuJJLcGii8UWBa9Ki4PTC29IiFulWuZZ825NUx0lEqIRNbfbCKnBrmRlrj8CAIhuJqZQXJiBPNrA3T2I5NtYI+H6KhjTM5qtA1NkJUGdhsk7SzH2VLDDjNC5NfC7eIUtHAUC74PuGdh3q0CSOthF0nxsNecTFhfRpeC5YAHRUCsyUHji2ZMCPDqnwlLmJmD98PQU+kCEBedeITCQTXpG/r6YYn1GH+uxyjyqkGYDSM1H7y5Dxv/0V4C+Q9Z0CFa0yHjNKgqeD0qr/td9NzbPI8t/Plc7SVbdX4tMivTTP9gkK4yxGaM24V/iXeRu8h+eef/dP/Eb2+oD+GBQhrnAAAAAElFTkSuQmCC",
	switchu: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCwMAEoF6AEAAAAKPSURBVDjLpZNLSJRhFIaf7//noo0yqGMOM97mq0ixqMDQLhNdKLOLbVolEa3atNAQNJJo4WARpqugVYsui0hIM7s3mLeg0FpUFPZrpqFdGMjK6/99LSwUV0VndeC85z1wHl74zxL76v9ePPGNR04PW1oq5vbEQtFCw6byub74DHpT2EVb+xR3KhEl9SB21oBwgdZgj8P9U3MmTeVQfJrPCny2gg0FICXERiStbRb3qhAO4YKDpTBjg2WBqJm7uiPCSGE+PpkNSoFtw/Q4eJMsSovCmEa7dqAhycjFVvHYgR7EOpAXJYD2By2yAuBhKTOMoQzB2OQISoAvLhMAM2cndPR8Id0rCflCOOPf89KK6YxgjOwg+OJWMvDB4NLtARbFfSfFC6FFxznbeB6XE2EYJtyr0jS2dzI0nEhnl9QhP2SlQSA+zNBwIreevHodrdai+wWsTb1A5FotbifCMH5j1Bqaj8HWCJPr8nDJAISSd/Puo83Vx3emotW499bBxA8w3Oi7lYiScyDEPIzbIwxuyCMj0w/LF5fyZniStrfXCfkRHb3woBqKzsCWNU6ivdPcrYSSejCLT9Mvt9OwPhdvlg9WBY9ijZp0ve2kbNdh8XO6m0QPBDfD6hBkpynSUyQqL0ZrBZjLimg4tBE8LigInWTgk8nDlzcBRFpCPiuC2xibjCL94PWAPQPxrhirMsNM5Azi0BrWZp1gyp6hu6+TZwP9DH61hABanl8mX0oKl1SitEBpB0/7axAGpCTMYhR76rgxbbNPaTAFjQ6T/YYx+xelID1Z0jdqYSvYuAxkKmQvPk6kuZY45zwK+ncwxIJ0/JkpBVM21B+4QNmVI7gdYJr/kMY/JkqDIcAwZg/+AhWO7GxV+mUrAAAAAElFTkSuQmCC",
	table: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAALRJREFUeNpibF4VOY2BgSGTgXQwvSZ0WRbL379/M42VXUjWffbuHpClQAP+/AFxSDYApA8EWP78/sPw6N5Dkg2QkpWGMEpmev6HgTNnzvxHBvj4UH0MTL9//WIgB8D0sfz6+Yvh7NmziMBBYuPjg/SBQUqbOVlegOpjYIKbRCKA6aPcC8FFqmR5AaqPCl4ARQc5XoBHv3OCCFlegOpjYAIlZXIATB8oM023jeAlKzuDCIAAAwCWU0nHcQInwgAAAABJRU5ErkJggg==",
	tagCloud: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAo0lEQVR42oVSAQ7EIAij/380JyeoQJ3dEoxiqQWIqIoAYtDxGSBQmWv8f4edj7MV53kQHEQrv5BEgQN+kSGTUQUjEgVZSahoz9l7bxgJLrmoxlkiizfybQ56YlQ9zaykyRDXiSr7reDbAaUdiSJdUp2NaOncI/lbbna7t5VNZ+p3b1W/3AnO8YTcp4/t1y6s2KxWaVPq+ZyAxepJUvACqrH7GT8Wn4n9RMz23QAAAABJRU5ErkJggg==",
	textShadow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB7ElEQVR42oWSu49pURjFFyERKomOBolHPJppUJAoRDHRiUY8ouYfEIVGVAoTlUa0EhGRqUQMEtEZJHMnEULhldEpvPc9Z9/cyTX3mFnV3ufb+3e+vb7Fw33pvux/cR3ifXdxNpu9SSQSyGQy/T3Qf4DJZEJyuRxqtRrW6zVYgNFoRDQaxePjo/4r5Abw/v5OvF4vBoMBlEol9Ho95vM5RqMRBAIB8vk8wuGw/i7A4/GQarUKn8+HTCYDuVzO22w2tKNkMsnuUSqVYLPZPiE3AOYPhHkC/H4/DAbDZ+3j44MoFAocj0d0Op37gH+13W4Jj/envN/voVarcTqdKMBisdwHVCoVUi6X8fr6Cj6fT79dr1cMh0Pqw8vLC6xWKzcgkUiQVCqFy+UCl8uFh4cHCIVCHA4H6gmrVqvFDWBaI06nEyKRCE9PTwgGgzdwsVhMWBD7BE5ANpslsVgMLKTRaNxcZkZJNBoNzucz2u02N6BYLJJAIACz2Yzn52cwrtPadDolkUiEhdLums0mt4nj8ZjY7XYsFguaPLfbjeVySeculUqx2+3oGOv1OhwOB7eJTHxJPB6nE/grFpROpxEKhdDv91EoFNj19znodruESSBUKhVMJhPNf6/Xe1utVtDpdNBqtT8GSYefRQG/AfzH5BHoatNLAAAAAElFTkSuQmCC",
	title: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUUlEQVR42mNkoBAwInP+gxFRmhixGgADBw4cwGqQg4MDIxbDqOgFfK7AZjt1DcDlb5IMsLe3h0scPHiQugbgchHRBqDLjRqAwwAGEgCGAeQCAEMiVhGsaR9tAAAAAElFTkSuQmCC",
	titleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcklEQVR42rWTgQrAIAhE55d1fxb7M/0yRwOnjBZbriOIAp93WLQlRfGg53pVRF2AiZm7IADUgf0Y4anzyA1ZYbtoeylld3zgq7NFpK4DpCMA7kAjLrgR5roOkJ8CcDmg8DCjm/EUZgCm6QgZffpM9+5NB3pNeBFWpMusAAAAAElFTkSuQmCC",
	titleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWUlEQVR42mNkoBAwogv8ByOiNDJiNQAGDhw4gNUgBwcHRjSDIIrRJYj2Aswmsg1AdwGprqG+CwY2DNBpqrkAn4FYw4CqLiBkGOWxADOAFE3IlmH4m1gapg8A63hmEZrKgWAAAAAASUVORK5CYII=",
	titleSubtitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAU0lEQVR42mNkoBAwInP+gxFRmhixGkDIIEYs6rEaQLYXkMGBAwdQXOHg4MBIWwPQNaADogywt7eHSxw8eJC6BuByEdEGoMuNGoDDAAYSAIYB5AIAZaFUEeAKb8EAAAAASUVORK5CYII=",
	titleSubtitleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAc0lEQVR42rWSUQoAIQhE15M1N4u9mZ7MxYXKD6lIGoIo8jmD0ZMU+YP+a6uIQsAKRMH7EHAcgZm3IpgAUAdYoV3YXkp5B97xdbBFpN4DpCMAw4F6nHMjzPUeID8FoDsg95+8m/kUTgBNxxEyCgErJ6276QOczHYRmJzoLQAAAABJRU5ErkJggg==",
	titleSubtitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWklEQVR42mNkoBAwogv8ByOiNDJiNYCQQYxoesCcAwcO/HdwcMBpGF6XgDSDGGQbgO4CUl1DfRcMbBig01RzAT4DsYYBVV1AyDDKYwFmACmakC3D8DexNEwfABYGZBGrZCCXAAAAAElFTkSuQmCC",
	top: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAm0lEQVR42rXPywkDIRAG4BHJ3q3BLtSDDahgMQoWYDeebMCzJW0OJi7sLWvEbH7wgTgfMwh+DOpbA9gXizd0SwdXKaXsUsptCejF532EoC/Fj/d6jpD/jXALMJOPgLW2YYyh1gqUUiCEQEoJTQM559bPGCOEEI43pdQ8cIZz3pxzYIy5/DcEGGPNe78O9A46oLVeA4QQxwjLwExedls1Efgb+DEAAAAASUVORK5CYII=",
	transform: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaklEQVR42rWSQRKAIAwD0/8/Oh4cHYQkIKO9wEC70IUCQJxR2IiriF8BKNbj7VwizQGvAX2eBNDMXQttu5XEEbmFKSBJvIFbT6cAvYfWh3MwFAyCxCglqpMS4BFu0/1MCZg5iKJXnvFfwAELrSwRQlW1oAAAAABJRU5ErkJggg==",
	transparency: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACcElEQVR42mNsaGjwZWBgkGQgDzxnrKmpSW9ubp5Bju7a2toMxsrKyvTW1tYZBgYG6aRovnDhwszq6uoMxpKSkoyOjo7pLi4u6fv37+cHyv24dOnSj3///jEADWUD8v+dPXv26+/fv/9aWFiA+MyOjo5Me/bsmVlRUZHJWFBQkNnV1TUtKioqffXq1SAF7w8ePPgNaMBfoEJ2IP/vpk2bvvz69etPSEgIiM8eGhoqtmzZspllZWVZjNnZ2Zm9vb3TUlJS0hcvXgxy3fvt27d/Adno5+cHMvDvvHnzPv348eNPVlYWyAC22NhYpTlz5swsLi7OYkxNTc2aOHHi1JycnPT4+Ph3r169ege16QeQ/+ratWvfT58+DeL/4+Dg+GJqasqppqbmNGXKlJn5+fnZjAkJCdmTJ0+eUlpamu7h4fHw5s2bb4FO+wPU8J2RkfEzyEn////nAdFA/hdFRUUWd3d3j+7u7pm5ubk5jEC/50yfPn0yKDo5OTnPzpgx4+XHjx+5YBqgBgiAKAEBgc+srKyMkZGRni0tLTMzMzNzGYODg3OB/pkETAvpwLA4AXI6kkaQzcxJSUnagoKCQmhpYCYw3PIYfX198xYsWDARGBPpwOg8CpT7jWYAIzC67IHpZeafP3/gBgDVMAC9n8/o5uaWv2TJkgnAgEwHOuswKLDQ/Q70ngMwwGYCLYAbADSUISYmpoDR2tq6YN26df1Tp07FmxKB0T3zxYsXDH19fQxFRUUMEhISDEFBQYWMSkpKJSdPnuxGdh4xgIWFhcHc3LyUkZubO4aJiUmanMwETK1PGUEpC4hB0cRCon6Qkz8AAFhXFNlVq9MXAAAAAElFTkSuQmCC",
	transpose: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB1ElEQVR42mNsXhU5jYGBIZOBdDC9Nmx5FmPD8rD/xsouJOs+e3cPQ0PkKkbG2sVB/5lZWEg24O+fPwzNsesYGSvn+f1/9vgpyQZIyUoztCdtYmQsmen5vzttG8RZZ88yGBsbI5yJh186y4uhJ307I2P+ZOf/E3L2EG3AiSAThuyH/xkKprgwTMzdy8iY2WP7P9mhnyhnX/A2YXCR8GLYd28bw+l6W4bpJYcZGVPazP/PrjxB0AWzpBkZYjx6GH7Pm8PwgfsPw7G/dxiifjAwMsbVG/5f2HAOrwFzJRgZwnLWMbyrbWPgZfjOwMXwj+Elw1eGE2yPGBgjKrT/l4QsxOv0S24mDAzMDAx6r+UZ1IBGPGd4y3CW7TnDDx4GBsbgItX/a3pvERWI84UZGcLfGTKsFDrPsDVBlWFt321GRt9s+f+bpjwg2YD1kfIMm6c+ZGT0SJX835K+mahYAHklEmjAcqABq4IlGXbMfs7I6Jwg8n/P/NcYNu7WVGEQuvGD4Z0GBwrNz8DGcFjoPsNSPxGGvQveMDLaRwv8P7DkPaYBjOIM4gwCwND+gEKfFbrFkPj2P4NDjCDDwaUfGBltwnmwZuek3V+wemOeKw+MOf3Iyi9ZAJi4122cufmuAAAAAElFTkSuQmCC",
	transposeData: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90MCBQYLb7brz8AAADoSURBVDjLlZPRjcMwDEPJtHN0FWl0epWMUaDgfThK3NRBcALyE8vSE0XT6EH8LyQd93xRwIA5HEnyeJ6ZXHzTyYCr24ziyY2gkmeJkTmFzEw8Jzf4DXAt0U62ruvj/X4vhWu7f4DdE1kaVJQeneD1+oyjjDStd5nqIAnLxuaaPzIN0gDQLsQbNaAkbiIdADYBoLU2Wco34VIC1b7bNu9FMCIYEQTAzATPMktCROBMEBEzIvDsMJKwXbj1/zEWzUxIOnww1rVdBATAWdcfJ+rWzVNBsWvQpM/wptgn4U6Umbx9jXc7v/LBH+FDl92wsFPlAAAAAElFTkSuQmCC",
	treemap: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXElEQVR42mM8cODAfwYKACPIAHsHB9wKGHCbf+DAwaFgAIr+Om0UqYPOU4eNAQ72DkTpp9gA5bqPKHLznM8PFgPsHexRJBj/IxvASD0D+Dagum6z4AEqGcBAAQAANUJzAdpYAIgAAAAASUVORK5CYII=",
	ua: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASklEQVR42mNkoBAw0tqA/4TUDW4D/kPl8RpCMwP+I8n9x6eeGAPwhgUjDs1EhxkuA/AZzIjPAHwBRjUDUOQZcSggJAeXp3lmIggA6gcUEZ7M1IgAAAAASUVORK5CYII=",
	ub: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAP0lEQVR42mNkoBAwUtOA/+RYis0F/3HI/cemjxQDsMrR1QCs4vgMIBiANHfB4AtEig0gGAbEJGWiYoEkQLEBANoSFRE2ehqdAAAAAElFTkSuQmCC",
	uc: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQ0lEQVR42mNkoBAw0tKA/zjU/kfWx0hAMyMOA/Ea8J8UOUYSNCOrGVgDUMDQNIBgOqAoGvEZgtVgUpIyVvU0zUxEAQChZhQR8AFGQAAAAABJRU5ErkJggg==",
	ud: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANklEQVR42mNkoBAwUtOA/+RYiM0F/3HIYRUnxQCscqQagCE/asAAGEBRNBJMSFRLyiQBig0AANNEFhH2/yopAAAAAElFTkSuQmCC",
	ue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARklEQVR42mNkoBAwUtOA/+Tow+aC/6TIkWoATJ5kA5A1kWwAXhfhM4AYtbR1Aa4wIMsABlyG0TUdIAcuVgOolpRJAhQbAACFQxYRf67AzwAAAABJRU5ErkJggg==",
	uf: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQUlEQVR42mNkoBAwUtOA/+Tow+aC/6TIkWoATJ5kA5A1kWwAXhfhM4AYtbR1Aa4wIMsAnGBwGUBS6BMlSa4XSAIARkITEYwMI/4AAAAASUVORK5CYII=",
	ug: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAVElEQVR42rWSwQ4AIAhC4/8/2k5ttQlSLq7JU0mMpvATEKQ2dh+EEQJIAcxM3zOAs1YKqLqnTV4Ah1xAMP/tBO0MrF9QkBKgICv98hJZaPYpX6kNmKeJGBFBzshvAAAAAElFTkSuQmCC",
	uh: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALklEQVR42mNkoBAwUtOA/3jU4JTD5oL/SBoJyg1zA/CBIeKFIWgA1ZIySYBiAwDLNhcRr/PZxQAAAABJRU5ErkJggg==",
	ui: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAJ0lEQVR42mNkoBAw0sqA/8SqJ+SC/4TUjRowagBNDaBaUiYIKDYAAJ2ADBEVe6i2AAAAAElFTkSuQmCC",
	ul: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAN0lEQVR42mNkoBAwUtOA/+RYgk3yPzEaRw0Y6gb8R5Yj1QAMOVIMQE6pWA3AlZTxep2qmYksAABskA8RjsBjswAAAABJRU5ErkJggg==",
	um: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASUlEQVR42mNkoBAwUsuA/0Qa/p+Qov8kGMCIywBGJIWMhOQGvwEMSHz0AMdrALrCIWoAhmJCBmBLREQbgCsp/8fCxlBEEaDYAAC4PikPUmotIgAAAABJRU5ErkJggg==",
	un: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWElEQVR42q3TSQ4AIAgDQPj/o+tFE2OKQJWjy6QYdHss/wkgwcHuswQoIh61gLmOC+IWbDKAtVoC9sgywBAZWOfbwImYArAkbYA+ajooHYCOapbw62eSagDjLB0RXy9ipAAAAABJRU5ErkJggg==",
	unchecked: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAN5JREFUOE/Nk0sLgkAUhfv/i/wpLYQI6UVZQg4lVBMyJsqECCKI6PrEFRwMbDDcNHDgLuZ8587jTiZ/saaGgV/10TiZq6oaLNrfCzCtGb5pvjKx3i2bEC3gwl10dfU9PMQdIvSxs7fDAR4/g8x++MAzChDLGEfnMAzQTSVjkiRI0xSMMT2Aztm2S0Yy5XmudOc3PcDaLJp2KTHLMhRFgbIslYIw0APoll+JVMlkrutaSUqpB9jOXpkpvWummjrTPqPLTuCcQwiBKIoaGB2lvQeqtYChv7H3I42ahTET/QZV7DlRP23G4AAAAABJRU5ErkJggg==",
	undo: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACQ0lEQVR42o1SbUhTURh+Tou53YbOi+HiSrThB30sXBHin4ygkH4YRH/MkGIFEklhGJqRLLDEKIhFCTmMEfmjKAoKCeqHYO1HlgiKkRJuCxNlLNFpq3V67z3XdO0avfDyvOfjed6PcxhWMV8PtxH4W6vZcfzDmNHmpfu8gqB7rQnOnylIl4+yhf8SuHCPm1U+edM+D0xTcWAkDJBIjPaekLdfOcbGDAXO3+UlBA+3u+DeVQzMzAKWLECmRpI/gNEI0D+MJN0523GS3UkTaLjNTQSP3S5UFSpAfB5I/VrOQq3ATkJmwqFxqmoCJ26cYoG0CupvaiK+PDta8mUgNzuzXytVZCJGb0irpMh/hoUzhlh3jVcRBDcpyFEzf50BHHnAelmcr7MAiQTwZgjtnY2s2fAVvG28UG3Jng13fBZlFHcUbECF4hDnNqrkVQiDgRbmMRRQrbaVWwm6gj5WQ7GDBjq5bYs4k0igL4QFOpNWFVhp1c1csUmIFpWI9RpiDbxHsucqy9IEDp/jEwQb/+L1ki/9wu7yHahM6Ivvi/SsIxh8dF1v4WA99+8px+my0mV2/zvgw7CIPVtpiNT/py9iHZ8GohG0PfWzi5rAgTruJBh1bYbZKolLxQWAM1/En6eAjxERz9EHC4/hG4WuF50s9mcG+73ca5fRZculKecYz2KOaNFxpCg89DLAnqV9JNX21vJKdfKyA4oqZNGrWZwX5NiklrnmdZA9X+JkvMLuI1zN30iuiu3Ut9/qQ73V94DFVt7/DQLjqBFSiWXDAAAAAElFTkSuQmCC",
	unpin: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAC9UlEQVR42oVSa0hUQRidmbt3Tde0XA0tfKeEkhmGLygwUitRKvtRUf0INaUQbQUh6keEP3IzZUFSEUGlsAeSr9JMLS1tLSvfK3RdNc3F3dVd3W0f9965XQ1l1ayB4fDNcM6c73wDwf+W8BKyjwlzYwVAZ23KssDjxYhrvoZXr+FWPP+MekQ9TMLul2vyFhYMEovVQkEICnhyhSC+CDItWdw/Bc7IhonazGA2MqepGm1zutjdp6QBoyMBQvmg5XouiJNB8DqT+6uA+Gw50j5PwW4Jed7Yam6LiY3zV5uETFdvP8CMVUCQwmi2Ma0HnSxB6wRQQinETVdXrPndUW0XGak30LoYbtTNYQdHJ6gxEaxOrxcwFvN5uiG1hkwqJzY5IGMLXWmlCkSlppd4eoiTzQxiJikFmhloR0s6zVtu1wEps6h6h1slxrUMiKQKyNZf4VBC2Q2hnd1dX/9A5ljUfkcWkqB/XA3nJkfhPPXJYtZMRBnlZV8dD2cjQ1ch3hTiznPVPeEhgZF+XntYL8/dsGtEjSiKYrXf5YRxTllk6pZl258oIE2vJPS6MUbltqCee/HYN+WpJPFI6H2RSMQMq2jB+Mw81lBfkH566KdZOxXKKWrVG1vekIE7EX3z0bN9e31P682A/jZCQZXig4ABwmnOLz7EWha2sKXA4xftxIVTR9mWtq6cml6tdGjJlbZgAamZ12PDkg4Z9AsR+GV6ryCxDDENaet/okY7j1zFLphhufCP7zvl8u5OmaTVvc5RbHebA8TB5s+3nCeVyl8EAKO2r/Pz7ltzMDWtcjAbdH3tHR1sekbGIf7IHOEdAOUuyU5PJkp1SYmJmz5cZVVVH/wxMUF4+viwwwODDxRjiuy6xsbQqsrK/szyciRLSVmxKgVAbeKRLyZtBaZWHUjz853ELi4Dg0ND0sKiomIPDw/n2dlZhu+QA6SIZ9IYsBb8xzWwxZUMiOCgoECEUAAvMEaS5A6apnkyYPm9jMszt9qg1aZmfgNaxWeX/YISmQAAAABJRU5ErkJggg==",
	uo: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR42mNkoBAw0tKA/8SoZcSjkZEYcaIU4ZPHZgChcEExhBGXxKgB5BlAjCEEoxGfIUQlJHTFBNXSNDMRBQDrbBYRul13eAAAAABJRU5ErkJggg==",
	up: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOUlEQVR42mNkoBAwUtOA/+RYiM0F/3HIYRUnxQCsckPLAJLDABugKBaIM3FoG/CfCDWkSZLrBZIAAD0KERHY36CdAAAAAElFTkSuQmCC",
	uq: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAU0lEQVR42s1SOQ4AIAiz/3+0bgSNxSIOMtKLVNGKgwDrCheBEMpeIkU4EmLPKxsY728D9ozUwBfUAxEtcU2VsOcfiSVSzalxdoH1cGMwhWcMtj0MROcdETswwvAAAAAASUVORK5CYII=",
	ur: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASklEQVR42mNkoBAwUtOA/+RYiM0F/3HI/cemjxQDsMrR1QCs4vgMICa8iHLBf3zqifXC/0FjAEmBiC8W/sPkiUnKeAOTqpmJLAAAXSwXEYB8u8oAAAAASUVORK5CYII=",
	us: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUElEQVR42r2SSQ4AMAgCy/8fTe8mIMa0HgXHuOAsA68AFD7WGphiCKAFUOSlNgFEI9Bo8RIZ+touESj9g9EVut/4c8aqSbAbgY13tEQZa8AFDjcUEayPQ4QAAAAASUVORK5CYII=",
	ut: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAANklEQVR42mNkoBAwUtuA/6Tqw2UAI5F82hjAiMdADDVUN4ABi4F41Y0aQEMD/hOrnuqZiWQAAPqKFBEVq6FIAAAAAElFTkSuQmCC",
	uv: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASklEQVR42mNkoBAwUtOA/wTU/Mcmjs0F/9E04pUjxwAUcXwGYJMnygB8rqDIgP/Y1OOLRnRD6G8AsiE41Q5+A3D6nRQD8AKKDQAAvoAUES0OguQAAAAASUVORK5CYII=",
	ux: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXElEQVR42q1TQQ4AIAjK/z+atk7NEFzlMZCpUIzHip8CMByGB5sAqVFi1QqVCPKbE8grHHx1xH0KVFznAhyvY6MU6UwQSsTdgGWg7QKzsCVwHSQaVYEt/OtnuqoJy1QWEd43kfMAAAAASUVORK5CYII=",
	uy: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVR42mNkoBAwUtOA/3jU/MelD5sL/uOQwypOqgEY6nGFAbohuAwlyQCsavHFwn9i1BJrAE51hNLB/xFswH9i1VM1M5EFAEYtEREV1FoeAAAAAElFTkSuQmCC",
	uz: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAS0lEQVR42q3TUQ4AMAREwbr/oblAl7fBZ9UETeMtI66BdGsU0MEj8BtLwQiQxfKQtO4C8l5sirvk2DoFxiVbT0aABDkMoLHPP5MdBQD7EhG/c8bvAAAAAElFTkSuQmCC",
	variableLabels: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaUlEQVR42r2R0QqAMAhF55d5P12/bLUoNHDlSPJpyN3xiNQ+FkVNEelpwAgDoP1HP4lHj5ldys3pxlbVQkD5CgBHQ282KlIIqL8CYKFmPG/zfIUsINJaWiEbXAZcFmO92fsfg1m9GmQBGz2tgIegBFX3AAAAAElFTkSuQmCC",
	variableLabelsH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcElEQVR42rWSQQ7AIAgE5WXuz0x/Bi+jTRsLB9tipF4kZjMOIpXFRaNDZtYwoIcBnHXfa62bpdw9amwRabmA1BYAM1CPczbC3HIBuVMAbgMqxvM271OIAkZaUy1Eg9MALZf3EaCn+l/AcgtfD9n/zQ4oCo6HGEvKBgAAAABJRU5ErkJggg==",
	variableTitle: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAaklEQVR42r2RWwrAMAgE48nco+vJ0gcNGrCtoVJ/EsJmHJHax6LoUUR6GrAn+0Wi4yOA82Rml3J9urFVtRhQOgLAUdPJRkWKAbVbACzUjOdtnreQBURaSyNkg8uAYTFGiu7/GNzVq0EWsAHi4XyHNxPQ2wAAAABJRU5ErkJggg==",
	variableTitleH: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbElEQVR42rWRYQrAIAhG9WR9N4vdTE/mYNCUkK2Y608S9nwfMn08nD2KiC0DRjOAqx53a+3wrjDHnK2qvRZQGgFwA4u4YKMivRZQuwXgNmByXrR53sIqINPairDauA2Yo2X1vwZGZC8fuQRwAjYQjodDfLAKAAAAAElFTkSuQmCC",
	variables: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVR42mNkYPgvx0ABYIQa8BCPGnkojU2NBqUGyIMM0AQyrhHQzIDFEKAc4yNGCPu/BZA4DsSfgZgXhwEYmqFhAANYvYJuwC8gZiNkwBMglkEzBKvtxLiAFAPwGsJALQNUgFruIgswYqrBawiK7aQagKGZVgZgNQSrZjwGoBiCUzMBA2CG4NYMAgAo8DVxyXmNoQAAAABJRU5ErkJggg==",
	venn: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACOUlEQVR42oWTW0gUURjHfzO7W6vuyhYVFq4mSqZuktBDF+iheopQhB66QLCxhFBSFKRS9BAUIUTQhZ4qiIzAiHro8pCUkJFhQoqaWaERorRa6izjujs7fZvjZcTLGb6Z8/2/j//8z/+co7D4UGbNzaUapsfOle7l/ePxsz/1eGCt29mf6XbcafoT7ZKSsSRBwOPalOZUH1bn+gIFHhdjhsnt3lE+j0WPftFi9RHD1BYlKF2TerciOz1Y4F02jWnxBLd6Rzpe/daP9erx5tlK5hIoIb93oirX53Sq9tLzwYh5pmuoJipckkamPJlLoJ7L82lBvzfFodhL74d1o7Jj6NJwLHFd0uF5CMqLwH/8fF4oFPSvd6nKa8HuQ2ErlMGH7HEqG8PRcGviKR+5xid5IG4RHHHBqhaoKC5Jz+FqoYOcVCl5f8DNcsj8S7U5xGMjgtEj7ffo5g17aGHAIig7AbU3IO9/5nPCgXUK+adh4ORFXnKZNiZmxP6S2CtetHNBmVzG1jp4exBcdkceSByuSyq04+MSK2iQb8giyBJjGkVFlr3xikRVrbxq7PhXiX08o4cqi2D7ZvmVuHVI0nSrS4cNj0SFcOe3zcDhJKlENxU08WJqFxywJQi7TsHujaJRhYY+aH5CabNGEfspIR8NlUb6+E4970iu7dusbfR6IKMYojvk7Mk8TfwOd+LRB8kghxG2MYaH1SI8TKcIlC1idO5BEiWkMOmmYdkVSx6wBXBzvtu40BWeF/8HHwO4mBMafN4AAAAASUVORK5CYII=",
	violinOn: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeklEQVR42mNkwALuJyT8xyauuGABI7oYhgBQZz2M/SAhoQFEKyxY0ICkoZGgATCN6ABkEF4DYLaDDEC2FV0M2RBCBsAMaaC9AeiBh88LyIbgNAAaaDA+PBCJNgCfF0gxgHgvDHwsoBvAgAUQNABPbGD4nXYGgAAp2RkA3ciEET6Q1jgAAAAASUVORK5CYII=",
	widthSpace: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42mNkoBAwUmzAfwaG/1CTCBoGUzvIDThw4MB/BwcHuGHIfIIGgBSD2OgGwMTwGnDwwAGCIW7v4IA/FihyAVXCYHBEI/0NIKSJEKDYAAA5GVD5SnvFkwAAAABJRU5ErkJggg==",
	widthSpaceThinner: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARElEQVR42mNkoBAwUmzAfwaG/1CTCBp24MCB/0PAAJAiBwcHRrIMgCkgy4CDBw6QFPrUdwFVwoAqsTAEDSCkiRCg2AAAZvROBZyCAtgAAAAASUVORK5CYII=",
	widthSpaceWider: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARUlEQVR42mNkoBAwUmzAgQMH/oMYDg4OBA37D0ZDzgCQPEyObANg8ngNIAbYOzgw4DSAYhfQLAwojoUhYAAhTYQAxQYAAE8YVfmGXZXIAAAAAElFTkSuQmCC",
	windowGradient: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAi0lEQVR42qXMQQmAQBhE4TWKAQQDCAYQDCAWEAMIBhA2gFhADCDYwAYmsIENVj35Dh4G/rnN4X2RcyF2hkUPkFqB3AqUuKuWfc0L1ABmEagJtABGEWgJ9AAGEegJeACdCHgCE4BGBCYCC4BKBBYCG4BCBDYCO4BMBHYCB4BEBA4Cpxb97wUuKxAswA00tC0CXCMQDQAAAABJRU5ErkJggg==",
	windowSolid: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAJklEQVR42mNkYPj/n4ECwDjYDGBkJE4bQs+oAaMG0MIA0sHAGwAAX10z8bIlEyoAAAAASUVORK5CYII=",
	xAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABEklEQVR42rWSsYqDQBCGf0kR8Am00sLGXrCS2OcFfA5BwcbGQjTgg1hY2Qr2gbQWYiCdqL2Fwly0ELxw3incsMuywz//frs7TJ7nhHfous7gQMxFk8lhg38hqOuaDMOYTGFZ1py73W7IsgxxHIPn+UX7I4Hv++Q4DqqqAhFBkiR4ngdN01bazTdQVZU4jsM4jmiaBvf7nfmu3XyDsixJURQMwzAVo23bD90mwfP5nA36vsfj8YAsyx+aTYLL5UKn0wnn8xld181X+HMfRFFEpmmiKAqwLAtBEBCGIWzbZn4leL1edL1eMU3XdedcEARIkgRpmkIUxe1f2NNcK4IjXbkQ7C1cGdA8jsVy4mTy3jB71y+z0a0PUbIQlAAAAABJRU5ErkJggg==",
	xAxisTitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZElEQVR42rWRbQoAIAhD82Ye3ZsVRYHR1xwkgf6Y82mSephZrllVJQViElcT1GBoZRQ0gZ96qm90/wiQ/SGClylFQN9gN0CYy08GXkz9QuRgkEGkeTHwFGgO4UIEPnJ7x8bWWwAOAolQfA/7LQAAAABJRU5ErkJggg==",
	xGridS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWElEQVR42mNkAIIDBw78d3BwYASx/wMRkEE0m5FiA0CaQYyBc8HQ8AJI3t7BgYEsAw4eOAB2Hf29gM/ZBA0g5GzaeYFYZ2M1AOYKslzwH4zIA4zoAqS6AADOZ74PsXcZywAAAABJRU5ErkJggg==",
	y: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAn0lEQVR42tWT0Q2AIAxEyx64hw7ilAyie8gggrkzZyxE45dNLpDmeNUWgn2MUBSLBqxe5KINe/UdeQImKDqHF8jEZ8wrYHYgFZAgg2eU/AGwDsQDRFSvuRykWoSBEEY1r+I5q7OJGpNALs3Cqj3JHqDXD3524mEP0PuVZNd+NAEmgPl/AF5rXhhvnEmm0gSMdn8fHOf6BNB6WApyAa9jB9FUPmXGbMfhAAAAAElFTkSuQmCC",
	yAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABG0lEQVR42rWRsYqDQBRF73xG0G+wCH5AagvTRgRBAoKlpWBnwI8QBO3TpNDW7WIhiI2ijbWlpc1sJoUk6K4bYS8Dwzzm3jnzHsFD9LEIQLBBhD79T/e2gH8j0HWdDsOA6/U61S3LonVdI0mSqfYjged51LZtlGUJQRBI3/eU4zgoioIoisgqAdPxeKRN06CqKnI6nWie5/B9H4fDYZ2A6Xa7UVmWcb/fWRgMw4Drum/3VqfgOA69XC6QJAlxHM/urE6hKAq63++f6OfzeR7wG0GaprTrOpimibZtwfP83wlY17Msg6ZpYH0Iw3CRcJGAvTyOI1RVhSiKCIIAu91uOeCVgBnZ+XVMa5oIvtL0I+OMgAVs0du/GcGn+zfMlaNQ+OlAKAAAAABJRU5ErkJggg==",
	yAxisTitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZElEQVR42rWRyw0AIAhDZTNGZzOVRBL/FhK5cCnlUSi1EpGsnZkpOWoQqwlqYFqqa3OdoDCBGcwEM82J7h8Bcj9E8DINEYQz2C24EiBEgzj0BU9gkIFneDHoKdDuwoUI0JMsqwLTeXtQiCq0vQAAAABJRU5ErkJggg==",
	yGridS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAUklEQVR42tWPOw4AIAhD25tx9HoyNE4mJn5QBxsGlj54RImXIUAEwmOA13485x/8oSDJzYwhwKj8VmF2eQhYLd9X2LncAZKE3XIHCCu0aTVW9gxUr0dI2tNB5gAAAABJRU5ErkJggg==",
	yellowCode: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90GExQvKwoXYgEAAAIkSURBVDjLhZNBS5RRFIafe7/7OTNppEEzy8IkaK8IUzEYtarQjKJEf0SLVm2DFv2CVoHJJMw4Y7gqpBwwopDoBxgzTkiYQpGZmjP3bfGN42hGL1w4nMt5znnP/T7zfGbmW61e75T3iFYJMFhjMMasDg8NJTlMU8Wi/qeVlRXlC4XsYfVWivqWK0uUK1UqS1XKlSrlyhIAE9ksyWSS8+n0nXyx+OxvQCNwLiAM945zAQDGWlbX1kilUlxIp28XpqfzrQBHw7m1DmtN88L7KH+mp4eXs7PIe0ZHRpB0Yz9AuxNYjNkDBIHY+LVBX28vfb29zbw5sGrX9GKDJsAacNYS1mtsr39nq+YBONZ1nKOOwwG7nq2BtsCSiAWUJjsAyNxaB0HpqSFxAGBbJwhsQDwMSSRilCY7yAy/wFrAhRCGWAvnBku8z+35aAJcYEnEHLEjbZSycTLXHqPlIbwHjAFj8B60fJW+y09YyDcguakpSdL21qbkf2tuHOnrfWnxpOazSPLSzra0syVJUe5Tt7T2QB+n0T4LmGgP2lkEd6K5d2wAtsV8kILalyjOFQqSJF+vR92kaIrqRal6KYobmhtH/vMV+eWbWsijgX5GrbW2+cVB9IyZMfFm/hWEp3AtjZ0DE3bz4W2Oe48Ye/2OCTM+MTHX3t6e8RJIWGOIO0NXzOJ+DOI9bHYUAUj8vE48BncfRsUNg5wGOg/+JAP9nOUf2i0G+AOIgBhW7Bye6QAAAABJRU5ErkJggg==",
	yg: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAtElEQVR42tWTwQ3DMAhFYQ9nil6aJXrzlL51CefSKZJBaqJP9NsQt0pPtYRsoc/DgK3y49LLXVLbh2bpQLM0m3Fm3ep3wAhLQXCFCenE/QzIAcQABSbQXMlf1bwdSARIyF4eN1nUUwGSCSJ01Qnn5NAWvJalJDTISJCXZmHfemLZI0CvH9XL8eAd4EMpHlxYvwMAkgnyTwB61v5gonEaYO5NYUDw+//wcU7fAI4+1gYKAWfWE0hXVxRNCdXsAAAAAElFTkSuQmCC",
	z: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAuElEQVR42qWTgQ3DIAwEzR5kjzAIUzJIskcZpCC90fM0aaNashwh+wxvJ9ifFug7Nt8Qv1lt/uqRAan5jshJJuB+fsAnQCb3pIrChOjn5Q6QqIPfzAFeXAAbGkQqNiR4cabuhbqbAviaFXowdOmugE0mkgU63o2cZQo8DddDhXN4t7OfKyDaLCZf/aRnDT3CD91ZNJ7SAtDuvDA6zqKASN11aXSZ7A7ASVer7LpMIj75kRj+cYyP7A2dTE0RinaMGwAAAABJRU5ErkJggg==",
	zAxis: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABCklEQVR42rWRsY5EUBiFz5XQTaImMT2tRCNZXmDnFeglHmWn0KPR66jYXqL0AhqvILg7V2J3ZMdak8xJbiTiO//3X6QsS4pbLMsieCIzxEqeLniZgeM4tK5rcBw3H0EQ5pMkCWRZ/v520yDLMtp13QwPwwDXdWEYBvI8hyiKZNfgPr7vUza5qioo5zOD9g2WhGFI2fQ0TfF+uazgXYOmaaiqqswAH9frL3jXQNd1ejqdUBTF5nqbBp7n0SAIEEURFEXBOI7ze03TIEnS/h3Ytk3btgXP8+j7HoQQTNOEOI5hmubff+HWSB/t+3CFewM6s8B/4ZXBm2UdAlcFbPJnWR5lfwqWLHdx5PkF88ufjwIy5cIAAAAASUVORK5CYII=",
	zAxisTitleS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcklEQVR42pVT0Q4AMQSbP/Pp/mx3SyZxOaq8kKHt2GRdM7N9vKrKGtin+ICwAF4rHiAFCFhisooRGKUAKRHEmuVeli1hdqMZxObfEOMhw0wpqJojQbuFTHb6kKKCTjZ8id0qKYCJlStj/ejnUQrYK/mcHkP8u1D8QpTsAAAAAElFTkSuQmCC",
	zGridS: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAX0lEQVR42mNkAIIDBw78d3BwYGQgAzBSbABIM4gxcC4YGl4A2vCfEaoWCxu/AQQ0M+L1AiHNeL1AjGacXiBBM6YXSNGM4QVSNaN4wd7BgYEMzYxwDjmJCO4FMkMfzAYA0Pt+CcV/PCoAAAAASUVORK5CYII=",
	zScore: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOklEQVR42mNkoBAwDl8D/hOrHp8BjESIEe2F/7jUEmPAf3zqCBnwn5AaRko04zOA4kCkOBqJBsPAAAB8dAoRZD+p8gAAAABJRU5ErkJggg=="
};
CanvasXpress.doc = {
	F: {
		fill: {
			M: "Genome",
			T: "color",
			C: "Color for the feature"
		},
		id: {
			M: "Genome",
			T: "string",
			C: "Feature id"
		}
	},
	M: {
		Shadows: {
			D: "Shadow properties used in most visualizations :",
			P: ["shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "showShadow", "showTextShadow"]
		},
		Acknowledgment: {
			D: "Properties used to acknowledge the use of canvasXpress :",
			P: ["acknowledgment"]
		},
		Clustering: {
			D: "Parameters used in clustering",
			P: ["clusterAxis", "distance", "imputeMethod", "kmeansSmpClusters", "kmeansVarClusters", "linkage", "maxIterations", "samplesClustered", "samplesKmeaned", "variablesClustered", "variablesKmeaned"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Area: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Stacked: "true"
			}
		},
		Histograms: {
			D: "Parameters used to create histograms in 2d scatter plots :",
			P: ["histogramBarWidth", "histogramBins", "histogramDensityKernel", "histogramStagger", "isCreateHistogram", "isHistogram", "showHistogramDensity"]
		},
		"Boxplot Graphs": {
			D: "General parameters in Boxplot Graphs",
			P: ["boxPlotOutliersRatio", "boxplotConnect", "boxplotConnectWidth", "boxplotDataPointRatio", "boxplotDataPointTransparency", "boxplotMean", "boxplotMeanColor", "boxplotMeanColorBorder", "boxplotMedianColor", "boxplotMedianWidth", "showBoxplotOriginalData", "showViolinBoxplot"],
			U: {
				Boxplot: "true"
			}
		},
		"Space and Width": {
			D: "Properties used to size the bars and point in one dimensional plots",
			P: ["sampleSeparationFactor", "variableSeparationFactor", "widthFactor"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				StackedLine: "true",
				BarLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Area: "true",
				Line: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		"Axis Resizer": {
			D: "Parameters used when resizing graphs",
			P: ["resizerBackgroundColor", "resizerBackgroundColorCurrent", "resizerBackgroundColorOutlineCurrent", "resizerBackgroundImage", "resizerDataIndex", "resizerDraw", "resizerPosition", "resizerTransparency", "resizerType", "resizerWidth"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Candlestick: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		"Y-Axis": {
			D: "Y axes parameters",
			P: ["setMaxY", "setMinY", "this", "yAxis", "yAxisAbsMax", "yAxisAbsMin", "yAxisCurrent", "yAxisExact", "yAxisHistogramHeight", "yAxisHistogramShow", "yAxisMajorTicks", "yAxisMaxStrLength", "yAxisMinorTicks", "yAxisMinorValues", "yAxisS2Show", "yAxisShow", "yAxisTickColor", "yAxisTickFormat", "yAxisTickStyle", "yAxisTicks", "yAxisTitle", "yAxisTransform", "yAxisTransformTicks", "yAxisValues"],
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		Foreground: {
			D: "Foreground properties used in all visualizations :",
			P: ["foreground", "foregroundWindow", "windowBox"]
		},
		"Venn Diagrams": {
			D: "General parameters in Venn diagrams",
			P: ["vennColors", "vennCompartments", "vennGroups", "vennLegendColors"],
			U: {
				Venn: "true"
			}
		},
		"Heatmap Graphs": {
			D: "General parameters for heatmaps",
			P: ["heatmapAutoAdjust", "heatmapCellBox", "heatmapCellBoxColor", "heatmapCellBoxColorHighlight", "heatmapCellBoxHighlightWidth", "heatmapCellBoxWidth", "heatmapIndicatorHeight", "heatmapIndicatorHistogram", "heatmapIndicatorHistogramColor", "heatmapIndicatorPosition", "heatmapIndicatorWidth", "heatmapLabelSizeAutoAdjust", "heatmapSeparatorWidth", "heatmapSmpSeparateBy", "heatmapVarSeparateBy", "isMultidimensionalData", "isOncoprint", "oncoprintAmplification", "oncoprintCode", "oncoprintDeletion", "showHeatmapIndicator", "smpIndicesStart", "varIndicesStart", "varTitleLabelOverlayPosition"],
			U: {
				Heatmap: "true"
			}
		},
		"Tag Cloud": {
			D: "General parameters used in tag clouds",
			P: ["tagCloudGridPoints", "tagCloudTextEllipticity", "tagCloudTextGridSize", "tagCloudTextRotateRatio", "tagCloudTextWeightFactor"],
			U: {
				Cloud: "true"
			}
		},
		Gradients: {
			D: "Properties used to adjust color gradients in all visualizations :",
			P: ["gradient", "gradientOrientation", "gradientRatio", "gradientType"]
		},
		"Remote Procedures": {
			D: "Parameters used when getting data remotely :",
			P: ["remoteAutoPlay", "remoteAutoPlayDelay", "remoteData", "remoteDataIndex", "remoteDirection", "remoteIds", "remoteParamOverride", "remoteParams", "remoteParentId", "remoteService", "remoteServiceType", "remoteUpdate", "remoteUpdateDelay", "remoteUpdating"]
		},
		Animation: {
			D: "Animation parameters :",
			P: ["animationCycles", "animationTime", "animationType", "showAnimation", "showAnimationFontColor", "showAnimationFontSize", "showAnimationFontStyle", "snapshotCopyChangeOnly"]
		},
		Events: {
			D: "Event parameters :",
			P: ["alignConfiguratorExamples", "broadcast", "broadcastType", "configuratorExamplesSize", "configuratorWidth", "dataEvent", "dataFilterWidth", "destroyCanvasXpressZombies", "disableAxisResizer", "disableConfigurator", "disableDataFilters", "disableDataTable", "disableEvents", "disableMenu", "disableToolbar", "disableTouchToolbar", "eventArrowKeys", "eventKeys", "eventPlusMinusKeys", "helpKeyEvents", "infoStartTime", "infoTimeIn", "infoTimeOut", "isLayoutConfigurator", "maintainZoomOnDrag", "maxItemMenuCheckbox", "maxSubMenus", "monitorCanvasXpressZombiesTime", "resizable", "resizeHeightOnLayout", "resizeWidthOnLayout", "showAdvancedConfiguration", "showConfiguratorExamplesOnSelect", "showFadeResizeMoveAnimation"]
		},
		"R-Axis": {
			D: "R axis parameters",
			P: ["rAxisAbsMax", "rAxisAbsMin", "rAxisLabelOrientation", "rAxisMaxStrLength", "rAxisMinorValues", "rAxisShow", "rAxisTickColor", "rAxisTicks", "rAxisValues"],
			U: {
				Circular: "true"
			}
		},
		Images: {
			D: "General parameters with images :",
			P: ["imageDir", "loadingImage"]
		},
		Videos: {
			D: "Video properties used in all visualizations",
			P: ["videoAutoplay", "videoClassName", "videoColor", "videoControls", "videoCurrentTime", "videoData", "videoGrid", "videoGridStep", "videoLoop", "videoPlaybackRate", "videoPoster", "videoPreload"],
			U: {
				Video: "true"
			}
		},
		"Genome Browser": {
			D: "General parameters used in genome browser",
			P: ["featureConfigurableProperties", "featureCoordinateHeight", "featureCoordinateShow", "featureDirColor", "featureFillColor", "featureHeightDefault", "featureNameFontColor", "featureNameFontSize", "featureNameFontStyle", "featureQualityHeight", "featureQualityShow", "featureQualityValues", "featureSignalToNoiseHeight", "featureSignalToNoiseShow", "featureSignalToNoiseValues", "featureStaggered", "featureTraceHeight", "featureTraceTrim", "featureTracesShow", "featureTranslateHeight", "featureTranslateShow", "featureTypeDefault", "featureWidthDefault", "filterFeatureBy", "genomeResolution", "genomeTicks", "maxFeatureStringLen", "periodTicksLabels", "sequenceAColor", "sequenceBColor", "sequenceCColor", "sequenceDColor", "sequenceEColor", "sequenceEndColor", "sequenceFColor", "sequenceFill", "sequenceFontSize", "sequenceFontStyle", "sequenceGAPColor", "sequenceGColor", "sequenceHColor", "sequenceIColor", "sequenceKColor", "sequenceLColor", "sequenceMColor", "sequenceNColor", "sequencePColor", "sequenceQColor", "sequenceRColor", "sequenceSColor", "sequenceStartColor", "sequenceTColor", "sequenceUColor", "sequenceVColor", "sequenceWColor", "sequenceXColor", "sequenceYColor", "sequenceZColor", "showFeatureNameThereshold", "subtracksMaxDefault", "trackConfigurableProperties", "trackDirColor", "trackFillColor", "trackNameFontColor", "trackNameFontSize", "trackNameFontStyle", "wireColor"],
			U: {
				Genome: "true"
			}
		},
		Random: {
			D: "Properties used to generate random data sets :",
			P: ["pseudoRandom", "randomData", "randomDataMean", "randomDataSampleAnnotationRatio", "randomDataSampleAnnotations", "randomDataSamples", "randomDataSigma", "randomDataSymmetrical", "randomDataUniform", "randomDataVariableAnnotationRatio", "randomDataVariableAnnotations", "randomDataVariables", "randomMissingDataPercentage", "randomNetworkNodeEdgesMax", "randomNetworkNodes", "randomNetworkReduce", "randomSeed"]
		},
		"Data Table/Filter": {
			D: "Parameters associated with data table and data filter",
			P: ["edgesProperties", "featuresProperties", "nodesProperties", "skipConfigurableProperties"],
			U: {
				Network: "true",
				Genome: "true"
			}
		},
		Samples: {
			D: "Properties associated with samples",
			P: ["filterSmpBy", "highlightSmp", "maxSmpStringLen", "showSampleNames", "smpHighlightColor", "smpLabelDescription", "smpLabelFontColor", "smpLabelFontSize", "smpLabelFontStyle", "smpLabelInterval", "smpLabelRotate", "smpLabelScaleFontFactor", "smpTitle", "smpTitleFontColor", "smpTitleFontSize", "smpTitleFontStyle", "smpTitleScaleFontFactor"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Stacked: "true"
			}
		},
		Snapshots: {
			D: "Paremeters used in snapshots",
			P: ["isAnimation", "snapshots"],
			U: {
				Network: "true"
			}
		},
		"General Attributes": {
			D: "Properties related to Shapes, Sizes, Images and Time :",
			P: ["images", "shapes", "sizes", "timeFormat"]
		},
		DOE: {
			D: "Parameters used to create pie and histograms in general data :",
			P: ["includeDOE", "maxDOENumber", "showDOEData"]
		},
		"Z-Axis": {
			D: "Z axes parameters",
			P: ["setMaxZ", "setMinZ", "zAxis", "zAxisAbsMax", "zAxisAbsMin", "zAxisCurrent", "zAxisExact", "zAxisMaxStrLength", "zAxisMinorValues", "zAxisShow", "zAxisTickColor", "zAxisTickFormat", "zAxisTickStyle", "zAxisTicks", "zAxisTitle", "zAxisValues"],
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true"
			}
		},
		Decorations: {
			D: "Additional elements added to graphs to increase data understanding",
			P: ["decorationFontSize", "decorationFontStyle", "decorationScaleFontFactor", "decorations", "decorationsBackgroundColor", "decorationsBox", "decorationsBoxColor", "decorationsColor", "decorationsColors", "decorationsHeight", "decorationsPosition", "decorationsProperties", "decorationsType", "decorationsWidth", "showDecorations", "showDecorationsKaplanMeierConfidence", "showDecorationsLegend", "showDecorationsRegressionConfidence"],
			U: {
				Network: "true",
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		Loess: {
			D: "Parameters used to create smooth lines in 2d scatter plots :",
			P: ["loessAccuracy", "loessBandwidth", "loessColor", "loessDrawOptimizer", "loessIteration", "showLoessFit"]
		},
		"Aspect Ratio": {
			D: "Properties used to adjust the aspect ratio in one dimensional plots",
			P: ["adjustAspectRatio", "adjustAspectRatioMax", "adjustAspectRatioXTries", "adjustAspectRatioYTries", "percentAspectRatioPlotArea"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				StackedLine: "true",
				BarLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Area: "true",
				Line: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		Overlays: {
			D: "Colored boxes to help in the visualization of samples and variables",
			P: ["overlayFontColor", "overlayFontSize", "overlayFontStyle", "overlayScaleFontFactor", "overlaysThickness", "showLevelOverlays", "showOverlays", "showSmpOverlaysLegend", "showVarOverlaysLegend", "smpOverlayProperties", "smpOverlays", "varOverlayProperties", "varOverlays"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Candlestick: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		Bins: {
			D: "Function to bin samples and variables",
			P: ["binConfigurations"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Candlestick: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		Contours: {
			D: "Parameters used to create contours in one and two dimensional plots :",
			P: ["contourType", "contourXBinSize", "contourYBinSize", "contourZBinSize"]
		},
		Margins: {
			D: "Margin properties used in most visualizations :",
			P: ["margin", "marginBottom", "marginLeft", "marginRight", "marginTop"]
		},
		"Citations or References": {
			D: "Properties associated with citations or references of the plot :",
			P: ["citation", "citationColor", "citationFontSize", "citationFontStyle", "citationScaleFontFactor"]
		},
		Text: {
			D: "Properties associated with text attributes :",
			P: ["align", "autoScaleFont", "baseline", "fontName", "fontScaleFontFactor", "fontSize", "fontStyle", "maxTextSize", "minTextSize", "scaleTextConstantAdd", "scaleTextConstantMult"]
		},
		"Plot area": {
			D: "General parameters for the plotting area in one dimensional plots",
			P: ["blockContrast", "is3DPlot", "jitter", "objectBorderColor", "plotByVariable", "showDataValues", "smpHairline", "smpHairlineColor", "smpHairlineWidth"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correlation: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Area: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Stacked: "true"
			}
		},
		Variables: {
			D: "Properties associated with variables",
			P: ["filterVarBy", "highlightVar", "maxVarStringLen", "showVariableNames", "varHighlightColor", "varLabelDescription", "varLabelFontColor", "varLabelFontSize", "varLabelFontStyle", "varLabelInterval", "varLabelRotate", "varLabelScaleFontFactor", "varTitle", "varTitleFontColor", "varTitleFontSize", "varTitleFontStyle", "varTitleScaleFontFactor"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Stacked: "true"
			}
		},
		"Data Point Attributes": {
			D: "General attributes for data points in scatter and one dimensional plots",
			P: ["colorBy", "colorByShowLegend", "connectBy", "connectByColor", "connectByData", "ellipseBy", "metadataColorProperties", "motionBy", "motionControlHeight", "motionTrails", "outlineBy", "outlineByData", "outlineByShowLegend", "patternBy", "patternByData", "patternByShowLegend", "shapeBy", "shapeByData", "shapeByShape", "shapeByShowLegend", "sizeBy", "sizeByContinuous", "sizeByData", "sizeByShowLegend", "treemapBy"],
			U: {
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				ScatterBubble2D: "true",
				Scatter3D: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Heatmap: "true"
			}
		},
		"Scatter Plot Matrix": {
			D: "Parameters used to create a matrix of 2d scatter plots",
			P: ["scatterPlotMatrix", "scatterPlotMatrixType"],
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		Dendrograms: {
			D: "General parameters in dendrograms",
			P: ["dendrogramColor", "dendrogramHang", "dendrogramHeight", "dendrogramSpace", "showSmpDendrogram", "showVarDendrogram", "smpDendrogramPosition", "varDendrogramPosition"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				Barline: "true",
				StackedLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Area: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Stacked: "true"
			}
		},
		"Area Graphs": {
			D: "General parameters in area graphs",
			P: ["areaType"],
			U: {
				Area: "true",
				AreaLine: "true"
			}
		},
		"Candlestick Plots": {
			D: "General parameters in candlestick plots",
			P: ["showVolume", "sma10Color", "sma20Color", "sma25Color", "sma50Color", "sma5Color", "stockIndicators"],
			U: {
				Candlestick: "true"
			}
		},
		"Pie Charts": {
			D: "General parameters in pie charts",
			P: ["maxPieSectors", "pieColors", "pieInnerRadius", "pieLabelType", "pieSegmentLabels", "pieSegmentPrecision", "pieSegmentSeparation", "pieType", "showPieGrid", "showPieSampleLabel", "showPieValues", "startPieSectors"],
			U: {
				Pie: "true"
			}
		},
		General: {
			D: "General properties used in most visualizations :",
			P: ["canvasBox", "canvasBoxColor", "functions", "graphOrientation", "graphType", "invertGraph", "isR", "isReproducibleResearch", "loadImagesTimeOut", "plotBox", "plotBoxColor", "printType", "reproduceTime", "thumbnail", "transparency"]
		},
		Axis: {
			D: "General axis parameters",
			P: ["axisAlgorithm", "axisExtension", "axisTickColor", "axisTickFontSize", "axisTickFontStyle", "axisTickScaleFontFactor", "axisTicksAutoAdjust", "axisTitleColor", "axisTitleFontSize", "axisTitleFontStyle", "axisTitleScaleFontFactor", "axisWilkinsonLoose", "setMax", "setMin"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Stacked: "true"
			}
		},
		"Line Graphs": {
			D: "General parameters in line graphs",
			P: ["coordinateLineColor", "hullScale", "lineDecoration", "lineErrorType", "lineThickness", "lineType", "tension"],
			U: {
				StackedLine: "true",
				Line: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		Colors: {
			D: "Properties to adjust Colors :",
			P: ["colorHSV", "colorRGB", "colorScheme", "colorSpectrum", "colorSpectrumBreaks", "colorSpectrumNumber", "colorSpectrumZeroValue", "colors", "evenColor", "oddColor"]
		},
		"X-Axis2": {
			D: "X2 Axis parameters",
			P: ["setMaxX2", "setMinX2", "xAxis2AbsMax", "xAxis2Exact", "xAxis2MaxStrLength", "xAxis2MinorValues", "xAxis2Show", "xAxis2TickFormat", "xAxis2Ticks", "xAxis2Title", "xAxis2Values"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				StackedLine: "true",
				BarLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Candlestick: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		"Network Graphs": {
			D: "General parameters used in networks",
			P: ["approximateNodePositions", "attractiveForceFunction", "autoHideOnDecorationsCenter", "calculateLayout", "calculateNetworkCommunities", "colorEdgeBy", "colorNodeBy3", "edgeConfigurableProperties", "edgeWidth", "filterEdgeBy", "filterNodeBy", "highlightNode", "initialTemperature", "is3DNetwork", "isCoordinateNodeColorsNetworkConvexHull", "isNetworkCommunities", "isNetworkConvexHull", "isSelectNodes", "labelNodePosition", "layoutTime", "moveParentsWithChildren", "network2DRotate", "networkCommunities", "networkConvexHulls", "networkDepth", "networkDivisions", "networkForceConstant", "networkFreeze", "networkFreezeOnLoad", "networkLayoutType", "networkNodeMinDistance", "networkNodesOnTop", "networkRoot", "networkStack", "networkStackIndex", "networkStackStates", "nodeConfigurableProperties", "nodeFontColor", "nodeFontSize", "nodeFontStyle", "nodeHighlightColor", "nodeScaleFontFactor", "nodeSize", "overrideAnchorNodes", "overrideEventlessNodes", "preScaleNetwork", "repulsiveForceFunction", "selectNode", "shapeEdgeBy", "shapeNodeBy", "showHiddenChildEdges", "showNetworkDecorationsLegend", "showNetworkEdgesLegend", "showNetworkNodesLegend", "showNetworkRadialLayout", "showNetworkTextLegend", "showNodeNameThreshold", "sizeDecorationBy", "sizeEdgeBy", "sizeNodeBy", "skipClick", "subNetworks", "temperature"],
			U: {
				Network: "true"
			}
		},
		"Combination Plots": {
			D: "Parameters used in complex plots :",
			P: ["layout", "layoutAdjust", "layoutAxis", "layoutBoxLabelColors", "layoutBoxShow", "layoutCanvasCompartments", "layoutCollapse", "layoutComb", "layoutCurrent", "layoutHeight", "layoutRemoveEmpty", "layoutWidth", "offsetX", "offsetY", "scaleX", "scaleY", "translateX", "translateY", "weight"]
		},
		"Circular Graphs": {
			D: "General parameters in circular graphs",
			P: ["arcSegmentsSeparation", "circularCenterProportion", "circularConnectionsTransparency", "circularLetterSeparationFactor", "rAxis", "rAxisZero", "ringSeparation", "ringsType", "ringsWeight", "showCircularConnections", "showRingLegend", "smpLabelOrientation"],
			U: {
				Circular: "true"
			}
		},
		"Zooming and Panning": {
			D: "Parameters associated with zooming and panning events :",
			P: ["panningGlobalX", "panningGlobalY", "panningStep", "panningX", "panningY", "zoom", "zoomGlobal", "zoomSamplesDisable", "zoomStep", "zoomVariablesDisable"]
		},
		Lines: {
			D: "Properties to adjust Lines :",
			P: ["arrowPointSize", "capType", "dashLength", "dotLength", "joinType", "lineWidthEvent", "lines", "outlineWidth"]
		},
		Debug: {
			D: "Debugging parameters :",
			P: ["codeType", "debug", "errors", "showCode", "showVersion"]
		},
		Legends: {
			D: "Legends for variables and samples",
			P: ["legendBackgroundColor", "legendBox", "legendBoxColor", "legendColor", "legendColumns", "legendFontSize", "legendFontStyle", "legendInside", "legendPosition", "legendScaleFontFactor", "showLegend"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Stacked: "true"
			}
		},
		Patterns: {
			D: "Properties related to Patterns :",
			P: ["patterns"]
		},
		"Data Table": {
			D: "Parameters associated with the data table :",
			P: ["axisTickFont", "axisTitleFont", "citationFont", "colWidth", "dataTableColumnWidth", "dataTableTransposed", "decorationFont", "featureNameFont", "font", "freezeColLeft", "freezeColRight", "freezeRowBottom", "freezeRowTop", "legendFont", "maxCols", "maxRows", "networkShowDataTable", "nodeFont", "overlayFont", "refresehDataTableOnDraw", "rowHeight", "sequenceFont", "showAnimationFont", "showDataTable", "showDataTableOnSelect", "smpLabelFont", "smpTitleFont", "startCol", "startRow", "subtitleFont", "titleFont", "trackNameFont", "varLabelFont", "varTitleFont"]
		},
		"Titles and Subtitles": {
			D: "Properties associated with titles and subtitles :",
			P: ["subtitle", "subtitleColor", "subtitleFontSize", "subtitleFontStyle", "subtitleScaleFontFactor", "title", "titleColor", "titleFontSize", "titleFontStyle", "titleScaleFontFactor"]
		},
		"Scatter Plots": {
			D: "General parameters in scatter plots",
			P: ["functionIntervals", "isSelectDataPoints", "scatterAxesEqual", "scatterOutlineThreshold", "scatterType", "selectDataMode", "selectDataModeDescription", "selectDataPoint"],
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		Background: {
			D: "Background properties used in all visualizations :",
			P: ["background", "backgroundGradient1Color", "backgroundGradient2Color", "backgroundImage", "backgroundType", "backgroundVideo", "backgroundWindow", "backgroundWindowGradient1Color", "backgroundWindowGradient2Color", "backgroundWindowGradientOrientation"]
		},
		"3D Attributes": {
			D: "General parameters in 3d scatter plots and networks",
			P: ["bar3DInverseWeight", "invMagnificationFactor", "perspectiveFactor", "rotationDelay", "rotationSensitivity", "rotationStep", "show3DGrid", "x3DRatio", "xRotate", "y3DRatio", "yRotate", "z3DRatio", "zRotate"],
			U: {
				Network: "true",
				Scatter3D: "true",
				Bar: "true"
			}
		},
		"Data Filters": {
			D: "Parameters associated with filtering :",
			P: ["filterSkipNullKeys", "filterSkipNullValues", "filterType"]
		},
		"Correlation Graphs": {
			D: "General parameters for correlation",
			P: ["correlationAnchorLegend", "correlationAnchorLegendAlignWidth", "correlationAxis", "correlationLabelInterval"],
			U: {
				Correlation: "true"
			}
		},
		Functions: {
			D: "Functions exposed in the configurator :",
			P: ["addNormalDistributionLine", "addRegressionLine", "clusterSamples", "clusterVariables", "createContour", "createHistogram", "createRandomData", "desegregateSamples", "desegregateVariables", "draw", "groupSamples", "hideCodeDiv", "hideInfoDiv", "hideUnhideSmps", "hideUnhideVars", "kmeansSamples", "kmeansVariables", "print", "recalculateLayout", "removeContour", "removeHistogram", "reset", "segregateSamples", "segregateVariables", "showCodeDiv", "showInfoDiv", "sortSamplesByCategory", "sortSamplesByVariable", "sortVariablesByCategory", "sortVariablesBySample", "transform", "transpose", "ungroupSamples", "updateCodeDiv"]
		},
		"X-Axis": {
			D: "X axis parameters",
			P: ["setMaxX", "setMinX", "this", "timeTicksFirst", "timeValueIndices", "timeValues", "xAxis", "xAxisAbsMax", "xAxisAbsMin", "xAxisCurrent", "xAxisExact", "xAxisHistogramHeight", "xAxisHistogramShow", "xAxisMajorTicks", "xAxisMaxStrLength", "xAxisMinorTicks", "xAxisMinorValues", "xAxisS2Show", "xAxisShow", "xAxisTickColor", "xAxisTickFormat", "xAxisTickStyle", "xAxisTicks", "xAxisTitle", "xAxisTransform", "xAxisTransformTicks", "xAxisValues"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				StackedLine: "true",
				Scatter2D: "true",
				BarLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Stacked: "true"
			}
		},
		R: {
			D: "Parameters associated with R :",
			P: ["RdatastesURL", "loadRDatasets"]
		},
		Data: {
			D: "Data related parameters",
			P: ["erroBarsWidth", "errorBarsType", "errorEllipseConfidence", "groupingFactors", "isBoxPlotCalc", "isGroupedData", "isLogData", "isMarketDataFormated", "isMarketSwitched", "isTransformedData", "missingDataColor", "ratioGroupReference", "ratioLevelReference", "ratioReference", "ratioSampleReference", "segregateSamplesBy", "segregateVariablesBy", "showErrorBars", "smpSort", "sortDir", "standardDeviationType", "tmpAsciiArray", "transformAxis", "transformBase", "transformCeilValue", "transformFloorValue", "transformType", "transformedData", "varSort"],
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Heatmap: "true",
				AreaLine: "true",
				Stacked: "true"
			}
		}
	},
	P: {
		yAxisTransform: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "ceil", "floor"],
			M: "Y-Axis",
			T: "option",
			C: "Transformation for the values in the Y axis.",
			D: "false"
		},
		vennCompartments: {
			Z: "true",
			M: "Venn Diagrams",
			T: "array",
			C: "Name for the compartments in the the Venn diagrams"
		},
		setMaxX: {
			Z: "true",
			H: ['{"setMaxX":200}', '{"setMaxX":50}', '{"setMaxX":null}'],
			M: "X-Axis",
			T: "float",
			C: "Maximum value to set the data in the X axis",
			D: "null"
		},
		adjustAspectRatioYTries: {
			Z: "true",
			M: "Aspect Ratio",
			T: "integer",
			C: "Counter set when trying to automatically adjust the vertical size of the canvas when adjustAspectRatio is true"
		},
		sequenceLColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the leucines in the genome browser",
			D: "rgb(0,103,0)"
		},
		pieSegmentLabels: {
			H: ["{*}"],
			O: ["inside", "outside"],
			M: "Pie Charts",
			T: "option",
			C: "Location for the values in the pie charts",
			D: "inside"
		},
		shapeBy: {
			S: ["shapeByData"],
			O: ["false", "variable"],
			T: "option",
			X: "getXZData",
			H: ['{"graphType":"Scatter3D","shapeBy":"Annt1"}', '{"graphType":"Scatter3D","shapeBy":"Sample4"}', '{"graphType":"Dotplot","shapeBy":"Factor1"}', '{"graphType":"Dotplot","shapeBy":"Annt1"}', '{"graphType":"Dotplot","shapeBy":"variable"}'],
			M: "Data Point Attributes",
			D: "false",
			C: "Name of a variable annotation or a sample name or the string 'variable' to shape the variables. When shapeByData is specified shapeBy is used for the title in the legend."
		},
		xAxis2Exact: {
			H: ['{*,"graphType":"BarLine"}'],
			M: "X-Axis2",
			T: "boolean",
			C: "Flag to force exact values for the data",
			D: "false",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		sequenceFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the text of the sequence in the genome browser"
		},
		networkStack: {
			Z: "true",
			M: "Network Graphs",
			T: "array",
			C: "Array to keep state of the network after a drag or move"
		},
		desegregateSamples: {
			S: ["segregateSamples"],
			M: "Functions",
			T: "void",
			C: "Desegreagate samples previously segregated based on a sample category (data.x object)",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		is3DNetwork: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to create or not a 3D network",
			D: "false"
		},
		variablesClustered: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Clustering",
			T: "boolean",
			C: "Configuration property to cluster variables",
			D: "false"
		},
		backgroundWindow: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"window"}'],
			M: "Background",
			T: "color",
			C: "Specifies the background color for the canvas when the background type is of a type 'window'.",
			D: "rgb(244,244,244)"
		},
		varDendrogramPosition: {
			H: ['{*,"data":"Generic","graphType":"Heatmap","showVarDendrogram":true}'],
			O: ["top", "bottom"],
			M: "Dendrograms",
			T: "option",
			C: "Position for the variable dendrogram in the plot. It could be top, bottom, right or left depending on the orientation of the graph.",
			D: "top"
		},
		calculateLayout: {
			H: ['{"data":"NetworkBasic","calculateLayout":false}', '{"data":"LesMiserables","calculateLayout":true,"colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to force or not to calculate the network layout.",
			D: "true"
		},
		varLabelInterval: {
			H: ["{*}"],
			M: "Variables",
			T: "integer",
			C: "Interval for the variable labels in heatmaps",
			D: "1",
			U: {
				Heatmap: "true"
			}
		},
		shapes: {
			H: ['{"data":"Shapes","calculateLayout":false,"graphType":"Network"}'],
			O: ["sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "pacman", "mdavid", "rect2", "rect3", "arc", "rectangle", "image"],
			M: "General Attributes",
			T: "array",
			C: "Shapes used in network graphs"
		},
		yAxisMinorValues: {
			M: "Y-Axis",
			T: "array",
			C: "Values for the minor ticks in the Y axis",
			D: "[]"
		},
		sequenceTColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the thymidines and threonines in the genome browser",
			D: "rgb(255,0,0)"
		},
		nodeFontColor: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "color",
			C: "Color for the network text",
			D: "rgb(0,0,0)"
		},
		networkNodeMinDistance: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "integer",
			C: "Minimum distance between nodes in forceDirected and organic layouts",
			D: "4"
		},
		lineThickness: {
			S: ["outlineWidth"],
			H: ['{*,"graphType":"Line"}'],
			M: "Line Graphs",
			T: "float",
			C: "Thickness in pixels for the lines in the line plots.",
			D: "1"
		},
		title: {
			S: ["titleHeight", "titleColor"],
			H: ['{"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "string",
			C: "Title of the graph.",
			D: "false"
		},
		pieInnerRadius: {
			H: ['{"data":"Generic","pieInnerRadius":0.2}', '{"data":"Generic","pieInnerRadius":0.35}', '{"data":"Generic","pieInnerRadius":0.5}'],
			M: "Pie Charts",
			T: "float",
			C: "Percentage of the radius in the pies to remove to make a donut. It must be a number between 0 to 1",
			D: "0"
		},
		zAxisMaxStrLength: {
			Z: "true",
			M: "Z-Axis",
			T: "string",
			C: "Longest string of all the values in the ticks in the Z axis"
		},
		remoteParamOverride: {
			M: "Remote Procedures",
			T: "boolean",
			C: "Flag to override parameters to maintain the state of the graphs when using remote services",
			D: "true"
		},
		yAxisExact: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to force exact values for the data",
			D: "false"
		},
		showShadow: {
			S: ["shadowOffsetX", "shadowOffsetY", "shadowBlur", "shadowColor"],
			H: ["{*}"],
			M: "Shadows",
			T: "boolean",
			C: "Flag used to add shadows to all graph objects in the canvas. It will be forced to false if the browser is IE.",
			D: "false"
		},
		colorScheme: {
			S: ["colors"],
			O: ["Default", "Basic", "Light", "Pastel", "Balanced", "User"],
			T: "option",
			X: "getColorSchemes",
			H: ['{*,"data":"Random:16:1:0:0:1","graphType":"Pie"}'],
			M: "Colors",
			D: "User",
			C: "Color schemes can be user defined which will take the colors in the color property or one provided in canvasXpress. The order of the colors will be used to sequentially select when a different color is needed in a particular visualization."
		},
		connectByColor: {
			H: ['{"graphType":"Scatter3D","connectBy":"Annt1"}', '{"graphType":"Scatter3D"}'],
			M: "Data Point Attributes",
			T: "color",
			C: "The color for the connectBy lines",
			D: "rgb(0,0,0)",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		showNetworkDecorationsLegend: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show node legends in the networks",
			D: "true"
		},
		zAxisTickFormat: {
			H: ['{"graphType":"Scatter3D","zAxisTickFormat":"%.2f cxs"}'],
			M: "Z-Axis",
			T: "string",
			C: "Format for the tick values in the Z axis",
			D: "false"
		},
		xAxisMinorValues: {
			M: "X-Axis",
			T: "array",
			C: "Values for the minor ticks in the X axis",
			D: "[]"
		},
		rAxisMinorValues: {
			M: "R-Axis",
			T: "array",
			C: "Values for the minor ticks in the R axis",
			D: "[]"
		},
		isMarketDataFormated: {
			Z: "true",
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the data has been formated to display Candlestick."
		},
		segregateSamples: {
			S: ["desegregateSamples"],
			M: "Functions",
			T: "option",
			C: "Segregate samples based on a sample category (data.x object)",
			X: "getXData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		ratioSampleReference: {
			O: ["false"],
			M: "Data",
			T: "option",
			C: "Name of the sample used in ratio transformation.",
			D: "false",
			X: "getSamplesAsArray"
		},
		ringsWeight: {
			H: ['{"data":"Circular","segregateVariablesBy":["Ring"],"ringsWeight":[0.5,0.25,0.25]}'],
			M: "Circular Graphs",
			T: "array",
			C: "Array containing the dimensions for each ring in the circular plots",
			D: "[]"
		},
		isTransformedData: {
			Z: "true",
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the data is transformed."
		},
		background: {
			S: ["backgroundType"],
			H: ["{*}"],
			M: "Background",
			T: "color",
			C: "Specifies the background color for the canvas.",
			D: "rgb(255,255,255)"
		},
		colorSpectrumBreaks: {
			S: ["colorSpectrum"],
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Colors",
			T: "array",
			C: "An array with cumulative fractions in ascending order for the color spectrum to create discontinuous spectra. It must have the same length of the colorSpectrum array for example [0, 0.3, 1]",
			D: "[]"
		},
		removeContour: {
			S: ["contourXBinSize", "contourYBinSize", "contourZBinSize", "contourType"],
			M: "Functions",
			T: "void",
			C: "Remove contour",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		resizerTransparency: {
			M: "Axis Resizer",
			T: "boolean",
			C: "Flag to make the axis resizers transparent",
			D: "true"
		},
		hideUnhideVars: {
			M: "Functions",
			T: "array",
			C: "Hide or unhide variables. It works like a switch",
			X: "getVariablesAsArray",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		periodTicksLabels: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Number of ticks to skip between values in the genome browser",
			D: "5"
		},
		colWidth: {
			M: "Data Table",
			T: "integer",
			C: "Mumber of pixels for the width of cells in the data table",
			D: "100"
		},
		showAnimationFontStyle: {
			O: ["", "bold", "italic", "bold italic"],
			M: "Animation",
			T: "option",
			C: "Font style for the animation.  @default"
		},
		varLabelFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the variable labels in one dimensional plots"
		},
		scaleY: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Scale factor for the Y axis"
		},
		startCol: {
			Z: "true",
			M: "Data Table",
			T: "integer",
			C: "Starting column in the data table"
		},
		xAxisTransform: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "ceil", "floor"],
			M: "X-Axis",
			T: "option",
			C: "Tranformation for the values in the X axis.",
			D: "false",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		nodesProperties: {
			M: "Data Table/Filter",
			T: "array",
			C: "Two dimensional array with object properties not at the root level for the nodes in the Network graph to include in the Data table and the data filter",
			D: "[]"
		},
		ratioReference: {
			H: ["{*}"],
			M: "Data",
			T: "integer",
			C: "Default index of sample used in ratio transformation.",
			D: "0"
		},
		citationColor: {
			S: ["citation"],
			H: ['{*,"citation":"Graph citation or reference"}'],
			M: "Citations or References",
			T: "color",
			C: "Color for a reference citation of the graph",
			D: "rgb(0,0,0)"
		},
		showDecorationsKaplanMeierConfidence: {
			S: ["decorations"],
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"KaplanMeier","showLegend":false,"title":"Kaplan-Meier Plot","functions":["addKaplanMeierCurve:Time:Censored-1:Data 1 Population:rgb(0,0,255)","addKaplanMeierCurve:Time:Censored-2:Data 2 Population:rgb(255,0,0)","draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to show or not the confidence intervals in the Kaplan-Meier plots",
			D: "false"
		},
		rAxisZero: {
			M: "Circular Graphs",
			T: "boolean",
			C: "Flag to force the rAxis to start from zero otherwise it starts from the minimum value",
			D: "false"
		},
		decorationsPosition: {
			H: ['{*,"showDecorations":true,"showLegend":false,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}', '{*,"data":"NetworkDecorations","graphType":"Network","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"],"conditional":{"decorationsPosition":["top","right"]}}', '{*,"data":"NetworkDecorations","graphType":"Network","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"],"conditional":{"decorationsPosition":["bottom","left"]}}'],
			O: ["rightTop", "right", "rightBottom", "bottom", "leftBottom", "left", "leftTop", "top"],
			M: "Decorations",
			T: "option",
			C: "Position for the decorations in one dimensional plots, scatter plots and network graphs. If legendInside is true the all the options apply but if legendInside is false only right and bottom are valid options",
			D: "bottom"
		},
		transformedData: {
			H: ["{*}"],
			S: ["transformType", "transformAxis"],
			M: "Data",
			T: "boolean",
			C: "Flag to transform data as a parameter. Works with transformType and transformAxis",
			D: "false"
		},
		eventPlusMinusKeys: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable plus / minus key binding events.",
			D: "false"
		},
		samplesKmeaned: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Clustering",
			T: "boolean",
			C: "Configuration property to k-mean samples",
			D: "false"
		},
		resizerBackgroundColorCurrent: {
			M: "Axis Resizer",
			T: "color",
			C: "Color for the div that shows up the current area selected in the axes in the canvas",
			D: "rgb(237,247,255)"
		},
		correlationAnchorLegend: {
			H: ["{*}"],
			M: "Correlation Graphs",
			T: "boolean",
			C: "Flag to show a region above the correlation plot that anchror a sample/variable to a position",
			D: "false"
		},
		axisTitleColor: {
			H: ["{*}"],
			M: "Axis",
			T: "color",
			C: "Color for the axis title in one and two dimensional plots",
			D: "rgb(0,0,0)"
		},
		varTitleFontColor: {
			H: ['{*,"varTitle":"Variable Title"}'],
			M: "Variables",
			T: "color",
			C: "Font color for the variable titles in one dimensional plots",
			D: "rgb(0,0,0)",
			U: {
				Heatmap: "true"
			}
		},
		circularConnectionsTransparency: {
			H: ['{*,"data":"Circular","segregateSamplesBy":["Segment"]}'],
			M: "Circular Graphs",
			T: "float",
			C: "Percentage of transparency applied to the connections in the circular graphs",
			D: "0.5"
		},
		loadImagesTimeOut: {
			M: "General",
			T: "integer",
			C: "Specifies the number of milliseconds to wait trying to load images before attempting to plot the data. For developers only.",
			D: "100"
		},
		xAxis2AbsMax: {
			Z: "true",
			M: "X-Axis2",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the 2nd X axis"
		},
		panningGlobalX: {
			Z: "true",
			M: "Zooming and Panning",
			T: "float",
			C: "Cumulative number of unit to pan the network in the X dimension"
		},
		xAxis: {
			H: ['{"xAxis":["Sample1","Sample2","Sample3"],"yAxis":["Sample4","Sample5","Sample6"],"graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "array",
			C: "Name of the samples or sample groups to be displayed in the X axis",
			D: "[]",
			X: "getSamplesAsArray",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		featureNameFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the text of the features in the genome browser"
		},
		offsetY: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Additional amount to move for the Y axis."
		},
		selectNode: {
			Z: "true",
			M: "Network Graphs",
			T: "object",
			C: "Name of nodes (in the data object) to select.",
			D: "{}"
		},
		featureTraceHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the trace height",
			D: "40"
		},
		featureQualityShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show quality",
			D: "true"
		},
		smpLabelFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Samples",
			T: "option",
			C: "Font style for the sample label.  @default"
		},
		lineDecoration: {
			H: ['{*,"graphType":"Line"}'],
			O: ["false", "dot", "symbol"],
			M: "Line Graphs",
			T: "option",
			C: "Lines decorations in the line graphs",
			D: "symbol"
		},
		kmeansVariables: {
			S: ["kmeansVarClusters", "maxIterations"],
			M: "Functions",
			T: "void",
			C: "Cluster variables using kmeans",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				Bar: "true",
				StackedPercentLine: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		clusterAxis: {
			S: ["distance", "linkage", "imputeMethod", "clusterSamples", "clusterVariables"],
			O: ["samples", "variables"],
			M: "Clustering",
			T: "option",
			C: "Default axis to use when clustering data.",
			D: "samples"
		},
		xAxisValues: {
			M: "X-Axis",
			T: "array",
			C: "Values for the ticks in the X axis",
			D: "[]"
		},
		varOverlayProperties: {
			M: "Overlays",
			T: "object",
			C: "Object to assign properties to the variable overlays. The key should be an annotation in the 'data.z' object and the value should be either type which could be either one of the one dimensional graph types or increasing, or decreasing for continuous annotations",
			D: "{}"
		},
		thumbnail: {
			M: "General",
			T: "string",
			C: "Name for the thumbnail",
			D: "false"
		},
		rotationDelay: {
			M: "3D Attributes",
			T: "integer",
			C: "Time in milliseconds to wait between rendering the plot when dragging the mouse.",
			D: "100"
		},
		varLabelScaleFontFactor: {
			H: ["{*}"],
			M: "Variables",
			T: "float",
			C: "Scaling factor used to increse or decrease variable font size in the canvas.",
			D: "1",
			U: {
				Heatmap: "true"
			}
		},
		maxVarStringLen: {
			H: ['{"maxVarStringLen":50}', '{"maxVarStringLen":5}'],
			M: "Variables",
			T: "integer",
			C: "Maximum length in characters a variable label or description can have so anything above is truncated.",
			D: "30",
			U: {
				Heatmap: "true"
			}
		},
		varLabelRotate: {
			H: ['{"varLabelRotate":0}', '{"varLabelRotate":45}', '{"varLabelRotate":90}'],
			M: "Variables",
			T: "integer",
			C: "Rotation for variable labels in degrees It could be positive or negative.",
			D: "0",
			U: {
				Heatmap: "true"
			}
		},
		networkNodesOnTop: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Order to use when drawing nodes and edges in the networks",
			D: "true"
		},
		colorRGB: {
			Z: "true",
			M: "Colors",
			T: "array",
			C: "Color RGB. Red, Green, Blue used in the configurator"
		},
		setMaxZ: {
			H: ['{"graphType":"Scatter3D","setMaxZ":200}', '{"graphType":"Scatter3D","setMaxZ":50}', '{"graphType":"Scatter3D","setMaxZ":null}'],
			M: "Z-Axis",
			T: "float",
			C: "Maximum value to set the data in the Z axis",
			D: "null"
		},
		dendrogramHeight: {
			H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true}'],
			S: ["dendrogramSpace", "dendrogramHang"],
			M: "Dendrograms",
			T: "integer",
			C: "Size in pixels for the dendrogram. If set to zero or false the length of the branches will be constant despite the similarity of the clusters and the value of dendrogramSpace will be used",
			D: "50"
		},
		showFeatureNameThereshold: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Threshehold used to set te limit when there are too many features in the genome browser",
			D: "20"
		},
		zAxisAbsMin: {
			Z: "true",
			M: "Z-Axis",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the Z axis"
		},
		setMinZ: {
			H: ['{"graphType":"Scatter3D","setMinY":15}', '{"graphType":"Scatter3D","setMinY":30}', '{"graphType":"Scatter3D","setMinY":null}'],
			M: "Z-Axis",
			T: "float",
			C: "Minimum value to set the data in the Z axis",
			D: "null"
		},
		varTitleFontSize: {
			H: ['{"varTitle":"Variable Title","autoScaleFont":false,"varTitleFontSize":10}', '{"varTitle":"Variable Title","autoScaleFont":false,"varTitleFontSize":20}'],
			M: "Variables",
			T: "integer",
			C: "Size for the variable title in one dimensional plots",
			D: "12",
			U: {
				Heatmap: "true"
			}
		},
		colorSpectrumNumber: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Colors",
			T: "integer",
			C: "Number of colors to use in the color spectrum",
			D: "100"
		},
		edgeWidth: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Default width for the edges in the networks",
			D: "1"
		},
		genomeTicks: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Number of ticks in the genome browser",
			D: "50"
		},
		sequenceSColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate G/C and serines in the genome browser",
			D: "rgb(255,165,0)"
		},
		showCircularConnections: {
			H: ['{*,"data":"Circular","segregateVariablesBy":["Ring"]}'],
			M: "Circular Graphs",
			T: "boolean",
			C: "Flag to show connections in circular graphs",
			D: "true"
		},
		showTextShadow: {
			S: ["shadowOffsetX", "shadowOffsetY", "shadowBlur", "shadowColor"],
			H: ["{*}"],
			M: "Shadows",
			T: "boolean",
			C: "Flag used to add shadows to all text in the canvas. It will be forced to false if the browser is IE.",
			D: "false"
		},
		maxIterations: {
			S: ["kmeansVarClusters", "kmeansSmpClusters", "kmeansSamples", "kmeansVariables"],
			M: "Clustering",
			T: "integer",
			C: "Number of maximum iterations when clustering data with kmeans for one dimensional graphs or maximum number of iterations when calculating force direct layout networks.",
			D: "10"
		},
		sortDir: {
			H: ["{*}"],
			O: ["ascending", "descending"],
			M: "Data",
			T: "option",
			C: "Default direction for data sorting.",
			D: "ascending"
		},
		filterSmpBy: {
			M: "Samples",
			T: "filter",
			C: "Filter samples by their annotation included in the 'data.x' object used in one dimensional plots",
			D: "[]",
			X: "getXData"
		},
		showOverlays: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "boolean",
			C: "Flag to indicate to show or not the overlays in one dimensional plots",
			D: "true"
		},
		graphOrientation: {
			H: ["{*}"],
			O: ["horizontal", "vertical"],
			M: "General",
			T: "option",
			C: "Specifies the orientation of one dimensional graphs.",
			D: "horizontal",
			U: {
				StackedPercent: "true",
				Bar: "true",
				StackedLine: "true",
				BarLine: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Treemap: "true",
				Candlestick: "true",
				TagCloud: "true",
				Area: "true",
				Line: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		outlineWidth: {
			S: ["lineThickness"],
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "integer",
			C: "Default width in pixels for lines in networks and other line elements in all visualizations except for the lines in the line plots.",
			D: "1"
		},
		randomDataVariableAnnotationRatio: {
			M: "Random",
			T: "integer",
			C: "Approximate number of variables in each class",
			D: "1"
		},
		marginRight: {
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Specifies the length in pixels for the right margin in the canvas.",
			D: "5"
		},
		boxplotMeanColorBorder: {
			H: ['{"data":"Boxplot","boxplotMean":true,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "color",
			C: "Color for the border of the mean of data in boxplots",
			D: "rgb(255,0,0)"
		},
		align: {
			H: ['{*,"title":"Graph Title"}'],
			O: ["right", "center", "left"],
			M: "Text",
			T: "option",
			C: "Default horizontal alignment for drawing text.",
			D: "center"
		},
		dataTableTransposed: {
			M: "Data Table",
			T: "boolean",
			C: "Flag to transpose the data in the data table",
			D: "true"
		},
		showDataTableOnSelect: {
			M: "Data Table",
			T: "boolean",
			C: "Flag to indicate to show data after selecting data in the plot",
			D: "false"
		},
		wireColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the ticks in the genome browser",
			D: "rgba(204,204,204,0.1)"
		},
		sequenceVColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/C/G and valines in the genome browser",
			D: "rgb(0,103,0)"
		},
		marginTop: {
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Specifies the length in pixels for the top margin in the canvas.",
			D: "5"
		},
		kmeansSmpClusters: {
			H: ['{"graphType":"Heatmap","kmeansSmpClusters":2,"functions":["kmeansSamples","kmeansVariables"]}', '{"graphType":"Heatmap","kmeansSmpClusters":4,"functions":["kmeansSamples","kmeansVariables"]}'],
			S: ["maxIterations", "kmeansVarClusters", "kmeansSamples", "kmeansVariables"],
			M: "Clustering",
			T: "integer",
			C: "Number of clusters when clustering sample data with kmeans.",
			D: "3"
		},
		setMin: {
			Z: "true",
			M: "Axis",
			T: "float",
			C: "Minimum value to set the data",
			D: "null"
		},
		animationCycles: {
			M: "Animation",
			T: "integer",
			C: "Number of cycles to plot the graph for the animations.",
			D: "20"
		},
		networkCommunities: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Number of network communities"
		},
		sequenceDColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/G/T and aspartic acids in the genome browser",
			D: "rgb(0,0,0)"
		},
		videoLoop: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "boolean",
			C: "Flag to loop videos"
		},
		shapeNodeBy: {
			H: ['{"data":"LesMiserables","colorNodeBy":"group","shapeNodeBy":"group"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to shape the nods.",
			D: "false"
		},
		tagCloudGridPoints: {
			Z: "true",
			M: "Tag Cloud",
			T: "array",
			C: "Array to keep state of the used space in the tag cloud visualization"
		},
		axisTickFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Axis",
			T: "option",
			C: "Font style for the axis.  @default"
		},
		errors: {
			Z: "true",
			M: "Debug",
			T: "array",
			C: "Array containing benign errors produced when rendering canvasXpress",
			D: "[]"
		},
		xAxisShow: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the X axis",
			D: "true"
		},
		heatmapSeparatorWidth: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Width for the heatmap separator",
			D: "2.5"
		},
		canvasBoxColor: {
			S: ["canvasBox"],
			H: ['{*,"canvasBox":true}'],
			M: "General",
			T: "color",
			C: "Color for the box around the canvas",
			D: "rgb(204,204,204)"
		},
		featureConfigurableProperties: {
			F: "id:[string];Feature id;[],fill:[color];Color for the feature;[]",
			H: ["{*}"],
			M: "Genome Browser",
			T: "array",
			C: "Feature configurable properties",
			D: ["'id'", "'name'", "'label'", "'hideName'", "'fill'", "'outline'", "'dir'", "'showDir'", "'connect'", "'offset'", "'data'", "'subtype'", "'quality'", "'signalToNoise'", "'coordinate'", "'sequence'", "'trace'", "'gaps'", "'translate'", "'hide'", "'counter'"]
		},
		subtracksMaxDefault: {
			M: "Genome Browser",
			T: "integer",
			C: "Maximum number of subtracks to show in a track",
			D: "8"
		},
		remoteData: {
			Z: "true",
			M: "Remote Procedures",
			T: "array",
			C: "Array for the remote data pased after a service call"
		},
		contourZBinSize: {
			H: ['{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":5,"contourYBinSize":5,"contourZBinSize":5}', '{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":10,"contourYBinSize":10,"contourZBinSize":10}'],
			S: ["createContour"],
			M: "Contours",
			T: "integer",
			C: "Size of Z bins in contour plots",
			D: "false"
		},
		acknowledgment: {
			H: ["{*}"],
			M: "Acknowledgment",
			T: "boolean",
			C: "Flag to include an acknowledgment image for canvasXpress",
			D: "false"
		},
		videoColor: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "color",
			C: "Color for the video grid and current time",
			D: "rgb(255,0,0)"
		},
		sizes: {
			H: ['{"data":"Random:16:3:16:0","graphType":"Scatter3D","sizeBy":"Annt1"}'],
			O: ["12", "14", "16", "18", "20", "22", "24", "26", "28", "30", "32", "34", "36", "38", "40", "42"],
			M: "General Attributes",
			T: "array",
			C: "Sizes used invisualizations"
		},
		infoTimeIn: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Time in milliseconds to start showing info after a mouse over",
			D: "50"
		},
		layoutHeight: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Height of the current segment of the canvas when there are multiple graphs."
		},
		sizeEdgeBy: {
			H: ['{"data":"LesMiserables","sizeEdgeBy":"value"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to size the edges.",
			D: "false"
		},
		heatmapSmpSeparateBy: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "string",
			C: "Factor used to separate the heatmap",
			D: "false",
			X: "getXData"
		},
		xAxis2Title: {
			H: ['{"graphType":"BarLine","xAxis2Title":"2nd X-axis title"}'],
			M: "X-Axis2",
			T: "string",
			C: "Title for the 2nd X axis",
			D: "false"
		},
		loadingImage: {
			H: ["{*}"],
			O: ["loading1", "loading2"],
			M: "Images",
			T: "image",
			C: "Relative path to an image file to the loading image (not including the image directory)",
			D: "loading1"
		},
		foregroundWindow: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"window"}'],
			M: "Foreground",
			T: "color",
			C: "Specifies the foreground color for text or lines when the background type is of a type 'window'.",
			D: "rgb(0,0,0)"
		},
		heatmapCellBoxColorHighlight: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "color",
			C: "Color for highlighting heatmap cells",
			D: "rgb(255,215,0)"
		},
		colorBy: {
			H: ['{"graphType":"Scatter3D","colorBy":"Annt1"}', '{"graphType":"Scatter3D","colorBy":"Sample4"}', '{"graphType":"Bar","colorBy":"Factor1"}', '{"graphType":"Dotplot","colorBy":"Factor1"}', '{"graphType":"Dotplot","colorBy":"Annt1"}'],
			O: ["false", "variable"],
			M: "Data Point Attributes",
			T: "option",
			C: "Name of a variable annotation or a sample name or the string 'variable' to color the variables.",
			D: "false",
			X: "getXZData"
		},
		randomNetworkNodeEdgesMax: {
			M: "Random",
			T: "integer",
			C: "Default number of maximum edges when creating random networks",
			D: "5",
			U: {
				Network: "true"
			}
		},
		scaleTextConstantAdd: {
			Z: "true",
			M: "Text",
			T: "float",
			C: "Constants to autoscale text (extra)",
			D: "2.0"
		},
		randomSeed: {
			M: "Random",
			T: "integer",
			C: "Specifies the random seed number to create pseudo random numbers",
			D: "8"
		},
		outlineByData: {
			H: ['{"data":"MultidimensionalHeatmap","outlineByData":"data2","outlineBy":"Data Outline"}'],
			S: ["outlineBy"],
			M: "Data Point Attributes",
			T: "string",
			C: "String that identify the object containing a two dimensional array with values used to color the outline data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data4)",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		transformBase: {
			H: ["{*}"],
			O: ["2", "10"],
			M: "Data",
			T: "integer",
			C: "Default log or exponential transformation.",
			D: "2"
		},
		plotBox: {
			S: ["plotBoxColor"],
			H: ["{*}"],
			M: "General",
			T: "boolean",
			C: "Flag to create a box around the plot",
			D: "false"
		},
		missingDataColor: {
			H: ['{*,"data":"Random:10:10::::::0.15","graphType":"Heatmap"}'],
			M: "Data",
			T: "color",
			C: "Color for the missing data",
			D: "rgb(255,255,0)"
		},
		patternByData: {
			H: ['{"data":"MultidimensionalHeatmap","patternByData":"data2","patternBy":"Data Outline"}'],
			S: ["patternBy"],
			M: "Data Point Attributes",
			T: "string",
			C: "String that identify the object containing a two dimensional array with values used to pattern the data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data4)",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		offsetX: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Additional amount to move for the X axis"
		},
		videoAutoplay: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "boolean",
			C: "Flag to autoplay videos"
		},
		rAxisAbsMin: {
			Z: "true",
			M: "R-Axis",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the R axis"
		},
		zAxisTickStyle: {
			H: ['{*,"graphType":"Scatter3D"}'],
			O: ["solid", "dotted"],
			M: "Z-Axis",
			T: "option",
			C: "Style for the tick lines in the Z axis",
			D: "solid"
		},
		showNodeNameThreshold: {
			H: ['{"data":"LesMiserables","showNodeNameThreshold":50,"colorNodeBy":"group"}', '{"data":"LesMiserables","showNodeNameThreshold":100,"colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "integer",
			C: "Thereshold used to set the limit to hide or display the name of nodes in a network. If the number of nodes exceed this thereshold then the name will not be shown.",
			D: "50"
		},
		arcSegmentsSeparation: {
			H: ['{*,"data":"Circular","segregateSamplesBy":["Segment"]}'],
			M: "Circular Graphs",
			T: "integer",
			C: "Number of degrees to separate the segments in the circular plots",
			D: "5"
		},
		sizeByData: {
			H: ['{"data":"MultidimensionalHeatmap","sizeByData":"data3","sizeBy":"Data Size"}'],
			S: ["sizeBy"],
			M: "Data Point Attributes",
			T: "string",
			C: "String that identify the object containing a two dimensional array with values used to size data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data3)",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		heatmapIndicatorHeight: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "integer",
			C: "Length in pixels for the heatmap indicator",
			D: "20"
		},
		transformAxis: {
			H: ["{*}"],
			S: ["transformedData", "transformType"],
			O: ["samples", "variables"],
			M: "Data",
			T: "option",
			C: "Default axis to use to transform the data.",
			D: "samples"
		},
		isSelectDataPoints: {
			Z: "true",
			M: "Scatter Plots",
			T: "integer",
			C: "Number of selected data points (in the data object).",
			D: "0"
		},
		randomDataSampleAnnotations: {
			M: "Random",
			T: "integer",
			C: "Default number of sample annotations when creating random data",
			D: "3"
		},
		smpLabelRotate: {
			H: ['{"smpLabelRotate":0}', '{"smpLabelRotate":-45}', '{"smpLabelRotate":90}'],
			M: "Samples",
			T: "integer",
			C: "Rotation for sample labels in degrees. It could be positive or negative.",
			D: "0"
		},
		randomDataUniform: {
			M: "Random",
			T: "boolean",
			C: "Flag to create or not uniform random data for debug and demonstration purposes",
			D: "false"
		},
		resizerWidth: {
			M: "Axis Resizer",
			T: "integer",
			C: "Length in pixels for the width of the visible axis resizer",
			D: "50"
		},
		showNetworkRadialLayout: {
			H: ['{*,"data":"NetworkRadial","networkLayoutType":"radial"}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show or not a radial layout wire.",
			D: "false"
		},
		overlayFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the overlays in one dimensional plots"
		},
		infoTimeOut: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Time in milliseconds to wait between updates for the mouse over info to show up",
			D: "3000"
		},
		showDecorationsLegend: {
			H: ['{"showDecorationsLegends":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}', '{"showDecorationsLegends":false,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to show or not the decoration legends",
			D: "true"
		},
		decorationsBackgroundColor: {
			S: ["decorationsBox"],
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			M: "Decorations",
			T: "color",
			C: "Color for the decoration legend background",
			D: "rgb(255,255,255)"
		},
		filterSkipNullValues: {
			M: "Data Filters",
			T: "boolean",
			C: "Flag to indicate to bypass filtering when a value is null",
			D: "false"
		},
		variablesKmeaned: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Clustering",
			T: "boolean",
			C: "Configuration property to k-mean variables",
			D: "false"
		},
		setMinY: {
			H: ['{"graphType":"Scatter2D","setMinY":15}', '{"graphType":"Scatter2D","setMinY":30}', '{"graphType":"Scatter2D","setMinY":null}'],
			M: "Y-Axis",
			T: "float",
			C: "Minimum value to set the data in the Y axis",
			D: "null"
		},
		showNetworkEdgesLegend: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show edge legends in the networks",
			D: "true"
		},
		alignConfiguratorExamples: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to align examples to the configurator",
			D: "false"
		},
		featureDirColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Default color for the strand direction of the feature in the genome browser",
			D: "rgb(0,0,0)"
		},
		filterNodeBy: {
			M: "Network Graphs",
			T: "filter",
			C: "Filter nodes by their properties used in network graphs",
			D: "[]",
			X: "getNodeData"
		},
		panningGlobalY: {
			Z: "true",
			M: "Zooming and Panning",
			T: "float",
			C: "Cumulative number of unit to pan the network in the Y dimension"
		},
		sizeByContinuous: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the size data continuously as opposed to by binning the sizes",
			D: "false"
		},
		legendInside: {
			H: ["{*}"],
			M: "Legends",
			T: "boolean",
			C: "Position the legend inside the graphs",
			D: "false"
		},
		featureHeightDefault: {
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the feature height",
			D: "14"
		},
		zAxisTicks: {
			Z: "true",
			M: "Z-Axis",
			T: "integer",
			C: "Number of ticks in the Z axis",
			D: "10"
		},
		invertGraph: {
			M: "General",
			T: "boolean",
			C: "Flag to invert horizontal one dimensional graph to plot from right to left",
			D: "false"
		},
		remoteIds: {
			Z: "true",
			M: "Remote Procedures",
			T: "array",
			C: "Array of the remoteIds passed after a service call"
		},
		freezeColLeft: {
			M: "Data Table",
			T: "integer",
			C: "Number of columns to freeze in the left side of the data table",
			D: "0"
		},
		yAxisTickFormat: {
			H: ['{"graphType":"Scatter2D","yAxisTickFormat":"%.2f cxs"}'],
			M: "Y-Axis",
			T: "string",
			C: "Format for the tick values in the Y axis",
			D: "false"
		},
		isGroupedData: {
			Z: "true",
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the data is grouped."
		},
		vennLegendColors: {
			H: ["{*}"],
			M: "Venn Diagrams",
			T: "boolean",
			C: "Flag to use the venn colors to use for the legends instead of the letters",
			D: "false"
		},
		samplesClustered: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Clustering",
			T: "boolean",
			C: "Configuration property to cluster samples",
			D: "false"
		},
		zoomGlobal: {
			Z: "true",
			M: "Zooming and Panning",
			T: "float",
			C: "Cumulative zoom factor for the networks."
		},
		decorationsType: {
			H: ['{*,"data":"NetworkDecorations","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"conditional":{"decorations":[["exp1","exp2","exp3"],["exp1","exp2","exp3"],["exp4","exp5"],["exp4","exp5"],["exp4","exp5"]]}}'],
			O: ["pie", "bar", "heatmap", "stacked", "stackedpercent"],
			M: "Decorations",
			T: "option",
			C: "Type for the decorations in the networks. The types stacked and stackedpercent must be two dimensional. Heatmap could be one or two dimensional",
			D: "bar",
			U: {
				Network: "true"
			}
		},
		showVersion: {
			M: "Debug",
			T: "boolean",
			C: "Flag to show version when mouse over top-left corner of the canvas.",
			D: "true"
		},
		networkDepth: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Depth of the radial network."
		},
		showHiddenChildEdges: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show or not children nodes when the parent node is hidden.",
			D: "true"
		},
		scatterAxesEqual: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Scatter Plots",
			T: "boolean",
			C: "Keep same range in both axes",
			D: "false"
		},
		randomDataSigma: {
			M: "Random",
			T: "integer",
			C: "Sigma value when creating random data",
			D: "1"
		},
		resizeWidthOnLayout: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable resizing the width of the canvas after changing the layout",
			D: "true"
		},
		nodeConfigurableProperties: {
			M: "Network Graphs",
			T: "array",
			C: "Node configurable properties  @nodes {x:[float];X coordinate;[],y:[float];Y coordinate;[],z:[float];Z coordinate;[],parentNode:[string];Id of parent node;[],shape:[string];Shape for the node. One of the ones defined in shapes;[shapes],color:[color];Color for the node;[],outline:[color];Color for the outline of the node;[],pattern:[open|closed];Whether to draw a solid shape or just an outline;[],rotate:[integer];Number of degrees to rotate the shape;[],outlineWidth:[integer];Pixels used to raw the outline of the node;[],imagePath:[url];Url for the node image;[],zIndex:[integer];Css property for the imagePath;[],eventless:[boolean];Flag to disable all events in the node;[overrideEventlessNodes],hide:[boolean];Flag to hide the node;[],hideLabel:[boolean];Flag to hide the label node;[],anchor:[boolean];Flag make the node transparent;[]}",
			D: ["'x'", "'y'", "'z'", "'shape'", "'color'", "'outline'", "'size'", "'width'", "'height'", "'pattern'", "'rotate'", "'outlineWidth'", "'imagePath'", "'zIndex'", "'eventless'"]
		},
		heatmapIndicatorPosition: {
			H: ["{*}"],
			O: ["topLeft", "top", "topRight", "right"],
			M: "Heatmap Graphs",
			T: "option",
			C: "Position for the heatmap indicator",
			D: "top"
		},
		zoomStep: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Zooming and Panning",
			T: "float",
			C: "Percentage step for zooming networks and genome panel.",
			D: "0.2"
		},
		axisTitleScaleFontFactor: {
			H: ["{*}"],
			M: "Axis",
			T: "float",
			C: "Scaling factor used to increase or decrease title font size in the canvas in one and two dimensional plots",
			D: "1"
		},
		zAxisExact: {
			H: ['{*,"graphType":"Scatter3D"}'],
			M: "Z-Axis",
			T: "boolean",
			C: "Flag to force exact values for the data in the Z axis",
			D: "false"
		},
		createContour: {
			S: ["contourXBinSize", "contourYBinSize", "contourZBinSize", "contourType"],
			M: "Functions",
			T: "void",
			C: "Create contour",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		featureSignalToNoiseValues: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show values for the quality",
			D: "false"
		},
		showNetworkTextLegend: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show node legends in the networks",
			D: "true"
		},
		overlaysThickness: {
			S: ["adjustAspectRatio"],
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "integer",
			C: "Relative length in pixels for the thickness of the colored boxes to classify samples and or variables in one dimensional plots. This value is adjusted acording to the graph dimensions if the adjustAspectRatio parameter is set to 'true'.",
			D: "18"
		},
		createHistogram: {
			O: ["x", "y"],
			M: "Functions",
			T: "option",
			C: "Create a histogram in 2D-Scatter plots in the 'x' axis or the 'y' axis  @advanced",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		sma20Color: {
			H: ['{*,"stockIndicators":["Sma20"]}'],
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 25 day single moving average",
			D: "rgb(0,0,255)"
		},
		smpHairlineColor: {
			H: ['{*,"graphType":"Bar","smpHairline":true}'],
			M: "Plot area",
			T: "color",
			C: "The color for the thin line that appears in the middle of the bar graphs",
			D: "rgb(204,204,204)"
		},
		axisTitleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the axis titles in one and two dimensional plots"
		},
		functions: {
			Z: "true",
			M: "General",
			T: "array",
			C: "Functions exposed to the api"
		},
		decorationsProperties: {
			H: ['{"data":"NetworkDecorations","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"],"decorationsProperties":{"exp1":{"color":"rgb(51,125,255)","shape":"square"},"exp2":{"color":"rgb(125,255,51)","shape":"square"},"exp2":{"color":"rgb(255,125,51)","shape":"square"}}}'],
			M: "Decorations",
			T: "object",
			C: "Object to assign properties like color for the network decorations",
			D: "{}",
			U: {
				Network: "true"
			}
		},
		ratioLevelReference: {
			M: "Data",
			T: "option",
			C: "Name of the level used in ratio transformation.  @default"
		},
		rAxisMaxStrLength: {
			Z: "true",
			M: "R-Axis",
			T: "string",
			C: "Longest string of all the values in the ticks in the R axis"
		},
		showAnimationFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Initialize configurations  @param void @returns void"
		},
		isOncoprint: {
			H: ['{*,"data":"MultidimensionalHeatmap"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to draw an oncoprint heatmap",
			D: "false"
		},
		videoPoster: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "url",
			C: "Video poster for videos  @default"
		},
		nodeFontSize: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Size in pixels for the font size of text in the networks",
			D: "20"
		},
		sortSamplesByVariable: {
			S: ["sortDir", "sortSamplesByCategory"],
			M: "Functions",
			T: "array",
			C: "Sort the samples by the value of a variable",
			X: "getVariablesAsArray",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		resizerBackgroundImage: {
			M: "Axis Resizer",
			T: "url",
			C: "Resizer background image",
			D: "false"
		},
		sizeDecorationBy: {
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to size the network decoration.",
			D: "false"
		},
		trackConfigurableProperties: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "array",
			C: "Track configurable properties",
			D: ["'name'", "'hideName'", "'hideFeatureNames'", "'type'", "'height'", "'fill'", "'outline'", "'data'", "'hide'", "'connect'", "'subtracksMax'", "'highlight'"],
			G: "name:[string];Track name;[]"
		},
		xAxisTickColor: {
			H: ["{*}"],
			M: "X-Axis",
			T: "color",
			C: "Color for the tick lines in the X axis",
			D: "rgb(204,204,204)"
		},
		yAxisTickColor: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "color",
			C: "Color for the tick lines in the Y axis",
			D: "rgb(204,204,204)",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		isAnimation: {
			Z: "true",
			M: "Snapshots",
			T: "boolean",
			C: "Flag to indicate if there is an active animation"
		},
		pieSegmentPrecision: {
			H: ["{*}"],
			M: "Pie Charts",
			T: "integer",
			C: "Number of decimals for values in the Pie charts",
			D: "0"
		},
		disableToolbar: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing the toolbar",
			D: "false"
		},
		decorationScaleFontFactor: {
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			M: "Decorations",
			T: "float",
			C: "Scaling factor used to increase or decrease decoration font size in the canvas.",
			D: "1"
		},
		boxPlotOutliersRatio: {
			H: ['{"data":"Boxplot","boxPlotOutliersRatio":8,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","boxPlotOutliersRatio":10,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "integer",
			C: "Ratio for the size of the outliers with respect to boxplot",
			D: "8"
		},
		panningY: {
			H: ["{*}"],
			M: "Zooming and Panning",
			T: "float",
			C: "Number of unit to pan the network in the Y dimension",
			D: "0"
		},
		errorBarsType: {
			H: ['{"errorBarsType":"standardDeviation","functions":["groupSamples:Factor1"]}', '{"errorBarsType":"standardErrorMean","functions":["groupSamples:Factor1"]}', '{"errorBarsType":"confidenceInterval95","functions":["groupSamples:Factor1"]}'],
			O: ["standardDeviation", "standardErrorMean", "confidenceInterval95"],
			M: "Data",
			T: "option",
			C: "Type of error bars.",
			D: "confidenceInterval95"
		},
		randomDataMean: {
			M: "Random",
			T: "integer",
			C: "Mean value when creating random data",
			D: "0"
		},
		transpose: {
			M: "Functions",
			T: "void",
			C: "Transpose the data. It takes no parameters",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				Bar: "true",
				StackedPercentLine: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		smpLabelScaleFontFactor: {
			H: ["{*}"],
			M: "Samples",
			T: "float",
			C: "Scaling factor used to increase or decrease sample label font size in the canvas.",
			D: "1"
		},
		circularLetterSeparationFactor: {
			H: ['{*,"data":"Circular","segregateSamplesBy":["Segment"]}'],
			M: "Circular Graphs",
			T: "float",
			C: "Factor to adjust the spacing between letters in the circular graphs. The greater the number the closer the letters in the labels",
			D: "2"
		},
		debug: {
			M: "Debug",
			T: "boolean",
			C: "Flag to turn on alerts.",
			D: "false"
		},
		citation: {
			S: ["citationColor"],
			H: ['{"citation":"Graph citation or reference"}'],
			M: "Citations or References",
			T: "string",
			C: "A reference citation of the graph which is placed at the bottom right corner",
			D: "false"
		},
		smpSort: {
			Z: "true",
			M: "Data",
			T: "integer",
			C: "Sample index used in sorting the data."
		},
		resizerBackgroundColorOutlineCurrent: {
			M: "Axis Resizer",
			T: "color",
			C: "Color for the div that shows up the current area selected in the axes in the canvas",
			D: "rgb(59,138,229)"
		},
		showAnimation: {
			H: ["{*}"],
			M: "Animation",
			T: "boolean",
			C: "Flag to show or not animation for the graphs",
			D: "false"
		},
		yAxisMajorTicks: {
			H: ["{*}"],
			M: "Y-Axis",
			T: "boolean",
			C: "A flag to show major tick lines in the Y axis",
			D: "true"
		},
		networkFreezeOnLoad: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to prevent autoscaling for the network layout after loading. Useful when images are part of the network.",
			D: "false"
		},
		layoutTime: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Time in milliseconds used to calculate the layout for the network",
			D: "15"
		},
		xAxisAbsMax: {
			Z: "true",
			M: "X-Axis",
			T: "float",
			C: "Maximum non-filtered value for the data plotted in the X axis"
		},
		showSmpOverlaysLegend: {
			H: ["{*}"],
			M: "Overlays",
			T: "boolean",
			C: "Flag to show or not the legend for the sample overlays in the graphs. If set to false the level information will be displayed in the actual colored boxes of the overlays",
			D: "false"
		},
		isLogData: {
			H: ["{*}"],
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the data is Log transformed.",
			D: "false"
		},
		tension: {
			H: ['{*,"data":"Random:4:6","graphType":"Line","lineType":"spline"}'],
			M: "Line Graphs",
			T: "float",
			C: "Curvature for the splines and hulls",
			D: "0.3"
		},
		networkStackIndex: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Index in the network stack for undo and redo operations"
		},
		axisTickColor: {
			H: ["{*}"],
			M: "Axis",
			T: "color",
			C: "Color for the axis ticks in one and two dimensional plots",
			D: "rgb(0,0,0)"
		},
		resizerBackgroundColor: {
			M: "Axis Resizer",
			T: "color",
			C: "Color for the div that shows up when resizing the axes in the canvas or the whole canvas",
			D: "rgba(204,204,204,0.7)"
		},
		groupSamples: {
			S: ["ungroupSamples"],
			M: "Functions",
			T: "array",
			C: "Group samples based on a sample category (data.x object)",
			X: "getXData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		zRotate: {
			H: ['{"graphType":"Scatter3D","zRotate":0}', '{"graphType":"Scatter3D","zRotate":45}'],
			M: "3D Attributes",
			T: "float",
			C: "Starting number of degrees to rotate graph arround the Z axis",
			D: "0"
		},
		xAxisMajorTicks: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "A flag to show major tick lines in the X axis",
			D: "true"
		},
		remoteDirection: {
			S: ["remoteService", "remoteServiceType", "remoteParams"],
			O: ["next", "prev"],
			M: "Remote Procedures",
			T: "option",
			C: "Direction parameter used to obtain data remotely.",
			D: "next"
		},
		loadRDatasets: {
			M: "R",
			T: "boolean",
			C: "Flag to load R datasets from Github",
			D: "false"
		},
		featureWidthDefault: {
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the feature width",
			D: "3"
		},
		rAxisShow: {
			H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			M: "R-Axis",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the R axis",
			D: "true"
		},
		showVariableNames: {
			H: ["{*}"],
			M: "Variables",
			T: "boolean",
			C: "Flag to show the variable names in one dimensional plots",
			D: "true",
			U: {
				Heatmap: "true"
			}
		},
		decorationFontSize: {
			H: ['{*,"autoScaleFont":false,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			M: "Decorations",
			T: "integer",
			C: "Font size for the decorations in scatter plots and network graphs",
			D: "12"
		},
		heatmapCellBoxWidth: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Width for the heatmap boxes around the cells",
			D: "0.5"
		},
		infoStartTime: {
			Z: "true",
			M: "Events",
			T: "time",
			C: "Time in milliseconds to keep track of time"
		},
		fontSize: {
			H: ['{*,"title":"Graph Title"}'],
			M: "Text",
			T: "integer",
			C: "Font size for text in complex plot only. See other categories to modify specific font sizes.",
			D: "12"
		},
		connectByData: {
			Z: "true",
			M: "Data Point Attributes",
			T: "object",
			C: "Object with connectBy data",
			D: "{}"
		},
		filterType: {
			O: ["and", "or"],
			M: "Data Filters",
			T: "option",
			C: "Type for the filter. Can be 'and' or 'or'",
			D: "and"
		},
		imageDir: {
			M: "Images",
			T: "url",
			C: "Relative path to a directory containing images.  @default"
		},
		animationTime: {
			M: "Animation",
			T: "integer",
			C: "Time in milliseconds to wait between rendering the plot when showing the animation.",
			D: "30"
		},
		motionTrails: {
			S: ["motionBy"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show motion trails. Applicable only to 'String' factors.",
			D: "true"
		},
		loessColor: {
			H: ["{*}"],
			M: "Loess",
			T: "color",
			C: "Color for the loess fit line",
			D: "rgb(255,215,0)"
		},
		resizable: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable resizing the canvas by dragging the mouse over the edges",
			D: "true"
		},
		attractiveForceFunction: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			O: ["Eades", "FruchtermanReingold"],
			M: "Network Graphs",
			T: "option",
			C: "Type of function to apply when calculating attractive force in forceDirected network layouts",
			D: "FruchtermanReingold"
		},
		rotationStep: {
			H: ['{*,"graphType":"Scatter3D","data":"3DScatter"}'],
			M: "3D Attributes",
			T: "integer",
			C: "Number of degrees used when the plot is automatically rotated",
			D: "2"
		},
		xAxis2Ticks: {
			Z: "true",
			M: "X-Axis2",
			T: "integer",
			C: "Number of ticks in the 2nd X axis. It is the same as xAxisTicks.",
			D: "5"
		},
		layoutCurrent: {
			Z: "true",
			M: "Combination Plots",
			T: "integer",
			C: "Integer to identify the current graph being displayed in the canvas."
		},
		graphType: {
			H: ['{*,"graphOrientation":"vertical"}'],
			O: ["Bar", "Line", "Area", "AreaLine", "BarLine", "Boxplot", "Dotplot", "DotLine", "Heatmap", "Candlestick", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine", "Treemap", "TagCloud", "Scatter2D", "ScatterBubble2D", "Scatter3D", "Correlation", "Pie", "Venn", "Network", "Genome", "Circular"],
			M: "General",
			T: "option",
			C: "Specifies the type of graph.",
			D: "Bar"
		},
		distance: {
			H: ['{"graphType":"Heatmap","distance":"euclidian","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","distance":"manhattan","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","distance":"max","functions":["clusterSamples","clusterVariables"]}'],
			S: ["linkage", "clusterAxis", "clusterSamples", "clusterVariables"],
			O: ["euclidian", "manhattan", "max"],
			M: "Clustering",
			T: "option",
			C: "Distance metric to use when clustering data.",
			D: "euclidian"
		},
		featureSignalToNoiseShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show quality",
			D: "true"
		},
		remoteUpdateDelay: {
			M: "Remote Procedures",
			T: "integer",
			C: "Time in milliseconds to wait between tryig to get an upated version of the file containing the data",
			D: "10000"
		},
		layout: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "string",
			C: "Topology of the canvas. Number of rows and columns.",
			D: "1X1"
		},
		marginBottom: {
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Specifies the length in pixels for the bottom margin in the canvas.",
			D: "5"
		},
		filterEdgeBy: {
			M: "Network Graphs",
			T: "filter",
			C: "Filter edges by their properties used in network graphs",
			D: "[]",
			X: "getEdgeData"
		},
		showPieValues: {
			H: ["{*}"],
			M: "Pie Charts",
			T: "boolean",
			C: "A flag to show the values for the pie",
			D: "true"
		},
		smpTitleFontSize: {
			H: ['{"smpTitle":"Sample Title","autoScaleFont":false,"smpTitleFontSize":10}', '{"smpTitle":"Sample Title","autoScaleFont":false,"smpTitleFontSize":20}'],
			M: "Samples",
			T: "integer",
			C: "Size for the sample title in one dimensional plots",
			D: "12"
		},
		subtitleFontStyle: {
			H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Titles and Subtitles",
			T: "option",
			C: "Font style for the title.  @default"
		},
		fontScaleFontFactor: {
			H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			M: "Text",
			T: "float",
			C: "Scaling factor used to increase or decrease the font size in the canvas.",
			D: "1"
		},
		edgeConfigurableProperties: {
			M: "Network Graphs",
			T: "array",
			C: "Edge configurable properties",
			D: ["'width'", "'cap'", "'exact'", "'type'"],
			E: "color:[color];Color for the edge;[],width:[integer];Pixel width for the edges between nodes;[],cap:[butt|round|square];Type of cap for the end of the lines;[capType],exact:[boolean];Flag to indicate to create the edge between nodes without subtracting the size of the nodes;[],type:[string];Type of line use to join the nodes;[lines],hide:[boolean];Flag to hide the edge;[],anchor:[boolean];Flag make the edge transparent;[]"
		},
		showDOEData: {
			M: "DOE",
			T: "boolean",
			C: "Flag to plot the original data in the DOE",
			D: "true"
		},
		zoomSamplesDisable: {
			H: ['{*,"graphType":"Heatmap"}'],
			S: ["zoomVariablesDisable"],
			M: "Zooming and Panning",
			T: "boolean",
			C: "Flag to disable zooming of samples with mouse wheel in Heatmaps",
			D: "false"
		},
		decorationsColor: {
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			M: "Decorations",
			T: "color",
			C: "Color for the decorations in scatter plots and network graphs",
			D: "rgb(0,0,0)"
		},
		sequenceUColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the uracils in the genome browser",
			D: "rgb(255,0,0)"
		},
		colorSpectrumZeroValue: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Colors",
			T: "float",
			C: "A value to be at the center of the color spectrum to produce symmetrical heatmaps",
			D: "null"
		},
		freezeRowTop: {
			M: "Data Table",
			T: "integer",
			C: "Number of rows to freeze at the top of the data table",
			D: "0"
		},
		trackDirColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Default color for the strand direction of the tracks in the genome browser",
			D: "rgb(0,0,0)"
		},
		nodeHighlightColor: {
			H: ['{*,"highlightNode":["Gene1","Gene2"]}'],
			M: "Network Graphs",
			T: "color",
			C: "The color for the highlighted nodes.",
			D: "rgb(255,0,0)"
		},
		oddColor: {
			S: ["blockContrast", "evenColor"],
			H: ['{*,"data":"Random:1:6:0:0","blockContrast":true}'],
			M: "Colors",
			T: "color",
			C: "The color for the odd numbers in samples when the property block contrast is set in one dimensional plots or the color for odd number residues in translations in genome plots.",
			D: "rgb(255,255,255)"
		},
		capType: {
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			O: ["butt", "round", "square"],
			M: "Lines",
			T: "option",
			C: "Default type of cap for lines.",
			D: "butt"
		},
		showAnimationFontColor: {
			M: "Animation",
			T: "color",
			C: "Color for the animation text",
			D: "rgb(255,255,255)"
		},
		patternBy: {
			S: ["patternByData"],
			O: ["false", "variable"],
			T: "option",
			X: "getXZData",
			H: ['{"graphType":"Scatter3D","patternBy":"Annt1"}', '{"graphType":"Dotplot","patternBy":"Factor1"}', '{"graphType":"Dotplot","patternBy":"variable"}'],
			M: "Data Point Attributes",
			D: "false",
			C: "Name of a variable annotation or a sample name or the string 'variable' to pattern the variables. When patternByData is specified patternBy is used for the title in the legend."
		},
		showLoessFit: {
			M: "Loess",
			T: "boolean",
			C: "Flag to show the loess fit in Scatter2D plots",
			D: "false"
		},
		canvasBox: {
			S: ["canvasBoxColor"],
			H: ["{*}"],
			M: "General",
			T: "boolean",
			C: "Flag to create a box around the canvas",
			D: "false"
		},
		updateCodeDiv: {
			M: "Functions",
			T: "void",
			C: "Update the code to generate the plot  @advanced"
		},
		videoGridStep: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "integer",
			C: "Number of steps to divide the grid in the video",
			D: "10"
		},
		rAxisTicks: {
			H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			M: "R-Axis",
			T: "integer",
			C: "Number of ticks in the R axis",
			D: "5"
		},
		sortVariablesBySample: {
			S: ["sortDir", "sortVariablesByCategory"],
			M: "Functions",
			T: "array",
			C: "Sort the variables by the value of a sample",
			X: "getSamplesAsArray",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		layoutWidth: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Width of the current segment of the canvas when there are multiple graphs."
		},
		histogramBarWidth: {
			S: ["scatterType", "isHistogram"],
			H: ['{*,"graphType":"Scatter2D","isHistogram":true}'],
			M: "Histograms",
			T: "float",
			C: "Length in pixels for half of the bar width in the 2D sccater plot histogram.",
			D: "0.5"
		},
		scatterOutlineThreshold: {
			H: ['{"data":"3DScatter","graphType":"Scatter3D","scatterOutlineThreshold":4000}', '{"data":"3DScatter","graphType":"Scatter3D","scatterOutlineThreshold":5}'],
			M: "Scatter Plots",
			T: "integer",
			C: "Maximum number of data points before skipping plotting their outline but only the fill color",
			D: "50000"
		},
		correlationAxis: {
			H: ["{*}"],
			O: ["samples", "variables"],
			M: "Correlation Graphs",
			T: "option",
			C: "Axis used for the correlation.",
			D: "samples"
		},
		disableTouchToolbar: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing the touch toolbar",
			D: "false"
		},
		shadowOffsetX: {
			S: ["showShadow"],
			H: ['{*,"showShadow":true}'],
			M: "Shadows",
			T: "integer",
			C: "Length in pixels for the shadow offset in the X axis.",
			D: "1"
		},
		heatmapAutoAdjust: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to adjust the range of the heatmaps when zooming in/out",
			D: "false"
		},
		xAxisTicks: {
			H: ["{*}"],
			M: "X-Axis",
			T: "integer",
			C: "Number of ticks in the X axis",
			D: "5"
		},
		sequenceZColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the glutamines in the genome browser",
			D: "rgb(0,0,0)"
		},
		areaType: {
			H: ['{*,"transparency":0.5}'],
			O: ["normal", "stacked", "percent"],
			M: "Area Graphs",
			T: "option",
			C: "Flag to produce normal, stacked, center or percent area graphs",
			D: "normal"
		},
		loessAccuracy: {
			M: "Loess",
			T: "float",
			C: "Loess accuracy",
			D: "1e-12"
		},
		setMaxY: {
			H: ['{"graphType":"Scatter2D","setMaxY":200}', '{"graphType":"Scatter2D","setMaxY":50}', '{"graphType":"Scatter2D","setMaxY":null}'],
			M: "Y-Axis",
			T: "float",
			C: "Maximum value to set the data in the Y axis",
			D: "null"
		},
		ungroupSamples: {
			S: ["groupSamples"],
			M: "Functions",
			T: "void",
			C: "Ungroup samples previously grouped according to a sample category (data.x object)",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		subtitleScaleFontFactor: {
			H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			M: "Titles and Subtitles",
			T: "float",
			C: "Scaling factor used to increase or decrease the subtitle font size in the canvas.",
			D: "1"
		},
		legendFontSize: {
			S: ["autoScaleFont", "legendScaleFontFactor"],
			H: ['{*,"autoScaleFont":false}'],
			M: "Legends",
			T: "integer",
			C: "Font size for the legends. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the legend scaling factor",
			D: "12"
		},
		randomDataSamples: {
			M: "Random",
			T: "integer",
			C: "Default number of samples when creating random data",
			D: "36"
		},
		yAxisHistogramShow: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to indicate whether to show a histogram for the data in the Y axis",
			D: "false"
		},
		shapeByShape: {
			H: ["{*}"],
			O: ["false", "sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "mdavid"],
			M: "Data Point Attributes",
			T: "option",
			C: "String that identify the shape to use in regular and multidimensional heatmaps. shapeByData will take precedence over this property.",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		marginLeft: {
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Specifies the length in pixels for the left margin in the canvas.",
			D: "5"
		},
		layoutComb: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag that identify that multiple graphs will be displayed in the canvas.",
			D: "false"
		},
		broadcast: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable broadcasting to other canvasXpress objects in the page",
			D: "true"
		},
		yAxisTitle: {
			H: ['{"graphType":"Scatter2D","yAxisTitle":"Y-axis title"}', '{"graphType":"Correlation","yAxisTitle":"Correlation Title"}'],
			M: "Y-Axis",
			T: "string",
			C: "Title for the Y axis in Scatter plots and in Correlation graphs.",
			D: "false",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		yAxisS2Show: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to show or not the values of the ticks in the Y axis at the right in Scatter plots",
			D: "false",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		eventKeys: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable key binding events. This prevent some default browser shortcuts and it is system specific. Please see the Event section bellow.",
			D: "true"
		},
		yRotate: {
			H: ['{"graphType":"Scatter3D","yRotate":0}', '{"graphType":"Scatter3D","yRotate":45}'],
			M: "3D Attributes",
			T: "float",
			C: "Starting number of degrees to rotate graph arround the Y axis",
			D: "0"
		},
		rAxisLabelOrientation: {
			H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			O: ["perpendicular", "circular"],
			M: "R-Axis",
			T: "option",
			C: "Orientation to show the ticks values in circular plots.",
			D: "perpendicular"
		},
		smpTitleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the sample title in one dimensional plots"
		},
		featureTraceTrim: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default triming for nucleotide values in the traces (expressed in percent)",
			D: "1"
		},
		sequenceCColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the cytosines and cysteins in the genome browser",
			D: "rgb(0,0,255)"
		},
		segregateVariablesBy: {
			H: ['{"data":"Random:3:2:3:0:0:1","segregateVariablesBy":["Annt3"],"smpLabelRotate":90,"smpLabelScaleFontFactor":0.5}'],
			M: "Data",
			T: "array",
			C: "An array that holds the annotation(s) used to segregate the variables. It must be categories in the 'data.z' object",
			D: "[]"
		},
		windowBox: {
			H: ["{*}"],
			M: "Foreground",
			T: "color",
			C: "Specifies the color for the border of the plot'.",
			D: "rgb(0,0,0)"
		},
		maxDOENumber: {
			M: "DOE",
			T: "integer",
			C: "Maximum number of graphs when creating a DOE.",
			D: "8"
		},
		yAxisMaxStrLength: {
			Z: "true",
			M: "Y-Axis",
			T: "string",
			C: "Longest string of all the values in the ticks in the Y axis"
		},
		showSmpDendrogram: {
			H: ['{*,"data":"Generic","graphType":"Heatmap"}'],
			M: "Dendrograms",
			T: "boolean",
			C: "Flag to show or not the sample dendrogram",
			D: "true"
		},
		showAdvancedConfiguration: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to show advanced configuration properties.",
			D: "false"
		},
		disableEvents: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable all events.",
			D: "false"
		},
		edgesProperties: {
			M: "Data Table/Filter",
			T: "array",
			C: "Two dimensional array with object properties not at the root level for the edges in the Network graph to include in the Data table and the data filter",
			D: "[]"
		},
		showVarDendrogram: {
			H: ['{*,"data":"Generic","graphType":"Heatmap"}'],
			M: "Dendrograms",
			T: "boolean",
			C: "Flag to show or not the variable dendrogram",
			D: "true"
		},
		freezeColRight: {
			M: "Data Table",
			T: "integer",
			C: "Number of columns to freeze in the right side of the data table",
			D: "0"
		},
		pieType: {
			H: ["{*}"],
			O: ["separated", "solid"],
			M: "Pie Charts",
			T: "option",
			C: "Position for the pices of the pie",
			D: "separated"
		},
		rAxis: {
			H: ['{"data":"Circular","segregateVariablesBy":["Ring"],"rAxis":false}', '{"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			M: "Circular Graphs",
			T: "string",
			C: "Radial axis for circular plots. It must be the name of a variable",
			D: "false"
		},
		heatmapVarSeparateBy: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "string",
			C: "Factor used to separate the heatmap",
			D: "false",
			X: "getZData"
		},
		reset: {
			M: "Functions",
			T: "void",
			C: "Reset the canvas"
		},
		remoteDataIndex: {
			Z: "true",
			M: "Remote Procedures",
			T: "integer",
			C: "Index of the canvasXpress object requested"
		},
		oncoprintAmplification: {
			H: ['{*,"data":"MultidimensionalHeatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Threshold to qualify amplifications in oncoprints",
			D: "3"
		},
		showDecorations: {
			H: ['{"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to show or not extra decorations like (regression lines, splines, etc) in scatter plots and (heatmaps, pie charts or stacked bar graphs in) network graphs",
			D: "false"
		},
		motionBy: {
			O: ["false", "variable"],
			M: "Data Point Attributes",
			T: "option",
			C: "Utility to create dynamic filtering of data in Scatter plots  @funtion getZData",
			D: "false"
		},
		backgroundVideo: {
			S: ["backgroundType"],
			H: ['{"graphType":"Video","videoAutoplay":true,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Background",
			T: "url",
			C: "An array containing urls for the background video when the background type is of the type 'video'.",
			D: "false"
		},
		approximateNodePositions: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to force approximate X, Y node positions.",
			D: "false"
		},
		citationScaleFontFactor: {
			H: ['{*,"citation":"Graph citation or reference"}'],
			M: "Citations or References",
			T: "float",
			C: "Scaling factor used to increase or decrease citation font size in the canvas",
			D: "1"
		},
		zoomVariablesDisable: {
			H: ['{*,"graphType":"Heatmap"}'],
			S: ["zoomSamplesDisable"],
			M: "Zooming and Panning",
			T: "boolean",
			C: "Flag to disable zooming of variables with mouse wheel in Heatmaps",
			D: "false"
		},
		hideInfoDiv: {
			M: "Functions",
			T: "void",
			C: "Hide additional information  @advanced"
		},
		xAxisTickStyle: {
			H: ["{*}"],
			O: ["solid", "dotted"],
			M: "X-Axis",
			T: "option",
			C: "Style for the tick lines in the X axis",
			D: "solid"
		},
		smpTitleScaleFontFactor: {
			H: ['{*,"smpTitle":"Sample Title"}'],
			M: "Samples",
			T: "float",
			C: "Scaling factor used to increse or decrease sample title font size in the canvas",
			D: "1"
		},
		showConfiguratorExamplesOnSelect: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to display examples as the configurator property changes",
			D: "false"
		},
		lineWidthEvent: {
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "integer",
			C: "Size in pixels of the width for the events in the lines.",
			D: "2"
		},
		monitorCanvasXpressZombiesTime: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Time in milliseconds to wait between checking for canvasXpress zombies",
			D: "30000"
		},
		selectDataPoint: {
			Z: "true",
			M: "Scatter Plots",
			T: "array",
			C: "Ids of data points (in the data object) to select.",
			D: "[]"
		},
		axisTicksAutoAdjust: {
			H: ["{*}"],
			M: "Axis",
			T: "boolean",
			C: "Flag to indicate whether to adjust automatically the number of ticks to put in the axes",
			D: "false"
		},
		subtitle: {
			S: ["subtitleHeight", "subtitleColor"],
			H: ['{"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			M: "Titles and Subtitles",
			T: "string",
			C: "Subtitle of the graph.",
			D: "false"
		},
		animationType: {
			O: ["grow", "spring", "random"],
			M: "Animation",
			T: "option",
			C: "Type of animation",
			D: "grow"
		},
		circularCenterProportion: {
			H: ['{*,"data":"Circular"}'],
			M: "Circular Graphs",
			T: "float",
			C: "Proportion of the center of the circular graph to use as void",
			D: "0.3"
		},
		showErrorBars: {
			H: ['{"showErrorBars":true,"functions":["groupSamples:Factor1"]}', '{"showErrorBars":false,"functions":["groupSamples:Factor1"]}'],
			M: "Data",
			T: "boolean",
			C: "Flag to indicate whether to show or not error bars in the graphs.",
			D: "true"
		},
		axisTickScaleFontFactor: {
			H: ["{*}"],
			M: "Axis",
			T: "float",
			C: "Scaling factor used to increase or decrease tick font size in the canvas in one and two dimensional plots",
			D: "1"
		},
		colorEdgeBy: {
			H: ['{"data":"LesMiserables","colorEdgeBy":"value"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to color the edges.",
			D: "false"
		},
		margin: {
			S: ["adjustAspectRatio"],
			H: ["{*}"],
			M: "Margins",
			T: "integer",
			C: "Relative length in pixels for the distance between various objects in the graphs. This value is adjusted acording to the graph dimensions if the adjustAspectRatio parameter is set to 'true'.",
			D: "5"
		},
		xAxisMaxStrLength: {
			Z: "true",
			M: "X-Axis",
			T: "string",
			C: "Longest string of all the values in the ticks in the X axis"
		},
		layoutRemoveEmpty: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to remove empty combinations in segregated layouts.",
			D: "true"
		},
		broadcastType: {
			H: ["{*}"],
			O: ["var", "comb"],
			M: "Events",
			T: "option",
			C: "Model for broadcasting to identify either variables or a combination of variable and samples",
			D: "var"
		},
		showDecorationsRegressionConfidence: {
			S: ["decorations"],
			H: ['{"showDecorationsRegressionConfidence":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}', '{"showDecorationsRegressionConfidence":false,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to show or not the confidence intervals in the regression plots",
			D: "true"
		},
		segregateSamplesBy: {
			H: ['{"data":"Random:2:3:0:3:0:1","segregateSamplesBy":["Factor3"],"smpLabelRotate":90,"smpLabelScaleFontFactor":0.5}'],
			M: "Data",
			T: "array",
			C: "An array that holds the annotation(s) used to segregate the samples. It must be categories in the 'data.x' object",
			D: "[]"
		},
		heatmapCellBoxHighlightWidth: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Width for the highlighting heatmap boxes around the cells",
			D: "1"
		},
		print: {
			M: "Functions",
			T: "void",
			C: "Print the canvas"
		},
		backgroundType: {
			H: ['{*,"backgroundImage":"http://www.canvasxpress.org/images/nanotube.jpg","skipExample":["video"]}'],
			S: ["backgroundImage", "gradientOrientation", "backgroundGradient1Color", "backgroundGradient2Color"],
			O: ["solid", "gradient", "window", "windowGradient", "windowGradient2", "windowSolidGradient", "image", "windowImage", "video"],
			M: "Background",
			T: "option",
			C: "Specifies the style for the background of the canvas. The canvas background is composed of a frame with a window where the data is plotted. Either of these elements the may be a solid or gradient color or an image or a video of your choosing.",
			D: "solid"
		},
		maxSmpStringLen: {
			H: ['{"maxSmpStringLen":50}', '{"maxSmpStringLen":5}'],
			M: "Samples",
			T: "integer",
			C: "Maximum length in characters a sample label or description can have so anything above is truncated.",
			D: "30"
		},
		showAnimationFontSize: {
			M: "Animation",
			T: "integer",
			C: "Size in pixels for the font size of text involved in the animation",
			D: "10"
		},
		axisExtension: {
			H: ['{"graphType":"Scatter2D","axisExtension":0.1}', '{"graphType":"Scatter2D","axisExtension":0.2}'],
			M: "Axis",
			T: "float",
			C: "Percentage to extend the values in the data",
			D: "0.1"
		},
		lineErrorType: {
			H: ['{*,"graphType":"Line"}'],
			O: ["bar", "area"],
			M: "Line Graphs",
			T: "option",
			C: "Line error type in the line graphs",
			D: "bar"
		},
		heatmapIndicatorHistogramColor: {
			H: ["{*}"],
			M: "Heatmap Graphs",
			T: "color",
			C: "Color for the heatmap indicator histogram",
			D: "rgb(0,255,255)"
		},
		sequenceMColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/G and methionines in the genome browser",
			D: "rgb(0,103,0)"
		},
		randomDataVariableAnnotations: {
			H: ["{*}"],
			M: "Random",
			T: "integer",
			C: "Default number of variable annotations when creating random data",
			D: "2"
		},
		axisWilkinsonLoose: {
			H: ['{*,"graphType":"Bar","axisAlgorithm":"wilkinson"}'],
			M: "Axis",
			T: "boolean",
			C: "Flag to indicate whether to use loose positioning when using the wilkinson algorithm to position the labels on the axis",
			D: "false"
		},
		featureTranslateHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the translation height",
			D: "12"
		},
		decorationsBox: {
			S: ["decorationsBoxColor", "decorationsBackgroundColor"],
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			M: "Decorations",
			T: "boolean",
			C: "Flag to create a box around the decoration legend",
			D: "true"
		},
		subNetworks: {
			Z: "true",
			M: "Network Graphs",
			T: "array",
			C: "Array to keep independent networks"
		},
		legendFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Legends",
			T: "option",
			C: "Font style for the legend.  @default"
		},
		showInfoDiv: {
			M: "Functions",
			T: "void",
			C: "Show additional information  @advanced"
		},
		sampleSeparationFactor: {
			S: ["widthFactor", "variableSeparationFactor"],
			H: ["{*}"],
			M: "Space and Width",
			T: "integer",
			C: "Factor to adjust the spacing between the sample blocks in the one dimensional graphs. The default is 1. If you want to make the blocks wider apart then increase this parameter (2 is twice as much).",
			D: "1"
		},
		isReproducibleResearch: {
			M: "General",
			T: "boolean",
			C: "Flag to indicate to track user modifications for Reproducible Research",
			D: "true"
		},
		yAxisAbsMin: {
			Z: "true",
			M: "Y-Axis",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the Y axis"
		},
		blockContrast: {
			S: ["evenColor", "oddColor"],
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "boolean",
			C: "A flag to creates a shade between the samples so there are two backgrounds, one for the odd samples and one for the even samples.",
			D: "false"
		},
		featureSignalToNoiseHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the quality height",
			D: "12"
		},
		titleFontStyle: {
			H: ['{*,"title":"Graph Title"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Titles and Subtitles",
			T: "option",
			C: "Font style for the title.  @default"
		},
		xAxisExact: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to force exact values for the data in the X axis",
			D: "false"
		},
		boxplotMean: {
			H: ['{"data":"Boxplot","boxplotMean":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","boxplotMean":false,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "boolean",
			C: "Flag to show mean of data in boxplots",
			D: "false"
		},
		videoData: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "object",
			C: "Data for videos",
			D: "{}"
		},
		resizeHeightOnLayout: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable resizing the height of the canvas after changing the layout",
			D: "true"
		},
		legendBox: {
			S: ["legendBoxColor", "legendBackgroundColor"],
			H: ["{*}"],
			M: "Legends",
			T: "boolean",
			C: "Flag to create a box around the legend",
			D: "true"
		},
		showDataTable: {
			M: "Data Table",
			T: "boolean",
			C: "Flag to indicate to show the data table",
			D: "false"
		},
		remoteService: {
			S: ["remoteServiceType", "remoteParams", "remoteDirection"],
			M: "Remote Procedures",
			T: "url",
			C: "Url used to obtain data remotely thorugh a web service or directly from a file. If the remote service is a file then it expects a json file with a two dimensional array. Each of the arrays should have a key (which will be used in a drop down menu) and a value to point to a url where to get the data. If the remote service is a web service it expects a canvasXpress object. You may specify additional parameters for the web service but you must specify the type of remote service in remoteServiceType. The default parameters for web services are index (to identify the current record number) and dir (to identify the direction; it could be either next or prev)",
			D: "false"
		},
		randomDataVariables: {
			M: "Random",
			T: "integer",
			C: "Default number of variables when creating random data",
			D: "3"
		},
		gradientRatio: {
			S: ["gradientType"],
			H: ['{*,"data":"Random:1:3:0:0","gradient":true,"gradientType":"linear"}'],
			M: "Gradients",
			T: "float",
			C: "Specifies the ratio used to generate linear gradients.",
			D: "1.3"
		},
		decorationFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the decoration in scatter plots and network graphs"
		},
		sequenceRColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/G and arginines in the genome browser",
			D: "rgb(255,0,0)"
		},
		zAxisShow: {
			H: ['{*,"graphType":"Scatter3D"}'],
			M: "Z-Axis",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the Z axis",
			D: "true"
		},
		isNetworkConvexHull: {
			Z: "true",
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to create a convex hull for the network communities",
			D: "false"
		},
		sequenceNColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/C/G/T and asparagines in the genome browser",
			D: "rgb(0,0,0)"
		},
		smpOverlays: {
			H: ['{"data":"Random:10:10:0:3","smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "array",
			C: "Sample annotations included in the 'data.x' object used in one dimensional plots",
			D: "[]",
			X: "getXData"
		},
		translateY: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Amount to translate for the Y axis."
		},
		axisTitleFontSize: {
			S: ["autoScaleFont", "axisTitleScaleFontFactor"],
			H: ['{*,"autoScaleFont":false}'],
			M: "Axis",
			T: "integer",
			C: "Font size for the axis titles in one and two dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the axis title scaling factor",
			D: "12"
		},
		shapeByData: {
			H: ['{"data":"MultidimensionalHeatmap","shapeByData":"data4","shapeBy":"Data Shape"}'],
			S: ["shapeBy"],
			M: "Data Point Attributes",
			T: "string",
			C: "String that identify the object containing a two dimensional array with values used to shape data points when drawing a multidimensional Heatmap. It must be located within the data.y object (for example: data.y.data2)",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		draw: {
			M: "Functions",
			T: "void",
			C: "Redraw the canvas"
		},
		featureNameFontSize: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Size in pixels for the font size of text of the features in the genome browser",
			D: "10"
		},
		sequenceFColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the phenylalanines in the genome browser",
			D: "rgb(0,0,255)"
		},
		plotBoxColor: {
			S: ["plotBox"],
			H: ['{*,"plotBox":true}'],
			M: "General",
			T: "color",
			C: "Color for the box around the plot",
			D: "rgb(204,204,204)"
		},
		xAxisTickFormat: {
			H: ['{"xAxisTickFormat":"%.2f cxs","graphOrientation":"vertical"}'],
			M: "X-Axis",
			T: "string",
			C: "Format for the tick values in the X axis",
			D: "false"
		},
		shapeByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the shapeBy legend",
			D: "true"
		},
		resizerDataIndex: {
			Z: "true",
			M: "Axis Resizer",
			T: "integer",
			C: "Object to store data when the canvas is zoomed with the axis resizer resizerEventData  @type {object}",
			D: "0"
		},
		addRegressionLine: {
			M: "Functions",
			T: "void",
			C: "Add regression line(s) to a 2D-Scatter plot",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		histogramDensityKernel: {
			H: ['{*,"data":"Random:200:2","functions":["createHistogram"],"histogramBins":50}'],
			S: ["createHistogram", "showHistogramDensity"],
			O: ["epanechnikovKernel", "uniformKernel", "triangularKernel", "quarticKernel", "triweightKernel", "gaussianKernel", "cosineKernel"],
			M: "Histograms",
			T: "option",
			C: "Histogram density kernels",
			D: "epanechnikovKernel"
		},
		isR: {
			M: "General",
			T: "boolean",
			C: "Flag to indicate is running from the R library",
			D: "false"
		},
		showVarOverlaysLegend: {
			H: ["{*}"],
			M: "Overlays",
			T: "boolean",
			C: "Flag to show or not the legend for the variable overlays in the graphs. If set to false the level information will be displayed in the actual colored boxes of the overlays",
			D: "false"
		},
		nodeSize: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Length in pixels for the size of the nodes in the network",
			D: "20"
		},
		maxRows: {
			M: "Data Table",
			T: "integer",
			C: "Maximum number of rows to display in the data table",
			D: "10"
		},
		patternByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the patternBy legend",
			D: "true"
		},
		pieLabelType: {
			H: ["{*}"],
			O: ["percentage", "value"],
			M: "Pie Charts",
			T: "option",
			C: "Pie label type to show the percentage of the slice or the actual number",
			D: "percentage"
		},
		yAxisShow: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the Y axis",
			D: "true",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		connectBy: {
			O: ["false"],
			T: "option",
			X: "getZData",
			H: ['{"graphType":"Scatter3D","connectBy":"Annt1"}', '{"graphType":"Scatter3D"}'],
			M: "Data Point Attributes",
			D: "false",
			C: "Name of a variable annotation to connect the variables.",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		contourType: {
			H: ['{*,"graphType":"Scatter2D"}'],
			S: ["images", "isHistogram", "histogramBarWidth"],
			O: ["overlay", "color"],
			M: "Contours",
			T: "option",
			C: "Type of contour plot",
			D: "overlay"
		},
		axisTickFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the axis ticks in one and two dimensional plots"
		},
		destroyCanvasXpressZombies: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to destroy canvasXpress objects stored in the instances array when they are no longer part of the DOM. This may happen when canvasXpress is used in other JS frameworks and the objects are not destroyed by the developer",
			D: "true"
		},
		heatmapCellBoxColor: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "color",
			C: "Color for the heatmap boxes around the cells",
			D: "rgb(220,220,220)"
		},
		baseline: {
			H: ['{*,"title":"Graph Title"}'],
			O: ["top", "middle", "bottom"],
			M: "Text",
			T: "option",
			C: "Default vertical alignment for drawing text.",
			D: "middle"
		},
		ringSeparation: {
			H: ['{*,"data":"Circular","segregateVariablesBy":["Ring"]}'],
			M: "Circular Graphs",
			T: "integer",
			C: "Number of pixels to separate the rings in the circular plots",
			D: "12"
		},
		setMinX2: {
			H: ['{"graphType":"BarLine","setMinX2":50}', '{"graphType":"BarLine","setMinX2":20}', '{"graphType":"BarLine","setMinX2":null}'],
			M: "X-Axis2",
			T: "float",
			C: "Minimum value to set the data in the 2nd axis",
			D: "null",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		smpDendrogramPosition: {
			H: ['{*,"data":"Generic","graphType":"Heatmap","showSmpDendrogram":true}'],
			O: ["right", "left"],
			M: "Dendrograms",
			T: "option",
			C: "Position for the sample dendrogram in the plot. It could be top, bottom, right or left depending on the orientation of the graph.",
			D: "left"
		},
		errorEllipseConfidence: {
			H: ["{*}"],
			M: "Data",
			T: "float",
			C: "Default confidence for error ellipses.",
			D: "0.99"
		},
		xAxisHistogramHeight: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "integer",
			C: "Number of pixels for the histogram in the X axis",
			D: "50"
		},
		is3DPlot: {
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "boolean",
			C: "Flag to create or not a 3D plot",
			D: "false"
		},
		isLayoutConfigurator: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing the configurator when there is a click in the full layout icon in the toolbar",
			D: "false"
		},
		removeHistogram: {
			M: "Functions",
			T: "void",
			C: "Remove histogram from a 2D-Scatter plot",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		disableDataFilters: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing data filters",
			D: "false"
		},
		createRandomData: {
			M: "Functions",
			T: "void",
			C: "Create a random data set"
		},
		yAxisMinorTicks: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "A flag to show minor tick lines in the Y axis",
			D: "true"
		},
		helpKeyEvents: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable help on key events.",
			D: "false"
		},
		remoteUpdate: {
			M: "Remote Procedures",
			T: "boolean",
			C: "Flag to indicate that the file to get the data needs to be updated",
			D: "false"
		},
		shadowOffsetY: {
			S: ["showShadow"],
			H: ['{*,"showShadow":true}'],
			M: "Shadows",
			T: "integer",
			C: "Length in pixels for the shadow offset in the Y axis.",
			D: "1"
		},
		variableSeparationFactor: {
			S: ["sampleSeparationFactor", "widthFactor"],
			H: ["{*}"],
			M: "Space and Width",
			T: "float",
			C: "Factor to adjust the spacing between the variables in the one dimensional plots.",
			D: "2"
		},
		transformCeilValue: {
			H: ["{*}"],
			M: "Data",
			T: "float",
			C: "Value to ceil the data when transform type is ceil",
			D: "false"
		},
		citationFontStyle: {
			H: ['{*,"citation":"Graph citation or reference"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Citations or References",
			T: "option",
			C: "Font style for the citation.  @default"
		},
		varSort: {
			Z: "true",
			M: "Data",
			T: "integer",
			C: "Variable index used in sorting the data."
		},
		yAxisTicks: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "integer",
			C: "Number of ticks in the Y axis",
			D: "5"
		},
		boxplotMeanColor: {
			H: ['{"data":"Boxplot","boxplotMean":true,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "color",
			C: "Color for the mean of data in boxplots",
			D: "rgb(255,215,0)"
		},
		decorations: {
			H: ['{"data":"NetworkDecorations","graphType":"Network","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}', '{"showDecorations":true,"graphType":"Scatter2D","data":"NonLinearFit","xAxisTransform":"log10","xAxisTransformTicks":false,"setMaxY":350,"setMinY":100,"yAxisExact":true}', '{"showDecorations":true,"graphType":"Scatter2D","data":"DecorationLine"}', '{"showDecorations":true,"graphType":"Bar","data":"DecorationLines","graphOrientation":"vertical"}', '{"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine","draw"]}', '{"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addRegressionLine","draw"]}', '{"showDecorations":true,"showLegend":false,"graphType":"Scatter2D","data":"DecorationArea"}', '{"showDecorations":true,"graphType":"Scatter2D","data":"KaplanMeier","showLegend":false,"title":"Kaplan-Meier Plot","functions":["addKaplanMeierCurve:Time:Censored-1:Data 1 Population:rgb(0,0,255)","addKaplanMeierCurve:Time:Censored-2:Data 2 Population:rgb(255,0,0)","draw"]}'],
			S: ["showDecorations"],
			M: "Decorations",
			T: "array",
			C: "Name of the node properties to include in the network decorations in the 'data.nodes' object",
			D: "[]",
			U: {
				Network: "true",
				Scatter2D: "true"
			}
		},
		titleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the title"
		},
		layoutCollapse: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to make layout graphs without any space in between",
			D: "false"
		},
		sequenceFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Genome Browser",
			T: "option",
			C: "Font style for the sequences.  @default"
		},
		showCode: {
			M: "Debug",
			T: "boolean",
			C: "Flag to show code for the canvas.",
			D: "false"
		},
		autoHideOnDecorationsCenter: {
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to hide node when decorations are positioned on the center",
			D: "false"
		},
		colors: {
			S: ["colorScheme"],
			H: ['{"data":"Random:16:1:0:0:1","graphType":"Pie"}'],
			M: "Colors",
			T: "array",
			C: "Colors.",
			D: "colors"
		},
		showSampleNames: {
			H: ["{*}"],
			M: "Samples",
			T: "boolean",
			C: "Flag to show the sample names in one dimensional plots.",
			D: "true"
		},
		panningX: {
			M: "Zooming and Panning",
			T: "float",
			C: "Number of unit to pan the network in the X dimension",
			D: "0"
		},
		yAxisCurrent: {
			H: ['{"yAxis":["Sample1","Sample2"],"xAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","yAxisCurrent":0}', '{"yAxis":["Sample1","Sample2"],"xAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","yAxisCurrent":1}'],
			M: "Y-Axis",
			T: "integer",
			C: "Index (zero-based) of the sample that is currently displayed in the Y axis when there are more series in the X axis than in the Y axis in an Scarrter2D plot or when there are multiple series in an ScatterBubble2D plot. Use ctrl + arrow keys to cycle through data series.",
			D: "0",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		citationFontSize: {
			H: ['{*,"citation":"Graph citation or reference"}'],
			M: "Citations or References",
			T: "integer",
			C: "Size for the text of the reference citation of the graph",
			D: "7"
		},
		maxItemMenuCheckbox: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Maximum number of items in a menu before it becomes a scroll box",
			D: "10"
		},
		shadowColor: {
			S: ["showShadow"],
			H: ['{*,"showShadow":true}'],
			M: "Shadows",
			T: "color",
			C: "Color for the shadow.",
			D: "rgba(0,0,0,0.5)"
		},
		xAxis2Show: {
			H: ["{*}"],
			M: "X-Axis2",
			T: "boolean",
			C: "Flag to show on not the values of the ticks in the second X axis",
			D: "true"
		},
		showCodeDiv: {
			M: "Functions",
			T: "void",
			C: "Show the code for the plot  @advanced"
		},
		dendrogramSpace: {
			H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true,"dendrogramHeight":false}'],
			S: ["dendrogramHeight", "dendrogramHang"],
			M: "Dendrograms",
			T: "integer",
			C: "Length in pixels to space the branches in the dendrograms.",
			D: "6"
		},
		hullScale: {
			M: "Line Graphs",
			T: "float",
			C: "Scaling factor for hulls",
			D: "1.25"
		},
		addNormalDistributionLine: {
			M: "Functions",
			T: "void",
			C: "Add a normaldistribution line(s) to a 2D-Scatter plot",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		kmeansSamples: {
			S: ["kmeansSmpClusters", "maxIterations"],
			M: "Functions",
			T: "void",
			C: "Cluster samples using kmeans",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				Bar: "true",
				StackedPercentLine: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		eventArrowKeys: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable arrow key binding events.",
			D: "true"
		},
		maxTextSize: {
			H: ['{*,"title":"Graph Title"}'],
			M: "Text",
			T: "integer",
			C: "Maximum size for any text in the canvas.",
			D: "40"
		},
		xAxisTitle: {
			H: ['{"xAxisTitle":"X-axis title"}'],
			M: "X-Axis",
			T: "string",
			C: "Title for the X axis",
			D: "false"
		},
		functionIntervals: {
			H: ['{*,"data":"Function"}'],
			M: "Scatter Plots",
			T: "integer",
			C: "Number of intervals to use when drawing functions in the decorations. In Scatter 3D is more like a factor",
			D: "25"
		},
		layoutCanvasCompartments: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to draw lines around each graph in the layout in the canvas.",
			D: "false"
		},
		gradient: {
			S: ["gradientType"],
			H: ['{*,"data":"Random:1:3:0:0"}'],
			M: "Gradients",
			T: "boolean",
			C: "Flag used to apply gradients to all objects in the graphs.",
			D: "false"
		},
		genomeResolution: {
			Z: "true",
			O: ["low", "medium", "high"],
			M: "Genome Browser",
			T: "option",
			C: "Number to adjust the splines curvature"
		},
		erroBarsWidth: {
			H: ['{"showErrorBars":true,"erroBarsWidth":2,"functions":["groupSamples:Factor1"]}', '{"showErrorBars":true,"erroBarsWidth":10,"functions":["groupSamples:Factor1"]}'],
			M: "Data",
			T: "integer",
			C: "Minimum size of the bar in pixels to determine to show or hide error bar ends in the graphs when available.",
			D: "2"
		},
		nodeFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the text in networks"
		},
		maxCols: {
			M: "Data Table",
			T: "integer",
			C: "Maximum number of columns to display in the data table",
			D: "6"
		},
		sma5Color: {
			H: ['{*,"stockIndicators":["Sma5"]}'],
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 5 day single moving average",
			D: "rgb(255,0,0)"
		},
		rAxisAbsMax: {
			Z: "true",
			M: "R-Axis",
			T: "float",
			C: "Maximum non-filtered value for the data plotted in the R axis"
		},
		x3DRatio: {
			H: ['{"graphType":"Scatter3D","x3DRatio":0.5}', '{"graphType":"Scatter3D","x3DRatio":1}'],
			M: "3D Attributes",
			T: "float",
			C: "Value between 0 - 1 for adjusting the 3D of the X Axis",
			D: "1",
			U: {
				Scatter3D: "true",
				Bar: "true"
			}
		},
		histogramStagger: {
			H: ['{"data":"Random:500:3","functions":["createHistogram"],"histogramStagger":false}', '{"data":"Random:500:3","functions":["createHistogram"],histogramStagger":true}'],
			S: ["createHistogram"],
			M: "Histograms",
			T: "boolean",
			C: "Flag to stagger histograms when multiple variables are present",
			D: "false"
		},
		heatmapIndicatorHistogram: {
			H: ["{*}"],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to show histogram in the heatmap indicator",
			D: "false"
		},
		sequenceGAPColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the deletions, insertions and gaps in the genome browser",
			D: "rgb(255,0,255)"
		},
		tagCloudTextGridSize: {
			H: ["{*}"],
			M: "Tag Cloud",
			T: "integer",
			C: "Size for the grid in text tag cloud visualizations",
			D: "8"
		},
		smpTitleFontStyle: {
			H: ['{*,"smpTitle":"Sample Title"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Samples",
			T: "option",
			C: "Font style for the samples.  @default"
		},
		showViolinBoxplot: {
			H: ['{"data":"Boxplot","showViolinBoxplot":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","showViolinBoxplot":false,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "boolean",
			C: "Flag to show violin plot in boxplots",
			D: "false"
		},
		remoteServiceType: {
			S: ["remoteService", "remoteParams"],
			O: ["webService", "file"],
			M: "Remote Procedures",
			T: "string",
			C: "Type of web service to obtain data remotely",
			D: "webService"
		},
		maintainZoomOnDrag: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to enable maintaining zooming after initial drag in one dimensional plots",
			D: "false"
		},
		disableConfigurator: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable configurator.",
			D: "false"
		},
		colorSpectrum: {
			S: ["colorSpectrumBreaks"],
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Colors",
			T: "array",
			C: "An array with valid color names to create a color brew for the default color indicators",
			D: [' "#4575b4"', ' "#91bfdb"', ' "#e0f3f8"', ' "#ffffbf"', ' "#fee090"', ' "#fc8d59"', ' "#d73027" ']
		},
		boxplotMedianColor: {
			H: ['{"data":"Boxplot","functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "color",
			C: "Color for the line of the median of data in boxplots",
			D: "rgb(0,0,0)"
		},
		sequenceIColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the isoleucines in the genome browser",
			D: "rgb(0,103,0)"
		},
		colorHSV: {
			Z: "true",
			M: "Colors",
			T: "array",
			C: "Color HSV. Hue, Saturation and Value used in the configurator"
		},
		smpTitle: {
			H: ['{"smpTitle":"Sample Title"}'],
			M: "Samples",
			T: "string",
			C: "Title for the sample axis in one dimensional plots",
			D: "false"
		},
		correlationAnchorLegendAlignWidth: {
			H: ['{*,"correlationAnchorLegend":true}'],
			M: "Correlation Graphs",
			T: "integer",
			C: "Length in pixels of the height of the correlation anchor legend",
			D: "40"
		},
		axisTitleFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Axis",
			T: "option",
			C: "Font style for the axis titles.  @default"
		},
		shapeEdgeBy: {
			H: ['{"data":"LesMiserables","shapeEdgeBy":"value"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to shape the nods.",
			D: "false"
		},
		tagCloudTextRotateRatio: {
			H: ["{*}"],
			M: "Tag Cloud",
			T: "float",
			C: "Ratio for rotation of text in cloud visualizations",
			D: "0.1"
		},
		featureNameFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Genome Browser",
			T: "option",
			C: "Font style for the feature name.  @default"
		},
		reproduceTime: {
			M: "General",
			T: "integer",
			C: "Time to wait in milliseconds to reproduce user modifications"
		},
		scatterPlotMatrixType: {
			H: ['{*,"graphType":"Scatter2D","scatterPlotMatrix":true}'],
			S: ["scatterPlotMatrix"],
			O: ["completeBoth", "completeUpper", "completeLower", "first"],
			M: "Scatter Plot Matrix",
			T: "option",
			C: "Type for the matrix of 2D sccaterplots",
			D: "completeBoth"
		},
		xAxis2MaxStrLength: {
			Z: "true",
			M: "X-Axis2",
			T: "string",
			C: "Longest string of all the values in the ticks in the 2nd X axis"
		},
		randomNetworkNodes: {
			M: "Random",
			T: "integer",
			C: "Default number of nodes when creating random networks",
			D: "50",
			U: {
				Network: "true"
			}
		},
		show3DGrid: {
			H: ["{*}"],
			M: "3D Attributes",
			T: "boolean",
			C: "Flag to show the X,Y,Z grid in scatter 3D plots",
			D: "true",
			U: {
				Scatter3D: "true"
			}
		},
		showHistogramDensity: {
			H: ['{*,"data":"Random:200:2","functions":["createHistogram"],"histogramBins":50}'],
			S: ["createHistogram", "histogramDensityKernel"],
			M: "Histograms",
			T: "boolean",
			C: "Flag to show the density kernel in histograms",
			D: "false"
		},
		codeType: {
			O: ["pretty", "compact", "tab", "params"],
			M: "Debug",
			T: "option",
			C: "Output type for the JSON code",
			D: "params"
		},
		xAxis2MinorValues: {
			M: "X-Axis2",
			T: "array",
			C: "Values for the minor ticks in the 2nd X axis",
			D: "[]",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		fontName: {
			H: ["{*}"],
			O: ["Courier", "Arial", "Verdana", "sans-serif", "Indie Flower", "Ubuntu"],
			M: "Text",
			T: "option",
			C: "Font name. It will be set depending on the browser.",
			D: "Verdana"
		},
		smpLabelInterval: {
			H: ["{*}"],
			M: "Samples",
			T: "integer",
			C: "Interval for the sample labels in one dimensional and circular plots",
			D: "1"
		},
		ellipseBy: {
			O: ["false", "variable"],
			M: "Data Point Attributes",
			T: "option",
			C: "Utility to create error ellipses in Scatter plots  @funtion getZData",
			D: "false"
		},
		dataTableColumnWidth: {
			Z: "true",
			M: "Data Table",
			T: "array",
			C: "Set the initial fonts"
		},
		highlightSmp: {
			H: ['{"highlightSmp":["Sample1","Sample3"]}'],
			M: "Samples",
			T: "array",
			C: "Name of samples in the 'data.y' object to highlight.",
			D: "[]",
			X: "getSamplesAsArray"
		},
		decorationsHeight: {
			H: ['{*,"data":"NetworkDecorations","decorationsPosition":"left","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}'],
			M: "Decorations",
			T: "integer",
			C: "Length in pixels of the height for the decorations in the networks",
			D: "20",
			U: {
				Network: "true"
			}
		},
		smpLabelFontColor: {
			H: ["{*}"],
			M: "Samples",
			T: "color",
			C: "Font color for the sample labels in one dimensional plots",
			D: "rgb(0,0,0)"
		},
		tagCloudTextWeightFactor: {
			H: ["{*}"],
			M: "Tag Cloud",
			T: "integer",
			C: "Factor weight for text in tag cloud visualizations",
			D: "1"
		},
		sequenceBColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate C/G/T and asparagines in the genome browser",
			D: "rgb(0,0,0)"
		},
		colorNodeBy3: {
			H: ['{"data":"LesMiserables","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to color the nodes.",
			D: "false"
		},
		segregateVariables: {
			S: ["segregateVariables"],
			M: "Functions",
			T: "option",
			C: "Segregate variables based on a variable category (data.z object)",
			X: "getZData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		coordinateLineColor: {
			H: ['{*,"graphType":"BarLine"}'],
			M: "Line Graphs",
			T: "boolean",
			C: "Flag to used same color in BarLine plots. If set to true the color of the bars and the lines will be the same",
			D: "false"
		},
		adjustAspectRatioMax: {
			M: "Aspect Ratio",
			T: "integer",
			C: "Specifies the number of times to try to automatically adjust the size of the canvas when adjustAspectRatio is true",
			D: "3"
		},
		widthFactor: {
			S: ["sampleSeparationFactor", "variableSeparationFactor"],
			H: ["{*}"],
			M: "Space and Width",
			T: "integer",
			C: "Factor to adjust the width of the sample blocks in the one dimensional graphs. The default is 1. If you want to make the blocks wider then increase this parameter (2 is twice as wide).",
			D: "1"
		},
		dendrogramColor: {
			H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true}'],
			M: "Dendrograms",
			T: "color",
			C: "The color for the dendrograms",
			D: "rgb(0,0,0)"
		},
		sequenceQColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the glutamines in the genome browser",
			D: "rgb(0,0,0)"
		},
		oncoprintDeletion: {
			H: ['{*,"data":"MultidimensionalHeatmap"}'],
			M: "Heatmap Graphs",
			T: "float",
			C: "Threshold to qualify deletions in oncoprints",
			D: "1"
		},
		layoutAxis: {
			Z: "true",
			O: ["1", "2", "3"],
			M: "Combination Plots",
			T: "option",
			C: "Flag to indicated whether to print axes values when multiple graphs are displayed in the canvas. The possible values are: 1: horizontal, 2: vertical, 3: both"
		},
		adjustAspectRatioXTries: {
			Z: "true",
			M: "Aspect Ratio",
			T: "integer",
			C: "Counter set when trying to automatically adjust the horizontal size of the canvas when adjustAspectRatio is true"
		},
		smpIndicesStart: {
			Z: "true",
			M: "Heatmap Graphs",
			T: "integer",
			C: "Number that indicates starting point for samples in heatmaps when the canvas is zoom in."
		},
		RdatastesURL: {
			Z: "true",
			M: "R",
			T: "array",
			C: "URL for R objects"
		},
		xAxisCurrent: {
			H: ['{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","xAxisCurrent":0}', '{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4","Sample5"],"graphType":"Scatter2D","xAxisCurrent":1}'],
			M: "X-Axis",
			T: "integer",
			C: "Index (zero-based) of the sample that is currently displayed in the X axis when there are more series in the Y axis than in the X axis in an Scarrter2D plot or when there are multiple series in an ScatterBubble2D plot. Use ctrl + arrow keys to cycle through data series.",
			D: "0",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		zAxisCurrent: {
			H: ['{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"ScatterBubble2D","yAxisCurrent":0}', '{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"ScatterBubble2D","yAxisCurrent":1}'],
			M: "Z-Axis",
			T: "integer",
			C: "Index (zero-based) of the sample that is currently displayed in the Z axis when there are multiple series in an ScatterBubble2D plot. Use ctrl + arrow keys to cycle through data series.",
			D: "0",
			U: {
				ScatterBubble2D: "true"
			}
		},
		isMultidimensionalData: {
			Z: "true",
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to indicate if there is more than a single data set."
		},
		nodeScaleFontFactor: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "float",
			C: "Scaling factor used to increse or decrease network text font size in the canvas.",
			D: "1"
		},
		evenColor: {
			S: ["blockContrast", "oddColor"],
			H: ['{*,"data":"Random:1:6:0:0","blockContrast":true}'],
			M: "Colors",
			T: "color",
			C: "The color for the even numbers in samples when the property block contrast is set in one dimensional plots or the color for odd number residues in translations in genome plots.",
			D: "rgb(245,245,245)"
		},
		backgroundWindowGradient2Color: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"windowSolidGradient"}'],
			M: "Background",
			T: "color",
			C: "Specifies the second color of the gradient if the background type is of the type of 'windowGradient'.",
			D: "rgb(0,0,36)"
		},
		showLevelOverlays: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "boolean",
			C: "Flag to indicate to show or not the level overlays in one dimensional plots",
			D: "true"
		},
		startPieSectors: {
			H: ['{"startPieSectors":0}', '{"startPieSectors":90}', '{"startPieSectors":180}', '{"startPieSectors":270}'],
			M: "Pie Charts",
			T: "float",
			C: "Starting degrees for pie sectors. 0 is equivalent to 3:00 oclock",
			D: "0"
		},
		sizeByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the sizeBy legend",
			D: "true"
		},
		legendBoxColor: {
			S: ["legendBox"],
			H: ["{*}"],
			M: "Legends",
			T: "color",
			C: "Color for the box around the legend",
			D: "rgb(204,204,204)"
		},
		rotationSensitivity: {
			M: "3D Attributes",
			T: "integer",
			C: "Factor to adjust the sensitivity of the mouse when rotating the graph",
			D: "45"
		},
		networkConvexHulls: {
			Z: "true",
			M: "Network Graphs",
			T: "array",
			C: "Array for the Network community convex hull property object"
		},
		selectDataMode: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["area", "transparency", "name"],
			M: "Scatter Plots",
			T: "option",
			C: "Type of mode to highlight selected data points with mouse events. (Shift + mouse drag)  @see{selectDataModeDescription}",
			D: "area"
		},
		legendColumns: {
			H: ["{*}"],
			M: "Legends",
			T: "integer",
			C: "Number of columns for the variable legends in one dimensional plots",
			D: "1"
		},
		font: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "The combination of font name style and size.",
			D: "Verdana 12pt"
		},
		skipClick: {
			Z: "true",
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to skip click events after a mouse down event in the networks when the eventModel is global"
		},
		trackNameFontColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the text of the tracks in the genome browser",
			D: "rgb(0,0,0)"
		},
		trackFillColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Default color for the fill of the tracks in the genome browser",
			D: "rgb(255,255,255)"
		},
		scaleTextConstantMult: {
			Z: "true",
			M: "Text",
			T: "integer",
			C: "Constants to autoscale text",
			D: "25"
		},
		varLabelDescription: {
			H: ['{"data":"Random:16:3:3:0","varLabelDescription":"Annt3"}'],
			M: "Variables",
			T: "string",
			C: "Variable label description is a valid sample classification included in the 'data.z' object used in heatmaps",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		images: {
			S: ["scatterType"],
			H: ['{"data":"Random:6:3:0:0","graphType":"Scatter2D","scatterType":"image","images":["area", "bar", "boxplot", "heatmap", "line", "pie"]}'],
			M: "General Attributes",
			T: "array",
			C: "Array of urls of images used in scatter plots.",
			D: "[]"
		},
		linkage: {
			H: ['{"graphType":"Heatmap","linkage":"single","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","linkage":"complete","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","linkage":"average","functions":["clusterSamples","clusterVariables"]}'],
			S: ["distance", "clusterAxis", "imputeMethod", "clusterSamples", "clusterVariables"],
			O: ["single", "complete", "average"],
			M: "Clustering",
			T: "option",
			C: "Linkage type to use when clustering data.",
			D: "complete"
		},
		titleFontSize: {
			S: ["title", "titleColor"],
			H: ['{*,"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "integer",
			C: "Font size for the title of the graph. The font height will be adjusted automatically to fit in the canvas.",
			D: "16"
		},
		adjustAspectRatio: {
			S: ["variableSeparationFactor", "sampleSeparationFactor", "widthFactor"],
			H: ['{*,"graphOrientation":"vertical"}'],
			M: "Aspect Ratio",
			T: "boolean",
			C: "Flag to automatically adjust the size of the bars or points in the one dimensional plots to fit in the provided canvas width and height. If the flag is set to 'false' the width and height of the canvas will be sized according to the number of bars or points in the data set.",
			D: "true"
		},
		layoutBoxShow: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to draw the layout boxes.",
			D: "true"
		},
		sequenceStartColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the start codon in the genome browser",
			D: "rgb(0,204,0)"
		},
		smpLabelDescription: {
			H: ['{"data":"Random:16:3:0:3","smpLabelDescription":"Factor3"}'],
			M: "Samples",
			T: "string",
			C: "Sample label description is a valid sample classification included in the 'data.x' object used in heatmaps",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		backgroundGradient1Color: {
			S: ["backgroundType", "backgroundGradient2Color"],
			H: ['{*,"backgroundType":"gradient"}'],
			M: "Background",
			T: "color",
			C: "Specifies the first color of the gradient if the background type is of the type of 'gradient'.",
			D: "rgb(0,0,200)"
		},
		smpLabelFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the sample labels in one dimensional plots"
		},
		timeValueIndices: {
			M: "X-Axis",
			T: "array",
			C: "Array containing the indices of the values when the the graph is a time series",
			D: "[]"
		},
		legendColor: {
			H: ["{*}"],
			M: "Legends",
			T: "color",
			C: "Color for the legends",
			D: "rgb(0,0,0)"
		},
		layoutAdjust: {
			H: ["{*}"],
			M: "Combination Plots",
			T: "boolean",
			C: "Flag to force recalculating the ranges in the axes when multiple graphs are displayed in the canvas.",
			D: "false"
		},
		invMagnificationFactor: {
			H: ['{*,"graphType":"Scatter3D","data":"3DScatter"}'],
			M: "3D Attributes",
			T: "float",
			C: "Factor to use initial magnification of the plot. The higher the value the smaller the maginication.",
			D: "4"
		},
		featureNameFontColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the text of the features in the genome browser",
			D: "rgb(0,0,0)"
		},
		isSelectNodes: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Number of selected nodes (in the data object).",
			D: "0"
		},
		treemapBy: {
			O: ["false", "variable"],
			M: "Data Point Attributes",
			T: "option",
			C: "Name of a variable annotation to treemap the variables.",
			D: "false",
			X: "getZData"
		},
		varHighlightColor: {
			H: ['{*,"highlightVar":["Variable1","Variable3"]}'],
			M: "Variables",
			T: "color",
			C: "The color for the highlighted variables.",
			D: "rgb(255,0,0)",
			U: {
				Heatmap: "true"
			}
		},
		startRow: {
			Z: "true",
			M: "Data Table",
			T: "integer",
			C: "Starting row in the data table"
		},
		remoteAutoPlayDelay: {
			M: "Remote Procedures",
			T: "integer",
			C: "Time in milliseconds to wait between iterations while automatically going over remote data sets",
			D: "3000"
		},
		transformFloorValue: {
			H: ["{*}"],
			M: "Data",
			T: "float",
			C: "Value to floor the data when transform type is floor",
			D: "false"
		},
		axisAlgorithm: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["heckbert", "wilkinson", "wilkinsonExtended", "rPretty"],
			M: "Axis",
			T: "option",
			C: "Algorithm to position labels in axis",
			D: "heckbert"
		},
		heatmapCellBox: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to print a box around the heatmap cells",
			D: "true"
		},
		boxplotMedianWidth: {
			H: ['{"data":"Boxplot","functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "integer",
			C: "Width for the line of the median of data in boxplots",
			D: "1"
		},
		lines: {
			Z: "true",
			H: ['{"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			O: ["", "dashed", "dotted", "bezierY", "bezierX", "curved + arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"],
			M: "Lines",
			T: "array",
			C: "Line types available network graphs The patterns can be: '', 'dashed', 'dotted', 'bezierY', 'bezierX' and 'curved'. The end could be: 'arrow', 'arrowHead', 'arrowTail', 'arrowHeadSquareTail', 'arrowTailSquareHead', 'square', 'squareHead', 'squareTail', 'squareHeadArrowTail' or 'squareTailArrowHead'."
		},
		varTitleScaleFontFactor: {
			H: ['{*,"varTitle":"Variable Title"}'],
			M: "Variables",
			T: "float",
			C: "Scaling factor used to increse or decrease variable font size in the canvas.",
			D: "1",
			U: {
				Heatmap: "true"
			}
		},
		sequenceHColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/C/T and histidines in the genome browser",
			D: "rgb(255,0,0)"
		},
		showPieGrid: {
			H: ['{*,"data":"Generic","xAxis":["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6"],"layout":"2X3"}'],
			M: "Pie Charts",
			T: "boolean",
			C: "A flag to show the labels for the grid when plotting multiple pies",
			D: "true"
		},
		timeFormat: {
			O: ["default", "shortDate", "mediumDate", "longDate", "fullDate", "shortTime", "mediumTime", "longTime", "isoDate", "isoTime", "isoDateTime", "isoUtcDateTime"],
			M: "General Attributes",
			T: "option",
			C: "Time Format according to date.format.js Steven Levithan <stevenlevithan.com>",
			D: "isoDate"
		},
		networkStackStates: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "integer",
			C: "Number of states to keep in the network stack after a drag or move",
			D: "8"
		},
		sequenceEColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the glutamic acids in the genome browser",
			D: "rgb(0,0,0)"
		},
		hideCodeDiv: {
			M: "Functions",
			T: "void",
			C: "Hide the code for the plot  @advanced"
		},
		trackNameFontSize: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Size in pixels for the font size of text of the tracks in the genome browser",
			D: "10"
		},
		sequenceEndColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the end codon in the genome browser",
			D: "rgb(255,0,0)"
		},
		subtitleColor: {
			S: ["subtitle", "subtitleHeight"],
			H: ['{*,"title":"Graph Title","subtitle":"Graph Subtitle"}'],
			M: "Titles and Subtitles",
			T: "color",
			C: "Color for the subtitle",
			D: "rgb(0,0,0)"
		},
		metadataColorProperties: {
			M: "Data Point Attributes",
			T: "object",
			C: "Object to assign color properties to metadata for variables and samples. The key should be an annotation either in the 'data.x' object or in the 'data.z' object and the value may contain any of the following values depending on the type of the annotation. For 'Numeric' annotations: spectrum : array with valid color names to create a color spectrum spectrumZeroValue: center for the color spectrum to produce a symmetrical color spectrum For 'String' annotations: spectrum : a valid color brew from those delveloped by Cynthia Brewer at (http://colorbrewer.org/) and some extra schemes from R and others like: YlGn, YlGnBu, GnBu, BuGn, PuBuGn, PuBu, BuPu, RdPu, PuRd, OrRd, YlOrRd, YlOrBr, Purples, Blues, Greens, Oranges, Reds, Greys, PuOr, BrBG, PRGn, PiYG, RdBu, RdGy, RdYlBu, Spectral, RdYlGn, Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3. colors : an array with valid color names for each the level in the annotation in asciibetical order",
			D: "{}"
		},
		legendFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the legends"
		},
		xAxisHistogramShow: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to indicate whether to show a histogram for the data in the X axis",
			D: "false"
		},
		randomDataSampleAnnotationRatio: {
			M: "Random",
			T: "integer",
			C: "Approximate number of samples in each class",
			D: "6"
		},
		objectBorderColor: {
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "color",
			C: "The color for the border of all objects in one dimensional graphs.",
			D: "rgb(0,0,0)"
		},
		xAxis2Values: {
			M: "X-Axis2",
			T: "array",
			C: "Values for the ticks in the 2nd X axis",
			D: "[]",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		freezeRowBottom: {
			M: "Data Table",
			T: "integer",
			C: "Number of rows to freeze at the bottom of the data table",
			D: "0"
		},
		overrideEventlessNodes: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to override nodes that do not take events to be able to edit them",
			D: "false"
		},
		tagCloudTextEllipticity: {
			H: ["{*}"],
			M: "Tag Cloud",
			T: "float",
			C: "Ellipticity for the for text in tag cloud visualizations",
			D: "0.65"
		},
		xAxisTransformTicks: {
			H: ['{*,"xAxisTransform":"log10","graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to transform the values of the ticks in the X axis",
			D: "true",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		legendScaleFontFactor: {
			H: ["{*}"],
			M: "Legends",
			T: "float",
			C: "Scaling factor used to increase or decrease legend font size in the canvas.",
			D: "1"
		},
		tmpAsciiArray: {
			Z: "true",
			M: "Data",
			T: "array",
			C: "A temporary array to enable sorting data asciibetically."
		},
		boxplotDataPointTransparency: {
			S: ["showBoxplotOriginalData", "boxplotDataPointRatio", "jitter"],
			H: ['{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointTransparency":0.5,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointTransparency":0.2,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "float",
			C: "Fraction to adjust color transparency for the data points when displaying original data in boxplots.",
			D: "0.5"
		},
		showRingLegend: {
			H: ['{*,"data":"Circular","segregateVariablesBy":["Ring"]}'],
			M: "Circular Graphs",
			T: "boolean",
			C: "Flag to show legends in each ring of a circular graph",
			D: "true"
		},
		sma50Color: {
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 50 day single moving average",
			D: "rgb(0,0,0)"
		},
		trackNameFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the text of the tracks in the genome browser"
		},
		networkDivisions: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Number of angular divisions in the radial network."
		},
		calculateNetworkCommunities: {
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to calculate the network communities using the jLouvain algorithm. If this flag is false the property community for each node will need to be provided",
			D: "true"
		},
		randomData: {
			Z: "true",
			M: "Random",
			T: "boolean",
			C: "Flag to indicate random data for debug and demonstration purposes"
		},
		jitter: {
			H: ['{"data":"Boxplot","graphType":"Dotplot","jitter":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","graphType":"Dotplot","jitter":false,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","graphType":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","graphType":"Boxplot","jitter":false,"showBoxplotOriginalData":true,"functions":["groupSamples:Factor1"]}'],
			S: ["showBoxplotOriginalData", "boxplotDataPointTransparency", "boxplotDataPointRatio"],
			M: "Plot area",
			T: "boolean",
			C: "Flag to jitter the point in dotplots and boxplots",
			D: "true",
			U: {
				Boxplot: "true",
				DotLine: "true",
				Dotplot: "true"
			}
		},
		pieColors: {
			H: ['{"data":"Generic","graphType":"Pie", "pieColors":["rgb(0,0,117)", "rgb(117,0,36)", "rgb(117,88,0)", "rgb(53,117,0)", "rgb(76,0,117)", "rgb(117,53,0)", "rgb(117,117,0)", "rgb(0,117,117)", "rgb(117,0,0)", "rgb(117,97,0)", "rgb(28,0,117)", "rgb(0,117,0)", "rgb(117,0,117)", "rgb(117,67,0)", "rgb(97,117,0)", "rgb(0,66,117)", "rgb(50,0,117)", "rgb(117,33,0)", "rgb(117,107,0)", "rgb(0,117,67)", "rgb(117,0,66)", "rgb(117,78,0)", "rgb(78,117,0)", "rgb(0,36,117)"]}'],
			M: "Pie Charts",
			T: "array",
			C: "Pie Colors. Defaults to the parameter colors.",
			D: "[]"
		},
		resizerDraw: {
			M: "Axis Resizer",
			T: "boolean",
			C: "Flag to make the axis resizers draw the canvas as they move",
			D: "false"
		},
		temperature: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "integer",
			C: "Temperature to limit displacement at later stages of forceDirected and organic layouts. A value based on the number of node and edges will be assigned if not specified",
			D: "0"
		},
		motionControlHeight: {
			S: ["motionBy"],
			M: "Data Point Attributes",
			T: "integer",
			C: "Length in pixels for the height of the motion controls",
			D: "50"
		},
		sequenceFontSize: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Size in pixels for the font size of text of the sequence in the genome browser",
			D: "10"
		},
		featureTypeDefault: {
			O: ["box", "bar", "heatmap", "sequence", "triangle", "line"],
			M: "Genome Browser",
			T: "option",
			C: "Default type for the feature in the genome browser",
			D: "line"
		},
		panningStep: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Zooming and Panning",
			T: "float",
			C: "Percentage step for panning networks.",
			D: "0.2"
		},
		contourYBinSize: {
			H: ['{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":5,"contourYBinSize":5,"contourZBinSize":5}', '{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":10,"contourYBinSize":10,"contourZBinSize":10}'],
			S: ["createContour"],
			M: "Contours",
			T: "integer",
			C: "Size of Y bins in contour plots",
			D: "false"
		},
		zAxisValues: {
			M: "Z-Axis",
			T: "array",
			C: "Values for the ticks in the Z axis",
			D: "[]"
		},
		disableAxisResizer: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable the axis resizer.",
			D: "false"
		},
		overlayFontSize: {
			H: ['{*,"autoScaleFont":false,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "integer",
			C: "Font size for the overlays in one dimensional plots",
			D: "10"
		},
		backgroundWindowGradientOrientation: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"windowGradient"}'],
			O: ["vertical", "horizontal"],
			M: "Background",
			T: "option",
			C: "Specifies the orientation of the gradient if the background type is of the type 'windowGradient' or 'windowGradient2'.",
			D: "vertical"
		},
		yAxisTransformTicks: {
			H: ['{*,"yAxisTransform":"log10","graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "boolean",
			C: "Flag to transform the values of the ticks in the Y axis",
			D: "true"
		},
		isCreateHistogram: {
			Z: "true",
			M: "Histograms",
			T: "boolean",
			C: "Flag to indicate there is a histogram",
			D: "false"
		},
		setMaxX2: {
			H: ['{"graphType":"BarLine","setMaxX2":200}', '{"graphType":"BarLine","setMaxX2":50}', '{"graphType":"BarLine","setMaxX2":null}'],
			M: "X-Axis2",
			T: "float",
			C: "Maximum value to set the data in the 2nd axis",
			D: "null",
			U: {
				StackedLine: "true",
				StackedPercentLine: "true",
				BarLine: "true",
				AreaLine: "true"
			}
		},
		autoScaleFont: {
			S: ["smpLabelFontSize", "varLabelFontSize", "legendFontSize", "axisTickFontSize", "axisTitleFontSize"],
			H: ['{*,"title":"Graph Title"}'],
			M: "Text",
			T: "boolean",
			C: "Flag to automatically adjust the font size in many visualization. Please be aware that scaling factors can still modify the font size. This flag needs to be false for the text to accept the specified font size.",
			D: "true"
		},
		rAxisValues: {
			M: "R-Axis",
			T: "array",
			C: "Values for the ticks in the R axis",
			D: "[]"
		},
		varIndicesStart: {
			Z: "true",
			M: "Heatmap Graphs",
			T: "integer",
			C: "Number that indicates starting point for variables in heatmaps when the canvas is zoom in."
		},
		backgroundGradient2Color: {
			S: ["backgroundType", "backgroundGradient1Color"],
			H: ['{*,"backgroundType":"gradient"}'],
			M: "Background",
			T: "color",
			C: "Specifies the second color of the gradient if the background type is of the type of 'gradient'.",
			D: "rgb(0,0,36)"
		},
		showHeatmapIndicator: {
			H: ['{*,"data":"Random:16:4:0:0","colorBy":"Sample4","graphType":"Scatter3D"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to show the heatmap color indicator",
			D: "true"
		},
		videoGrid: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "boolean",
			C: "Flag to show grid in video",
			D: "false"
		},
		decorationFontStyle: {
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Decorations",
			T: "option",
			C: "Font style for the decorations.  @default"
		},
		titleScaleFontFactor: {
			H: ['{*,"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "float",
			C: "Scaling factor used to increase or decrease the title font size in the canvas.",
			D: "1"
		},
		dataFilterWidth: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Size in pixels for the data filters.",
			D: "180"
		},
		overlayFontStyle: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Overlays",
			T: "option",
			C: "Font style for the overlays.  @default"
		},
		transparency: {
			H: ["{*}"],
			M: "General",
			T: "float",
			C: "Percentage of transparency applied to all elements in the visualizations",
			D: "null"
		},
		isNetworkCommunities: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to create network communities",
			D: "false"
		},
		smpOverlayProperties: {
			M: "Overlays",
			T: "object",
			C: "Object to assign properties to the variable overlays. The key should be an annotation in the 'data.z' object and the value may contain 'type' which could be either one of the one dimensional graph types or Increase, or Decrease for continuous annotations; 'color' to assign the color for the Bar, Line, etc.; 'level' which is an object where the key is the level and the value is the corresponding color. 'height' to identify how tall the overlay will be",
			D: "{}"
		},
		zAxisTickColor: {
			H: ['{*,"graphType":"Scatter3D"}'],
			M: "Z-Axis",
			T: "color",
			C: "Color for the tick lines in the Z axis",
			D: "rgb(204,204,204)"
		},
		transform: {
			S: ["transformType", "transformBase", "ratioReference", "zscoreAxis"],
			O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "zscore", "ratio", "ratio2", "ratio10", "save", "reset", "undo"],
			M: "Functions",
			T: "option",
			C: "Transform all the data. Warning: the option 'save' overwrites the original data",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		transformType: {
			H: ["{*}"],
			S: ["transformedData", "transformAxis"],
			O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "zscore", "ratio", "ratio2", "ratio10", "ceil", "floor", "save", "reset", "undo"],
			M: "Data",
			T: "option",
			C: "Default transformation type.",
			D: "false"
		},
		timeValues: {
			M: "X-Axis",
			T: "array",
			C: "Array containing the tick values when the the graph is a time series",
			D: "[]"
		},
		sequenceKColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate G/T and lysines in the genome browser",
			D: "rgb(255,0,0)"
		},
		backgroundWindowGradient1Color: {
			S: ["backgroundType"],
			H: ['{*,"backgroundType":"windowSolidGradient"}'],
			M: "Background",
			T: "color",
			C: "Specifies the first color of the gradient if the background type is of the type of 'windowGradient'.",
			D: "rgb(0,0,200)"
		},
		disableDataTable: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing data table",
			D: "false"
		},
		maxFeatureStringLen: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Maximum length in characters a feature label can have so anything above is truncated.",
			D: "30"
		},
		yAxis: {
			H: ['{"xAxis":["Sample1","Sample2","Sample3"],"yAxis":["Sample4","Sample5","Sample6"],"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "array",
			C: "Name of the samples groups or variables to be displayed in the Y axis",
			D: "[]",
			X: "getSamplesAsArray",
			U: {
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		setMinX: {
			H: ['{"setMinX":50}', '{"setMinX":20}', '{"setMinX":null}'],
			M: "X-Axis",
			T: "float",
			C: "Minimum value to set the data in the X axis",
			D: "null"
		},
		sizeBy: {
			S: ["sizeByData"],
			O: ["false", "variable"],
			T: "option",
			X: "getXZData",
			H: ['{"graphType":"Scatter3D","sizeBy":"Annt1"}', '{"graphType":"Scatter3D","sizeBy":"Sample4"}', '{"graphType":"Dotplot","sizeBy":"Factor1"}', '{"graphType":"Dotplot","sizeBy":"Annt1"}', '{"graphType":"Dotplot","sizeBy":"variable"}'],
			M: "Data Point Attributes",
			D: "false",
			C: "Name of a variable annotation or a sample name or the string 'variable' to size the variables. When sizeByData is specified sizeBy is used for the title in the legend."
		},
		featureTranslateShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show tranlation",
			D: "true"
		},
		varTitleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the variable titles in one dimensional plots"
		},
		videoClassName: {
			H: ['{"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "string",
			C: "Video class name / css for videos",
			D: "video-js vjs-default-skin"
		},
		preScaleNetwork: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to prescale or not the network. This is an aesthetic parameter to make the graph look nicer... Sometimes...",
			D: "false"
		},
		kmeansVarClusters: {
			H: ['{"graphType":"Heatmap","kmeansVarClusters":2,"functions":["kmeansSamples","kmeansVariables"]}', '{"graphType":"Heatmap","kmeansVarClusters":4,"functions":["kmeansSamples","kmeansVariables"]}'],
			S: ["maxIterations", "kmeansSmpClusters", "kmeansSamples", "kmeansVariables"],
			M: "Clustering",
			T: "integer",
			C: "Number of clusters when clustering variable data with kmeans.",
			D: "3"
		},
		sequencePColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the prolines in the genome browser",
			D: "rgb(255,165,0)"
		},
		randomDataSymmetrical: {
			M: "Random",
			T: "boolean",
			C: "Flag to add missing data to the random data for debug and demonstration purposes  @cfg {} randomDataMissing",
			D: "false"
		},
		isHistogram: {
			S: ["scatterType", "histogramBarWidth"],
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Histograms",
			T: "boolean",
			C: "Flag to convert the 2D scatter plot into a histogram. That is, the points in the scatter plot are converted to bars that start at the bottom of the Y axis. It is useful to represent proteomics spectra. This can also be done setting scatterType to 'bar'.",
			D: "false"
		},
		smpTitleFontColor: {
			H: ['{*,"smpTitle":"Sample Title"}'],
			M: "Samples",
			T: "color",
			C: "Font color for the sample title in one dimensional plots",
			D: "rgb(0,0,0)"
		},
		xRotate: {
			H: ['{"graphType":"Scatter3D","xRotate":0}', '{"graphType":"Scatter3D","xRotate":45}'],
			M: "3D Attributes",
			T: "float",
			C: "Starting number of degrees to rotate graph arround the X axis",
			D: "45"
		},
		featureCoordinateShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show coordinates",
			D: "true"
		},
		subtitleFontSize: {
			S: ["subtitle", "subtitleColor"],
			H: ['{*,"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "integer",
			C: "Font size for the subtitle of the graph. The font height will be adjusted automatically to fit in the canvas.",
			D: "14"
		},
		weight: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Fraction of the canvas to be used (a value between 0 and 1). Used when multiple graphs are displayed in one canvas. Could be an number or an array of numbers."
		},
		showLegend: {
			H: ["{*}"],
			M: "Legends",
			T: "boolean",
			C: "Flag to show or not the legend in the graphs",
			D: "true"
		},
		sequenceYColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate C/T and tyrosines in the genome browser",
			D: "rgb(0,0,255)"
		},
		histogramBins: {
			H: ['{"data":"Random:200:2","functions":["createHistogram"],"histogramBins":50}', '{"data":"Random:200:2","functions":["createHistogram"],"histogramBins":10}'],
			S: ["createHistogram"],
			M: "Histograms",
			T: "integer",
			C: "Number of bins in histogram",
			D: "false"
		},
		yAxisTickStyle: {
			H: ['{*,"graphType":"Scatter2D"}'],
			O: ["solid", "dotted"],
			M: "Y-Axis",
			T: "option",
			C: "Style for the tick lines in the Y axis",
			D: "solid",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		networkFreeze: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to prevent autoscaling for the network layout. Useful when images are part of the network.",
			D: "false"
		},
		varTitle: {
			H: ['{"varTitle":"Variable Title"}'],
			M: "Variables",
			T: "string",
			C: "Title for the sample axis in one dimensional plots",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		stockIndicators: {
			H: ['{"graphType":"Candlestick"}'],
			O: ["Sma5", "Sma10", "Sma20", "Sma25", "Sma50"],
			M: "Candlestick Plots",
			T: "array",
			C: "Stock technical indicators",
			D: ["'Sma5'", "'Sma10'", "'Sma25'"]
		},
		scatterPlotMatrix: {
			H: ['{"graphType":"Scatter2D","scatterPlotMatrix":true}'],
			S: ["scatterPlotMatrixType"],
			M: "Scatter Plot Matrix",
			T: "boolean",
			C: "Flag to plot a matrix of 2D sccaterplots",
			D: "false"
		},
		loessIteration: {
			M: "Loess",
			T: "integer",
			C: "Loess iterations",
			D: "2"
		},
		featureCoordinateHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the coordinates height",
			D: "12"
		},
		backgroundImage: {
			S: ["backgroundType"],
			H: ['{"backgroundType":"image","backgroundImage":"http://www.canvasxpress.org/images/nanotube.jpg"}', '{"backgroundType":"windowImage","backgroundImage":"http://www.canvasxpress.org/images/nanotube.jpg"}'],
			M: "Background",
			T: "url",
			C: "Specifies the url for the background image when the background type is of the type 'image' or 'windowImage'.",
			D: "false"
		},
		showPieSampleLabel: {
			H: ['{*,"data":"Generic","xAxis":["Sample1", "Sample2", "Sample3", "Sample4", "Sample5", "Sample6"],"layout":"2X3"}'],
			M: "Pie Charts",
			T: "boolean",
			C: "A flag to show the sample label when plotting multiple pies",
			D: "true"
		},
		minTextSize: {
			H: ['{*,"title":"Graph Title"}'],
			M: "Text",
			T: "integer",
			C: "Minimum size for any text in the canvas.",
			D: "4"
		},
		varLabelFontColor: {
			H: ["{*}"],
			M: "Variables",
			T: "color",
			C: "Font color for the variable labels in one dimensional plots",
			D: "rgb(0,0,0)",
			U: {
				Heatmap: "true"
			}
		},
		isBoxPlotCalc: {
			Z: "true",
			M: "Data",
			T: "boolean",
			C: "Flag to indicate if the iqr has been calculated if the graph type is Boxplot."
		},
		nodeFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Network Graphs",
			T: "option",
			C: "Font style for the node label.  @default"
		},
		pieSegmentSeparation: {
			H: ["{*}"],
			M: "Pie Charts",
			T: "integer",
			C: "Length in pixels for the separation of the pieces of the pie charts",
			D: "1"
		},
		smpLabelOrientation: {
			H: ['{*,"data":"Circular","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			O: ["perpendicular", "circular"],
			M: "Circular Graphs",
			T: "option",
			C: "Orientation to show the sample names",
			D: "perpendicular"
		},
		timeTicksFirst: {
			H: ['{*,"isGraphTime":true,"data":"Random:1:150:0:0:0:0:1","showVolume":false}'],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to indicate whether to use the first date on a time graph or the last",
			D: "false"
		},
		remoteParams: {
			S: ["remoteService", "remoteServiceType", "remoteDirection"],
			M: "Remote Procedures",
			T: "object",
			C: "Object to hold additional parameters used to obtain data remotely. The target property will be always added to the method as well as the direction [next|prev].",
			D: "{}"
		},
		dotLength: {
			H: ['{*,"data":"DashDot","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "integer",
			C: "Size in pixels of the length between dots in the doted lines.",
			D: "1"
		},
		zAxisMinorValues: {
			M: "Z-Axis",
			T: "array",
			C: "Values for the minor ticks in the Z axis",
			D: "[]"
		},
		boxplotDataPointRatio: {
			S: ["showBoxplotOriginalData", "boxplotDataPointTransparency", "jitter"],
			H: ['{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointRatio":2,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","jitter":true,"showBoxplotOriginalData":true,"boxplotDataPointRatio":4,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "float",
			C: "Ratio to adjust the size of the data points when displaying original data in boxplots. The higher the number the smaller the data points",
			D: "2"
		},
		smpHighlightColor: {
			H: ['{*,"highlightSmp":["Sample1","Sample3"]}'],
			M: "Samples",
			T: "color",
			C: "The color for the higlighted samples.",
			D: "rgb(255,0,0)"
		},
		overrideAnchorNodes: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to override anchor nodes",
			D: "false"
		},
		network2DRotate: {
			Z: "true",
			M: "Network Graphs",
			T: "integer",
			C: "Number of degrees to rotate network arround the X axis"
		},
		clusterSamples: {
			S: ["distance", "linkage", "clusterAxis", "imputeMethod"],
			M: "Functions",
			T: "void",
			C: "Cluster samples based on data and generate a dendrogram on the sample axis. It takes no parameters",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				Bar: "true",
				StackedPercentLine: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		arrowPointSize: {
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "integer",
			C: "Size in pixels of the arrow head in arrow lines.",
			D: "10"
		},
		yAxisValues: {
			M: "Y-Axis",
			T: "array",
			C: "Values for the ticks in the Y axis",
			D: "[]"
		},
		sequenceFill: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the background when showing sequnces in the box or sequence object in the Genome. The default is to use the background of the object. If specied a valid color then all the background of sequences will be uniform",
			D: "false"
		},
		sma25Color: {
			H: ['{*,"stockIndicators":["Sma25"]}'],
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 25 day single moving average",
			D: "rgb(255,0,255)"
		},
		titleColor: {
			S: ["title", "titleHeight"],
			H: ['{*,"title":"Graph Title"}'],
			M: "Titles and Subtitles",
			T: "color",
			C: "Color for the title",
			D: "rgb(0,0,0)"
		},
		outlineBy: {
			H: ["{*}"],
			S: ["outlineByData"],
			M: "Data Point Attributes",
			T: "string",
			C: "Name of the annotation for the outline when drawing a multidimensional Heatmap",
			D: "false",
			U: {
				Heatmap: "true"
			}
		},
		maxSubMenus: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Maximum number of submenus in the context menus",
			D: "20"
		},
		ratioGroupReference: {
			O: ["false"],
			M: "Data",
			T: "option",
			C: "Name of the group used in ratio transformation.",
			D: "false",
			X: "getXData"
		},
		sortVariablesByCategory: {
			S: ["sortDir", "sortVariablesBySample"],
			M: "Functions",
			T: "array",
			C: "Sort the variables by a variable category (data.z object)",
			X: "getZData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		desegregateVariables: {
			S: ["segregateVariables"],
			M: "Functions",
			T: "void",
			C: "Desegregate variables previously segregated based on a variable category (data.z object)",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		setMax: {
			Z: "true",
			M: "Axis",
			T: "float",
			C: "Maximum value to set the data",
			D: "null"
		},
		selectDataModeDescription: {
			H: ['{"selectDataMode":"name","selectDataModeDescription":false}', '{"selectDataMode":"name","selectDataModeDescription":"Annt1"}'],
			O: ["false"],
			M: "Scatter Plots",
			T: "option",
			C: "Variable label to display when highlighting selected data points that must be in the 'data.z' object. (Shift + mouse drag)  @see{selectDataMode}",
			D: "false",
			X: "getZData"
		},
		includeDOE: {
			M: "DOE",
			T: "array",
			C: "Array containing the factors to include when exploring the DOE. If left empty all the factors will be included",
			D: "[]"
		},
		networkLayoutType: {
			H: ['{"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}', '{"data":"LesMiserables","networkLayoutType":"organic","colorNodeBy":"group"}', '{"data":"NetworkRadial","networkLayoutType":"radial"}'],
			O: ["forceDirected", "organic", "radial"],
			M: "Network Graphs",
			T: "option",
			C: "Type of network layout.",
			D: "forceDirected"
		},
		zoom: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Zooming and Panning",
			T: "float",
			C: "Zoom factor for the networks. A number greater than zero",
			D: "1"
		},
		citationFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the reference citation"
		},
		initialTemperature: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "integer",
			C: "Initial temperature to limit displacement at later stages of forceDirected and organic layouts. A value based on the number of node and edges will be assigned if not specified",
			D: "0"
		},
		legendBackgroundColor: {
			S: ["legendBox"],
			H: ["{*}"],
			M: "Legends",
			T: "color",
			C: "Color for the legend background",
			D: "rgb(255,255,255)"
		},
		binConfigurations: {
			M: "Bins",
			T: "object",
			C: "Properties for the binning functions",
			D: "{}"
		},
		overlayScaleFontFactor: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "float",
			C: "Scaling factor used to increse or decrease overlays font size in the canvas in one dimensional plots",
			D: "1"
		},
		loessBandwidth: {
			M: "Loess",
			T: "float",
			C: "Loess bandwidth",
			D: "0.3"
		},
		colorByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the colorBy legend",
			D: "true"
		},
		showNetworkNodesLegend: {
			H: ['{*,"data":"NetworkBasic","calculateLayout":false}'],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to show node legends in the networks",
			D: "true"
		},
		shadowBlur: {
			S: ["showShadow"],
			H: ['{*,"showShadow":true}'],
			M: "Shadows",
			T: "integer",
			C: "Amount in blur for the shadow.",
			D: "2"
		},
		perspectiveFactor: {
			H: ['{*,"graphType":"Scatter3D","data":"3DScatter"}'],
			M: "3D Attributes",
			T: "float",
			C: "Factor to use to make the 3D perspective. The higher the number the more perspective. Perspective of zero is no perspective at all.",
			D: "2.2"
		},
		varTitleLabelOverlayPosition: {
			H: ["{*}"],
			O: ["bottom", "top"],
			M: "Heatmap Graphs",
			T: "option",
			C: "Position for variable labels",
			D: "bottom"
		},
		remoteAutoPlay: {
			M: "Remote Procedures",
			T: "boolean",
			C: "Flag to automatically iterate over remote data sets",
			D: "false"
		},
		recalculateLayout: {
			M: "Functions",
			T: "void",
			C: "Recalculate the network layout",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Scatter2D: "true"
			}
		},
		varTitleFontStyle: {
			H: ['{*,"varTitle":"Variable Title"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Variables",
			T: "option",
			C: "Font style for the var title.  @default",
			U: {
				Heatmap: "true"
			}
		},
		sequenceXColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the any aminoacid code in the genome browser",
			D: "rgb(0,0,0)"
		},
		sizeNodeBy: {
			H: ['{"data":"LesMiserables","colorNodeBy":"group","sizeNodeBy":"group"}'],
			M: "Network Graphs",
			T: "string",
			C: "Name of the attribute to size the nodes.",
			D: "false"
		},
		overlayFontColor: {
			H: ['{*,"graphType":"Heatmap","data":"Random:10:10:3:3","varOverlays":["Annt1","Annt2","Annt3"],"smpOverlays":["Factor1","Factor2","Factor3"]}'],
			M: "Overlays",
			T: "color",
			C: "Color for the overlays in one dimensional plots",
			D: "rgb(0,0,0)"
		},
		snapshotCopyChangeOnly: {
			M: "Animation",
			T: "boolean",
			C: "Flag to indicate whether to copy all or only the changed attributes in the network animation. This optimizes memory usage for snapshots.",
			D: "true"
		},
		axisTickFontSize: {
			S: ["autoScaleFont", "axisTickScaleFontFactor"],
			H: ['{*,"autoScaleFont":false}'],
			M: "Axis",
			T: "integer",
			C: "Font size for the axis ticks in one and two dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the tick scaling factor",
			D: "12"
		},
		sequenceGColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the guanines and glycines in the genome browser",
			D: "rgb(0,0,0)"
		},
		xAxisMinorTicks: {
			H: ["{*}"],
			M: "X-Axis",
			T: "boolean",
			C: "A flag to show minor tick lines in the X axis",
			D: "true"
		},
		legendPosition: {
			S: ["legendInside"],
			H: ["{*}"],
			O: ["rightTop", "right", "rightBottom", "bottom", "leftBottom", "left", "leftTop", "top"],
			M: "Legends",
			T: "option",
			C: "Position for the legend in the graphs. If legendInside is true the all the options apply but if legendInside is false only right and bottom are valid options",
			D: "right"
		},
		dashLength: {
			H: ['{*,"data":"DashDot","calculateLayout":false,"graphType":"Network"}'],
			M: "Lines",
			T: "integer",
			C: "Size in pixels of the length of the dashes and the separation between the dashes in the dashed lines.",
			D: "8"
		},
		zAxisTitle: {
			H: ['{"graphType":"Scatter3D","zAxisTitle":"Z-axis title"}'],
			M: "Z-Axis",
			T: "string",
			C: "Title for the Z axis",
			D: "false"
		},
		remoteParentId: {
			Z: "true",
			M: "Remote Procedures",
			T: "string",
			C: "Id for the parent holding the remoteWindow to prevent id collisions"
		},
		groupingFactors: {
			M: "Data",
			T: "array",
			C: "An array that holds the group names used for grouping the data. It must be a category in the 'data.x' object",
			D: "[]"
		},
		configuratorWidth: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Size in pixels for the configurator.",
			D: "250"
		},
		featureQualityHeight: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "integer",
			C: "Default size in pixels of the quality height",
			D: "12"
		},
		joinType: {
			H: ['{*,"data":"Lines","calculateLayout":false,"graphType":"Network"}'],
			O: ["mitter", "bevel", "round"],
			M: "Lines",
			T: "option",
			C: "Default type for joining lines.",
			D: "mitter"
		},
		translateX: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Amount to translate for the X axis."
		},
		networkRoot: {
			H: ['{"data":"NetworkRadial","networkLayoutType":"radial","networkRoot":"Gene1"}', '{"data":"NetworkRadial","networkLayoutType":"radial","networkRoot":"Gene2"}'],
			M: "Network Graphs",
			T: "string",
			C: "Node Id of the network root.",
			D: "false"
		},
		varOverlays: {
			H: ['{"graphType":"Heatmap","data":"Random:10:10:3:0","varOverlays":["Annt1","Annt2","Annt3"]}'],
			M: "Overlays",
			T: "array",
			C: "Variable annotations included in the 'data.z' object used in one dimensional plots",
			D: "[]",
			X: "getZData"
		},
		z3DRatio: {
			H: ['{"graphType":"Scatter3D","z3DRatio":0.5}', '{"graphType":"Scatter3D","z3DRatio":1}'],
			M: "3D Attributes",
			T: "float",
			C: "Value between 0 - 1 for adjusting the 3D of the Z Axis",
			D: "1",
			U: {
				Scatter3D: "true",
				Bar: "true"
			}
		},
		remoteUpdating: {
			Z: "true",
			M: "Remote Procedures",
			T: "boolean",
			C: "Flag to indicate that updating data is in progress"
		},
		filterFeatureBy: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "filter",
			C: "Filter features by their properties used in genome browser",
			D: "[]",
			X: "getFeatureData"
		},
		foreground: {
			H: ['{*,"data":"Random:1:3:0:0","graphType":"Dotplot"}'],
			M: "Foreground",
			T: "color",
			C: "Specifies the foreground color for text or lines not covered in a more specific configuration property.",
			D: "rgb(0,0,0)"
		},
		plotByVariable: {
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "boolean",
			C: "Flag to indicate whether to group the data variable rather than by sample",
			D: "false"
		},
		rowHeight: {
			M: "Data Table",
			T: "integer",
			C: "Mumber of pixels for the height of cells in the data table",
			D: "18"
		},
		smpHairlineWidth: {
			H: ['{*,"graphType":"Bar","smpHairline":true}'],
			M: "Plot area",
			T: "float",
			C: "The width for the thin line that appears in the middle of the sample block just for aesthetics.",
			D: "0.3"
		},
		boxplotConnect: {
			H: ['{"data":"Boxplot","functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "boolean",
			C: "Flag to show data in boxplots connected",
			D: "false"
		},
		scatterType: {
			H: ['{*,"graphType":"Scatter2D","scatterType":"image","images":["area", "bar", "boxplot", "heatmap", "line", "pie"]}'],
			S: ["images", "isHistogram", "histogramBarWidth"],
			O: ["false", "line", "bar", "dot", "image", "lineImage", "lineStep"],
			M: "Scatter Plots",
			T: "option",
			C: "Type of scatter plot",
			D: "false"
		},
		subtitleFont: {
			Z: "true",
			M: "Data Table",
			T: "font",
			C: "Font for the subtitle"
		},
		standardDeviationType: {
			H: ['{"standardDeviationType":"unbiased","functions":["groupSamples:Factor1"]}', '{"standardDeviationType":"unbiased","functions":["groupSamples:Factor1"]}'],
			O: ["biased", "unbiased"],
			M: "Data",
			T: "option",
			C: "Type of Standard Deviation. 'biased' uses n as denominator and 'unbiased' uses (n - 1) as denominator where n is the number of values",
			D: "unbiased"
		},
		videoCurrentTime: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "boolean",
			C: "Flag to show video current time",
			D: "false"
		},
		featureQualityValues: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show values for the quality",
			D: "false"
		},
		dendrogramHang: {
			H: ['{*,"data":"Generic","graphType":"Bar","showSmpDendrogram":true,"dendrogramHeight":false}'],
			S: ["dendrogramHeight", "dendrogramSpace"],
			M: "Dendrograms",
			T: "boolean",
			C: "Flag to show or not the nodes in the dendrogram as hanging or not similar to that one in R",
			D: "false"
		},
		bar3DInverseWeight: {
			H: ['{*,"data":"3DScatter","scatterType":"bar"}'],
			M: "3D Attributes",
			T: "float",
			C: "Value for adjusting the thickness of 3D bars. The larger the value the the thinner the bar",
			D: "1",
			U: {
				Scatter3D: "true"
			}
		},
		resizerPosition: {
			O: ["top", "rigth", "bottom", "left"],
			M: "Axis Resizer",
			T: "option",
			C: "Position for the axis resizer in complex plots",
			D: "bottom"
		},
		repulsiveForceFunction: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			O: ["square", "log", "pow", "sqrt"],
			M: "Network Graphs",
			T: "option",
			C: "Type of function to apply when calculating repulsive force in forceDirected network layouts",
			D: "square"
		},
		vennGroups: {
			H: ['{"vennGroups":2}', '{"vennGroups":3}', '{"vennGroups":4}'],
			M: "Venn Diagrams",
			T: "integer",
			C: "Number of groups in the Venn diagram",
			D: "4"
		},
		zAxis: {
			H: ['{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"ScatterBubble2D"}', '{"xAxis":["Sample1","Sample2"],"yAxis":["Sample3","Sample4"],"zAxis":["Sample5","Sample6"],"graphType":"Scatter3D"}'],
			M: "Z-Axis",
			T: "array",
			C: "Name of the samples groups or variables to be displayed in the Z axis",
			D: "[]",
			X: "getSamplesAsArray"
		},
		videoPlaybackRate: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "float",
			C: "Video Playback Rate",
			D: "1"
		},
		lineType: {
			H: ['{*,"data":"Random:4:6","graphType":"Line"}'],
			O: ["rect", "spline"],
			M: "Line Graphs",
			T: "option",
			C: "Type of line used to join the points in line graphs",
			D: "rect"
		},
		y3DRatio: {
			H: ['{"graphType":"Scatter3D","y3DRatio":0.5}', '{"graphType":"Scatter3D","y3DRatio":1}'],
			M: "3D Attributes",
			T: "float",
			C: "Value between 0 - 1 for adjusting the 3D of the Y Axis",
			D: "1",
			U: {
				Scatter3D: "true",
				Bar: "true"
			}
		},
		featureStaggered: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to stagger the features in the genome panel",
			D: "false"
		},
		decorationsWidth: {
			H: ['{*,"data":"NetworkDecorations","decorationsPosition":"top","networkFreezeOnLoad":true,"showDecorations":true,"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}'],
			M: "Decorations",
			T: "integer",
			C: "Length in pixels of the width for the decorations in the networks",
			D: "10",
			U: {
				Network: "true"
			}
		},
		heatmapIndicatorWidth: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "integer",
			C: "Length in pixels for the heatmap indicator line width used for increase the size of the indicator",
			D: "160"
		},
		moveParentsWithChildren: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to make parents move when a child is moved",
			D: "false"
		},
		filterVarBy: {
			H: ["{*}"],
			M: "Variables",
			T: "filter",
			C: "Filter variables by their annotation included in the 'data.z' object used in one dimensional plots",
			D: "[]",
			X: "getZData"
		},
		heatmapLabelSizeAutoAdjust: {
			H: ['{*,"graphType":"Heatmap"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to adjust the font size of the heatmaps labels if they overlap",
			D: "true"
		},
		layoutBoxLabelColors: {
			M: "Combination Plots",
			T: "array",
			C: "Layout box label background colors.",
			D: "[]"
		},
		disableMenu: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to disable showing the menu on right clicks",
			D: "false"
		},
		yAxisAbsMax: {
			Z: "true",
			M: "Y-Axis",
			T: "float",
			C: "Maximum non-filtered value for the data plotted in the Y axis"
		},
		maxPieSectors: {
			H: ['{"data":"Generic","maxPieSectors":2}', '{"data":"Generic","maxPieSectors":3}'],
			M: "Pie Charts",
			T: "float",
			C: "Max pie sectors. After that number the sectors will be put in a sector named 'other'.",
			D: "20"
		},
		featureFillColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Default color for the fill of the feature in the genome browser",
			D: "rgb(255,255,255)"
		},
		xAxisAbsMin: {
			Z: "true",
			M: "X-Axis",
			T: "float",
			C: "Minimum non-filtered value for the data plotted in the X axis"
		},
		filterSkipNullKeys: {
			M: "Data Filters",
			T: "boolean",
			C: "Flag to indicate to bypass filtering when a key is non existent in the data objects",
			D: "false"
		},
		showFadeResizeMoveAnimation: {
			H: ["{*}"],
			M: "Events",
			T: "boolean",
			C: "Flag to show animation in data table, data filter and tool bar.",
			D: "true"
		},
		correlationLabelInterval: {
			H: ["{*}"],
			M: "Correlation Graphs",
			T: "integer",
			C: "Interval for the sample or variable labels in the correlation plot",
			D: "1"
		},
		networkForceConstant: {
			H: ['{*,"data":"LesMiserables","networkLayoutType":"forceDirected","colorNodeBy":"group"}'],
			M: "Network Graphs",
			T: "float",
			C: "Constant used for calculating attractive and repulsive forces in forcedDirected and organic layouts. A value based on the average area per node will be assigned if not specified",
			D: "0"
		},
		oncoprintCode: {
			H: ['{*,"data":"MultidimensionalHeatmap"}'],
			M: "Heatmap Graphs",
			T: "boolean",
			C: "Flag to print code for mutations in oncoprint",
			D: "false"
		},
		patterns: {
			H: ['{"data":"Random:14:1:0:0:1","graphType":"Bar","graphOrientation":"vertical","setMaxX":1,"setMinX":0,"smpLabelRotate":90,"patternBy":"variable","showLegend":false}'],
			M: "Patterns",
			T: "array",
			C: "Patterns used in visualizations to fill objects. This array must contain one or more pattern names and in concert with the color array can be used to specify the pattern colors for all filled objects in the visualizations."
		},
		networkShowDataTable: {
			O: ["nodes", "edges"],
			M: "Data Table",
			T: "option",
			C: "Show nodes or edges on data table",
			D: "nodes"
		},
		pseudoRandom: {
			M: "Random",
			T: "boolean",
			C: "Flag to indicate to use pseudo random rather than random",
			D: "true"
		},
		vennColors: {
			S: ["colors"],
			H: ['{"vennColors":["rgb(51,151,255)","rgb(151,255,51)","rgb(255,51,125)"],"vennGroups":3}'],
			M: "Venn Diagrams",
			T: "array",
			C: "Colors for the Venn bubles. If not specified the colors will be chosen from the colors array. Colors in this array need to be at least the same number of groups in the Venn diagram",
			D: "[]"
		},
		skipConfigurableProperties: {
			M: "Data Table/Filter",
			T: "boolean",
			C: "Flag to indicate to exclude configurable parameters in the data table and the data filters in Networks and Genome Browser",
			D: "true"
		},
		outlineByShowLegend: {
			H: ["{*}"],
			M: "Data Point Attributes",
			T: "boolean",
			C: "Flag to show the outlineBy legend",
			D: "true"
		},
		scaleX: {
			Z: "true",
			M: "Combination Plots",
			T: "float",
			C: "Scale factor for the X axis"
		},
		configuratorExamplesSize: {
			H: ["{*}"],
			M: "Events",
			T: "integer",
			C: "Size in pixels for the examples in the configurator.",
			D: "400"
		},
		"this": {
			M: "Y-Axis",
			T: "float",
			C: "Value to floor the data in the Y axis when transform type is floor",
			D: "false"
		},
		gradientType: {
			S: ["gradient"],
			H: ['{*,"data":"Random:1:3:0:0","gradient":true}'],
			O: ["linear", "radial"],
			M: "Gradients",
			T: "option",
			C: "Specifies the gradient pattern.",
			D: "radial"
		},
		resizerType: {
			O: ["false", "samples", "box"],
			M: "Axis Resizer",
			T: "option",
			C: "String to indicate the type of axis resizer in complex plots",
			D: "false"
		},
		showDataValues: {
			H: ['{*,"graphType":"Bar"}'],
			M: "Plot area",
			T: "boolean",
			C: "Flag to indicate whether to show data values in the one bar graphs.",
			D: "false",
			U: {
				Bar: "true",
				Heatmap: "true"
			}
		},
		xAxisS2Show: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "X-Axis",
			T: "boolean",
			C: "Flag to show or not the values of the ticks in the X axis at the top in Scatter plots",
			D: "false",
			U: {
				Scatter3D: "true",
				ScatterBubble2D: "true",
				Correlation: "true",
				Scatter2D: "true"
			}
		},
		featureTracesShow: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "boolean",
			C: "Flag use to show traces",
			D: "true"
		},
		contourXBinSize: {
			H: ['{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":5,"contourYBinSize":5,"contourZBinSize":5}', '{"data":"Random:50:50","functions":["createContour"],"contourXBinSize":10,"contourYBinSize":10,"contourZBinSize":10}'],
			S: ["createContour"],
			M: "Contours",
			T: "integer",
			C: "Size of X bins in contour plots",
			D: "false"
		},
		hideUnhideSmps: {
			M: "Functions",
			T: "array",
			C: "Hide or unhide samples. It works like a switch",
			X: "getSamplesAsArray",
			U: {
				StackedPercent: "true",
				Bar: "true",
				Correletion: "true",
				Pie: "true",
				ScatterBubble2D: "true",
				Barline: "true",
				StackedLine: "true",
				Scatter2D: "true",
				Dotplot: "true",
				Boxplot: "true",
				DotLine: "true",
				StackedPercentLine: "true",
				Scatter3D: "true",
				Area: "true",
				Line: "true",
				Stacked: "true",
				Heatmap: "true",
				AreaLine: "true"
			}
		},
		decorationsColors: {
			H: ['{"data":"NetworkDecorations","decorationsPosition":"right","networkFreezeOnLoad":true,"showDecorations":true,"decorationsColors":["rgb(51,125,255)","rgb(125,255,51)","rgb(255,125,51)"],"calculateLayout":false,"decorations":["exp1","exp2","exp3"]}'],
			M: "Decorations",
			T: "array",
			C: "Array of colors used for selection in network decorations not to be confused by its singular form 'decorationsColor' above",
			D: "[]",
			U: {
				Network: "true"
			}
		},
		printType: {
			O: ["download", "window"],
			M: "General",
			T: "option",
			C: "Print type",
			D: "download"
		},
		zAxisAbsMax: {
			Z: "true",
			M: "Z-Axis",
			T: "float",
			C: "Maximum non-filtered value for the data plotted in the Z axis"
		},
		loessDrawOptimizer: {
			M: "Loess",
			T: "integer",
			C: "Loess draw optimizer is a number to skip values that that are the same to draw the loess fit",
			D: "5"
		},
		isMarketSwitched: {
			H: ['{"isGraphTime":true,"data":"Random:1:150:0:0:0:0:1","showVolume":false}'],
			Z: "true",
			M: "Data",
			T: "boolean",
			D: "false",
			C: "Flag to indicate if the data is a time series so there is no need to plot every time interval. It is boolean in one dimensional plots or a string indicating the axis which is timed 'x', 'y' or 'z'  @cfg {boolean|string} isGraphTime"
		},
		imputeMethod: {
			H: ['{"graphType":"Heatmap","data":"Random:10:10::::::0.15","imputeMethod":"mean","functions":["clusterSamples","clusterVariables"]}', '{"graphType":"Heatmap","data":"Random:10:10::::::0.15","imputeMethod":"median","functions":["clusterSamples","clusterVariables"]}'],
			S: ["distance", "linkage", "clusterAxis", "clusterSamples", "clusterVariables"],
			O: ["mean", "median"],
			M: "Clustering",
			T: "option",
			C: "Imputation method for missing data when clustering",
			D: "mean"
		},
		labelNodePosition: {
			H: ['{*,"data":"LesMiserables","colorNodeBy":"group"}'],
			O: ["auto", "center", "top", "right", "bottom", "left"],
			M: "Network Graphs",
			T: "option",
			C: "Default position for the node label",
			D: "auto"
		},
		randomMissingDataPercentage: {
			M: "Random",
			T: "float",
			C: "Default percentage of missing values when creating random data. A value between 0 and 1.",
			D: "0"
		},
		videoPreload: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			O: ["Auto", "Metadata", "none"],
			M: "Videos",
			T: "option",
			C: "Preload type for videos",
			D: "none"
		},
		yAxisHistogramHeight: {
			H: ['{*,"graphType":"Scatter2D"}'],
			M: "Y-Axis",
			T: "integer",
			C: "Number of pixels for the histogram in the Y axis",
			D: "50"
		},
		highlightVar: {
			H: ['{"highlightVar":["Variable1","Variable3"]}'],
			M: "Variables",
			T: "array",
			C: "Name of variables in the 'data.y' object to highlight.",
			D: "[]",
			X: "getVariablesAsArray",
			U: {
				Heatmap: "true"
			}
		},
		smpHairline: {
			H: ['{*,"graphType":"Bar"}'],
			O: ["false", "solid", "dotted"],
			M: "Plot area",
			T: "option",
			C: "This is a thin line that appears in the middle of the bar graphs just for aesthetics.",
			D: "false"
		},
		sortSamplesByCategory: {
			S: ["sortDir", "sortSamplesByVariable"],
			M: "Functions",
			T: "array",
			C: "Sort the samples by a sample category (data.x object)",
			X: "getXData",
			U: {
				StackedPercent: "true",
				Boxplot: "true",
				DotLine: "true",
				Bar: "true",
				Correletion: "true",
				StackedPercentLine: "true",
				Pie: "true",
				Barline: "true",
				Area: "true",
				StackedLine: "true",
				Line: "true",
				Dotplot: "true",
				AreaLine: "true",
				Heatmap: "true",
				Stacked: "true"
			}
		},
		featuresProperties: {
			M: "Data Table/Filter",
			T: "array",
			C: "Two dimensional array with object properties not at the root level for the features in the Genome graph to include in the Data table and the data filter",
			D: "[]"
		},
		boxplotConnectWidth: {
			H: ['{"data":"Boxplot","boxplotConnect":true,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "integer",
			C: "Width for the line of the connection of boxes in boxplots",
			D: "2"
		},
		sequenceWColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the degenerate A/T and tryptophans in the genome browser",
			D: "rgb(0,0,255)"
		},
		fontStyle: {
			H: ['{*,"title":"Graph Title"}'],
			O: ["", "bold", "italic", "bold italic"],
			M: "Text",
			T: "option",
			C: "Font style.  @default"
		},
		showBoxplotOriginalData: {
			S: ["boxplotDataPointRatio", "boxplotDataPointTransparency", "jitter"],
			H: ['{"data":"Boxplot","showBoxplotOriginalData":true,"functions":["groupSamples:Factor1"]}', '{"data":"Boxplot","showBoxplotOriginalData":false,"functions":["groupSamples:Factor1"]}'],
			M: "Boxplot Graphs",
			T: "boolean",
			C: "Flag to show original data in boxplots",
			D: "false"
		},
		rAxisTickColor: {
			H: ['{*,"data":"Circular2","rAxis":"Number","segregateVariablesBy":["Ring"],"segregateSamplesBy":["Segment"]}'],
			M: "R-Axis",
			T: "color",
			C: "Color for the tick lines in the R axis",
			D: "rgb(0,0,0)"
		},
		trackNameFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Genome Browser",
			T: "option",
			C: "Font style for the track name.  @default"
		},
		showVolume: {
			H: ["{*}"],
			M: "Candlestick Plots",
			T: "boolean",
			C: "Flag to show or not volume in the candlestick graphs",
			D: "true"
		},
		videoControls: {
			H: ['{*,"backgroundType":"video","backgroundVideo":["http://video-js.zencoder.com/oceans-clip.mp4", "http://video-js.zencoder.com/oceans-clip.webm"]}'],
			M: "Videos",
			T: "boolean",
			C: "Flag to show controls in videos"
		},
		sma10Color: {
			H: ['{*,"stockIndicators":["Sma10"]}'],
			M: "Candlestick Plots",
			T: "color",
			C: "The color for the 5 day single moving average",
			D: "rgb(0,255,0)"
		},
		varLabelFontStyle: {
			H: ["{*}"],
			O: ["", "bold", "italic", "bold italic"],
			M: "Variables",
			T: "option",
			C: "Font style for the variable label.  @default",
			U: {
				Heatmap: "true"
			}
		},
		ringsType: {
			H: ['{"data":"Circular","segregateVariablesBy":["Ring"],"ringsType":["bar","heatmap","dot"]}'],
			M: "Circular Graphs",
			T: "array",
			C: "Array containing the types for each ring in the circular plots",
			D: "[]"
		},
		gradientOrientation: {
			S: ["backgroundType"],
			H: ['{*,"data":"Random:1:3:0:0","gradient":true,"gradientType":"linear"}'],
			O: ["vertical", "horizontal"],
			M: "Gradients",
			T: "option",
			C: "Specifies the orientation of the gradient if the gradient type is of the type 'linear'",
			D: "vertical"
		},
		isCoordinateNodeColorsNetworkConvexHull: {
			H: ["{*}"],
			M: "Network Graphs",
			T: "boolean",
			C: "Flag to coordinate colors of the nodes with convex hull for the network communities",
			D: "false"
		},
		refresehDataTableOnDraw: {
			M: "Data Table",
			T: "boolean",
			C: "Flag to indicate to refresh data after drawing the plot",
			D: "false"
		},
		percentAspectRatioPlotArea: {
			M: "Aspect Ratio",
			T: "float",
			C: "Specifies the minimum percentage for the ploting area",
			D: "0.3"
		},
		randomNetworkReduce: {
			M: "Random",
			T: "boolean",
			C: "Flag to create or not a single random network for debug and demonstration purposes",
			D: "true",
			U: {
				Network: "true"
			}
		},
		decorationsBoxColor: {
			S: ["decorationsBox"],
			H: ['{*,"showDecorations":true,"graphType":"Scatter2D","data":"Random:16:2:0:0","functions":["addNormalDistributionLine", "draw"]}'],
			M: "Decorations",
			T: "color",
			C: "Color for the box around the decoration legend",
			D: "rgb(204,204,204)"
		},
		varLabelFontSize: {
			S: ["autoScaleFont", "varLabelScaleFontFactor"],
			H: ['{"autoScaleFont":false,"varLabelFontSize":10}', '{"autoScaleFont":false,"varLabelFontSize":20}'],
			M: "Variables",
			T: "integer",
			C: "Size for the variable labels in one dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the variable label scaling factor",
			D: "12",
			U: {
				Heatmap: "true"
			}
		},
		smpLabelFontSize: {
			S: ["autoScaleFont", "smpLabelScaleFontFactor"],
			H: ['{"autoScaleFont":false,"smpLabelFontSize":10}', '{"autoScaleFont":false,"smpLabelFontSize":20}'],
			M: "Samples",
			T: "integer",
			C: "Size for the sample labels in one dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the sample label scaling factor",
			D: "12"
		},
		sequenceAColor: {
			H: ["{*}"],
			M: "Genome Browser",
			T: "color",
			C: "Color for the adenines and alanines in the genome browser",
			D: "rgb(0,103,0)"
		},
		clusterVariables: {
			S: ["distance", "linkage", "clusterAxis", "imputeMethod"],
			M: "Functions",
			T: "void",
			C: "Cluster variables based on data and generate a dendrogram on the variable axis. It takes no parameters",
			U: {
				Heatmap: "true"
			}
		},
		xAxis2TickFormat: {
			H: ['{"graphType":"BarLine","xAxis2TickFormat":"%.2f cxs","graphOrientation":"vertical"}'],
			M: "X-Axis2",
			T: "string",
			C: "Format for the tick values in the second X axis",
			D: "false"
		},
		dataEvent: {
			Z: "true",
			M: "Events",
			T: "array",
			C: "Array to store the areas that will trigger an event"
		},
		highlightNode: {
			H: ['{"highlightNode":["Gene1","Gene2"]}'],
			M: "Network Graphs",
			T: "array",
			C: "Name of nodes in the 'data.nodes' object to highlight.",
			D: "[]"
		},
		snapshots: {
			Z: "true",
			M: "Snapshots",
			T: "array",
			C: "Array to hold the data used in the animation"
		}
	},
	G: {
		name: {
			M: "Genome",
			T: "string",
			C: "Track name"
		}
	},
	E: {
		cap: {
			O: "butt, round, square",
			M: "Network",
			T: "option",
			C: "Type of cap for the end of the lines"
		},
		width: {
			M: "Network",
			T: "integer",
			C: "Pixel width for the edges between nodes"
		},
		anchor: {
			M: "Network",
			T: "boolean",
			C: "Flag make the edge transparent"
		},
		color: {
			M: "Network",
			T: "color",
			C: "Color for the edge"
		},
		hide: {
			M: "Network",
			T: "boolean",
			C: "Flag to hide the edge"
		},
		exact: {
			M: "Network",
			T: "boolean",
			C: "Flag to indicate to create the edge between nodes without subtracting the size of the nodes"
		},
		type: {
			M: "Network",
			T: "string",
			C: "Type of line use to join the nodes"
		}
	}
};
